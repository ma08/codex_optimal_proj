"""
You are given an undirected unweighted connected graph consisting of $n$ vertices and $m$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.

Your task is to find any spanning tree of this graph such that the degree of the first vertex (vertex with label $1$ on it) is equal to $D$ (or say that there are no such spanning trees). Recall that the degree of a vertex is the number of edges incident to it.


-----Input-----

The first line contains three integers $n$, $m$ and $D$ ($2 \le n \le 2 \cdot 10^5$, $n - 1 \le m \le min(2 \cdot 10^5, \frac{n(n-1)}{2}), 1 \le D < n$) â€” the number of vertices, the number of edges and required degree of the first vertex, respectively.

The following $m$ lines denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \le v_i, u_i \le n$, $u_i \ne v_i$), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the list of edges, and for each pair $(v_i, u_i)$ the condition $v_i \ne u_i$ is satisfied.


-----Output-----

If there is no spanning tree satisfying the condition from the problem statement, print "NO" in the first line.

Otherwise print "YES" in the first line and then print $n-1$ lines describing the edges of a spanning tree such that the degree of the first vertex (vertex with label $1$ on it) is equal to $D$. Make sure that the edges of the printed spanning tree form some subset of the input edges (order doesn't matter and edge $(v, u)$ is considered the same as the edge $(u, v)$).

If there are multiple possible answers, print any of them.


-----Examples-----
Input
4 5 1
1 2
1 3
1 4
2 3
3 4

Output
YES
2 1
2 3
3 4

Input
4 5 3
1 2
1 3
1 4
2 3
3 4

Output
YES
1 2
1 3
4 1

Input
4 4 3
1 2
1 4
2 3
3 4

Output
NO



-----Note-----

The picture corresponding to the first and second examples: [Image]

The picture corresponding to the third example: [Image]
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])"
    }
  ],
  "created": 1648683042,
  "id": "cmpl-4rc3uxxNegG1lN0eCsJKzr8GEAY7f",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])"
}
REASON stop
