["import sys\ninput = sys.stdin.readline\n\nNEGINF = -1000000\n\nn = int(input())\nadj = [[] for i in range(n)]\nparent = [-1] * n\n\nvisited = [False] * n\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    adj[a - 1].append(b - 1)\n    adj[b - 1].append(a - 1)\n\ntup = tuple()\nouts = [tup] * n\nq = [(0, 0)]\n\nwhile q:\n    node, type = q.pop()\n    if type == 0:\n        visited[node] = True\n        q.append((node, 1))\n        for v in adj[node]:\n            if not visited[v]:\n                parent[v] = node\n                q.append((v, 0))\n    else:\n        ones = [(0, node)]\n        twos = []\n        threes = []\n        for v in adj[node]:\n            if v != parent[node]:\n                a, b, c = outs[v]\n                ones.append((a[0] + 1, a[1], v))\n                twos.append((b[0] + 1, b[1], v))\n                threes.append(c)\n        ones.sort(reverse = True)\n        twos.sort(reverse = True)\n        threes.sort(reverse = True)\n\n        bestOne = (ones[0][0], ones[0][1])\n        \n        bestsTwo = [(NEGINF, (0, 0))]\n        if len(twos) > 0:\n            bestsTwo.append((twos[0][0], twos[0][1]))\n        if len(ones) > 1:\n            o1 = ones[0]\n            o2 = ones[1]\n            bestsTwo.append((o1[0] + o2[0], (o1[1], o2[1])))\n\n        bestsThree = [(NEGINF, (0, 0, 0))]\n        if len(threes) > 0:\n            bestsThree.append(threes[0])\n        if len(ones) > 2:\n            o1 = ones[0]\n            o2 = ones[1]\n            o3 = ones[2]\n            bestsThree.append((o1[0] + o2[0] + o3[0], (o1[1], o2[1], o3[1])))\n        if len(twos) > 0:\n            o1 = ones[0]\n            t1 = twos[0]\n            if o1[2] != t1[2]:\n                bestsThree.append((o1[0] + t1[0], (o1[1], t1[1][0], t1[1][1])))\n            else:\n                if len(twos) > 1:\n                    t2 = twos[1]\n                    bestsThree.append((o1[0] + t2[0], (o1[1], t2[1][0], t2[1][1])))\n                if len(ones) > 1:\n                    o2 = ones[1]\n                    bestsThree.append((o2[0] + t1[0], (o2[1], t1[1][0], t1[1][1])))\n                    \n\n        outs[node] = (bestOne, max(bestsTwo), max(bestsThree))\n\nfinal = outs[0][2]\nprint(final[0])\nprint(' '.join([str(x + 1) for x in final[1]]))\n", "import sys\nfrom collections import deque\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    v, to = list(map(int, input().split()))\n    v -= 1\n    to -= 1\n    g[v].append(to)\n    g[to].append(v)\n\n# (vertex, distance)\nqueue = deque([(0, 0)])\nvisited = [False] * n\nwhile queue:\n    v, d = queue.popleft()\n    visited[v] = True\n    for to in g[v]:\n        if not visited[to]:\n            queue.append((to, d + 1))\na = v\n\n# (vertex, distance)\nqueue = deque([(a, 0)])\nprev = [-1] * n\nfor i in range(n):\n    visited[i] = False\nwhile queue:\n    v, d = queue.popleft()\n    visited[v] = True\n    for to in g[v]:\n        if not visited[to]:\n            queue.append((to, d + 1))\n            prev[to] = v\nb, ctr = v, d\n\nfor i in range(n):\n    visited[i] = False\ncurr = prev[b]\nnxt = b\nprv = prev[curr]\nadd = 0\nif a != 0 and b != 0:\n    c = 0\nelif a != 1 and b != 1:\n    c = 1\nelse:\n    c = 2\nwhile curr != a:\n    visited[curr] = True\n    for to in g[curr]:\n        if to == nxt or to == prv:\n            continue\n        queue = deque([(to, 1)])\n        while queue:\n            v, d = queue.popleft()\n            visited[v] = True\n            for to in g[v]:\n                if not visited[to]:\n                    queue.append((to, d + 1))\n        if add < d:\n            c, add = v, d    \n    nxt = curr\n    curr = prev[curr]\n    prv = prev[curr]\n    \nprint(ctr + add)\nprint(a + 1, b + 1, c + 1)\n\n# inf.close()\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nE=[[] for i in range(n+1)]\n\nfor i in range(n-1):\n    x,y=list(map(int,input().split()))\n    E[x].append(y)\n    E[y].append(x)\n\ndef dfs(t):\n    L=[-1]*(n+1)\n    L[t]=0\n\n    Q=[t]\n\n    while Q:\n        x=Q.pop()\n        for to in E[x]:\n            if L[to]==-1:\n                L[to]=L[x]+1\n                Q.append(to)\n\n    return L.index(max(L))\n\nA=dfs(1)\nB=dfs(A)\n\nDEPTH=[-1]*(n+1)\nDEPTH[1]=0\n\nfrom collections import deque\nQUE = deque([1])\nQUE2 = deque()\nEULER=[]\n\nUSED=[0]*(n+1)\nwhile QUE:\n    x=QUE.pop()\n    EULER.append((DEPTH[x],x))\n    if USED[x]==1:\n        continue\n    for to in E[x]:\n        \n        if USED[to]==0:\n            DEPTH[to]=DEPTH[x]+1\n            QUE2.append(to)\n        else:\n            QUE.append(to)\n    QUE.extend(QUE2)\n    QUE2=deque()\n \n    USED[x]=1\n\nMINP=[1<<30]*(n+1)\nMAXP=[-1]*(n+1)\n\nfor ind,(depth,p) in enumerate(EULER):\n    MINP[p]=min(MINP[p],ind)\n    MAXP[p]=max(MAXP[p],ind)\n\nLEN=len(EULER)\n\nseg_el=1<<(LEN.bit_length())\nSEG=[(1<<30,0)]*(2*seg_el)\n\nfor i in range(LEN):\n    SEG[i+seg_el]=EULER[i]\n\nfor i in range(seg_el-1,0,-1):\n    SEG[i]=min(SEG[i*2],SEG[i*2+1])\n\ndef update(n,x,seg_el):\n    i=n+seg_el\n    SEG[i]=x\n    i>>=1\n    \n    while i!=0:\n        SEG[i]=min(SEG[i*2],SEG[i*2+1])\n        i>>=1\n        \ndef getvalues(l,r):\n    L=l+seg_el\n    R=r+seg_el\n    ANS=(1<<30,0)\n\n    while L<R:\n        if L & 1:\n            ANS=min(ANS , SEG[L])\n            L+=1\n\n        if R & 1:\n            R-=1\n            ANS=min(ANS , SEG[R])\n        L>>=1\n        R>>=1\n\n    return ANS\n\ndef LCA(l,r):\n    return getvalues(min(MINP[l],MINP[r]),max(MAXP[l],MAXP[r])+1)\n\nA2=DEPTH[A]*2+DEPTH[B]*2-LCA(A,B)[0]*2\nANS=0\n\nfor i in range(1,n+1):\n    if i==A or i==B:\n        continue\n\n    if ANS<A2+DEPTH[i]*2-LCA(i,A)[0]*2-LCA(i,B)[0]*2:\n        ANS=A2+DEPTH[i]*2-LCA(i,A)[0]*2-LCA(i,B)[0]*2\n        Aind=i\n\nprint(ANS//2)\nprint(A,B,Aind)\n    \n    \n", "import sys\nfrom collections import deque\nn = int(input())\nadj = [[] for _ in range(n)]\nfor u, v in (list(map(int, l.split())) for l in sys.stdin):\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ninf = 10**9\n\n\ndef rec(s):\n    prev = [-1]*n\n    prev[s] = inf\n    dq = deque([s])\n    last = s\n\n    while dq:\n        v = dq.popleft()\n        last = v\n        for dest in adj[v]:\n            if prev[dest] > -1:\n                continue\n            prev[dest] = v\n            dq.append(dest)\n\n    return last, prev\n\n\nv1, _ = rec(0)\nv2, prev = rec(v1)\nv = prev[v2]\nvisited = [0]*n\nvisited[v] = visited[v1] = visited[v2] = 1\ndia = 0\nmax_e, max_e_i = 0, v\n\nwhile v != inf:\n    dia += 1\n    if prev[v] != inf:\n        visited[prev[v]] = 1\n\n    stack = [(v, 0)]\n    while stack:\n        cv, e = stack.pop()\n        if max_e < e:\n            max_e, max_e_i = e, cv\n        e += 1\n\n        for dest in adj[cv]:\n            if visited[dest]:\n                continue\n            visited[dest] = 1\n            stack.append((dest, e))\n\n    v = prev[v]\n\nprint(dia + max_e)\nprint(v1+1, v2+1, max_e_i+1)\n"]