["import sys\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        for _ in range(n):\n            grid.append(list(input()))\n        directions = []\n        for _ in range(n):\n            directions.append(list(input()))\n        black_cells = 0\n        white_cells = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '0':\n                    black_cells += 1\n                else:\n                    white_cells += 1\n        num_robots = 0\n        for i in range(n):\n            for j in range(m):\n                if directions[i][j] == 'U':\n                    if i != 0:\n                        if grid[i-1][j] == '1':\n                            num_robots += 1\n                elif directions[i][j] == 'R':\n                    if j != m-1:\n                        if grid[i][j+1] == '1':\n                            num_robots += 1\n                elif directions[i][j] == 'D':\n                    if i != n-1:\n                        if grid[i+1][j] == '1':\n                            num_robots += 1\n                elif directions[i][j] == 'L':\n                    if j != 0:\n                        if grid[i][j-1] == '1':\n                            num_robots += 1\n        max_black = min(num_robots, black_cells)\n        print(num_robots, max_black)\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\n# Get the number of test cases\nt = int(sys.stdin.readline())\n\n# Loop through each test case\nfor i in range(t):\n\n    # Get the number of rows and columns in the grid\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Initialize the number of black cells in the grid\n    blackCells = 0\n\n    # Initialize the number of white cells in the grid\n    whiteCells = 0\n\n    # Initialize the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n    robots = 0\n\n    # Initialize the maximum number of black cells that can be occupied by robots before all movements\n    maxBlackCells = 0\n\n    # Loop through each row in the grid\n    for j in range(n):\n\n        # Get the current row in the grid\n        row = sys.stdin.readline()\n\n        # Loop through each column in the current row in the grid\n        for k in range(m):\n\n            # If the current cell in the grid is black\n            if row[k] == '0':\n\n                # Increment the number of black cells in the grid\n                blackCells += 1\n\n            # If the current cell in the grid is white\n            elif row[k] == '1':\n\n                # Increment the number of white cells in the grid\n                whiteCells += 1\n\n    # Loop through each row in the grid\n    for j in range(n):\n\n        # Get the current row in the grid\n        row = sys.stdin.readline()\n\n        # Loop through each column in the current row in the grid\n        for k in range(m):\n\n            # If the current cell in the grid is black\n            if row[k] == '0':\n\n                # If the current cell in the grid is in the top row\n                if j == 0:\n\n                    # Increment the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n                    robots += 1\n\n                # If the current cell in the grid is in the bottom row\n                elif j == n - 1:\n\n                    # Increment the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n                    robots += 1\n\n                # If the current cell in the grid is in the leftmost column\n                elif k == 0:\n\n                    # Increment the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n                    robots += 1\n\n                # If the current cell in the grid is in the rightmost column\n                elif k == m - 1:\n\n                    # Increment the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n                    robots += 1\n\n                # If the current cell in the grid is not in the top row, bottom row, leftmost column, or rightmost column\n                else:\n\n                    # Increment the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n                    robots += 2\n\n    # If the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell is less than the number of white cells in the grid\n    if robots < whiteCells:\n\n        # Set the maximum number of black cells that can be occupied by robots before all movements to the number of black cells in the grid\n        maxBlackCells = blackCells\n\n    # If the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell is greater than or equal to the number of white cells in the grid\n    else:\n\n        # Set the maximum number of black cells that can be occupied by robots before all movements to the number of black cells in the grid minus the number of white cells in the grid plus the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell\n        maxBlackCells = blackCells - whiteCells + robots\n\n    # Print the maximum number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell and the maximum number of black cells that can be occupied by robots before all movements\n    print(str(robots) + \" \" + str(maxBlackCells))", "\ndef num_robots_to_place(grid, n, m):\n    # Find the number of robots that can be placed in the grid such that there is no move before which two different robots occupy the same cell.\n    # This is really a variation of the longest increasing subsequence problem.\n    # We can use a dynamic programming approach to solve the problem in O(n * m) time.\n    # We will create a grid of zeros and ones where a 1 represents that a robot can be placed in that cell.\n    # We will use a 2D array where the first dimension is the row number and the second dimension is the column number.\n    robot_grid = [[0 for i in range(m)] for j in range(n)]\n    # We will iterate over the rows of the grid.\n    for i in range(n):\n        # We will iterate over the columns of the grid.\n        for j in range(m):\n            # We will iterate over the possible robot placements in the previous row.\n            # We will start at the first column in the previous row.\n            # If we are in the first row then we will start at the first column in the current row.\n            for k in range(j + (i == 0), m):\n                # If we are in the first row then we will check if the current column is valid for a robot placement.\n                # Otherwise we will check if the current column is valid for a robot placement and the previous column is valid for a robot placement.\n                if i == 0 and grid[i][j] != grid[i][k] or i > 0 and grid[i][j] != grid[i][k] and robot_grid[i - 1][k]:\n                    # If the current column is valid for a robot placement then we will mark it as valid for a robot placement.\n                    robot_grid[i][j] = 1\n                    break\n    # We will initialize the number of robots to place to zero.\n    num_robots = 0\n    # We will iterate over the rows of the grid.\n    for i in range(n):\n        # We will iterate over the columns of the grid.\n        for j in range(m):\n            # If a robot can be placed in the current cell then we will increment the number of robots to place.\n            if robot_grid[i][j]:\n                num_robots += 1\n    # We will return the number of robots to place.\n    return num_robots\n\ndef max_black_cells(grid, n, m):\n    # Find the maximum number of black cells that can be occupied by robots before all movements.\n    # We can use a dynamic programming approach to solve the problem in O(n * m) time.\n    # We will create a grid of zeros and ones where a 1 represents that a robot can be placed in that cell.\n    # We will use a 2D array where the first dimension is the row number and the second dimension is the column number.\n    robot_grid = [[0 for i in range(m)] for j in range(n)]\n    # We will iterate over the rows of the grid.\n    for i in range(n):\n        # We will iterate over the columns of the grid.\n        for j in range(m):\n            # We will iterate over the possible robot placements in the previous row.\n            # We will start at the first column in the previous row.\n            # If we are in the first row then we will start at the first column in the current row.\n            for k in range(j + (i == 0), m):\n                # If we are in the first row then we will check if the current column is valid for a robot placement.\n                # Otherwise we will check if the current column is valid for a robot placement and the previous column is valid for a robot placement.\n                if i == 0 and grid[i][j] != grid[i][k] or i > 0 and grid[i][j] != grid[i][k] and robot_grid[i - 1][k]:\n                    # If the current column is valid for a robot placement then we will mark it as valid for a robot placement.\n                    robot_grid[i][j] = 1\n                    break\n    # We will initialize the maximum number of black cells to zero.\n    max_black = 0\n    # We will iterate over the rows of the grid.\n    for i in range(n):\n        # We will iterate over the columns of the grid.\n        for j in range(m):\n            # If a robot can be placed in the current cell and the current cell is black then we will increment the maximum number of black cells.\n            if robot_grid[i][j] and grid[i][j] == '0':\n                max_black += 1\n    # We will return the maximum number of black cells.\n    return max_black\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(input())\n    for i in range(n):\n        grid.append(input())\n    print(num_robots_to_place(grid, n, m), max_black_cells(grid, n, m))"]