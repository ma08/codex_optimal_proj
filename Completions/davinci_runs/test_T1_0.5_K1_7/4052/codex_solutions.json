["\n\n\ndef solve(n, s, t):\n    if s == t:\n        return 0\n    swaps = []\n    # find the first mismatch\n    for i in range(n):\n        if s[i] != t[i]:\n            break\n    # find the char that is supposed to be at index i\n    for j in range(i+1, n):\n        if t[j] == t[i]:\n            break\n    # swap\n    swaps.append(j-1)\n    s = s[:j-1] + s[j] + s[j-1] + s[j+1:]\n    # find the next mismatch\n    for i in range(i+1, n):\n        if s[i] != t[i]:\n            break\n    # find the char that is supposed to be at index i\n    for j in range(i+1, n):\n        if t[j] == t[i]:\n            break\n    # swap\n    swaps.append(j-1)\n    s = s[:j-1] + s[j] + s[j-1] + s[j+1:]\n    # find the next mismatch\n    for i in range(i+1, n):\n        if s[i] != t[i]:\n            break\n    # find the char that is supposed to be at index i\n    for j in range(i+1, n):\n        if t[j] == t[i]:\n            break\n    # swap\n    swaps.append(j-1)\n    s = s[:j-1] + s[j] + s[j-1] + s[j+1:]\n    # find the next mismatch\n    for i in range(i+1, n):\n        if s[i] != t[i]:\n            break\n    # find the char that is supposed to be at index i\n    for j in range(i+1, n):\n        if t[j] == t[i]:\n            break\n    # swap\n    swaps.append(j-1)\n    s = s[:j-1] + s[j] + s[j-1] + s[j+1:]\n    if s == t:\n        return swaps\n    else:\n        return -1\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input()\n    t = input()\n    swaps = solve(n, s, t)\n    if swaps == -1:\n        print(swaps)\n    else:\n        print(len(swaps))\n        print(\" \".join(str(swap) for swap in swaps))", "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    if s == t:\n        print(0)\n        return\n    if len(set(t)) != len(set(s)):\n        print(-1)\n        return\n    s = list(s)\n    t = list(t)\n    moves = []\n    for i in range(n):\n        if s[i] == t[i]:\n            continue\n        for j in range(i+1, n):\n            if s[j] == t[i]:\n                moves.append(i)\n                s = s[:i] + [s[j]] + s[i+1:j] + [s[i]] + s[j+1:]\n                break\n        else:\n            print(-1)\n            return\n    print(len(moves))\n    print(*moves)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    if s == t:\n        print(0)\n        return\n\n    # Use a dictionary to store the locations of each character\n    s_dict = {}\n    for i in range(n):\n        if s[i] in s_dict:\n            s_dict[s[i]].append(i)\n        else:\n            s_dict[s[i]] = [i]\n    \n    # Use a dictionary to store the locations of each character\n    t_dict = {}\n    for i in range(n):\n        if t[i] in t_dict:\n            t_dict[t[i]].append(i)\n        else:\n            t_dict[t[i]] = [i]\n\n    # If a character is not in both dictionaries, then it is impossible to transform s to t\n    for key in s_dict:\n        if key not in t_dict:\n            print(-1)\n            return\n\n    # If the number of a character in s is not equal to the number of that character in t, then it is impossible to transform s to t\n    for key in s_dict:\n        if len(s_dict[key]) != len(t_dict[key]):\n            print(-1)\n            return\n\n    # If the locations of a character in s is not equal to the locations of that character in t, then it is impossible to transform s to t\n    for key in s_dict:\n        if s_dict[key] != t_dict[key]:\n            print(-1)\n            return\n\n    # If we have not returned a -1 yet, then it is possible to transform s to t\n    # We will use a greedy algorithm to perform the swaps\n    # We will start from the left and swap the next character with the next character in t\n    # Then we will continue from the left and swap the next character with the next character in t\n    # We will continue this until we have swapped all characters\n\n    # We will use a list to store the swaps\n    swaps = []\n    for i in range(n):\n        # If the i-th character in s is already in the i-th position in t, then we do not need to swap\n        if s[i] == t[i]:\n            continue\n        # Otherwise, we will find the location of the i-th character in t in s\n        for j in range(i+1, n):\n            if s[j] == t[i]:\n                # We will swap the i-th character with the j-th character\n                swaps.append(j)\n                s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                break\n    \n    # If the number of swaps are greater than 10^4, then it is impossible to transform s to t\n    if len(swaps) > 10000:\n        print(-1)\n        return\n    \n    # Otherwise, we will print the number of swaps and the swaps\n    print(len(swaps))\n    for swap in swaps:\n        print(swap, end = \" \")\n\nmain()", "\n\n#-----Solution-----\n\nn = int(input())\n\ns = input()\n\nt = input()\n\nmove = []\n\nwhile t != s:\n    for i in range(n-1):\n        if t[i] != s[i]:\n            if t[i+1] == s[i]:\n                move.append(i+1)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n                break\n            elif t[i+1] == s[i+1]:\n                move.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n                break\n            else:\n                move.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n                move.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n                break\n    if t != s:\n        move = []\n        break\n\nif move == []:\n    print(-1)\nelse:\n    print(len(move))\n    for i in move:\n        print(i+1, end = \" \")", "\n\nn = int(input())\ns = input()\nt = input()\n\ndef swap(s, i):\n    return s[:i] + s[i + 1] + s[i] + s[i + 2:]\n\ndef is_swap(s, t, i):\n    return s[:i] + s[i + 1] + s[i] + s[i + 2:] == t\n\ndef is_swap_2(s, t, i):\n    return s[:i] + s[i + 2] + s[i] + s[i + 1] + s[i + 3:] == t\n\ndef solve():\n    for i in range(n - 1):\n        if s[i] != t[i]:\n            if is_swap(s, t, i):\n                print(1)\n                print(i + 1)\n                return\n            elif is_swap(s, t, i + 1):\n                print(1)\n                print(i + 2)\n                return\n            elif is_swap_2(s, t, i):\n                print(2)\n                print(i + 1, i + 2)\n                return\n            else:\n                print(-1)\n                return\n    print(0)\n\nsolve()", "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    #print(s,t)\n    #print(n)\n    moves = 0\n    i = 0\n    c = []\n    while (i < n-1):\n        if (s[i] != t[i]):\n            if (s[i+1] == t[i]):\n                c.append(i+1)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n                moves += 1\n                #print(s,t)\n            elif (s[i+1] == t[i+1]):\n                c.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n                moves += 1\n                #print(s,t)\n                i -= 1\n            else:\n                print(-1)\n                return\n        i += 1\n    if (s != t):\n        print(-1)\n        return\n    print(moves)\n    for i in c:\n        print(i, end = \" \")\n    \n\nmain()"]