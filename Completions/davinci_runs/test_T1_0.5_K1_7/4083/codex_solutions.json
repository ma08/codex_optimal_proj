["\n\n\"\"\"\nThe only difference between easy and hard versions is the number of elements in the array.\n\nYou are given an array $a$ consisting of $n$ integers. In one move you can choose any $a_i$ and divide it by $2$ rounding down (in other words, in one move you can set $a_i := \\lfloor\\frac{a_i}{2}\\rfloor$).\n\nYou can perform such an operation any (possibly, zero) number of times with any $a_i$.\n\nYour task is to calculate the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.\n\nDon't forget that it is possible to have $a_i = 0$ after some operations, thus the answer always exists.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 50$) \u2014 the number of elements in the array and the number of equal numbers required.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nPrint one integer \u2014 the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.\n\n\n-----Examples-----\nInput\n5 3\n1 2 2 4 5\n\nOutput\n1\n\nInput\n5 3\n1 2 3 4 5\n\nOutput\n2\n\nInput\n5 3\n1 2 3 3 3\n\nOutput\n0\n\"\"\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\n\nans = 0\n\nif a[0] == a[k-1]:\n    print(0)\n\nelse:\n    ans = a[k-1] - a[0]\n    print(ans)", "\n\nimport math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_a = min(a)\nmax_a = max(a)\n\nmin_operations = math.inf\n\nfor i in range(min_a, max_a + 1):\n    operations = 0\n    for ai in a:\n        operations += (ai - i) // 2\n    if operations < min_operations:\n        min_operations = operations\n\nprint(min_operations)", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort()\n    ans = 0\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        if a[-1] % 2 == 0:\n            a[-1] = a[-1] // 2\n            ans += 1\n        else:\n            a[-1] = a[-1] // 2\n            ans += 1\n            a[-1] += 1\n        while a[0] != a[-1]:\n            a[0] = a[0] // 2\n            a[-1] = a[-1] // 2\n            ans += 1\n        if a[0] == a[-1]:\n            print(ans)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(n, k, a):\n    # sort the array\n    a.sort(reverse=True)\n    # find the number of operations required to get the same number\n    num_operations = a[0] - a[k-1]\n    return num_operations\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))", "\n\n\ndef solve(a, k):\n    return 0\n\ndef main():\n    input_n, input_k = map(int, input().split())\n    input_a = list(map(int, input().split()))\n    print(solve(input_a, input_k))\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    arr = list(map(int, sys.stdin.readline().split()))\n    num = [0] * 2 * 10 ** 5\n    for i in arr:\n        num[i] += 1\n    for i in range(2 * 10 ** 5 - 1, -1, -1):\n        num[i] += num[i + 1]\n    for i in range(1, 2 * 10 ** 5):\n        num[i] = min(num[i], num[i - 1])\n    ans = 2 * 10 ** 5\n    for i in range(2 * 10 ** 5):\n        if num[i] >= k:\n            ans = min(ans, i)\n    print(ans)\n\nmain()"]