["\n\n# from collections import defaultdict\n\n# def process(n, p, u, k):\n#     children = defaultdict(list)\n#     for i in range(1, n):\n#         children[p[i]].append(i + 1)\n#     visited = [False] * n\n#     res = []\n#     def dfs(i):\n#         if visited[i]: return\n#         visited[i] = True\n#         res.append(i + 1)\n#         for child in children[i]:\n#             dfs(child)\n#     dfs(u - 1)\n#     return res[k - 1] if k <= len(res) else -1\n\n# n, q = [int(x) for x in input().split()]\n# p = [0]\n# p += [int(x) - 1 for x in input().split()]\n# for _ in range(q):\n#     u, k = [int(x) for x in input().split()]\n#     print(process(n, p, u, k))\n\nfrom collections import defaultdict\n\ndef process(n, p, u, k):\n    children = defaultdict(list)\n    for i in range(1, n):\n        children[p[i]].append(i + 1)\n    visited = [False] * n\n    res = []\n    def dfs(i):\n        if visited[i]: return\n        visited[i] = True\n        res.append(i + 1)\n        for child in children[i]:\n            dfs(child)\n    dfs(u - 1)\n    return res[k - 1] if k <= len(res) else -1\n\nn, q = [int(x) for x in input().split()]\np = [0]\np += [int(x) - 1 for x in input().split()]\nfor _ in range(q):\n    u, k = [int(x) for x in input().split()]\n    print(process(n, p, u, k))", "\n\ndef main():\n    n, q = map(int, input().split())\n    p = [0]\n    p.extend(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        tree[p[i]].append(i)\n\n    for _ in range(q):\n        u, k = map(int, input().split())\n        stack = [u]\n        ans = []\n        while stack:\n            cur = stack.pop()\n            ans.append(cur)\n            stack.extend(reversed(tree[cur]))\n        if k <= len(ans):\n            print(ans[k - 1])\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()", "\n\n#Solution:\n\nimport sys\n\nn,q = map(int, input().split())\n\ntree = [[] for i in range(n)]\nfor i in range(n-1):\n    p = int(input())\n    tree[i+1].append(p)\n    tree[p].append(i+1)\n\nfor i in range(q):\n    u,k = map(int, input().split())\n    queue = [u]\n    visited = set()\n    count = 0\n    while queue:\n        curr = queue.pop(0)\n        if curr not in visited:\n            visited.add(curr)\n            count += 1\n            if count == k:\n                print(curr)\n                break\n            for n in tree[curr]:\n                if n not in visited:\n                    queue.append(n)\n    if count < k:\n        print(-1)", "\n\n# SOLUTION\n\nimport sys\ninput = sys.stdin.readline\n\nn, q = map(int, input().split())\nparent = list(map(int, input().split()))\n\n# build graph\ngraph = [set() for _ in range(n)]\nfor i in range(1, n):\n    graph[parent[i - 1]].add(i)\n\n# dfs\ndef dfs(u):\n    if not graph[u]:\n        return [u]\n    \n    res = []\n    for v in graph[u]:\n        res += dfs(v)\n    return res + [u]\n\nfor _ in range(q):\n    u, k = map(int, input().split())\n    u -= 1\n    res = dfs(u)\n    if k > len(res):\n        print(-1)\n    else:\n        print(res[k - 1] + 1)", "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n\tglobal a\n\tglobal t\n\tglobal s\n\tglobal d\n\tglobal k\n\tglobal n\n\tglobal u\n\n\ta[v] = True\n\ts[t] = v\n\tt += 1\n\tif k == t:\n\t\tprint(s[k-1])\n\t\treturn\n\tfor i in range(n+1):\n\t\tif d[v][i] and not a[i]:\n\t\t\tdfs(i,v)\n\tt -= 1\n\ta[v] = False\n\nn, q = map(int, input().split())\nd = [[0]*(n+1) for i in range(n+1)]\nfor i in range(2, n+1):\n\tp = int(input())\n\td[p][i] = d[i][p] = 1\na = [False]*(n+1)\ns = [0]*(n+1)\nt = 0\nfor i in range(q):\n\tu, k = map(int, input().split())\n\tdfs(u, 0)", "\nimport sys\n\ndef get_input(filepath):\n    with open(filepath) as f:\n        n, q = map(int, f.readline().split())\n        p = list(map(int, f.readline().split()))\n        queries = []\n        for _ in range(q):\n            queries.append(tuple(map(int, f.readline().split())))\n    return (n, q, p, queries)\n\ndef dfs(u, p, k):\n    global visited\n    if visited[u] == 1:\n        return -1\n    visited[u] = 1\n    if k == 1:\n        return u\n    for v in range(1, len(p)):\n        if p[v] == u and visited[v] == 0:\n            ret = dfs(v, p, k-1)\n            if ret != -1:\n                return ret\n    return -1\n\nif __name__ == \"__main__\":\n    n, q, p, queries = get_input(sys.argv[1])\n    for (u, k) in queries:\n        visited = [0] * n\n        print(dfs(u, p, k))", "\n\n\ndef solve(n, q, p, queries):\n    # TODO: Implement solution\n    pass\n\n\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n    p = [int(i) for i in input().split()]\n    queries = []\n    for _ in range(q):\n        u, k = map(int, input().split())\n        queries.append((u, k))\n    solve(n, q, p, queries)"]