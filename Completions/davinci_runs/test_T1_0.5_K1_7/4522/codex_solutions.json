["\n\n# SOLUTION\n\nimport sys\n\ndef readline_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef readline_int():\n    return int(sys.stdin.readline())\n\ndef read_input():\n    n, m = readline_ints()\n    edges = []\n    for _ in range(n - 1):\n        edges.append(readline_ints())\n    queries = readline_ints()\n    return n, m, edges, queries\n\n\ndef solve(n, edges, queries):\n    from collections import defaultdict\n    from itertools import combinations\n    \n    # build a graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # compute all pairwise distances\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n        stack = [(i, 0)]\n        while stack:\n            u, d = stack.pop()\n            for v, w in graph[u]:\n                if dist[i][v] > d + w:\n                    dist[i][v] = d + w\n                    stack.append((v, d + w))\n    \n    # find all pairs of vertices\n    pairs = list(combinations(range(n), 2))\n    \n    # solve the queries\n    for q in queries:\n        yield sum(dist[i][j] <= q for i, j in pairs)\n\n\ndef main():\n    n, m, edges, queries = read_input()\n    for result in solve(n, edges, queries):\n        print(result)\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport heapq\n\ndef solve(adj_list, n, q_list):\n    # set up a heap of (weight, (node1, node2))\n    edge_heap = []\n    for node1 in adj_list:\n        for node2 in adj_list[node1]:\n            edge_heap.append((adj_list[node1][node2], (node1, node2)))\n    heapq.heapify(edge_heap)\n\n    # set up a union find structure\n    parent = [i for i in range(n+1)]\n    size = [1 for i in range(n+1)]\n\n    # iterate through queries and edges\n    answer_list = []\n    for q in q_list:\n        while edge_heap and edge_heap[0][0] <= q:\n            weight, (node1, node2) = heapq.heappop(edge_heap)\n            union(node1, node2, parent, size)\n\n        answer_list.append(n*(n-1)//2 - sum(size[1:]))\n\n    return answer_list\n\ndef union(node1, node2, parent, size):\n    p1 = find(node1, parent)\n    p2 = find(node2, parent)\n    if p1 != p2:\n        if size[p1] > size[p2]:\n            size[p1] += size[p2]\n            parent[p2] = p1\n        else:\n            size[p2] += size[p1]\n            parent[p1] = p2\n\ndef find(node, parent):\n    if parent[node] != node:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef main():\n    # parse input\n    n, m = map(int, sys.stdin.readline().split())\n    adj_list = {}\n    for i in range(1, n+1):\n        adj_list[i] = {}\n    for i in range(n-1):\n        node1, node2, weight = map(int, sys.stdin.readline().split())\n        adj_list[node1][node2] = weight\n        adj_list[node2][node1] = weight\n    q_list = list(map(int, sys.stdin.readline().split()))\n\n    # solve problem\n    answer_list = solve(adj_list, n, q_list)\n\n    # print answer\n    for answer in answer_list:\n        print(answer)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    \"\"\"\n    This function will be run when you hit Run.\n    \"\"\"\n    print('Hello World')\n\nif __name__ == '__main__':\n    main()", "\n\n# ----- Solution -----\n\ndef dfs(v, p):\n    global arr, ans, dp, n, m\n    dp[v][0] = 1\n    dp[v][1] = 1\n    for i in range(0, len(arr[v])):\n        if arr[v][i][0] != p:\n            dfs(arr[v][i][0], v)\n            dp[v][0] += dp[arr[v][i][0]][1]\n            dp[v][1] += dp[arr[v][i][0]][0]\n    for i in range(0, m):\n        if arr[v][i][1] <= q[i]:\n            ans[i] += dp[v][0]\n        else:\n            ans[i] += dp[v][1]\n\nn, m = map(int, input().split())\nq = list(map(int, input().split()))\narr = [[] for i in range(n + 1)]\ndp = [[0 for i in range(2)] for i in range(n + 1)]\nans = [0 for i in range(m)]\nfor i in range(n - 1):\n    a, b, c = map(int, input().split())\n    arr[a].append([b, c])\n    arr[b].append([a, c])\ndfs(1, 0)\nprint(*ans)", "\n\n# SOLUTION\n\nimport sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, arr, func):\n        self.n = len(arr)\n        self.size = 2**(self.n-1).bit_length()\n        self.func = func\n        self.default = self.func(0,0)\n        self.data = [self.default]*(2*self.size)\n        self.data[self.size : self.size+self.n] = arr\n        for i in range(self.size-1, 0, -1):\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        res = self.default\n        while l < r:\n            if l&1:\n                res = self.func(res, self.data[l])\n                l += 1\n            if r&1:\n                res = self.func(res, self.data[r-1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def update(self, i, x):\n        i += self.size\n        self.data[i] = x\n        i >>= 1\n        while i:\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n            i >>= 1\n\n\ndef dfs(v, p, g, dep, dp):\n    dp[v] = dep\n    for u in g[v]:\n        if u == p:\n            continue\n        dfs(u, v, g, dep+1, dp)\n\ndef solve(n, q, g, dep, dp):\n    dfs(0, -1, g, 0, dp)\n    st = SegmentTree(dp, max)\n    ans = [0]*n\n    for i in range(n):\n        ans[i] = st.query(0, i)\n    return ans\n\ndef main():\n    n, m = map(int, input().split())\n    g = [[] for i in range(n)]\n    for i in range(n-1):\n        u, v, w = map(int, input().split())\n        g[u-1].append((v-1, w))\n        g[v-1].append((u-1, w))\n    q = list(map(int, input().split()))\n    dep = [0]*n\n    dp = [0]*n\n    ans = solve(n, q, g, dep, dp)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\n#-----Solution-----\n\nclass Node:\n    def __init__(self, val, weight):\n        self.val = val\n        self.weight = weight\n        self.children = []\n        self.max_weight = 0\n        self.max_pair = 0\n        self.max_pair_weight = 0\n        self.max_pair_count = 0\n        self.max_pair_count_weight = 0\n        self.max_pair_count_weight_weight = 0\n\n\ndef dfs(node):\n    for child in node.children:\n        dfs(child)\n        node.max_weight = max(node.max_weight, child.max_weight)\n        node.max_pair = max(node.max_pair, child.max_pair + 1)\n        node.max_pair_weight = max(node.max_pair_weight, child.max_pair_weight + child.weight)\n        node.max_pair_count = max(node.max_pair_count, child.max_pair_count + 1)\n        node.max_pair_count_weight = max(node.max_pair_count_weight, child.max_pair_count_weight + child.weight)\n        node.max_pair_count_weight_weight = max(node.max_pair_count_weight_weight, child.max_pair_count_weight_weight + child.weight)\n    if node.max_pair == 0:\n        node.max_pair = 1\n        node.max_pair_weight = node.weight\n    if node.max_pair_count == 0:\n        node.max_pair_count = 1\n        node.max_pair_count_weight = node.weight\n\n\ndef calc(node, q):\n    count = 0\n    for child in node.children:\n        if child.max_weight <= q:\n            count += calc(child, q)\n    if node.max_pair_weight <= q:\n        count += node.max_pair\n    if node.max_pair_count_weight <= q:\n        count += node.max_pair_count * (node.max_pair_count - 1) // 2\n    if node.max_pair_count_weight_weight <= q:\n        count += node.max_pair_count * (node.max_pair_count - 1) // 2\n    return count\n\n\nn, m = map(int, input().split())\nnodes = [Node(i, 0) for i in range(n)]\nfor i in range(n - 1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    nodes[u].children.append(nodes[v])\n    nodes[v].children.append(nodes[u])\n    nodes[u].weight = w\n    nodes[v].weight = w\ndfs(nodes[0])\nq = list(map(int, input().split()))\nfor i in range(m):\n    print(calc(nodes[0], q[i]))"]