["", "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport itertools\nimport string\nimport queue\nimport copy\nimport time\n\nsys.setrecursionlimit(10000)\n\ndef readString():\n    return sys.stdin.readline()\n\ndef readInteger():\n    return int(readString())\n\ndef readStringSet(n):\n    return sys.stdin.readline().split(\" \")[:n]\n\ndef readIntegerSet(n):\n    return list(map(int, readStringSet(n)))\n\ndef readIntegerMatrix(n, m):\n    return [lambda _: readIntegerSet(m) for _ in range(0, n)]\n\ninf = float(\"inf\")\nmod = 1000000007\n\n#---------------------------------------------\n\ndef main():\n    n = readInteger()\n    edges = [None] * (n - 1)\n    for i in range(0, n - 1):\n        edges[i] = readIntegerSet(2)\n    graph = [[] for i in range(0, n + 1)]\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n    def dfs(v, p):\n        if v == 1:\n            return 0\n        for u in graph[v]:\n            if u != p:\n                return 1 + dfs(u, v)\n    res = 0\n    for e in edges:\n        a = dfs(e[0], e[1])\n        b = dfs(e[1], e[0])\n        if a > 1 or b > 1:\n            res += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = [False for _ in range(n + 1)]\n    dfs(adj, visited, 1)\n    print(ans)\n\ndef dfs(adj, visited, v):\n    global ans\n    visited[v] = True\n    for u in adj[v]:\n        if not visited[u]:\n            dfs(adj, visited, u)\n    # check if v is a leaf\n    if len(adj[v]) == 1:\n        ans += 1\n\nans = 0\nmain()", "\n\nimport sys\nimport math\n\ndef get_graph():\n    n = int(input())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    return graph\n\ndef dfs(graph, v, p):\n    if v == 0:\n        return 0, 0\n    else:\n        d1 = d2 = math.inf\n        for u in graph[v]:\n            if u == p:\n                continue\n            d, d_ = dfs(graph, u, v)\n            d += 1\n            d_ += 1\n            if d < d1:\n                d1, d2 = d, d1\n            elif d < d2:\n                d2 = d\n        return d1, d2\n\ndef main():\n    graph = get_graph()\n    d1, d2 = dfs(graph, 0, -1)\n    print(d1 + d2)\n\nif __name__ == '__main__':\n    main()", "\n\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom queue import Queue\n\ndef main():\n    n = int(stdin.readline())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    q = Queue()\n    q.put(1)\n    visited = set()\n    visited.add(1)\n    count = 0\n    while not q.empty():\n        size = q.qsize()\n        while size:\n            size -= 1\n            curr = q.get()\n            for neighbor in graph[curr]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.put(neighbor)\n        count += 1\n        if count == 2:\n            break\n    stdout.write(str(n - len(visited)))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport os\nimport heapq\nfrom collections import deque,defaultdict\nfrom itertools import permutations,combinations,product\nfrom copy import deepcopy\n\nint_input=lambda : int(sys.stdin.readline())\nstring_input=lambda : sys.stdin.readline()\nmulti_int_input =lambda : map(int, sys.stdin.readline().split())\nmulti_input = lambda : sys.stdin.readline().split()\nlist_input=lambda : list(map(int,sys.stdin.readline().split()))\nstring_list_input=lambda: list(string_input())\nMOD = pow(10,9)+7\n\nclass Graph:\n    def __init__(self,size):\n        self.size = size\n        self.edges = defaultdict(list)\n        self.weights = {}\n    \n    def add_edge(self,from_node,to_node,weight):\n        # check if edge already exists\n        for i,edge in enumerate(self.edges[from_node]):\n            if edge == to_node:\n                self.weights[(from_node,to_node)] = weight\n                return\n        self.edges[from_node].append(to_node)\n        self.edges[to_node].append(from_node)\n        self.weights[(from_node,to_node)] = weight\n        self.weights[(to_node,from_node)] = weight\n\n    def bfs(self,start,end):\n        visited = [False]*(self.size+1)\n        visited[start] = True\n        queue = deque()\n        queue.append(start)\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                return True\n            for neighbour in self.edges[node]:\n                if not visited[neighbour]:\n                    visited[neighbour] = True\n                    queue.append(neighbour)\n        return False\n\ndef main():\n    n = int_input()\n    graph = Graph(n)\n    for i in range(n-1):\n        a,b = multi_int_input()\n        graph.add_edge(a,b,1)\n\n    if graph.bfs(1,n):\n        print(0)\n        return\n\n    for i in range(1,n+1):\n        for neighbour in graph.edges[i]:\n            if graph.bfs(i,n):\n                print(1)\n                return\n    print(2)\n    return\n\nif __name__ == '__main__':\n    main()", "\n\ndef bfs(G, s):\n    Q, dist = [s], {s: 0}\n    while Q:\n        u = Q.pop(0)\n        for v in G[u]:\n            if v not in dist:\n                dist[v] = dist[u] + 1\n                Q.append(v)\n    return dist\n\ndef solve(N, G):\n    dist = bfs(G, 1)\n    return sum(d > 2 for d in dist.values())\n\ndef main():\n    N = int(input())\n    G = defaultdict(list)\n    for i in range(N-1):\n        u, v = map(int, input().split())\n        G[u].append(v)\n        G[v].append(u)\n    print(solve(N, G))\n\nmain()"]