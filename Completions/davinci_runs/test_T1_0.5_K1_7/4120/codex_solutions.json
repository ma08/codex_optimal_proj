["\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n\n    visited = [False] * n\n    stack = [0]\n    visited[0] = True\n    while stack:\n        v = stack.pop()\n        for u in adj[v]:\n            if not visited[u]:\n                visited[u] = True\n                stack.append(u)\n\n    if not all(visited):\n        print(0)\n        return\n\n    stack = [0]\n    visited = [False] * n\n    visited[0] = True\n    dist = [0] * n\n    while stack:\n        v = stack.pop()\n        for u in adj[v]:\n            if not visited[u]:\n                visited[u] = True\n                dist[u] = dist[v] + 1\n                stack.append(u)\n\n    if not all(visited):\n        print(0)\n        return\n\n    d = dist[1:]\n    d.sort()\n\n    res = []\n    for i in range(m):\n        if d[i] == d[i+1]:\n            res.append(i)\n\n    print(len(res))\n    for i in res:\n        print('1' * (i+1) + '0' * (m - i - 1))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\n\ndef get_input():\n    n, m, k = [int(i) for i in sys.stdin.readline().split()]\n    roads = []\n    for i in range(m):\n        roads.append([int(i) for i in sys.stdin.readline().split()])\n    return n, m, k, roads\n\n\ndef get_adj_list(roads, n):\n    adj_list = [[] for i in range(n)]\n    for road in roads:\n        adj_list[road[0] - 1].append(road[1] - 1)\n        adj_list[road[1] - 1].append(road[0] - 1)\n    return adj_list\n\n\ndef get_distances(adj_list, n):\n    distances = [-1 for i in range(n)]\n    distances[0] = 0\n    queue = [0]\n    while queue:\n        curr = queue[0]\n        queue.pop(0)\n        for neighbor in adj_list[curr]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[curr] + 1\n                queue.append(neighbor)\n    return distances\n\n\ndef get_roads_to_remove(roads, n, distances):\n    roads_to_remove = []\n    for road in roads:\n        if (distances[road[0] - 1] - distances[road[1] - 1]) % 2 == 0:\n            roads_to_remove.append(road)\n    return roads_to_remove\n\n\ndef get_roads_to_remove_in_order(roads_to_remove, roads):\n    roads_to_remove_in_order = []\n    for road in roads:\n        if road in roads_to_remove:\n            roads_to_remove_in_order.append(1)\n        else:\n            roads_to_remove_in_order.append(0)\n    return roads_to_remove_in_order\n\n\ndef get_roads_to_remove_options(roads_to_remove_in_order, k):\n    roads_to_remove_options = set()\n    for i in range(len(roads_to_remove_in_order)):\n        if roads_to_remove_in_order[i] == 0:\n            roads_to_remove_in_order[i] = 1\n            roads_to_remove_options.add(tuple(roads_to_remove_in_order))\n            roads_to_remove_in_order[i] = 0\n    return roads_to_remove_options\n\n\ndef print_roads_to_remove_options(roads_to_remove_options, k):\n    print(len(roads_to_remove_options))\n    for option in roads_to_remove_options:\n        print(''.join([str(i) for i in option]))\n\n\ndef main():\n    n, m, k, roads = get_input()\n    adj_list = get_adj_list(roads, n)\n    distances = get_distances(adj_list, n)\n    roads_to_remove = get_roads_to_remove(roads, n, distances)\n    roads_to_remove_in_order = get_roads_to_remove_in_order(roads_to_remove, roads)\n    roads_to_remove_options = get_roads_to_remove_options(roads_to_remove_in_order, k)\n    print_roads_to_remove_options(roads_to_remove_options, k)\n\n\nif __name__ == '__main__':\n    main()", "\n\n# Use DFS to find the number of roads needed to reach each city from the capital\n# Then, use DFS to find the number of roads needed to reach each city from the\n# capital, but this time, treat the roads with the largest number of roads needed\n# to reach a city as a \"roadblock\". Then repeat the process with the next largest\n# number of roads needed to reach a city as a roadblock, and so on.\n\nimport sys\n\ndef dfs(city, parent, adj_list, ignore):\n    if city in ignore:\n        return 0\n    if city in adj_list:\n        total = 0\n        for next_city in adj_list[city]:\n            if next_city != parent:\n                total += dfs(next_city, city, adj_list, ignore)\n        return total + 1\n    return 0\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    adj_list = {}\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        if a not in adj_list:\n            adj_list[a] = [b]\n        else:\n            adj_list[a].append(b)\n        if b not in adj_list:\n            adj_list[b] = [a]\n        else:\n            adj_list[b].append(a)\n    # Find the number of roads needed to reach each city from the capital\n    num_roads = {}\n    for city in adj_list:\n        num_roads[city] = dfs(city, 0, adj_list, set())\n    # Sort the cities by the number of roads needed to reach them from the capital\n    sorted_cities = sorted(num_roads, key=lambda city: num_roads[city])\n    # Use DFS to find the number of roads needed to reach each city from the\n    # capital, with the largest number of roads needed to reach a city as a roadblock\n    for city in sorted_cities[:-1]:\n        num_roads[city] = dfs(city, 0, adj_list, set([city]))\n    # Sort the cities by the number of roads needed to reach them from the capital\n    sorted_cities = sorted(num_roads, key=lambda city: num_roads[city])\n    # For each city, find the roads that are needed to reach it from the capital\n    needed_roads = {}\n    for city in sorted_cities:\n        needed_roads[city] = set()\n        parent = city\n        while parent != 1:\n            for next_city in adj_list[parent]:\n                if next_city != parent and num_roads[next_city] == num_roads[parent] - 1:\n                    needed_roads[city].add((parent, next_city))\n                    parent = next_city\n                    break\n    # Enumerate all possible ways to choose k roads\n    ways = set()\n    for city in sorted_cities[:-1]:\n        if len(ways) == k:\n            break\n        for road in needed_roads[city]:\n            if len(ways) == k:\n                break\n            ways.add(road)\n            for next_city in sorted_cities[sorted_cities.index(city)+1:]:\n                if len(ways) == k:\n                    break\n                if road in needed_roads[next_city]:\n                    needed_roads[next_city].remove(road)\n    # Convert the set of roads to a string of 0s and 1s\n    ways = [bin(sum([2**i for i in range(m) if (i+1, i+2) in way]))[2:] for way in ways]\n    # Output the answer\n    print(len(ways))\n    for way in ways:\n        print(way.zfill(m))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef read_ints():\n  return [int(x) for x in raw_input().split()]\n\ndef read_int():\n  return int(raw_input())\n\ndef read_matrix(n, m):\n  return [read_ints() for x in range(n)]\n\ndef dfs(graph, start, visited):\n  visited.add(start)\n  for neighbor in graph[start]:\n    if neighbor not in visited:\n      dfs(graph, neighbor, visited)\n\ndef main():\n  n, m, k = read_ints()\n  graph = [[] for x in range(n)]\n  for _ in range(m):\n    a, b = read_ints()\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n  visited = set()\n  dfs(graph, 0, visited)\n  if len(visited) != n:\n    print 0\n    return\n  print k\n  for i in range(k):\n    roads = []\n    for i in range(n-1):\n      roads.append(str(i % 2))\n    print ''.join(roads)\n\nif __name__ == '__main__':\n  main()", "\n\nimport sys\nimport queue\n\ndef find_shortest_path(graph, start, end):\n    q = queue.Queue()\n    q.put((start, 0))\n    visited = set()\n    while not q.empty():\n        node, dist = q.get()\n        if node == end:\n            return dist\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                q.put((neighbor, dist + 1))\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().strip().split()]\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    total_dist = 0\n    for i in range(1, n):\n        total_dist += find_shortest_path(graph, 0, i)\n    min_dist = total_dist\n    min_edges = set()\n    for i in range(m):\n        for j in range(i + 1, m):\n            dist = total_dist\n            a1, b1 = [int(x) for x in sys.stdin.readline().strip().split()]\n            a2, b2 = [int(x) for x in sys.stdin.readline().strip().split()]\n            if a1 == a2 or a1 == b2 or b1 == a2 or b1 == b2:\n                continue\n            for c in range(1, n):\n                if c == a1 or c == a2 or c == b1 or c == b2:\n                    continue\n                dist -= find_shortest_path(graph, 0, c)\n                dist += find_shortest_path(graph, a1, c)\n                dist += find_shortest_path(graph, a2, c)\n                dist += find_shortest_path(graph, b1, c)\n                dist += find_shortest_path(graph, b2, c)\n            if dist < min_dist:\n                min_dist = dist\n                min_edges = set()\n            if dist == min_dist:\n                min_edges.add((i, j))\n    print(len(min_edges))\n    for i in range(m):\n        if (i, i + 1) in min_edges:\n            print('1', end='')\n        else:\n            print('0', end='')\n    print()\n    for i in range(m):\n        if (i + 1, i + 2) in min_edges:\n            print('1', end='')\n        else:\n            print('0', end='')\n    print()\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef read_input():\n    n, m, k = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        roads.append(tuple(map(int, input().split())))\n    return n, m, k, roads\n\n\ndef main():\n    n, m, k, roads = read_input()\n    # TODO\n\n\nif __name__ == '__main__':\n    main()"]