["\n\nn = int(input())\nx = list(map(int, input().split()))\nx.sort()\n\nans = 1\ncurr = x[0]\nfor i in range(1, n):\n    if x[i] == curr:\n        continue\n    if x[i] == curr*2:\n        ans += 1\n        curr = x[i]\n    elif x[i] > curr*2:\n        break\n\nprint(ans)\nfor i in range(ans):\n    print(x[i], end=' ')", "\n\n# SOLUTION\n\ndef get_closest_power_of_2(x):\n    d = 0\n    while x != 1:\n        x //= 2\n        d += 1\n    return d\n\n# read input\nn = int(input())\npoints = list(map(int, input().split()))\npoints.sort()\n\n# get differences between each point\ndifferences = []\nfor i in range(n-1):\n    differences.append(points[i+1] - points[i])\n\n# get powers of 2 closest to the differences\nd_powers = []\nfor d in differences:\n    d_powers.append(get_closest_power_of_2(d))\n\n# get the maximum number of points\nm = 1\nfor i in range(n-1):\n    if d_powers[i] == d_powers[i+1]:\n        m += 1\n\n# print the result\nprint(m)\nprint(*points[:m])", "\n\n# TODO: Finish this problem.", "\n\nn = int(input())\nx = list(map(int, input().split()))\n\n# 2^0 = 1, 2^1 = 2 ... 2^18 = 262144\n# So max distance between two points is 2^18\n# We can use a list to store distances between each point and every other point\n# Then use a greedy approach to choose the longest distance first, and then the second longest and so on\n\n# Store all distances between each point in a list\ndistances = []\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            continue\n        # Use abs to get the distance between the two points\n        distances.append(abs(x[i] - x[j]))\n\n# Sort the list in descending order\ndistances.sort(reverse=True)\n\n# Use a set to store the chosen points\nchosen = set()\n\n# For each distance, find the two points that have that distance\n# and add them to the set of chosen points\nfor d in distances:\n    # Calculate the two points that have that distance\n    # If the two points are already in the set, then skip them\n    # If the two points are not in the set, add them to the set\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if abs(x[i] - x[j]) == d:\n                if x[i] not in chosen and x[j] not in chosen:\n                    chosen.add(x[i])\n                    chosen.add(x[j])\n\n# Print the length of the set\nprint(len(chosen))\n\n# Print the set\nprint(*chosen)", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n    x = sorted(x)\n    #print(x)\n    d = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            d[x[j] - x[i]] = (i, j)\n    #print(d)\n    ans = [x[0]]\n    for i in range(1, n):\n        s = ans[-1]\n        while s in d:\n            s = d[s][1]\n            ans.append(s)\n    print(len(ans))\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    x = list(map(int, input().split()))\n\n    # This is a greedy algorithm\n    # For each point, find the closest point which is 2^i away from it\n    # If there is no such point, then this point is not included in the answer\n    # Otherwise, the point is added to the answer and the closest point is removed from the list\n    # The closest point is removed so that we don't have to consider it again\n    # We do not have to consider the point again because any other point which is 2^i away from it\n    # has already been considered when we considered the closest point\n    #\n    # Time complexity: O(n log n)\n    # Space complexity: O(n)\n    x.sort()\n    ans = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n:\n            if x[j] - x[i] == 2:\n                ans.append(x[i])\n                x.pop(j)\n                break\n            elif x[j] - x[i] > 2:\n                break\n            j += 1\n        i += 1\n    print(len(ans))\n    print(' '.join(map(str, ans)))\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    # arr.sort()\n\n    def get_powers(arr):\n        powers = []\n        for i in range(len(arr)):\n            powers.append([])\n            for j in range(i+1, len(arr)):\n                power = 0\n                while arr[i] - arr[j] != 2 ** power and arr[j] - arr[i] != 2 ** power:\n                    power += 1\n                powers[i].append(power)\n        return powers\n\n    powers = get_powers(arr)\n\n    def get_max_powers(powers):\n        max_powers = []\n        for i in range(len(powers)):\n            max_powers.append(max(powers[i]))\n        return max_powers\n\n    max_powers = get_max_powers(powers)\n\n    def get_max_power(max_powers):\n        max_power = 0\n        for i in range(len(max_powers)):\n            if max_powers[i] > max_power:\n                max_power = max_powers[i]\n        return max_power\n\n    max_power = get_max_power(max_powers)\n\n    def get_max_power_indices(max_powers, max_power):\n        max_power_indices = []\n        for i in range(len(max_powers)):\n            if max_powers[i] == max_power:\n                max_power_indices.append(i)\n        return max_power_indices\n\n    max_power_indices = get_max_power_indices(max_powers, max_power)\n\n    def get_max_power_arr(arr, max_power_indices):\n        max_power_arr = []\n        for i in max_power_indices:\n            max_power_arr.append(arr[i])\n        return max_power_arr\n\n    max_power_arr = get_max_power_arr(arr, max_power_indices)\n\n    print(len(max_power_arr))\n    for i in max_power_arr:\n        print(i, end=' ')\n\n\nif __name__ == '__main__':\n    main()"]