["\n\nT = int(input())\nfor _ in range(T):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, input().split())) + list(map(int, input().split())))\n\n    def checkTile(tile):\n        for i in range(4):\n            if tile[i] > m:\n                return False\n        return True\n\n    def checkSquare(square):\n        for i in range(m):\n            for j in range(i+1, m):\n                if square[i][j] != square[j][i]:\n                    return False\n        return True\n\n    def search(square):\n        if len(square) == m:\n            if checkSquare(square):\n                return True\n            else:\n                return False\n        for tile in tiles:\n            if checkTile(tile):\n                square.append(tile)\n                if search(square):\n                    return True\n                square.pop()\n        return False\n\n    if search([]):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "\n# Solution = TLE\nimport numpy as np\n\nt = int(input())\n\nfor i in range(t):\n  n,m = map(int,input().split())\n  t_list = []\n  for j in range(n):\n    t1 = list(map(int,input().split()))\n    t2 = list(map(int,input().split()))\n    t_list.append(np.array([t1,t2]))\n  m_list = []\n  for k in range(m):\n    m_list.append(list(map(int,input().split())))\n  m_list = np.array(m_list)\n  m_list = np.transpose(m_list)\n  m_list = m_list.tolist()\n\n  m_list_copy = m_list.copy()\n  i = 0\n  j = 0\n  while i < m:\n    while j < m:\n      for t in t_list:\n        if t.tolist() == m_list[i][j:j+2]:\n          m_list_copy[i][j:j+2] = []\n          m_list_copy[j:j+2][i] = []\n      j += 2\n    i += 2\n    j = 0\n  if any(m_list_copy):\n    print(\"NO\")\n  else:\n    print(\"YES\")", "\n\n# Solution\n\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, input().split())))\n        tiles.append(list(map(int, input().split())))\n    ans = \"YES\"\n    for i in range(m):\n        for j in range(i+1, m):\n            for k in range(len(tiles)):\n                if tiles[k][0] == tiles[k][1] and tiles[k][0] == i+1:\n                    if tiles[k][2] == tiles[k][3] and tiles[k][2] == j+1:\n                        break\n                elif tiles[k][0] == tiles[k][1] and tiles[k][0] == j+1:\n                    if tiles[k][2] == tiles[k][3] and tiles[k][2] == i+1:\n                        break\n                else:\n                    ans = \"NO\"\n                    break\n            if ans == \"NO\":\n                break\n        if ans == \"NO\":\n            break\n    print(ans)", "\ndef build_matrix(n, m, tiles):\n    matrix = []\n    for i in xrange(m):\n        matrix.append([0] * m)\n    return matrix\n\ndef check_matrix(matrix, tiles):\n    pass\n\ndef solve():\n    pass\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()", "\n\nfrom collections import defaultdict\n\ndef read_tiles(n):\n    tiles = defaultdict(list)\n    for i in range(n):\n        t = [(int(x), int(y)) for x, y in [input().split()]]\n        tiles[t[0]].append(t)\n    return tiles\n\ndef solve(n, m, tiles):\n    if m % 2 == 1:\n        return 'NO'\n\n    def dfs(i, j, size, tile, visited, t):\n        if i < 0 or j < 0 or i >= m or j >= m or visited[i][j] == 1:\n            return False\n\n        if size == 1:\n            if t[i][j] == tile[0]:\n                visited[i][j] = 1\n                return True\n            else:\n                return False\n\n        if t[i][j] != tile[0]:\n            return False\n\n        visited[i][j] = 1\n\n        if dfs(i + size//2, j, size//2, tile[1], visited, t) and\\\n            dfs(i, j + size//2, size//2, tile[2], visited, t) and\\\n            dfs(i + size//2, j + size//2, size//2, tile[3], visited, t):\n            return True\n        else:\n            visited[i][j] = 0\n            return False\n\n    t = [[0 for _ in range(m)] for _ in range(m)]\n    for i in range(m//2):\n        for j in range(m//2):\n            visited = [[0 for _ in range(m)] for _ in range(m)]\n            if not dfs(i, j, m//2, (0, 0, 0, 0), visited, t):\n                return 'NO'\n\n    for i in range(m//2):\n        for j in range(m//2, m):\n            visited = [[0 for _ in range(m)] for _ in range(m)]\n            if not dfs(i, j, m//2, (0, 0, 0, 0), visited, t):\n                return 'NO'\n\n    for i in range(m//2, m):\n        for j in range(m//2):\n            visited = [[0 for _ in range(m)] for _ in range(m)]\n            if not dfs(i, j, m//2, (0, 0, 0, 0), visited, t):\n                return 'NO'\n\n    for i in range(m//2, m):\n        for j in range(m//2, m):\n            visited = [[0 for _ in range(m)] for _ in range(m)]\n            if not dfs(i, j, m//2, (0, 0, 0, 0), visited, t):\n                return 'NO'\n\n    return 'YES'\n\nif __name__ == '__main__':\n    t = int(input())\n    for i in range(t):\n        n, m = [int(x) for x in input().split()]\n        tiles = read_tiles(n)\n        print(solve(n, m, tiles))"]