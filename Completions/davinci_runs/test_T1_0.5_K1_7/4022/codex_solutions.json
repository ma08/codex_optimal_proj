["\n\n# Read the input\nn = int(input())\n\n# Create an array of segments\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\n# Sort the segments by their starting point\nsegments.sort(key=lambda x: x[0])\n\n# Create an array of length of intersections in which the i-th element is the length of the intersection of the first i segments\nintersections = [segments[0][1] - segments[0][0]]\nfor i in range(1, n):\n    intersections.append(max(0, min(segments[i][1], intersections[i-1]) - segments[i][0]))\n\n# Create an array of length of intersections in which the i-th element is the length of the intersection of the i-th to the last segment\nintersections_reversed = [0]\nfor i in range(n-1, 0, -1):\n    intersections_reversed.append(max(0, min(segments[i][1], intersections_reversed[-1]) - segments[i][0]))\n\n# Create an array of length of intersections in which the i-th element is the length of the intersection of the first i-1 segments and the i+1-th to the last segments\nintersections_reversed.reverse()\nintersections_2 = [0]\nfor i in range(1, n):\n    intersections_2.append(max(0, min(intersections[i-1], intersections_reversed[i]) - segments[i][0]))\n\n# Create an array of length of intersections in which the i-th element is the length of the intersection of the i-th to the last segment and the first i-1 segments\nintersections_2.reverse()\nintersections_3 = [0]\nfor i in range(1, n):\n    intersections_3.append(max(0, min(intersections_reversed[i], intersections[i-1]) - segments[i][0]))\n\n# Find the maximum of the array of length of intersections\nprint(max(intersections_2 + intersections_3))", "\n\nimport sys\n\ndef solve(n, segments):\n    segments.sort()\n    for i in range(n):\n        if i < n - 1 and segments[i][1] >= segments[i+1][0]:\n            return segments[i][1] - segments[i+1][0]\n        if i > 0 and segments[i][0] <= segments[i-1][1]:\n            return segments[i-1][1] - segments[i][0]\n    return 0\n\nif __name__ == \"__main__\":\n    n = int(input())\n    segments = [tuple(map(int, input().split())) for _ in range(n)]\n    print(solve(n, segments))", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    points = defaultdict(list)\n    for _ in xrange(n):\n        l, r = map(int, sys.stdin.readline().strip().split())\n        points[l].append(r)\n        points[r].append(l)\n    points = sorted(points.items())\n    ans = 0\n    for i in xrange(len(points)-1):\n        l, r = points[i]\n        if len(points[i][1]) == 1:\n            continue\n        for r2 in points[i][1]:\n            if r2 == points[i+1][0]:\n                ans = max(ans, r2-l)\n    print ans\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef read_ints(inp = sys.stdin):\n    return list(map(int, inp.readline().strip().split()))\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        segments.append(read_ints())\n\n    segments.sort()\n\n    best = 0\n    for i in range(n):\n        if i == 0:\n            l = segments[i + 1][0]\n            r = segments[i + 1][1]\n        elif i == n - 1:\n            l = segments[i - 1][0]\n            r = segments[i - 1][1]\n        else:\n            l = max(segments[i - 1][0], segments[i + 1][0])\n            r = min(segments[i - 1][1], segments[i + 1][1])\n        best = max(best, r - l)\n    print(best)\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef solve(segments):\n    segments.sort(key=lambda x: x[1])\n    max_intersection = 0\n    for i in range(len(segments) - 1):\n        intersection = segments[i][1] - segments[i + 1][0]\n        if intersection > max_intersection:\n            max_intersection = intersection\n    return max_intersection\n\n\nif __name__ == '__main__':\n    n = int(input())\n    segments = [tuple(map(int, input().split())) for _ in range(n)]\n    print(solve(segments))", "\n\n\nclass Query:\n    def __init__(self, l, r, idx):\n        self.l = l\n        self.r = r\n        self.idx = idx\n\n\ndef solve(queries):\n    queries.sort(key=lambda x: x.l)\n    l = queries[0].l\n    r = queries[0].r\n    idx = queries[0].idx\n    res1 = 0\n    res2 = 0\n    for i in range(1, len(queries)):\n        if queries[i].l <= r:\n            r = max(r, queries[i].r)\n        else:\n            res1 = max(res1, r - l)\n            res2 = max(res2, r - l - queries[i].r + queries[i].l)\n            l = queries[i].l\n            r = queries[i].r\n    res1 = max(res1, r - l)\n    return max(res1, res2)\n\n\ndef main():\n    n = int(input())\n    queries = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        queries.append(Query(l, r, i))\n    print(solve(queries))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments = sorted(segments, key=lambda x: x[0])\n\nmax_intersection = 0\nfor i in range(n):\n    if i > 0:\n        max_intersection = max(max_intersection, segments[i-1][1] - segments[i][0])\n    if i < n-1:\n        max_intersection = max(max_intersection, segments[i+1][1] - segments[i][0])\n\nprint(max_intersection)"]