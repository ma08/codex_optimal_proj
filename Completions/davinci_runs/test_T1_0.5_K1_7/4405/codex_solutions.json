["", "\n\n\nn = int(input())\na = list(map(int,input().split()))\n\nd = {}\nfor i in range(n):\n    if a[i] not in d:\n        d[a[i]] = 0\n    d[a[i]] += 1\n\nans = 0\nfor v in d.values():\n    ans += v\n    if v >= 2:\n        v -= 2\n        ans += v//4*4\n        v %= 4\n        if v:\n            ans += 2\nprint(ans)", "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # remove duplicates\n    a = set(a)\n\n    # count occurences\n    cnt = {}\n    for i in a:\n        if i not in cnt:\n            cnt[i] = 0\n        cnt[i] += 1\n\n    # sort by number of occurences\n    cnt = sorted(cnt.items(), key=lambda x: x[1], reverse=True)\n\n    # count answer\n    ans = 0\n    for i in range(len(cnt)):\n        ans += cnt[i][1]\n        if i != 0:\n            if cnt[i][1] > cnt[i-1][1] * 2:\n                ans -= cnt[i][1] - cnt[i-1][1] * 2\n            else:\n                break\n    print(ans)\n\nmain()", "\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # count = collections.Counter(a)\n    # res = 0\n    # for i in range(1, n+1):\n    #     res += count[i] // 2\n    # return res\n\n    count = collections.Counter(a)\n    res = 0\n    for i in range(1, n+1):\n        res += count[i] // 2\n    return res\n\nprint(solve())", "\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    #print(n, a)\n    d = dict()\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]] += 1\n        else:\n            d[a[i]] = 1\n    #print(d)\n    d = dict(sorted(d.items(), key=lambda x: x[1], reverse=True))\n    #print(d)\n    res = 0\n    for k, v in d.items():\n        res += v\n        if v > 1:\n            d[k] = v // 2\n        else:\n            del d[k]\n    #print(d)\n    while len(d) > 0:\n        new_d = dict()\n        for k, v in d.items():\n            if v > 1:\n                new_d[k] = v // 2\n        d = new_d\n        res += len(d)\n    print(res)\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(problems, topics):\n\tcontests = []\n\tfor topic in topics:\n\t\tcontests.append(problems.count(topic))\n\tcontests.sort()\n\tcontests.reverse()\n\tfor i in range(len(contests)):\n\t\tcontests[i] = contests[i] / (2 ** i)\n\treturn int(sum(contests))\n\nn = int(raw_input())\nproblems = [int(x) for x in raw_input().split()]\ntopics = list(set(problems))\nprint solve(problems, topics)", "\n\nimport collections\n\nn = int(input())\na = list(map(int, input().split()))\n\ncnt = collections.Counter(a)\n\n# sort the topics by the number of problems with them\ntopics = sorted(cnt.keys(), key=lambda x: cnt[x], reverse=True)\n\n# the number of problems in the current contest\ncur_cnt = 0\n\n# the number of problems in the optimal set of contests\nans = 0\n\nfor t in topics:\n    # the number of problems with the topic t\n    n = cnt[t]\n\n    # the optimal number of problems with the topic t to include in the current contest\n    # is the maximum number of problems with the topic t such that the number of problems\n    # in the current contest is exactly twice as much as in the previous contest\n    cur_cnt = max(cur_cnt, min(n, 2 * cur_cnt))\n\n    # update the answer\n    ans += cur_cnt\n\n    # the number of problems with the topic t is decreased\n    cnt[t] -= cur_cnt\n\nprint(ans)"]