2022-04-13 21:50:30.138463 """
Takahashi is now competing in a programming contest, but he received TLE in a problem where the answer is YES or NO.
When he checked the detailed status of the submission, there were N test cases in the problem, and the code received TLE in M of those cases.
Then, he rewrote the code to correctly solve each of those M cases with 1/2 probability in 1900 milliseconds, and correctly solve each of the other N-M cases without fail in 100 milliseconds.
Now, he goes through the following process:
 - Submit the code.
 - Wait until the code finishes execution on all the cases.
 - If the code fails to correctly solve some of the M cases, submit it again.
 - Repeat until the code correctly solve all the cases in one submission.
Let the expected value of the total execution time of the code be X milliseconds. Print X (as an integer).

-----Constraints-----
 - All input values are integers.
 - 1 \leq N \leq 100
 - 1 \leq M \leq {\rm min}(N, 5)

-----Input-----
Input is given from Standard Input in the following format:
N M

-----Output-----
Print X, the expected value of the total execution time of the code, as an integer. It can be proved that, under the constraints in this problem, X is an integer not exceeding 10^9.

-----Sample Input-----
1 1

-----Sample Output-----
3800

In this input, there is only one case. Takahashi will repeatedly submit the code that correctly solves this case with 1/2 probability in 1900 milliseconds.
The code will succeed in one attempt with 1/2 probability, in two attempts with 1/4 probability, and in three attempts with 1/8 probability, and so on.
Thus, the answer is 1900 \times 1/2 + (2 \times 1900) \times 1/4 + (3 \times 1900) \times 1/8 + ... = 3800.
"""
2022-04-13 21:50:30.138471 --------------------------
2022-04-13 21:50:59.825398 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\n\ntotal = 0\nfor i in range(N):\n    if i < M:\n        total += (1/2) * (1900 * (2 ** i))\n    else:\n        total += 100 * (2 ** (N-i))\n\nprint(int(total))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nfrom math import factorial\nfrom decimal import Decimal, getcontext\nfrom operator import mul\nfrom fractions import Fraction\n\ndef nCk(n,k):\n    return int(factorial(n) / (factorial(k) * factorial(n-k)))\n\ndef nPk(n,k):\n    return int(factorial(n) / factorial(n-k))\n\ndef solve(n,m):\n    getcontext().prec = 6\n    a = Decimal(1900)\n    b = Decimal(100)\n    p = Decimal(1/2)\n    q = Decimal(1-p)\n    ans = Decimal(0)\n    for i in range(m):\n        ans += Decimal(nPk(m,i)) * Decimal(p**i) * Decimal(q**(m-i)) * Decimal(a*i + b*(n-m))\n    return int(ans)\n\ndef main():\n    n,m = map(int,input().split())\n    print(solve(n,m))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"main function\"\"\"\n    n, m = map(int, input().split())\n    if n == 1:\n        print(3800)\n    else:\n        print(int(1900 * (1/2 + 1/4 + 1/8 + 1/16 + 1/32)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\n\ndef get_total_expectation(n, m):\n    \"\"\"\n    :param n: total number of cases\n    :param m: number of cases that pass with 1/2 probability\n    :return: expected value of the total execution time of the code\n    \"\"\"\n    # init\n    p = 1/2\n    expectation = 0\n    for i in range(1, n+1):\n        if i <= m:\n            expectation += (i*1900)*p\n        else:\n            expectation += (i*100)*p\n        p /= 2\n    return expectation\n\nprint(int(get_total_expectation(n, m)))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nN, M = map(int, input().split())\n\nif M == 0:\n    print(100*N)\nelse:\n    prob_fail = M/N\n    prob_success = 1-prob_fail\n    prob_fail_n = prob_fail\n    prob_success_n = prob_success\n\n    prob_success_1 = prob_success_n*(prob_success**(N-1))\n    prob_fail_1 = prob_fail_n*(prob_success**(N-1))\n    prob_fail_2 = prob_fail_n*(prob_fail**(N-1))*prob_success\n    prob_fail_3 = prob_fail_n*(prob_fail**(N-1))*prob_fail\n\n    # print(prob_success_1, prob_fail_1, prob_fail_2, prob_fail_3)\n    print(100*prob_success_1 + (100+1900)*prob_fail_1 + (100+1900*2)*prob_fail_2 + (100+1900*3)*prob_fail_3)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    N, M = map(int, input().split())\n    case_times = [100] * (N-M) + [1900] * M\n    total_time = 0\n    for case_time in case_times:\n        total_time += case_time\n    print(total_time)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\n\nprint(1900 * m * 2**m + 100 * (n - m))"
    }
  ],
  "created": 1649886630,
  "id": "cmpl-4wfAck1WjWBdI1liMXpTApOqavb0E",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:50:59.825668 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\n\ntotal = 0\nfor i in range(N):\n    if i < M:\n        total += (1/2) * (1900 * (2 ** i))\n    else:\n        total += 100 * (2 ** (N-i))\n\nprint(int(total))"
}
2022-04-13 21:50:59.825707 REASON stop
2022-04-13 21:50:59.826150 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nfrom math import factorial\nfrom decimal import Decimal, getcontext\nfrom operator import mul\nfrom fractions import Fraction\n\ndef nCk(n,k):\n    return int(factorial(n) / (factorial(k) * factorial(n-k)))\n\ndef nPk(n,k):\n    return int(factorial(n) / factorial(n-k))\n\ndef solve(n,m):\n    getcontext().prec = 6\n    a = Decimal(1900)\n    b = Decimal(100)\n    p = Decimal(1/2)\n    q = Decimal(1-p)\n    ans = Decimal(0)\n    for i in range(m):\n        ans += Decimal(nPk(m,i)) * Decimal(p**i) * Decimal(q**(m-i)) * Decimal(a*i + b*(n-m))\n    return int(ans)\n\ndef main():\n    n,m = map(int,input().split())\n    print(solve(n,m))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:50:59.826296 REASON stop
2022-04-13 21:50:59.826656 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"main function\"\"\"\n    n, m = map(int, input().split())\n    if n == 1:\n        print(3800)\n    else:\n        print(int(1900 * (1/2 + 1/4 + 1/8 + 1/16 + 1/32)))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:50:59.826706 REASON stop
2022-04-13 21:50:59.840089 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\n\ndef get_total_expectation(n, m):\n    \"\"\"\n    :param n: total number of cases\n    :param m: number of cases that pass with 1/2 probability\n    :return: expected value of the total execution time of the code\n    \"\"\"\n    # init\n    p = 1/2\n    expectation = 0\n    for i in range(1, n+1):\n        if i <= m:\n            expectation += (i*1900)*p\n        else:\n            expectation += (i*100)*p\n        p /= 2\n    return expectation\n\nprint(int(get_total_expectation(n, m)))"
}
2022-04-13 21:50:59.840152 REASON stop
2022-04-13 21:50:59.855203 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nN, M = map(int, input().split())\n\nif M == 0:\n    print(100*N)\nelse:\n    prob_fail = M/N\n    prob_success = 1-prob_fail\n    prob_fail_n = prob_fail\n    prob_success_n = prob_success\n\n    prob_success_1 = prob_success_n*(prob_success**(N-1))\n    prob_fail_1 = prob_fail_n*(prob_success**(N-1))\n    prob_fail_2 = prob_fail_n*(prob_fail**(N-1))*prob_success\n    prob_fail_3 = prob_fail_n*(prob_fail**(N-1))*prob_fail\n\n    # print(prob_success_1, prob_fail_1, prob_fail_2, prob_fail_3)\n    print(100*prob_success_1 + (100+1900)*prob_fail_1 + (100+1900*2)*prob_fail_2 + (100+1900*3)*prob_fail_3)"
}
2022-04-13 21:50:59.855356 REASON stop
2022-04-13 21:50:59.856996 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    N, M = map(int, input().split())\n    case_times = [100] * (N-M) + [1900] * M\n    total_time = 0\n    for case_time in case_times:\n        total_time += case_time\n    print(total_time)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:50:59.857082 REASON stop
2022-04-13 21:50:59.857992 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\n\nprint(1900 * m * 2**m + 100 * (n - m))"
}
2022-04-13 21:50:59.858057 REASON stop
