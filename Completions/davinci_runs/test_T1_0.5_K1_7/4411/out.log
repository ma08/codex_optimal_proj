2022-04-13 20:35:28.180203 """
The only difference between easy and hard versions is constraints.

You are given $n$ segments on the coordinate axis $OX$. Segments can intersect, lie inside each other and even coincide. The $i$-th segment is $[l_i; r_i]$ ($l_i \le r_i$) and it covers all integer points $j$ such that $l_i \le j \le r_i$.

The integer point is called bad if it is covered by strictly more than $k$ segments.

Your task is to remove the minimum number of segments so that there are no bad points at all.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of segments and the maximum number of segments by which each integer point can be covered.

The next $n$ lines contain segments. The $i$-th line contains two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le 2 \cdot 10^5$) — the endpoints of the $i$-th segment.


-----Output-----

In the first line print one integer $m$ ($0 \le m \le n$) — the minimum number of segments you need to remove so that there are no bad points.

In the second line print $m$ distinct integers $p_1, p_2, \dots, p_m$ ($1 \le p_i \le n$) — indices of segments you remove in any order. If there are multiple answers, you can print any of them.


-----Examples-----
Input
7 2
11 11
9 11
7 8
8 9
7 8
9 11
7 9

Output
3
4 6 7 

Input
5 1
29 30
30 30
29 29
28 30
30 30

Output
3
1 4 5 

Input
6 1
2 3
3 3
2 3
2 2
2 3
2 3

Output
4
1 3 5 6
"""
2022-04-13 20:35:28.180267 --------------------------
2022-04-13 20:36:30.898409 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    l = [0] * n\n    r = [0] * n\n    for i in xrange(n):\n        l[i], r[i] = map(int, sys.stdin.readline().split())\n\n    print n - solve(n, k, l, r)\n    for i in xrange(n):\n        if not l[i]:\n            print i + 1,\n\ndef solve(n, k, l, r):\n    \"\"\"\n    We are given $n$ segments of the form $[l_i, r_i]$ on the number line.\n    We want to remove a minimum number of segments $[l_i, r_i]$ such that no\n    point is covered by more than $k$ segments.\n\n    We will first solve a simpler problem: given $n$ segments of the form\n    $[l_i, r_i]$ on the number line, we want to remove a minimum number of\n    segments $[l_i, r_i]$ such that no point is covered by more than $1$\n    segment.\n\n    This is equivalent to finding the minimum number of segments $[l_i, r_i]$\n    such that the union of the remaining segments is a connected set.\n\n    Let $S$ be the set of all positions on the number line. Let $R$ be the\n    set of all positions on the number line covered by at least one segment.\n    Then, $R$ is a set of intervals.\n\n    Let $T$ be the set of all positions on the number line covered by at least\n    two segments. Then, $T$ is a set of intervals.\n\n    We want to remove a minimum number of segments $[l_i, r_i]$ such that\n    $T$ is empty.\n\n    This is equivalent to finding a minimum number of intervals in $R$ such\n    that the union of the remaining intervals is a connected set.\n\n    Suppose we have a set of intervals $I$ such that the union of the\n    intervals is a connected set.\n\n    We will construct a graph $G$ such that $I$ is the set of intervals\n    corresponding to the connected components of $G$.\n\n    Let $G$ be a graph with a vertex for each position $i$ on the number\n    line. Add an edge between $i$ and $i + 1$ for each $i$ on the number\n    line.\n\n    For each interval $[l_i, r_i]$ in $I$, add an edge between $l_i$ and\n    $r_i$.\n\n    The connected components of $G$ are the intervals in $I$.\n\n    We can solve the problem by finding the connected components of $G$\n    and removing the components with the most vertices.\n\n    Let $C$ be the number of connected components of $G$.\n\n    We can find $C$ in $O(n \\log n)$ time using a disjoint set data\n    structure.\n\n    We can find the size of the largest connected component in $O(n)$\n    time by iterating over the vertices of $G$ and finding the size of\n    the connected component for each vertex.\n\n    The time complexity is $O(n \\log n)$.\n    \"\"\"\n\n    def disjoint_set_init(n):\n        \"\"\"\n        Initialize a disjoint set data structure with $n$ elements.\n        \"\"\"\n        d = {}\n        for i in xrange(n):\n            d[i] = i\n        return d\n\n    def disjoint_set_find(d, i):\n        \"\"\"\n        Find the set containing $i$.\n        \"\"\"\n        if d[i] == i:\n            return i\n        return disjoint_set_find(d, d[i])\n\n    def disjoint_set_union(d, i, j):\n        \"\"\"\n        Merge the sets containing $i$ and $j$.\n        \"\"\"\n        i = disjoint_set_find(d, i)\n        j = disjoint_set_find(d, j)\n        d[i] = j\n\n    def disjoint_set_count(d):\n        \"\"\"\n        Count the number of sets.\n        \"\"\"\n        c = 0\n        for i in d:\n            if d[i] == i:\n                c += 1\n        return c\n\n    def disjoint_set_size(d, i):\n        \"\"\"\n        Count the number of elements in the set containing $i$.\n        \"\"\"\n        i = disjoint_set_find(d, i)\n        c = 0\n        for j in d:\n            if d[j] == i:\n                c += 1\n        return c\n\n    # Construct a graph $G$ such that the connected components of $G$ are\n    # the intervals in $R$.\n    d = disjoint_set_init(2 * 10 ** 5 + 1)\n    for i in xrange(n):\n        disjoint_set_union(d, l[i], r[i])\n    for i in xrange(2 * 10 ** 5):\n        disjoint_set_union(d, i, i + 1)\n\n    # Find the number of connected components of $G$.\n    c = disjoint_set_count(d)\n\n    # Find the size of the largest connected component of $G$.\n    m = 0\n    for i in xrange(2 * 10 ** 5 + 1):\n        m = max(m, disjoint_set_size(d, i))\n\n    # The number of intervals in $R$ is $c$.\n    # The number of intervals in $T$ is $c - 1$.\n    # The number of intervals in $R$ to remove is $c - 1 - k$.\n    # The number of segments to remove is $c - 1 - k$.\n    return c - 1 - k\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    l = []\n    for i in range(n):\n        l.append([int(x) for x in input().split()])\n    l.sort(key=lambda x: x[1])\n    #print(l)\n    count = 0\n    res = []\n    for i in range(n):\n        if l[i][1] - l[i][0] + 1 > k:\n            count += 1\n            res.append(i+1)\n        k -= l[i][1] - l[i][0] + 1\n    print(count)\n    print(*res)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n, k = map(int, input().split())\n    lst = []\n    for i in range(n):\n        lst.append(list(map(int, input().split())))\n    lst.sort(key=lambda x: x[0])\n    lst.sort(key=lambda x: x[1])\n    # print(lst)\n    count = 0\n    for i in range(n):\n        count += lst[i][1] - lst[i][0] + 1\n    if count <= k:\n        print(0)\n        print()\n        return\n    else:\n        count = 0\n        for i in range(n):\n            count += lst[i][1] - lst[i][0] + 1\n            if count > k:\n                break\n        # print(lst[:i])\n        ans_lst = []\n        for j in range(i, n):\n            if lst[j][0] >= lst[i - 1][0] and lst[j][1] <= lst[i - 1][1]:\n                ans_lst.append(j + 1)\n        print(len(ans_lst))\n        print(*ans_lst)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nfrom collections import Counter\nfrom typing import List\n\ndef solve(n: int, k: int, segments: List[List[int]]) -> List[int]:\n    \"\"\"\n    >>> solve(7, 2, [[11, 11], [9, 11], [7, 8], [8, 9], [7, 8], [9, 11], [7, 9]])\n    [4, 6, 7]\n    >>> solve(5, 1, [[29, 30], [30, 30], [29, 29], [28, 30], [30, 30]])\n    [1, 4, 5]\n    >>> solve(6, 1, [[2, 3], [3, 3], [2, 3], [2, 2], [2, 3], [2, 3]])\n    [1, 3, 5, 6]\n    \"\"\"\n    bad = Counter()\n    for l, r in segments:\n        bad[l] += 1\n        bad[r + 1] -= 1\n    for i in range(2, len(bad)):\n        bad[i] += bad[i - 1]\n    return [i + 1 for i, count in bad.items() if count > k]\n\nif __name__ == \"__main__\":\n    n, k = [int(s) for s in input().split()]\n    segments = [tuple(int(s) for s in input().split()) for _ in range(n)]\n    result = solve(n, k, segments)\n    print(len(result))\n    print(*result)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = [int(x) for x in sys.stdin.readline().split()]\n    segments = []\n    for i in range(n):\n        segments.append([int(x) for x in sys.stdin.readline().split()])\n    segments = sorted(segments, key=lambda x: x[1])\n    d = {}\n    for i in range(n):\n        if segments[i][0] not in d:\n            d[segments[i][0]] = 1\n        else:\n            d[segments[i][0]] += 1\n        if segments[i][1] + 1 not in d:\n            d[segments[i][1] + 1] = -1\n        else:\n            d[segments[i][1] + 1] -= 1\n    points = sorted(d.keys())\n    bad_points = []\n    curr_sum = 0\n    for point in points:\n        curr_sum += d[point]\n        if curr_sum > k:\n            bad_points.append(point)\n    if len(bad_points) == 0:\n        print(0)\n        return\n    i = 0\n    result = []\n    while i < len(segments):\n        if segments[i][0] in bad_points:\n            result.append(i + 1)\n            segments.pop(i)\n        else:\n            i += 1\n    for point in bad_points:\n        for i in range(len(segments)):\n            if segments[i][1] >= point:\n                result.append(i + 1)\n                segments.pop(i)\n                break\n    print(len(result))\n    print(' '.join([str(x) for x in result]))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef solve(segments, k):\n    segments.sort(key=lambda x: x[0])\n    n = len(segments)\n    cnt = 0\n    ans = []\n    for i in xrange(n-1):\n        if segments[i][1] >= segments[i+1][0]:\n            cnt += 1\n            if cnt > k:\n                ans.append(i+1)\n                cnt -= 1\n    return ans\n\nn, k = map(int, raw_input().split())\nsegments = []\nfor _ in xrange(n):\n    l, r = map(int, raw_input().split())\n    segments.append((l, r))\n\nans = solve(segments, k)\nprint len(ans)\nfor i in ans:\n    print i,"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n\ndef solve(segments, k):\n    \"\"\"\n    >>> solve([[11, 11], [9, 11], [7, 8], [8, 9], [7, 8], [9, 11], [7, 9]], 2)\n    [4, 6, 7]\n    >>> solve([[29, 30], [30, 30], [29, 29], [28, 30], [30, 30]], 1)\n    [1, 4, 5]\n    >>> solve([[2, 3], [3, 3], [2, 3], [2, 2], [2, 3], [2, 3]], 1)\n    [1, 3, 5, 6]\n    \"\"\"\n    n = len(segments)\n    left = [0] * n\n    right = [0] * n\n    for i in range(n):\n        left[i] = segments[i][0]\n        right[i] = segments[i][1]\n    left.sort()\n    right.sort()\n    i = 0\n    j = 0\n    cnt = 0\n    ans = []\n    while i < n:\n        if left[i] <= right[j]:\n            cnt += 1\n            i += 1\n        else:\n            cnt -= 1\n            j += 1\n        if cnt > k:\n            ans.append(i)\n    return ans\n\n\nif __name__ == '__main__':\n    n, k = [int(x) for x in input().split()]\n    segments = []\n    for i in range(n):\n        segments.append([int(x) for x in input().split()])\n    ans = solve(segments, k)\n    print(len(ans))\n    print(' '.join([str(x) for x in ans]))"
    }
  ],
  "created": 1649882128,
  "id": "cmpl-4we00lAdmCmXwDfkdP2ShxrsClfhB",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:36:30.898775 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    l = [0] * n\n    r = [0] * n\n    for i in xrange(n):\n        l[i], r[i] = map(int, sys.stdin.readline().split())\n\n    print n - solve(n, k, l, r)\n    for i in xrange(n):\n        if not l[i]:\n            print i + 1,\n\ndef solve(n, k, l, r):\n    \"\"\"\n    We are given $n$ segments of the form $[l_i, r_i]$ on the number line.\n    We want to remove a minimum number of segments $[l_i, r_i]$ such that no\n    point is covered by more than $k$ segments.\n\n    We will first solve a simpler problem: given $n$ segments of the form\n    $[l_i, r_i]$ on the number line, we want to remove a minimum number of\n    segments $[l_i, r_i]$ such that no point is covered by more than $1$\n    segment.\n\n    This is equivalent to finding the minimum number of segments $[l_i, r_i]$\n    such that the union of the remaining segments is a connected set.\n\n    Let $S$ be the set of all positions on the number line. Let $R$ be the\n    set of all positions on the number line covered by at least one segment.\n    Then, $R$ is a set of intervals.\n\n    Let $T$ be the set of all positions on the number line covered by at least\n    two segments. Then, $T$ is a set of intervals.\n\n    We want to remove a minimum number of segments $[l_i, r_i]$ such that\n    $T$ is empty.\n\n    This is equivalent to finding a minimum number of intervals in $R$ such\n    that the union of the remaining intervals is a connected set.\n\n    Suppose we have a set of intervals $I$ such that the union of the\n    intervals is a connected set.\n\n    We will construct a graph $G$ such that $I$ is the set of intervals\n    corresponding to the connected components of $G$.\n\n    Let $G$ be a graph with a vertex for each position $i$ on the number\n    line. Add an edge between $i$ and $i + 1$ for each $i$ on the number\n    line.\n\n    For each interval $[l_i, r_i]$ in $I$, add an edge between $l_i$ and\n    $r_i$.\n\n    The connected components of $G$ are the intervals in $I$.\n\n    We can solve the problem by finding the connected components of $G$\n    and removing the components with the most vertices.\n\n    Let $C$ be the number of connected components of $G$.\n\n    We can find $C$ in $O(n \\log n)$ time using a disjoint set data\n    structure.\n\n    We can find the size of the largest connected component in $O(n)$\n    time by iterating over the vertices of $G$ and finding the size of\n    the connected component for each vertex.\n\n    The time complexity is $O(n \\log n)$.\n    \"\"\"\n\n    def disjoint_set_init(n):\n        \"\"\"\n        Initialize a disjoint set data structure with $n$ elements.\n        \"\"\"\n        d = {}\n        for i in xrange(n):\n            d[i] = i\n        return d\n\n    def disjoint_set_find(d, i):\n        \"\"\"\n        Find the set containing $i$.\n        \"\"\"\n        if d[i] == i:\n            return i\n        return disjoint_set_find(d, d[i])\n\n    def disjoint_set_union(d, i, j):\n        \"\"\"\n        Merge the sets containing $i$ and $j$.\n        \"\"\"\n        i = disjoint_set_find(d, i)\n        j = disjoint_set_find(d, j)\n        d[i] = j\n\n    def disjoint_set_count(d):\n        \"\"\"\n        Count the number of sets.\n        \"\"\"\n        c = 0\n        for i in d:\n            if d[i] == i:\n                c += 1\n        return c\n\n    def disjoint_set_size(d, i):\n        \"\"\"\n        Count the number of elements in the set containing $i$.\n        \"\"\"\n        i = disjoint_set_find(d, i)\n        c = 0\n        for j in d:\n            if d[j] == i:\n                c += 1\n        return c\n\n    # Construct a graph $G$ such that the connected components of $G$ are\n    # the intervals in $R$.\n    d = disjoint_set_init(2 * 10 ** 5 + 1)\n    for i in xrange(n):\n        disjoint_set_union(d, l[i], r[i])\n    for i in xrange(2 * 10 ** 5):\n        disjoint_set_union(d, i, i + 1)\n\n    # Find the number of connected components of $G$.\n    c = disjoint_set_count(d)\n\n    # Find the size of the largest connected component of $G$.\n    m = 0\n    for i in xrange(2 * 10 ** 5 + 1):\n        m = max(m, disjoint_set_size(d, i))\n\n    # The number of intervals in $R$ is $c$.\n    # The number of intervals in $T$ is $c - 1$.\n    # The number of intervals in $R$ to remove is $c - 1 - k$.\n    # The number of segments to remove is $c - 1 - k$.\n    return c - 1 - k\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:36:30.898829 REASON stop
2022-04-13 20:36:30.899219 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    l = []\n    for i in range(n):\n        l.append([int(x) for x in input().split()])\n    l.sort(key=lambda x: x[1])\n    #print(l)\n    count = 0\n    res = []\n    for i in range(n):\n        if l[i][1] - l[i][0] + 1 > k:\n            count += 1\n            res.append(i+1)\n        k -= l[i][1] - l[i][0] + 1\n    print(count)\n    print(*res)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 20:36:30.899333 REASON stop
2022-04-13 20:36:30.899690 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n, k = map(int, input().split())\n    lst = []\n    for i in range(n):\n        lst.append(list(map(int, input().split())))\n    lst.sort(key=lambda x: x[0])\n    lst.sort(key=lambda x: x[1])\n    # print(lst)\n    count = 0\n    for i in range(n):\n        count += lst[i][1] - lst[i][0] + 1\n    if count <= k:\n        print(0)\n        print()\n        return\n    else:\n        count = 0\n        for i in range(n):\n            count += lst[i][1] - lst[i][0] + 1\n            if count > k:\n                break\n        # print(lst[:i])\n        ans_lst = []\n        for j in range(i, n):\n            if lst[j][0] >= lst[i - 1][0] and lst[j][1] <= lst[i - 1][1]:\n                ans_lst.append(j + 1)\n        print(len(ans_lst))\n        print(*ans_lst)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 20:36:30.899746 REASON stop
2022-04-13 20:36:30.927481 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nfrom collections import Counter\nfrom typing import List\n\ndef solve(n: int, k: int, segments: List[List[int]]) -> List[int]:\n    \"\"\"\n    >>> solve(7, 2, [[11, 11], [9, 11], [7, 8], [8, 9], [7, 8], [9, 11], [7, 9]])\n    [4, 6, 7]\n    >>> solve(5, 1, [[29, 30], [30, 30], [29, 29], [28, 30], [30, 30]])\n    [1, 4, 5]\n    >>> solve(6, 1, [[2, 3], [3, 3], [2, 3], [2, 2], [2, 3], [2, 3]])\n    [1, 3, 5, 6]\n    \"\"\"\n    bad = Counter()\n    for l, r in segments:\n        bad[l] += 1\n        bad[r + 1] -= 1\n    for i in range(2, len(bad)):\n        bad[i] += bad[i - 1]\n    return [i + 1 for i, count in bad.items() if count > k]\n\nif __name__ == \"__main__\":\n    n, k = [int(s) for s in input().split()]\n    segments = [tuple(int(s) for s in input().split()) for _ in range(n)]\n    result = solve(n, k, segments)\n    print(len(result))\n    print(*result)"
}
2022-04-13 20:36:30.927589 REASON stop
2022-04-13 20:36:30.944503 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = [int(x) for x in sys.stdin.readline().split()]\n    segments = []\n    for i in range(n):\n        segments.append([int(x) for x in sys.stdin.readline().split()])\n    segments = sorted(segments, key=lambda x: x[1])\n    d = {}\n    for i in range(n):\n        if segments[i][0] not in d:\n            d[segments[i][0]] = 1\n        else:\n            d[segments[i][0]] += 1\n        if segments[i][1] + 1 not in d:\n            d[segments[i][1] + 1] = -1\n        else:\n            d[segments[i][1] + 1] -= 1\n    points = sorted(d.keys())\n    bad_points = []\n    curr_sum = 0\n    for point in points:\n        curr_sum += d[point]\n        if curr_sum > k:\n            bad_points.append(point)\n    if len(bad_points) == 0:\n        print(0)\n        return\n    i = 0\n    result = []\n    while i < len(segments):\n        if segments[i][0] in bad_points:\n            result.append(i + 1)\n            segments.pop(i)\n        else:\n            i += 1\n    for point in bad_points:\n        for i in range(len(segments)):\n            if segments[i][1] >= point:\n                result.append(i + 1)\n                segments.pop(i)\n                break\n    print(len(result))\n    print(' '.join([str(x) for x in result]))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:36:30.944629 REASON stop
2022-04-13 20:36:30.945507 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef solve(segments, k):\n    segments.sort(key=lambda x: x[0])\n    n = len(segments)\n    cnt = 0\n    ans = []\n    for i in xrange(n-1):\n        if segments[i][1] >= segments[i+1][0]:\n            cnt += 1\n            if cnt > k:\n                ans.append(i+1)\n                cnt -= 1\n    return ans\n\nn, k = map(int, raw_input().split())\nsegments = []\nfor _ in xrange(n):\n    l, r = map(int, raw_input().split())\n    segments.append((l, r))\n\nans = solve(segments, k)\nprint len(ans)\nfor i in ans:\n    print i,"
}
2022-04-13 20:36:30.945570 REASON stop
2022-04-13 20:36:30.946481 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n\ndef solve(segments, k):\n    \"\"\"\n    >>> solve([[11, 11], [9, 11], [7, 8], [8, 9], [7, 8], [9, 11], [7, 9]], 2)\n    [4, 6, 7]\n    >>> solve([[29, 30], [30, 30], [29, 29], [28, 30], [30, 30]], 1)\n    [1, 4, 5]\n    >>> solve([[2, 3], [3, 3], [2, 3], [2, 2], [2, 3], [2, 3]], 1)\n    [1, 3, 5, 6]\n    \"\"\"\n    n = len(segments)\n    left = [0] * n\n    right = [0] * n\n    for i in range(n):\n        left[i] = segments[i][0]\n        right[i] = segments[i][1]\n    left.sort()\n    right.sort()\n    i = 0\n    j = 0\n    cnt = 0\n    ans = []\n    while i < n:\n        if left[i] <= right[j]:\n            cnt += 1\n            i += 1\n        else:\n            cnt -= 1\n            j += 1\n        if cnt > k:\n            ans.append(i)\n    return ans\n\n\nif __name__ == '__main__':\n    n, k = [int(x) for x in input().split()]\n    segments = []\n    for i in range(n):\n        segments.append([int(x) for x in input().split()])\n    ans = solve(segments, k)\n    print(len(ans))\n    print(' '.join([str(x) for x in ans]))"
}
2022-04-13 20:36:30.946541 REASON stop
