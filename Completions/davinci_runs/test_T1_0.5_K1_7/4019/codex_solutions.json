["\n\nfrom collections import defaultdict\n\nclass Graph(object):\n    def __init__(self, n, edges):\n        self.n = n\n        self.edges = edges\n        self.graph = defaultdict(list)\n        self.visited = [False] * n\n        self.degree = [0] * n\n        for i, j in self.edges:\n            self.graph[i].append(j)\n            self.graph[j].append(i)\n            self.degree[i] += 1\n            self.degree[j] += 1\n        self.ans = []\n\n    def dfs(self, v):\n        self.visited[v] = True\n        for i in self.graph[v]:\n            if not self.visited[i]:\n                self.ans.append((v, i))\n                self.dfs(i)\n\n    def check(self, D):\n        if D == 0:\n            return True\n        for i in range(1, self.n):\n            if self.degree[i] == D:\n                self.dfs(i)\n                if len(self.ans) == self.n - 1:\n                    return True\n                else:\n                    self.ans.clear()\n                    self.visited = [False] * self.n\n        return False\n\n\nif __name__ == \"__main__\":\n    n, m, D = map(int, input().split())\n    edges = []\n    for i in range(m):\n        edges.append(tuple(map(int, input().split())))\n    graph = Graph(n, edges)\n    if graph.check(D):\n        print(\"YES\")\n        for i in graph.ans:\n            print(i[0], i[1])\n    else:\n        print(\"NO\")", "\n\n#------------------------------------------------------------------------------#\n\nimport sys\nimport heapq\n\ndef main():\n    n, m, D = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    # find any spanning tree\n    visited = set()\n    queue = [1]\n    visited.add(1)\n    while queue:\n        v = queue.pop(0)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append(u)\n                visited.add(u)\n\n    # check if spanning tree exists\n    if len(visited) != n:\n        print('NO')\n        return\n\n    # check if there is a spanning tree with degree D\n    if len(graph[1]) == D:\n        print('YES')\n        for u in graph[1]:\n            print(1, u)\n        return\n\n    # find a spanning tree with degree D\n    # try to remove edges from the first vertex\n    for u in graph[1]:\n        if u in visited:\n            visited.remove(u)\n        for v in graph[u]:\n            if v in visited:\n                visited.remove(v)\n\n        if len(visited) == n - 1:\n            break\n\n        visited.add(u)\n        for v in graph[u]:\n            visited.add(v)\n\n    if len(visited) == n - 1:\n        print('YES')\n        for u in graph[1]:\n            if u in visited:\n                print(1, u)\n    else:\n        print('NO')\n\nmain()", "\n\nn, m, d = [int(x) for x in input().split()]\n\nif d == 0:\n    print(\"NO\")\n    quit()\n\nedges = {}\nfor i in range(1, n+1):\n    edges[i] = []\n\nfor i in range(m):\n    v, u = [int(x) for x in input().split()]\n    edges[v].append(u)\n    edges[u].append(v)\n\ndef dfs(v, p, d):\n    if d == 0:\n        return True\n    for u in edges[v]:\n        if u != p:\n            if dfs(u, v, d-1):\n                print(v, u)\n                return True\n    return False\n\nif dfs(1, 1, d):\n    print(\"YES\")\nelse:\n    print(\"NO\")", "\n\n#-----Solution-----\n\nn, m, d = [int(x) for x in input().split()]\n\ngraph = [[] for i in range(n)]\n\nfor i in range(m):\n    a, b = [int(x) for x in input().split()]\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nif (d == n-1):\n    print(\"YES\")\n    for i in graph[0]:\n        print(1, i+1)\n    exit()\n\nif (d == 0):\n    print(\"YES\")\n    for i in graph[0]:\n        print(i+1, 1)\n    exit()\n\nif (d > n-1):\n    print(\"NO\")\n    exit()\n\nif (d > len(graph[0])):\n    print(\"NO\")\n    exit()\n\nprint(\"YES\")\n\nfor i in graph[0]:\n    print(1, i+1)\n    d -= 1\n    if (d == 0):\n        break\n\nfor i in range(1, n):\n    if (i in graph[0]):\n        continue\n    print(1, i+1)", "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, m, d = [int(x) for x in input().split()]\n    edges = []\n    for i in range(m):\n        a, b = [int(x) for x in input().split()]\n        edges.append((a, b))\n    edges.sort()\n\n    # Check if there is a solution\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i+1))\n    elif d == n-1:\n        print(\"YES\")\n        for i in range(n-1):\n            print(\"{} {}\".format(1, i+2))\n    else:\n        # Check if we can use the input edges\n        if m == n-1:\n            print(\"YES\")\n            for a, b in edges:\n                print(\"{} {}\".format(a, b))\n            return\n\n        # Check if we can construct a solution\n        if n-1-d > d:\n            print(\"NO\")\n            return\n        print(\"YES\")\n        for i in range(d):\n            print(\"{} {}\".format(1, i+2))\n        for i in range(d+1, n):\n            print(\"{} {}\".format(i, i+1))\n\nif __name__ == \"__main__\":\n    main()"]