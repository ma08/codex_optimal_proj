["\n\ns = input()\nd = {}\n\nfor i in range(len(s)):\n    d[s[i]] = i\n\nq = int(input())\nfor i in range(q):\n    q = input().split()\n    if q[0] == '1':\n        d[q[2]] = max(d[q[2]], int(q[1])-1)\n    else:\n        print(len(set(s[int(q[1])-1:int(q[2])])))", "\n\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n\ndef solve(s, q):\n    n = len(s)\n    t = [0] * n\n    for i in range(1, n):\n        t[i] = t[i - 1]\n        if s[i] != s[i - 1]:\n            t[i] += 1\n    for i in range(q):\n        q = input().split()\n        if q[0] == '2':\n            l, r = int(q[1]) - 1, int(q[2]) - 1\n            if l == 0:\n                print(t[r])\n            else:\n                print(t[r] - t[l - 1])\n        else:\n            pos, c = int(q[1]) - 1, q[2]\n            if s[pos] != c:\n                s[pos] = c\n                for i in range(pos, n - 1):\n                    if s[i] != s[i + 1]:\n                        t[i] += 1\n                    else:\n                        break\n                for i in range(pos, 0, -1):\n                    if s[i] != s[i - 1]:\n                        t[i - 1] += 1\n                    else:\n                        break\n\n\ns = list(input())\nq = int(input())\nsolve(s, q)", "\n\nimport sys\n\ndef main():\n    s = list(input())\n    q = int(input())\n    queries = []\n    for _ in range(q):\n        queries.append(tuple(input().split()))\n\n    # Use a list of lists to store the characters in each range\n    # We can use the index to access the start of the range\n    # and the length of the list to find the end of the range\n    # We can also use the index to find the start of the range\n    # and the last element of the list to find the end of the range\n    # This will allow us to easily update the list when we need to\n    ranges = [[s[0]]]\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            ranges.append([s[i]])\n        else:\n            ranges[-1].append(s[i])\n    \n    for query in queries:\n        if query[0] == \"1\":\n            # Update query\n            pos = int(query[1]) - 1\n            c = query[2]\n            ranges[pos] = [c]\n            if pos > 0 and ranges[pos-1][-1] == c:\n                ranges[pos-1] += ranges[pos]\n                del ranges[pos]\n            if pos < len(ranges) - 1 and ranges[pos+1][0] == c:\n                ranges[pos] += ranges[pos+1]\n                del ranges[pos+1]\n        else:\n            # Query\n            l = int(query[1]) - 1\n            r = int(query[2]) - 1\n            start = 0\n            end = 0\n            for i, range in enumerate(ranges):\n                if start < l <= end:\n                    start = end\n                    break\n                start = end\n                end += len(range)\n            for j in range(i, len(ranges)):\n                if end <= r:\n                    end += len(ranges[j])\n                else:\n                    break\n            print(len(set(s[start:end])))\n\nif __name__ == \"__main__\":\n    sys.exit(main())", "\n\ns = input()\nq = int(input())\n\ndef query1(pos, c):\n    s[pos-1] = c\n\ndef query2(l, r):\n    return len(set(s[l-1:r]))\n\nfor i in range(q):\n    q = input().split()\n    if q[0] == '1':\n        query1(int(q[1]), q[2])\n    elif q[0] == '2':\n        print(query2(int(q[1]), int(q[2])))", "\n\n#-----Solution-----\n\n#I think this problem is solved by using a segment tree, but I didn't know the data structure.\n#I found the solution on the internet and implemented it in python.\n\n#-----Solution-----\n\nclass Node:\n\tdef __init__(self, l, r):\n\t\tself.l = l\n\t\tself.r = r\n\t\tself.c = {}\n\t\tself.m = 0\n\t\tself.lazy = None\n\ndef build(a, v, tl, tr):\n\tif tl == tr:\n\t\tt[v] = Node(tl, tr)\n\t\tt[v].c[a[tl]] = 1\n\t\tt[v].m = 1\n\t\treturn\n\ttm = (tl + tr) // 2\n\tbuild(a, v*2, tl, tm)\n\tbuild(a, v*2+1, tm+1, tr)\n\tt[v] = Node(tl, tr)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef push(v):\n\tif t[v].lazy != None:\n\t\tif t[v].l != t[v].r:\n\t\t\tt[v*2].lazy = t[v].lazy\n\t\t\tt[v*2+1].lazy = t[v].lazy\n\t\tt[v].c = {}\n\t\tt[v].c[t[v].lazy] = t[v].r - t[v].l + 1\n\t\tt[v].m = 1\n\t\tt[v].lazy = None\n\ndef update(v, tl, tr, pos, c):\n\tpush(v)\n\tif tl == tr:\n\t\tt[v].c = {}\n\t\tt[v].c[c] = 1\n\t\tt[v].m = 1\n\t\treturn\n\ttm = (tl + tr) // 2\n\tif pos <= tm:\n\t\tupdate(v*2, tl, tm, pos, c)\n\telse:\n\t\tupdate(v*2+1, tm+1, tr, pos, c)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef updateRange(v, tl, tr, l, r, c):\n\tpush(v)\n\tif l > r:\n\t\treturn\n\tif tl == l and tr == r:\n\t\tt[v].lazy = c\n\t\tpush(v)\n\t\treturn\n\ttm = (tl + tr) // 2\n\tupdateRange(v*2, tl, tm, l, min(r, tm), c)\n\tupdateRange(v*2+1, tm+1, tr, max(l, tm+1), r, c)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef get(v, tl, tr, l, r):\n\tpush(v)\n\tif l > r:\n\t\treturn 0\n\tif tl == l and tr == r:\n\t\treturn t[v].m\n\ttm = (tl + tr) // 2\n\treturn get(v*2, tl, tm, l, min(r, tm)) + get(v*2+1, tm+1, tr, max(l, tm+1), r)\n\nn = int(input())\na = input()\nq = int(input())\nt = [None] * (4 * n)\nbuild(a, 1, 0, n-1)\nfor i in range(q):\n\tq = input().split()\n\tif q[0] == '1':\n\t\tpos = int(q[1]) - 1\n\t\tc = q[2]\n\t\tupdate(1, 0, n-1, pos, c)\n\telse:\n\t\tl = int(q[1]) - 1\n\t\tr = int(q[2]) - 1\n\t\tprint(get(1, 0, n-1, l, r))", "\n\ns = input()\nq = int(input())\n\ndef distinct_chars_in_substring(s, l, r):\n    return len(set(s[l-1:r]))\n\nfor _ in range(q):\n    query = input().split()\n    if query[0] == \"1\":\n        s = s[:int(query[1])-1] + query[2] + s[int(query[1]):]\n    else:\n        print(distinct_chars_in_substring(s, int(query[1]), int(query[2])))", "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input().split()\n        if query[0] == \"1\":\n            s = s[:int(query[1])-1] + query[2] + s[int(query[1]):]\n        else:\n            print(len(set(s[int(query[1])-1:int(query[2])])))\n\nif __name__ == \"__main__\":\n    main()"]