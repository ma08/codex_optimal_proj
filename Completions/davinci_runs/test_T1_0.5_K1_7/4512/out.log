2022-04-13 21:23:35.483989 """
You are given a string $s$ consisting of lowercase Latin letters and $q$ queries for this string.

Recall that the substring $s[l; r]$ of the string $s$ is the string $s_l s_{l + 1} \dots s_r$. For example, the substrings of "codeforces" are "code", "force", "f", "for", but not "coder" and "top".

There are two types of queries:   $1~ pos~ c$ ($1 \le pos \le |s|$, $c$ is lowercase Latin letter): replace $s_{pos}$ with $c$ (set $s_{pos} := c$);  $2~ l~ r$ ($1 \le l \le r \le |s|$): calculate the number of distinct characters in the substring $s[l; r]$. 


-----Input-----

The first line of the input contains one string $s$ consisting of no more than $10^5$ lowercase Latin letters.

The second line of the input contains one integer $q$ ($1 \le q \le 10^5$) — the number of queries.

The next $q$ lines contain queries, one per line. Each query is given in the format described in the problem statement. It is guaranteed that there is at least one query of the second type.


-----Output-----

For each query of the second type print the answer for it — the number of distinct characters in the required substring in this query.


-----Examples-----
Input
abacaba
5
2 1 4
1 4 b
1 5 b
2 4 6
2 1 7

Output
3
1
2

Input
dfcbbcfeeedbaea
15
1 6 e
1 4 b
2 6 14
1 7 b
1 12 c
2 6 8
2 1 6
1 7 c
1 2 f
1 10 a
2 7 9
1 10 a
1 14 b
1 1 f
2 1 11

Output
5
2
5
2
6
"""
2022-04-13 21:23:35.484002 --------------------------
2022-04-13 21:24:11.436949 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ns = input()\nq = int(input())\n\ndef query1(pos, c):\n    s[pos-1] = c\n\ndef query2(l, r):\n    return len(set(s[l-1:r]))\n\nfor i in range(q):\n    q = input().split()\n    if q[0] == '1':\n        query1(int(q[1]), q[2])\n    elif q[0] == '2':\n        print(query2(int(q[1]), int(q[2])))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\n#I think this problem is solved by using a segment tree, but I didn't know the data structure.\n#I found the solution on the internet and implemented it in python.\n\n#-----Solution-----\n\nclass Node:\n\tdef __init__(self, l, r):\n\t\tself.l = l\n\t\tself.r = r\n\t\tself.c = {}\n\t\tself.m = 0\n\t\tself.lazy = None\n\ndef build(a, v, tl, tr):\n\tif tl == tr:\n\t\tt[v] = Node(tl, tr)\n\t\tt[v].c[a[tl]] = 1\n\t\tt[v].m = 1\n\t\treturn\n\ttm = (tl + tr) // 2\n\tbuild(a, v*2, tl, tm)\n\tbuild(a, v*2+1, tm+1, tr)\n\tt[v] = Node(tl, tr)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef push(v):\n\tif t[v].lazy != None:\n\t\tif t[v].l != t[v].r:\n\t\t\tt[v*2].lazy = t[v].lazy\n\t\t\tt[v*2+1].lazy = t[v].lazy\n\t\tt[v].c = {}\n\t\tt[v].c[t[v].lazy] = t[v].r - t[v].l + 1\n\t\tt[v].m = 1\n\t\tt[v].lazy = None\n\ndef update(v, tl, tr, pos, c):\n\tpush(v)\n\tif tl == tr:\n\t\tt[v].c = {}\n\t\tt[v].c[c] = 1\n\t\tt[v].m = 1\n\t\treturn\n\ttm = (tl + tr) // 2\n\tif pos <= tm:\n\t\tupdate(v*2, tl, tm, pos, c)\n\telse:\n\t\tupdate(v*2+1, tm+1, tr, pos, c)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef updateRange(v, tl, tr, l, r, c):\n\tpush(v)\n\tif l > r:\n\t\treturn\n\tif tl == l and tr == r:\n\t\tt[v].lazy = c\n\t\tpush(v)\n\t\treturn\n\ttm = (tl + tr) // 2\n\tupdateRange(v*2, tl, tm, l, min(r, tm), c)\n\tupdateRange(v*2+1, tm+1, tr, max(l, tm+1), r, c)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef get(v, tl, tr, l, r):\n\tpush(v)\n\tif l > r:\n\t\treturn 0\n\tif tl == l and tr == r:\n\t\treturn t[v].m\n\ttm = (tl + tr) // 2\n\treturn get(v*2, tl, tm, l, min(r, tm)) + get(v*2+1, tm+1, tr, max(l, tm+1), r)\n\nn = int(input())\na = input()\nq = int(input())\nt = [None] * (4 * n)\nbuild(a, 1, 0, n-1)\nfor i in range(q):\n\tq = input().split()\n\tif q[0] == '1':\n\t\tpos = int(q[1]) - 1\n\t\tc = q[2]\n\t\tupdate(1, 0, n-1, pos, c)\n\telse:\n\t\tl = int(q[1]) - 1\n\t\tr = int(q[2]) - 1\n\t\tprint(get(1, 0, n-1, l, r))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    s = list(input())\n    q = int(input())\n    queries = []\n    for _ in range(q):\n        queries.append(tuple(input().split()))\n\n    # Use a list of lists to store the characters in each range\n    # We can use the index to access the start of the range\n    # and the length of the list to find the end of the range\n    # We can also use the index to find the start of the range\n    # and the last element of the list to find the end of the range\n    # This will allow us to easily update the list when we need to\n    ranges = [[s[0]]]\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            ranges.append([s[i]])\n        else:\n            ranges[-1].append(s[i])\n    \n    for query in queries:\n        if query[0] == \"1\":\n            # Update query\n            pos = int(query[1]) - 1\n            c = query[2]\n            ranges[pos] = [c]\n            if pos > 0 and ranges[pos-1][-1] == c:\n                ranges[pos-1] += ranges[pos]\n                del ranges[pos]\n            if pos < len(ranges) - 1 and ranges[pos+1][0] == c:\n                ranges[pos] += ranges[pos+1]\n                del ranges[pos+1]\n        else:\n            # Query\n            l = int(query[1]) - 1\n            r = int(query[2]) - 1\n            start = 0\n            end = 0\n            for i, range in enumerate(ranges):\n                if start < l <= end:\n                    start = end\n                    break\n                start = end\n                end += len(range)\n            for j in range(i, len(ranges)):\n                if end <= r:\n                    end += len(ranges[j])\n                else:\n                    break\n            print(len(set(s[start:end])))\n\nif __name__ == \"__main__\":\n    sys.exit(main())"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ns = input()\nd = {}\n\nfor i in range(len(s)):\n    d[s[i]] = i\n\nq = int(input())\nfor i in range(q):\n    q = input().split()\n    if q[0] == '1':\n        d[q[2]] = max(d[q[2]], int(q[1])-1)\n    else:\n        print(len(set(s[int(q[1])-1:int(q[2])])))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ns = input()\nq = int(input())\n\ndef distinct_chars_in_substring(s, l, r):\n    return len(set(s[l-1:r]))\n\nfor _ in range(q):\n    query = input().split()\n    if query[0] == \"1\":\n        s = s[:int(query[1])-1] + query[2] + s[int(query[1]):]\n    else:\n        print(distinct_chars_in_substring(s, int(query[1]), int(query[2])))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n\ndef solve(s, q):\n    n = len(s)\n    t = [0] * n\n    for i in range(1, n):\n        t[i] = t[i - 1]\n        if s[i] != s[i - 1]:\n            t[i] += 1\n    for i in range(q):\n        q = input().split()\n        if q[0] == '2':\n            l, r = int(q[1]) - 1, int(q[2]) - 1\n            if l == 0:\n                print(t[r])\n            else:\n                print(t[r] - t[l - 1])\n        else:\n            pos, c = int(q[1]) - 1, q[2]\n            if s[pos] != c:\n                s[pos] = c\n                for i in range(pos, n - 1):\n                    if s[i] != s[i + 1]:\n                        t[i] += 1\n                    else:\n                        break\n                for i in range(pos, 0, -1):\n                    if s[i] != s[i - 1]:\n                        t[i - 1] += 1\n                    else:\n                        break\n\n\ns = list(input())\nq = int(input())\nsolve(s, q)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input().split()\n        if query[0] == \"1\":\n            s = s[:int(query[1])-1] + query[2] + s[int(query[1]):]\n        else:\n            print(len(set(s[int(query[1])-1:int(query[2])])))\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649885015,
  "id": "cmpl-4wekZiftR1t8hEPJZYolgIDBY2iTY",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:24:11.437309 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ns = input()\nq = int(input())\n\ndef query1(pos, c):\n    s[pos-1] = c\n\ndef query2(l, r):\n    return len(set(s[l-1:r]))\n\nfor i in range(q):\n    q = input().split()\n    if q[0] == '1':\n        query1(int(q[1]), q[2])\n    elif q[0] == '2':\n        print(query2(int(q[1]), int(q[2])))"
}
2022-04-13 21:24:11.437348 REASON stop
2022-04-13 21:24:11.437788 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\n#I think this problem is solved by using a segment tree, but I didn't know the data structure.\n#I found the solution on the internet and implemented it in python.\n\n#-----Solution-----\n\nclass Node:\n\tdef __init__(self, l, r):\n\t\tself.l = l\n\t\tself.r = r\n\t\tself.c = {}\n\t\tself.m = 0\n\t\tself.lazy = None\n\ndef build(a, v, tl, tr):\n\tif tl == tr:\n\t\tt[v] = Node(tl, tr)\n\t\tt[v].c[a[tl]] = 1\n\t\tt[v].m = 1\n\t\treturn\n\ttm = (tl + tr) // 2\n\tbuild(a, v*2, tl, tm)\n\tbuild(a, v*2+1, tm+1, tr)\n\tt[v] = Node(tl, tr)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef push(v):\n\tif t[v].lazy != None:\n\t\tif t[v].l != t[v].r:\n\t\t\tt[v*2].lazy = t[v].lazy\n\t\t\tt[v*2+1].lazy = t[v].lazy\n\t\tt[v].c = {}\n\t\tt[v].c[t[v].lazy] = t[v].r - t[v].l + 1\n\t\tt[v].m = 1\n\t\tt[v].lazy = None\n\ndef update(v, tl, tr, pos, c):\n\tpush(v)\n\tif tl == tr:\n\t\tt[v].c = {}\n\t\tt[v].c[c] = 1\n\t\tt[v].m = 1\n\t\treturn\n\ttm = (tl + tr) // 2\n\tif pos <= tm:\n\t\tupdate(v*2, tl, tm, pos, c)\n\telse:\n\t\tupdate(v*2+1, tm+1, tr, pos, c)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef updateRange(v, tl, tr, l, r, c):\n\tpush(v)\n\tif l > r:\n\t\treturn\n\tif tl == l and tr == r:\n\t\tt[v].lazy = c\n\t\tpush(v)\n\t\treturn\n\ttm = (tl + tr) // 2\n\tupdateRange(v*2, tl, tm, l, min(r, tm), c)\n\tupdateRange(v*2+1, tm+1, tr, max(l, tm+1), r, c)\n\tt[v].c = t[v*2].c.copy()\n\tt[v].m = t[v*2].m\n\tfor k in t[v*2+1].c:\n\t\tif k not in t[v].c:\n\t\t\tt[v].c[k] = 0\n\t\tt[v].c[k] += t[v*2+1].c[k]\n\t\tif t[v].c[k] == 1:\n\t\t\tt[v].m += 1\n\t\telif t[v].c[k] == 0:\n\t\t\tt[v].m -= 1\n\ndef get(v, tl, tr, l, r):\n\tpush(v)\n\tif l > r:\n\t\treturn 0\n\tif tl == l and tr == r:\n\t\treturn t[v].m\n\ttm = (tl + tr) // 2\n\treturn get(v*2, tl, tm, l, min(r, tm)) + get(v*2+1, tm+1, tr, max(l, tm+1), r)\n\nn = int(input())\na = input()\nq = int(input())\nt = [None] * (4 * n)\nbuild(a, 1, 0, n-1)\nfor i in range(q):\n\tq = input().split()\n\tif q[0] == '1':\n\t\tpos = int(q[1]) - 1\n\t\tc = q[2]\n\t\tupdate(1, 0, n-1, pos, c)\n\telse:\n\t\tl = int(q[1]) - 1\n\t\tr = int(q[2]) - 1\n\t\tprint(get(1, 0, n-1, l, r))"
}
2022-04-13 21:24:11.437911 REASON stop
2022-04-13 21:24:11.438298 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    s = list(input())\n    q = int(input())\n    queries = []\n    for _ in range(q):\n        queries.append(tuple(input().split()))\n\n    # Use a list of lists to store the characters in each range\n    # We can use the index to access the start of the range\n    # and the length of the list to find the end of the range\n    # We can also use the index to find the start of the range\n    # and the last element of the list to find the end of the range\n    # This will allow us to easily update the list when we need to\n    ranges = [[s[0]]]\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            ranges.append([s[i]])\n        else:\n            ranges[-1].append(s[i])\n    \n    for query in queries:\n        if query[0] == \"1\":\n            # Update query\n            pos = int(query[1]) - 1\n            c = query[2]\n            ranges[pos] = [c]\n            if pos > 0 and ranges[pos-1][-1] == c:\n                ranges[pos-1] += ranges[pos]\n                del ranges[pos]\n            if pos < len(ranges) - 1 and ranges[pos+1][0] == c:\n                ranges[pos] += ranges[pos+1]\n                del ranges[pos+1]\n        else:\n            # Query\n            l = int(query[1]) - 1\n            r = int(query[2]) - 1\n            start = 0\n            end = 0\n            for i, range in enumerate(ranges):\n                if start < l <= end:\n                    start = end\n                    break\n                start = end\n                end += len(range)\n            for j in range(i, len(ranges)):\n                if end <= r:\n                    end += len(ranges[j])\n                else:\n                    break\n            print(len(set(s[start:end])))\n\nif __name__ == \"__main__\":\n    sys.exit(main())"
}
2022-04-13 21:24:11.438355 REASON stop
2022-04-13 21:24:11.455696 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ns = input()\nd = {}\n\nfor i in range(len(s)):\n    d[s[i]] = i\n\nq = int(input())\nfor i in range(q):\n    q = input().split()\n    if q[0] == '1':\n        d[q[2]] = max(d[q[2]], int(q[1])-1)\n    else:\n        print(len(set(s[int(q[1])-1:int(q[2])])))"
}
2022-04-13 21:24:11.455760 REASON stop
2022-04-13 21:24:11.456543 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ns = input()\nq = int(input())\n\ndef distinct_chars_in_substring(s, l, r):\n    return len(set(s[l-1:r]))\n\nfor _ in range(q):\n    query = input().split()\n    if query[0] == \"1\":\n        s = s[:int(query[1])-1] + query[2] + s[int(query[1]):]\n    else:\n        print(distinct_chars_in_substring(s, int(query[1]), int(query[2])))"
}
2022-04-13 21:24:11.456602 REASON stop
2022-04-13 21:24:11.457541 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n\ndef solve(s, q):\n    n = len(s)\n    t = [0] * n\n    for i in range(1, n):\n        t[i] = t[i - 1]\n        if s[i] != s[i - 1]:\n            t[i] += 1\n    for i in range(q):\n        q = input().split()\n        if q[0] == '2':\n            l, r = int(q[1]) - 1, int(q[2]) - 1\n            if l == 0:\n                print(t[r])\n            else:\n                print(t[r] - t[l - 1])\n        else:\n            pos, c = int(q[1]) - 1, q[2]\n            if s[pos] != c:\n                s[pos] = c\n                for i in range(pos, n - 1):\n                    if s[i] != s[i + 1]:\n                        t[i] += 1\n                    else:\n                        break\n                for i in range(pos, 0, -1):\n                    if s[i] != s[i - 1]:\n                        t[i - 1] += 1\n                    else:\n                        break\n\n\ns = list(input())\nq = int(input())\nsolve(s, q)"
}
2022-04-13 21:24:11.457605 REASON stop
2022-04-13 21:24:11.458419 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input().split()\n        if query[0] == \"1\":\n            s = s[:int(query[1])-1] + query[2] + s[int(query[1]):]\n        else:\n            print(len(set(s[int(query[1])-1:int(query[2])])))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:24:11.458471 REASON stop
