2022-04-13 17:30:46.679472 """
You are given an integer $n$ from $1$ to $10^{18}$ without leading zeroes.

In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words, after each move the number you have cannot contain any leading zeroes.

What is the minimum number of moves you have to make to obtain a number that is divisible by $25$? Print -1 if it is impossible to obtain a number that is divisible by $25$.


-----Input-----

The first line contains an integer $n$ ($1 \le n \le 10^{18}$). It is guaranteed that the first (left) digit of the number $n$ is not a zero.


-----Output-----

If it is impossible to obtain a number that is divisible by $25$, print -1. Otherwise print the minimum number of moves required to obtain such number.

Note that you can swap only adjacent digits in the given number.


-----Examples-----
Input
5071

Output
4

Input
705

Output
1

Input
1241367

Output
-1



-----Note-----

In the first example one of the possible sequences of moves is 5071 $\rightarrow$ 5701 $\rightarrow$ 7501 $\rightarrow$ 7510 $\rightarrow$ 7150.
"""
2022-04-13 17:30:46.679479 --------------------------
2022-04-13 17:31:06.861001 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = input()\n\n# # O(n)\n# def get_num_moves(n):\n#     if n % 25 == 0:\n#         return 0\n#     elif len(n) == 1:\n#         return -1\n#     elif n[-1] == '0' or n[-1] == '5':\n#         return 1 + get_num_moves(n[:-1])\n#     else:\n#         return 1 + get_num_moves(n[:-2] + n[-1] + n[-2])\n\n# O(1)\ndef get_num_moves(n):\n    if n % 25 == 0:\n        return 0\n    elif len(n) == 1:\n        return -1\n    elif n[-1] == '0' or n[-1] == '5':\n        return 1 + get_num_moves(n[:-1])\n    else:\n        return 1 + get_num_moves(n[:-2] + n[-1] + n[-2])\n\nprint(get_num_moves(n))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef swap_nums(n):\n    if n % 25 == 0:\n        return 0\n    else:\n        if n % 5 == 0:\n            return 1\n        else:\n            return -1\n\nif __name__ == '__main__':\n    print(swap_nums(int(input())))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    if n % 25 == 0:\n        print 0\n    else:\n        n = str(n)\n        n = n[::-1]\n        moves = 0\n        for i in range(len(n)):\n            if n[i] == '0':\n                moves += 1\n            else:\n                break\n        if moves == len(n):\n            print -1\n        else:\n            print moves\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    Find the minimum number of moves to obtain a number divisible by 25\n    \"\"\"\n    inp = input()\n    count = 0\n    for i in range(len(inp)-1):\n        if inp[i] == \"2\" and inp[i+1] == \"5\":\n            count += 1\n            inp = inp[:i] + \"5\" + inp[i+1:]\n    if int(inp) % 25 == 0:\n        print(count)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# Solution\n\nn = input()\n\nif len(n) == 1:\n    print(-1)\nelif len(n) == 2:\n    if int(n) % 25 == 0:\n        print(0)\n    else:\n        print(-1)\nelse:\n    moves = 0\n    while len(n) > 2:\n        if int(n[-2:]) % 25 == 0:\n            print(moves)\n            break\n        else:\n            n = n[:-2]\n            moves += 1\n\n    if len(n) == 2:\n        if int(n) % 25 == 0:\n            print(moves)\n        else:\n            print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n = input()\n    dig = [int(i) for i in n]\n    if dig[-2] == 0 and dig[-1] == 0:\n        print(0)\n        return\n    if dig[-2] == 0:\n        print(1)\n        return\n    if dig[-1] == 0:\n        print(1)\n        return\n    if dig[-1] == 5:\n        print(1)\n        return\n    if dig[-2] == 5:\n        print(2)\n        return\n    print(-1)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef solution(n):\n    if n % 25 == 0:\n        return 0\n\n    n = str(n)\n    count = 0\n    i = 1\n    while i < len(n):\n        if n[i] == '0':\n            n = n[:i] + n[i+1:]\n            count += 1\n        else:\n            i += 1\n\n    return -1 if len(n) < 3 else count + 1\n\nif __name__ == '__main__':\n    n = int(input())\n    print(solution(n))"
    }
  ],
  "created": 1649871046,
  "id": "cmpl-4wb7GEFYCkOl2kXK9ctu3A3XjPpYP",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 17:31:06.861276 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = input()\n\n# # O(n)\n# def get_num_moves(n):\n#     if n % 25 == 0:\n#         return 0\n#     elif len(n) == 1:\n#         return -1\n#     elif n[-1] == '0' or n[-1] == '5':\n#         return 1 + get_num_moves(n[:-1])\n#     else:\n#         return 1 + get_num_moves(n[:-2] + n[-1] + n[-2])\n\n# O(1)\ndef get_num_moves(n):\n    if n % 25 == 0:\n        return 0\n    elif len(n) == 1:\n        return -1\n    elif n[-1] == '0' or n[-1] == '5':\n        return 1 + get_num_moves(n[:-1])\n    else:\n        return 1 + get_num_moves(n[:-2] + n[-1] + n[-2])\n\nprint(get_num_moves(n))"
}
2022-04-13 17:31:06.861323 REASON stop
2022-04-13 17:31:06.864178 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef swap_nums(n):\n    if n % 25 == 0:\n        return 0\n    else:\n        if n % 5 == 0:\n            return 1\n        else:\n            return -1\n\nif __name__ == '__main__':\n    print(swap_nums(int(input())))"
}
2022-04-13 17:31:06.864345 REASON stop
2022-04-13 17:31:06.864720 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    if n % 25 == 0:\n        print 0\n    else:\n        n = str(n)\n        n = n[::-1]\n        moves = 0\n        for i in range(len(n)):\n            if n[i] == '0':\n                moves += 1\n            else:\n                break\n        if moves == len(n):\n            print -1\n        else:\n            print moves\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 17:31:06.864774 REASON stop
2022-04-13 17:31:06.887522 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    Find the minimum number of moves to obtain a number divisible by 25\n    \"\"\"\n    inp = input()\n    count = 0\n    for i in range(len(inp)-1):\n        if inp[i] == \"2\" and inp[i+1] == \"5\":\n            count += 1\n            inp = inp[:i] + \"5\" + inp[i+1:]\n    if int(inp) % 25 == 0:\n        print(count)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 17:31:06.887634 REASON stop
2022-04-13 17:31:06.903751 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# Solution\n\nn = input()\n\nif len(n) == 1:\n    print(-1)\nelif len(n) == 2:\n    if int(n) % 25 == 0:\n        print(0)\n    else:\n        print(-1)\nelse:\n    moves = 0\n    while len(n) > 2:\n        if int(n[-2:]) % 25 == 0:\n            print(moves)\n            break\n        else:\n            n = n[:-2]\n            moves += 1\n\n    if len(n) == 2:\n        if int(n) % 25 == 0:\n            print(moves)\n        else:\n            print(-1)"
}
2022-04-13 17:31:06.903874 REASON stop
2022-04-13 17:31:06.904754 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n = input()\n    dig = [int(i) for i in n]\n    if dig[-2] == 0 and dig[-1] == 0:\n        print(0)\n        return\n    if dig[-2] == 0:\n        print(1)\n        return\n    if dig[-1] == 0:\n        print(1)\n        return\n    if dig[-1] == 5:\n        print(1)\n        return\n    if dig[-2] == 5:\n        print(2)\n        return\n    print(-1)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 17:31:06.904863 REASON stop
2022-04-13 17:31:06.905620 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef solution(n):\n    if n % 25 == 0:\n        return 0\n\n    n = str(n)\n    count = 0\n    i = 1\n    while i < len(n):\n        if n[i] == '0':\n            n = n[:i] + n[i+1:]\n            count += 1\n        else:\n            i += 1\n\n    return -1 if len(n) < 3 else count + 1\n\nif __name__ == '__main__':\n    n = int(input())\n    print(solution(n))"
}
2022-04-13 17:31:06.905701 REASON stop
