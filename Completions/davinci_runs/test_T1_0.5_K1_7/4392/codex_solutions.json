["\n\ndef main():\n    \"\"\"main function\"\"\"\n    t_c = int(input())\n    for _ in range(t_c):\n        _, m = map(int, input().split())\n        a_list = list(map(int, input().split()))\n        p_list = list(map(int, input().split()))\n        if m == 0:\n            print(\"YES\" if all(a_list[i] <= a_list[i+1] for i in range(len(a_list) - 1)) else \"NO\")\n            continue\n        # print(a_list, p_list)\n        flag = True\n        for i, _ in enumerate(p_list):\n            if i == 0:\n                if a_list[p_list[i]] > a_list[p_list[i]+1]:\n                    a_list[p_list[i]], a_list[p_list[i]+1] = a_list[p_list[i]+1], a_list[p_list[i]]\n                    flag = True\n                else:\n                    flag = False\n            else:\n                if flag:\n                    if a_list[p_list[i]] > a_list[p_list[i]+1]:\n                        a_list[p_list[i]], a_list[p_list[i]+1] = a_list[p_list[i]+1], a_list[p_list[i]]\n                        flag = True\n                    else:\n                        flag = False\n        print(\"YES\" if flag else \"NO\")\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n# The idea is to use a graph where the vertices are the elements of the array and the edges are the positions where the swaps are allowed.\n# If we can sort the array in non-decreasing order, then the graph must be a directed acyclic graph.\n# We can check if the graph is a directed acyclic graph using a topological sort algorithm.\n# If we can sort the graph in non-decreasing order, then we can sort the array in non-decreasing order too.\n# Otherwise, we cannot sort the array in non-decreasing order.\n\nfrom collections import defaultdict\n\ndef topological_sort(graph):\n    in_degree = defaultdict(int)\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n    queue = [u for u in graph if in_degree[u] == 0]\n    sorted_nodes = []\n    while queue:\n        u = queue.pop()\n        sorted_nodes.append(u)\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    return sorted_nodes\n\ndef can_sort_array(n, m, a, p):\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        if i + 1 in p:\n            graph[a[i]].append(a[i + 1])\n    sorted_nodes = topological_sort(graph)\n    if len(sorted_nodes) != n:\n        return False\n    for i in range(n - 1):\n        if sorted_nodes[i] > sorted_nodes[i + 1]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        p = set(map(int, input().split()))\n        if can_sort_array(n, m, a, p):\n            print(\"YES\")\n        else:\n            print(\"NO\")", "\n\ndef solve(n, m, a, p):\n    for i in range(m):\n        if a[p[i]] > a[p[i]+1]:\n            a[p[i]], a[p[i]+1] = a[p[i]+1], a[p[i]]\n\n    for i in range(n-1):\n        if a[i] > a[i+1]:\n            return False\n    return True\n\nif __name__ == '__main__':\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        p = list(map(int, input().split()))\n        if solve(n, m, a, p):\n            print(\"YES\")\n        else:\n            print(\"NO\")", "\n\nimport sys\n\ndef main():\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        n, m = map(int, sys.stdin.readline().split())\n        a = list(map(int, sys.stdin.readline().split()))\n        p = list(map(int, sys.stdin.readline().split()))\n        # print(a, p)\n\n        if len(p) == 0:\n            print(\"YES\")\n            continue\n\n        # print(a, p)\n        for i in p:\n            if i < len(a) - 1 and a[i] > a[i+1]:\n                a[i], a[i+1] = a[i+1], a[i]\n        # print(a)\n\n        if sorted(a) == a:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef solve(a, p):\n    n, m = len(a), len(p)\n\n    # Sort the positions in ascending order\n    p.sort()\n\n    # Initialize the next position to swap with\n    next_position = p[0]\n\n    # Iterate over all positions\n    for i in range(m):\n        # If the current position is not the next position\n        if p[i] != next_position:\n            # The array cannot be sorted\n            return False\n\n        # Update the next position\n        next_position = p[i] + 1\n\n        # If the next position is out of bounds\n        if next_position >= n:\n            # The array cannot be sorted\n            return False\n\n        # If the next position is not the next position in the set of positions\n        if next_position not in p:\n            # The array cannot be sorted\n            return False\n\n    # The array can be sorted\n    return True\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        a = list(map(int, input().split()))\n        p = list(map(int, input().split()))\n        if solve(a, p):\n            print('YES')\n        else:\n            print('NO')", "\n\ndef solve(a, p):\n    for i in range(len(a)):\n        for j in range(len(a)-1):\n            if a[j] > a[j+1] and j+1 in p:\n                a[j], a[j+1] = a[j+1], a[j]\n    return a\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = set(map(int, input().split()))\n    a = solve(a, p)\n    if all(a[i] <= a[i+1] for i in range(len(a)-1)):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "\n\n\ndef swap(arr, i):\n    arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n\ndef solve(arr, positions):\n    for position in positions:\n        if position == 0:\n            if arr[0] > arr[1]:\n                swap(arr, 0)\n        elif position == len(arr) - 1:\n            if arr[-1] < arr[-2]:\n                swap(arr, -1)\n        else:\n            if arr[position] > arr[position - 1] and arr[position] > arr[position + 1]:\n                swap(arr, position)\n            elif arr[position] < arr[position - 1] and arr[position] < arr[position + 1]:\n                swap(arr, position)\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            return \"NO\"\n    return \"YES\"\n\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        arr = list(map(int, input().split()))\n        positions = list(map(int, input().split()))\n        print(solve(arr, positions))"]