["\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print(max(m - n + 2, 0))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(n*(n-1)//2 - m + 1)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    if m <= n-1:\n        print(0)\n    elif m >= n*(n-1)/2:\n        print(int(m*(m+1)/2))\n    else:\n        print(int(m*(m+1)/2 - (m-n+1)*(m-n)/2))\n\nmain()", "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print(n * (n-1) - m)\n\nmain()", "\n\n#Use a disjoint set data structure to find the maximum cost\n\n#The maximum cost is the number of edges in each tree minus one\n#This is because we can always select the highest numbered edge to plow in each tree\n#and then the rest of the edges in the tree are not needed\n\n#Use union by rank and path compression for the disjoint set data structure\n\n#Union by rank and path compression:\n#For find, make each node point to its grandparent (not just parent)\n#For union, link the smaller tree to the larger tree\n#By linking the smaller tree to the larger tree, we ensure that the height of the tree is never more than log n\n\nimport sys\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n    \n    def find(self, node):\n        if self.parent[node] != node:\n            #Path compression\n            self.parent[node] = self.find(self.parent[node])\n        return self.parent[node]\n    \n    def union(self, node1, node2):\n        root1 = self.find(node1)\n        root2 = self.find(node2)\n        \n        if root1 != root2:\n            #Union by rank\n            if self.rank[root1] > self.rank[root2]:\n                self.parent[root2] = root1\n            elif self.rank[root1] < self.rank[root2]:\n                self.parent[root1] = root2\n            else:\n                self.parent[root2] = root1\n                self.rank[root1] += 1\n\ndef main():\n    line = sys.stdin.readline()\n    n, m = map(int, line.split())\n    \n    ds = DisjointSet(n)\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if m > 0:\n                ds.union(i, j)\n                m -= 1\n    \n    num_edges = [0 for i in range(n)]\n    for i in range(n):\n        root = ds.find(i)\n        num_edges[root] += 1\n    \n    total_cost = 0\n    for num_edge in num_edges:\n        if num_edge > 0:\n            total_cost += num_edge-1\n    \n    print(total_cost)\n    \nmain()\n\n#This solution is O(n^2)", "\nimport sys\n\ndef main():\n    n, m = [int(i) for i in sys.stdin.readline().split()]\n    if n == 2:\n        print(m)\n    elif n == 3:\n        print(m+1)\n    else:\n        print(m+(m-1)//(n-2))\n\nmain()", "\n\ndef main():\n    \"\"\"\n    The key is to realize that the optimal way to plow is to connect the cities in a line. We can then do a greedy approach\n    by starting at the end of the line and plowing back towards the start.\n    \"\"\"\n    n, m = map(int, input().split())\n\n    # The cost of plowing is the sum of the cost of each road\n    cost = 0\n\n    # The end of the line is the first city to be plowed, so plow it\n    cost += 1\n    m -= 1\n\n    # Now we will add roads one by one to the end of the line\n    # m is the number of roads left to add\n    # The cost of adding a road is the number of roads that have been plowed so far plus 1\n    # This is because we must plow the new road plus every road that has been plowed so far\n    # This is because we must be able to get from the new city to every other city\n    while m > 0:\n        cost += m\n        m -= 1\n\n    print(cost)\n\nmain()"]