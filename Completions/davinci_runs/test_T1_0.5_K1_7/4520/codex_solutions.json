["\n\nfrom collections import defaultdict\n\nn, k = [int(x) for x in input().split()]\n\nsegments = defaultdict(int)\n\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    for j in range(l, r+1):\n        segments[j] += 1\n\nbad_points = [x for x in segments if segments[x] > k]\n\nremove_count = 0\nremove_segments = []\n\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    if any(l <= x <= r for x in bad_points):\n        remove_count += 1\n        remove_segments.append(i+1)\n\nprint(remove_count)\nprint(' '.join([str(x) for x in remove_segments]))", "\n\nimport sys\nimport math\n\ndef solution(n, k, segments):\n\tif k == 1:\n\t\treturn [i for i in range(1, n+1)]\n\n\t# sort the segments by the start point\n\tsegments.sort(key=lambda x: x[0])\n\n\t# initialize the minimum number of segments to remove\n\tmin_num_segments = len(segments)\n\n\t# initialize the start and end points of the first segment\n\tstart = segments[0][0]\n\tend = segments[0][1]\n\n\t# initialize the list of segments to remove\n\tsegments_to_remove = []\n\n\t# for each segment\n\tfor i in range(1, n):\n\t\t# if the current segment is covered by the previous segment(s)\n\t\tif segments[i][0] <= end:\n\t\t\t# if the current segment is completely covered by the previous segment(s)\n\t\t\tif segments[i][1] <= end:\n\t\t\t\t# add the current segment to the list of segments to remove\n\t\t\t\tsegments_to_remove.append(i+1)\n\n\t\t\t# if the current segment is not completely covered by the previous segment(s)\n\t\t\telse:\n\t\t\t\t# update the end point of the previous segment(s)\n\t\t\t\tend = segments[i][1]\n\n\t\t# if the current segment is not covered by the previous segment(s)\n\t\telse:\n\t\t\t# if the number of segments to remove is less than the current minimum number of segments to remove\n\t\t\tif len(segments_to_remove) < min_num_segments:\n\t\t\t\t# update the minimum number of segments to remove\n\t\t\t\tmin_num_segments = len(segments_to_remove)\n\n\t\t\t# reset the start and end points of the previous segment(s)\n\t\t\tstart = segments[i][0]\n\t\t\tend = segments[i][1]\n\n\t\t\t# reset the list of segments to remove\n\t\t\tsegments_to_remove = []\n\n\t# if the number of segments to remove is less than the current minimum number of segments to remove\n\tif len(segments_to_remove) < min_num_segments:\n\t\t# update the minimum number of segments to remove\n\t\tmin_num_segments = len(segments_to_remove)\n\n\treturn segments_to_remove\n\nif __name__ == \"__main__\":\n\tn, k = map(int, sys.stdin.readline().split())\n\tsegments = []\n\tfor i in range(n):\n\t\tsegments.append(tuple(map(int, sys.stdin.readline().split())))\n\n\tsegments_to_remove = solution(n, k, segments)\n\tprint(len(segments_to_remove))\n\tprint(\" \".join(map(str, segments_to_remove)))", "\n\nn, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(tuple(map(int, input().split())))\n\ndef calc_bad_points(segments, k):\n    # O(n^2)\n    # return [i for i in range(1, 201) if len([1 for s in segments if i in range(s[0], s[1]+1)]) > k]\n    # O(nlogn)\n    points = set()\n    for s in segments:\n        for i in range(s[0], s[1]+1):\n            points.add(i)\n    bad_points = set()\n    for p in points:\n        if len([1 for s in segments if p in range(s[0], s[1]+1)]) > k:\n            bad_points.add(p)\n    return bad_points\n\ndef segments_to_remove(segments, k):\n    # O(n^3)\n    # return [i+1 for i in range(len(segments)) if calc_bad_points(segments[:i]+segments[i+1:], k) == set()]\n    # O(n^2)\n    bad_points = calc_bad_points(segments, k)\n    # print(bad_points)\n    segments_to_remove = []\n    for i in range(len(segments)):\n        for p in range(segments[i][0], segments[i][1]+1):\n            if p in bad_points:\n                segments_to_remove.append(i+1)\n                break\n    return segments_to_remove\n\nprint(len(segments_to_remove(segments, k)))\nprint(*segments_to_remove(segments, k))", "\n\n\ndef solve(n, k, l, r):\n    # print(n, k, l, r)\n    if n <= 0:\n        return 0, []\n    if k <= 0:\n        return n, list(range(1, n + 1))\n    if k == 1:\n        # print(n, k, l, r)\n        m = 0\n        p = []\n        for i in range(1, n + 1):\n            if l[i] == r[i]:\n                m += 1\n                p.append(i)\n        return m, p\n    m = n\n    p = []\n    for i in range(1, n + 1):\n        if l[i] != r[i]:\n            l1 = l[1: i] + l[i + 1: n + 1]\n            r1 = r[1: i] + r[i + 1: n + 1]\n            m1, p1 = solve(n - 1, k, l1, r1)\n            if m1 + 1 < m:\n                m = m1 + 1\n                p = [i] + p1\n    return m, p\n\n\nn, k = map(int, input().split())\nl = [0]\nr = [0]\nfor i in range(n):\n    l1, r1 = map(int, input().split())\n    l.append(l1)\n    r.append(r1)\nm, p = solve(n, k, l, r)\nprint(m)\nprint(*p)", "\n\nn, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\n# sort segments by start point\nsegments.sort(key=lambda x: x[0])\n\n# for each segment, if its start point is already covered by more than k segments,\n# then it is not necessary to add it to the covered segments.\n# otherwise, add it to the covered segments.\n# if the number of covered segments is larger than k, remove the segment with the smallest end point.\ncovered = []\nremoved = []\nfor i in range(n):\n    if len(covered) == 0 or covered[-1][1] < segments[i][0]:\n        covered.append(segments[i])\n    else:\n        if len(covered) < k:\n            covered.append(segments[i])\n        else:\n            removed.append(i+1)\n            covered.sort(key=lambda x: x[1])\n            covered.pop(0)\n\nprint(len(removed))\nprint(*removed)", "\n\nfrom sys import stdin\n\ndef main():\n    n, k = map(int, stdin.readline().strip().split())\n    lr = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        lr.append((l, r))\n    lr = sorted(lr, key=lambda x: x[0])\n    bad = set()\n    for i in range(n):\n        for j in range(lr[i][0], lr[i][1]+1):\n            bad.add(j)\n    res = []\n    for i in range(n):\n        for j in range(lr[i][0], lr[i][1]+1):\n            bad.remove(j)\n        bad.add(lr[i][0])\n        bad.add(lr[i][1])\n        if len(bad) <= k:\n            res.append(i+1)\n            break\n    print(len(res))\n    print(*res)\n\nif __name__ == '__main__':\n    main()"]