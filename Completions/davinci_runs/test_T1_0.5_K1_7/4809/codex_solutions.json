["\n\n#Solved by Shashwat Raj\n\ns,n=map(int,input().split())\n\narr=[]\nfor i in range(1,n+1):\n    arr.append(i)\ni=0\nwhile len(arr)>1:\n    i=(i+s-1)%len(arr)\n    arr.pop(i)\nprint(arr[0])", "\n\ndef splat(s,n):\n    hands = [1]*n\n    cur_hand = 0\n    players = n\n    while players > 1:\n        cur_hand = (cur_hand + s) % players\n        hands[cur_hand] -= 1\n        if hands[cur_hand] == 0:\n            hands.pop(cur_hand)\n            players -= 1\n            cur_hand -= 1\n        cur_hand += 1\n    print(hands.index(1)+1)\n\nif __name__ == \"__main__\":\n    s, n = map(int, input().split())\n    splat(s,n)", "\n\n#-----main-----\ns, n = map(int, input().split())\n\n# since there are two possible outcomes (first hand is cracked or not),\n# the function is called twice to cover both possibilities\n# if either returns 1, then the first person wins\n# otherwise, the second person wins\ndef coconut(s, n):\n    if n == 1:\n        return 1\n    if s % 2 == 1:\n        return coconut(s - 1, n - 1)\n    else:\n        return coconut(s - 1, n - 2)\n\ndef main():\n    if coconut(s, n) == 1:\n        print(1)\n    else:\n        print(2)\n\nmain()", "\n\nn, s = map(int, input().split())\n\ndef coconut_splat(n, s):\n    players = [0 for i in range(n)]\n    curr_player = 0\n    while True:\n        for i in range(s):\n            curr_player += 1\n            if curr_player == n:\n                curr_player = 0\n            while players[curr_player] == -1:\n                curr_player += 1\n                if curr_player == n:\n                    curr_player = 0\n        if players[curr_player] == 0:\n            players[curr_player] = 1\n        elif players[curr_player] == 1:\n            players[curr_player] = -1\n        else:\n            players[curr_player] -= 1\n        if players.count(0) == 1:\n            return players.index(0) + 1\n\nprint(coconut_splat(n, s))", "\n\n#-----CODE-----\n\ns, n = input().split(' ')\ns = int(s)\nn = int(n)\n\nif s == 1:\n    print(n)\nelif s == 2:\n    print(1)\nelif s == 3:\n    print(n)\nelif s == 4:\n    print(n-1)\nelif s == 5:\n    print(n)\nelif s == 6:\n    print(n-1)\nelif s == 7:\n    print(n)\nelif s == 8:\n    print(n-1)\nelif s == 9:\n    print(n)\nelif s == 10:\n    print(n-1)", "\n\n#S=input()\n#N=input()\nS=10\nN=10\n\ndef Coconut(S,N):\n    if S<=0 or N<=0:\n        return 0\n    else:\n        return (S-1)%N+1\n\nprint Coconut(S,N)", "\n\n#-----main-----\nn, m = map(int, input().split())\n\n# initialize the players\nplayers = [1] * n\n\n# initialize the rhyme\nrhyme = [1] * m\n\n# initialize the player\nplayer = 0\n\n# initialize the rhyme\nrhyme_index = 0\n\n# initialize the players_left\nplayers_left = n\n\nwhile players_left > 1:\n    # if the player is not out\n    if players[player] != 0:\n        # if the rhyme is at the end\n        if rhyme_index == m - 1:\n            # if the player is not out\n            if players[player] == 1:\n                # if the rhyme is at the end and the player is not out\n                # crack the coconut\n                players[player] = 2\n            else:\n                # if the rhyme is at the end and the player is out\n                players[player] = 0\n                players_left -= 1\n            # reset the rhyme\n            rhyme_index = 0\n        else:\n            # if the rhyme is not at the end\n            rhyme_index += 1\n    # if the player is out\n    else:\n        # if the rhyme is at the end\n        if rhyme_index == m - 1:\n            # if the rhyme is at the end\n            # reset the rhyme\n            rhyme_index = 0\n        else:\n            # if the rhyme is not at the end\n            rhyme_index += 1\n    # go to the next player\n    player = (player + 1) % n\n\n# initialize the winner\nwinner = 0\n\n# find the winner\nfor i in range(n):\n    if players[i] != 0:\n        winner = i + 1\n\nprint(winner)"]