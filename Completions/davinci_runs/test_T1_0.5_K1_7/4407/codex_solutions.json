["\n\ndef solve(n, q, a, b):\n    a.sort()\n    res = []\n    for i in range(q):\n        res.append(solve_one(n, a, b[i]))\n    return res\n\ndef solve_one(n, a, b):\n    if b in a:\n        return 1\n    if b == 0:\n        return 0\n    if b > a[-1] * 2:\n        return -1\n    if b % 2 == 0:\n        return solve_one(n, a, b // 2) + 1\n    for i in range(n):\n        if a[i] * 2 > b:\n            break\n    return solve_one(n, a, b - a[i]) + 1\n\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(q):\n        b.append(int(input()))\n    res = solve(n, q, a, b)\n    for i in range(q):\n        print(res[i])", "\n\n\"\"\"\n----Solution----\n\nThe idea is to solve this problem using dynamic programming. We will create a table of size $2^n$ where $n$ is the number of coins. We will fill this table using the following rule:\n\nThe value of the $i$-th cell is the minimum number of coins necessary to get the value $i$.\n\nLet's look at the example of table filling for $n = 5$ coins:\n\n$a_1 = 2$, $a_2 = 4$, $a_3 = 8$, $a_4 = 2$, $a_5 = 4$\n\nThe table will be filled as follows:\n\n$0$\n$1$\n$2$\n$3$\n$4$\n$5$\n$6$\n$7$\n$8$\n$9$\n$10$\n$11$\n$12$\n$13$\n$14$\n$15$\n\n$1$\n$1$\n$1$\n$2$\n$1$\n$2$\n$2$\n$3$\n$1$\n$2$\n$2$\n$3$\n$2$\n$3$\n$3$\n$4$\n\nSo, the answer to the first query is $1$, the answer to the second query is $2$, the answer to the third query is $3$ and the answer to the fourth query is $2$.\n\nNow let's look at the algorithm.\n\nWe will iterate over all the coins. At each step we will iterate over all the cells of our table from the least to the greatest. If the value of the current coin is less than or equal to the value of the current cell and the current cell can be obtained using the least number of coins (the value of the current cell is equal to the value of the previous cell plus the value of the current coin), then we will set the value of the current cell to be equal to the value of the previous cell plus the value of the current coin.\n\nThe time complexity of this solution is $O(n \\cdot 2^n)$.\n\"\"\"\n\n\"\"\"\n----Solution----\n\nThe idea is to solve this problem using dynamic programming. We will create a table of size $2^n$ where $n$ is the number of coins. We will fill this table using the following rule:\n\nThe value of the $i$-th cell is the minimum number of coins necessary to get the value $i$.\n\nLet's look at the example of table filling for $n = 5$ coins:\n\n$a_1 = 2$, $a_2 = 4$, $a_3 = 8$, $a_4 = 2$, $a_5 = 4$\n\nThe table will be filled as follows:\n\n$0$\n$1$\n$2$\n$3$\n$4$\n$5$\n$6$\n$7$\n$8$\n$9$\n$10$\n$11$\n$12$\n$13$\n$14$\n$15$\n\n$1$\n$1$\n$1$\n$2$\n$1$\n$2$\n$2$\n$3$\n$1$\n$2$\n$2$\n$3$\n$2$\n$3$\n$3$\n$4$\n\nSo, the answer to the first query is $1$, the answer to the second query is $2$, the answer to the third query is $3$ and the answer to the fourth query is $2$.\n\nNow let's look at the algorithm.\n\nWe will iterate over all the coins. At each step we will iterate over all the cells of our table from the least to the greatest. If the value of the current coin is less than or equal to the value of the current cell and the current cell can be obtained using the least number of coins (the value of the current cell is equal to the value of the previous cell plus the value of the current coin), then we will set the value of the current cell to be equal to the value of the previous cell plus the value of the current coin.\n\nThe time complexity of this solution is $O(n \\cdot 2^n)$.\n\"\"\"\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\ntable = [0] * (2 ** n)\nfor i in range(n):\n    for j in range(2 ** n):\n        if coins[i] <= j and table[j] == table[j - coins[i]] + coins[i]:\n            table[j] = table[j - coins[i]] + coins[i]\nfor i in range(q):\n    query = int(input())\n    if table[query] == query:\n        print(1)\n    else:\n        print(-1)", "\n\n# Solution\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nb = [int(input()) for _ in range(q)]\n\ndef answer(x):\n    if x == 0:\n        return 0\n    if x in a:\n        return 1\n    for i in a:\n        if x % i == 0:\n            return 1 + answer(x // i)\n    return -1\n\nfor i in b:\n    print(answer(i))", "\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\nqueries = []\nfor _ in range(q):\n    queries.append(int(input()))\n\n# print(coins, queries)\n\n# for each query, find the number of coins that can be added up to the query.\n# if not possible, print -1\n\n# for each query, check if the coin is a factor of the query.\n# if yes, check if the coin is already used.\n# if not, add the coin to the list of used coins and divide the query by the coin.\n# if not, move on to the next coin.\n# if all coins are exhausted, print -1\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\nfor query in queries:\n    used_coins = []\n    while query > 0:\n        # print(query, used_coins)\n        if query % 2 == 0:\n            if 2 in coins:\n                query = query // 2\n                used_coins.append(2)\n            else:\n                print(-1)\n                break\n        else:\n            if query % 2 == 1:\n                print(-1)\n                break\n    if query == 0:\n        print(len(used_coins))", "\n\nimport math\n\ndef get_number_of_coins(coins, sum_to_obtain):\n    if sum_to_obtain == 0:\n        return 0\n    if sum_to_obtain in coins:\n        return 1\n    if sum_to_obtain < min(coins):\n        return -1\n\n    # find the largest coin that is smaller than the sum to obtain\n    largest_smaller_coin = 0\n    for coin in coins:\n        if coin < sum_to_obtain:\n            largest_smaller_coin = coin\n        else:\n            break\n\n    # calculate the number of coins needed to obtain the sum to obtain\n    number_of_coins = get_number_of_coins(coins, sum_to_obtain - largest_smaller_coin)\n    if number_of_coins == -1:\n        return -1\n    else:\n        return number_of_coins + 1\n\n\ndef get_number_of_queries(queries):\n    number_of_queries = input()\n    for _ in range(int(number_of_queries)):\n        queries.append(int(input()))\n    return queries\n\n\ndef get_coins(coins):\n    number_of_coins = int(input())\n    coin_values = input().split()\n    for i in range(number_of_coins):\n        coins.append(int(math.pow(2, int(coin_values[i]))))\n    return coins\n\n\ndef main():\n    coins = []\n    queries = []\n    coins = get_coins(coins)\n    queries = get_number_of_queries(queries)\n    for query in queries:\n        print(get_number_of_coins(coins, query))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\n\nfor _ in range(q):\n    query = int(input())\n    if query in coins:\n        print(1)\n    else:\n        possible_answers = []\n\n        for coin in coins:\n            if coin < query:\n                possible_answers.append(query - coin)\n        if len(possible_answers) == 0:\n            print(-1)\n        else:\n            possible_answers.sort()\n            print(possible_answers[0])", "\n\ndef solve(n, q, a, b):\n    a.sort()\n    for i in range(q):\n        ans = 0\n        for j in range(n-1, -1, -1):\n            if b[i] == 0:\n                break\n            if a[j] <= b[i]:\n                ans += 1\n                b[i] -= a[j]\n        if b[i] > 0:\n            ans = -1\n        print(ans)\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nb = []\nfor i in range(q):\n    b.append(int(input()))\nsolve(n, q, a, b)"]