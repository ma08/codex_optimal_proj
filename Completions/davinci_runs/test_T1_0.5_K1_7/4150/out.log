2022-04-13 18:44:57.726013 """
There are $n$ students standing in a row. Two coaches are forming two teams — the first coach chooses the first team and the second coach chooses the second team.

The $i$-th student has integer programming skill $a_i$. All programming skills are distinct and between $1$ and $n$, inclusive.

Firstly, the first coach will choose the student with maximum programming skill among all students not taken into any team, and $k$ closest students to the left of him and $k$ closest students to the right of him (if there are less than $k$ students to the left or to the right, all of them will be chosen). All students that are chosen leave the row and join the first team. Secondly, the second coach will make the same move (but all students chosen by him join the second team). Then again the first coach will make such move, and so on. This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).

Your problem is to determine which students will be taken into the first team and which students will be taken into the second team.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of students and the value determining the range of chosen students during each move, respectively.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le n$), where $a_i$ is the programming skill of the $i$-th student. It is guaranteed that all programming skills are distinct.


-----Output-----

Print a string of $n$ characters; $i$-th character should be 1 if $i$-th student joins the first team, or 2 otherwise.


-----Examples-----
Input
5 2
2 4 5 3 1

Output
11111

Input
5 1
2 1 3 5 4

Output
22111

Input
7 1
7 2 1 3 5 4 6

Output
1121122

Input
5 1
2 4 5 3 1

Output
21112



-----Note-----

In the first example the first coach chooses the student on a position $3$, and the row becomes empty (all students join the first team).

In the second example the first coach chooses the student on position $4$, and the row becomes $[2, 1]$ (students with programming skills $[3, 4, 5]$ join the first team). Then the second coach chooses the student on position $1$, and the row becomes empty (and students with programming skills $[1, 2]$ join the second team).

In the third example the first coach chooses the student on position $1$, and the row becomes $[1, 3, 5, 4, 6]$ (students with programming skills $[2, 7]$ join the first team). Then the second coach chooses the student on position $5$, and the row becomes $[1, 3, 5]$ (students with programming skills $[4, 6]$ join the second team). Then the first coach chooses the student on position $3$, and the row becomes $[1]$ (students with programming skills $[3, 5]$ join the first team). And then the second coach chooses the remaining student (and the student with programming skill $1$ joins the second team).

In the fourth example the first coach chooses the student on position $3$, and the row becomes $[2, 1]$ (students with programming skills $[3, 4, 5]$ join the first team). Then the second coach chooses the student on position $1$, and the row becomes empty (and students with programming skills $[1, 2]$ join the second team).
"""
2022-04-13 18:44:57.726030 --------------------------
2022-04-13 18:45:58.994850 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = [0] * n\n    a = sorted(enumerate(a), key=lambda x: x[1], reverse=True)\n    for i in range(n):\n        if i % 2 == 0:\n            for j in range(max(0, a[i][0] - k), min(n, a[i][0] + k + 1)):\n                ans[j] = 1\n        else:\n            for j in range(max(0, a[i][0] - k), min(n, a[i][0] + k + 1)):\n                ans[j] = 2\n    print(\"\".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef read_ints():\n    temp = input().split()\n    temp = [int(t) for t in temp]\n    return temp\n\ndef main():\n    n, k = read_ints()\n    a = read_ints()\n    res = [0] * n\n    while a:\n        max_a = max(a)\n        max_a_index = a.index(max_a)\n        left_index = max(max_a_index - k, 0)\n        right_index = min(max_a_index + k, len(a) - 1)\n        res[left_index : right_index+1] = [1] * (right_index - left_index + 1)\n        a = a[:left_index] + a[right_index+1:]\n        if a:\n            max_a = max(a)\n            max_a_index = a.index(max_a)\n            left_index = max(max_a_index - k, 0)\n            right_index = min(max_a_index + k, len(a) - 1)\n            res[left_index : right_index+1] = [2] * (right_index - left_index + 1)\n            a = a[:left_index] + a[right_index+1:]\n    print(''.join(map(str, res)))\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# a[i] is the skill of ith student\n# a[i] is the index of the student who has skill i\n# a[a[i]] is the skill of the student who has skill i\n\n# First, get the index of the student with the maximum skill\nmax_skill = max(a)\nmax_index = a.index(max_skill)\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nans = [0]*n\n\nfor i in range(left_bound, right_bound+1):\n    ans[i] = 1\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nfor i in range(left_bound, right_bound+1):\n    if ans[i] == 0:\n        ans[i] = 2\n    else:\n        ans[i] = 1\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nfor i in range(left_bound, right_bound+1):\n    if ans[i] == 0:\n        ans[i] = 1\n    else:\n        ans[i] = 2\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nfor i in range(left_bound, right_bound+1):\n    if ans[i] == 0:\n        ans[i] = 2\n    else:\n        ans[i] = 1\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\nfor i in range(n):\n    print(ans[i], end=\"\")\nprint()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = list(zip(a, range(n)))\n    a.sort(reverse=True)\n    a = [i[1] for i in a]\n    ans = [0 for i in range(n)]\n    for i in range(n):\n        if i % 2 == 0:\n            ans[a[i]] = 1\n        else:\n            ans[a[i]] = 2\n        if i < n - 1:\n            if a[i] - a[i + 1] >= 2 * k:\n                a = a[:i + 1] + a[i + 1:][::-1]\n    print(''.join(map(str, ans)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().strip().split())\n    skills = map(int, sys.stdin.readline().strip().split())\n    skills = [skills[i] - 1 for i in range(n)]\n    teams = [1] * n\n\n    for i in range(n):\n        max_skill = max(skills)\n        max_skill_pos = skills.index(max_skill)\n\n        left_range = max(0, max_skill_pos - k)\n        right_range = min(n, max_skill_pos + k + 1)\n\n        for j in range(left_range, right_range):\n            if teams[j] == 1:\n                teams[j] = 2\n\n        skills = [skills[j] for j in range(n) if j not in range(left_range, right_range)]\n        teams = [teams[j] for j in range(n) if j not in range(left_range, right_range)]\n\n    print ''.join([str(team) for team in teams])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# This problem is solved using a greedy algorithm\n# The first coach will always choose the student with the maximum programming skill\n# If there are multiple students with the maximum programming skill, then the coach will choose the student that is closest to the right\n# The second coach will always choose the student with the second highest programming skill\n# If there are multiple students with the second highest programming skill, then the coach will choose the student that is closest to the right\n# This is repeated until all students are chosen\n\n# Note that the second coach will never choose the student with the maximum programming skill\n# This is because the first coach will always choose the student with the maximum programming skill\n\n# Function to get the maximum programming skill\ndef maxSkill(skills):\n    maximum = 0\n    for i in range(len(skills)):\n        if skills[i] > maximum:\n            maximum = skills[i]\n    return maximum\n\n# Function to get the second highest programming skill\ndef secondMaxSkill(skills):\n    secondMax = 0\n    for i in range(len(skills)):\n        if skills[i] > secondMax and skills[i] < maxSkill(skills):\n            secondMax = skills[i]\n    return secondMax\n\n# Function to get the index of the student with the maximum programming skill\ndef maxSkillIndex(skills):\n    index = 0\n    for i in range(len(skills)):\n        if skills[i] == maxSkill(skills):\n            index = i\n    return index\n\n# Function to get the index of the student with the second highest programming skill\ndef secondMaxSkillIndex(skills):\n    index = 0\n    for i in range(len(skills)):\n        if skills[i] == secondMaxSkill(skills):\n            index = i\n    return index\n\n# Function to get the indices of the students that are closest to the student with the maximum programming skill\ndef closestStudents(skills, k, index):\n    closest = []\n    for i in range(len(skills)):\n        if i != index:\n            closest.append(i)\n    closest.sort(key=lambda x: abs(x - index))\n    return closest[:k]\n\n# Function to get the indices of the students that are closest to the student with the second highest programming skill\ndef secondClosestStudents(skills, k, index):\n    closest = []\n    for i in range(len(skills)):\n        if i != index:\n            closest.append(i)\n    closest.sort(key=lambda x: abs(x - index))\n    return closest[:k]\n\n# Function to remove the student with the maximum programming skill\ndef removeMaxSkill(skills):\n    skills.remove(maxSkill(skills))\n\n# Function to remove the student with the second highest programming skill\ndef removeSecondMaxSkill(skills):\n    skills.remove(secondMaxSkill(skills))\n\n# Function to remove the indices of the students that are closest to the student with the maximum programming skill\ndef removeClosestStudents(skills, index):\n    closest = closestStudents(skills, k, index)\n    for i in range(len(closest)):\n        skills.remove(skills[closest[i]])\n\n# Function to remove the indices of the students that are closest to the student with the second highest programming skill\ndef removeSecondClosestStudents(skills, index):\n    closest = secondClosestStudents(skills, k, index)\n    for i in range(len(closest)):\n        skills.remove(skills[closest[i]])\n\n# Function to determine which students will be taken into the first team\ndef firstTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(1)\n    while len(skills) > 0:\n        index = maxSkillIndex(skills)\n        removeMaxSkill(skills)\n        removeClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 2\n    return team\n\n# Function to determine which students will be taken into the second team\ndef secondTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(2)\n    while len(skills) > 0:\n        index = secondMaxSkillIndex(skills)\n        removeSecondMaxSkill(skills)\n        removeSecondClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 1\n    return team\n\n# Function to determine which students will be taken into the first team\ndef firstTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(1)\n    while len(skills) > 0:\n        index = maxSkillIndex(skills)\n        removeMaxSkill(skills)\n        removeClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 2\n    return team\n\n# Function to determine which students will be taken into the second team\ndef secondTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(2)\n    while len(skills) > 0:\n        index = secondMaxSkillIndex(skills)\n        removeSecondMaxSkill(skills)\n        removeSecondClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 1\n    return team\n\n# Main function\ndef main():\n    # Get the number of students and the value determining the range of chosen students during each move\n    n, k = map(int, input().split())\n\n    # Get the programming skill of each student\n    skills = list(map(int, input().split()))\n\n    # Determine which students will be taken into the first team\n    team = firstTeam(skills, k)\n\n    # Print the team\n    print(''.join(map(str, team)))\n\n# Run program\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# SOLUTION\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nans = [0] * n\n\ncur = 0\n\nfor i in range(n):\n    l = max(0, cur - k)\n    r = min(cur + k, n - 1)\n\n    if i % 2 == 0:\n        ans[a.index(cur + 1)] = 1\n        cur = a[l:r + 1].index(cur + 1) + l\n    else:\n        ans[a.index(cur + 1)] = 2\n        cur = a[l:r + 1].index(cur + 1) + l\n\nprint(''.join(map(str, ans)))"
    }
  ],
  "created": 1649875497,
  "id": "cmpl-4wcH3KplNErBFgaQH9qEQkFuklsV7",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 18:45:58.995241 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = [0] * n\n    a = sorted(enumerate(a), key=lambda x: x[1], reverse=True)\n    for i in range(n):\n        if i % 2 == 0:\n            for j in range(max(0, a[i][0] - k), min(n, a[i][0] + k + 1)):\n                ans[j] = 1\n        else:\n            for j in range(max(0, a[i][0] - k), min(n, a[i][0] + k + 1)):\n                ans[j] = 2\n    print(\"\".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 18:45:58.995289 REASON stop
2022-04-13 18:45:58.995770 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef read_ints():\n    temp = input().split()\n    temp = [int(t) for t in temp]\n    return temp\n\ndef main():\n    n, k = read_ints()\n    a = read_ints()\n    res = [0] * n\n    while a:\n        max_a = max(a)\n        max_a_index = a.index(max_a)\n        left_index = max(max_a_index - k, 0)\n        right_index = min(max_a_index + k, len(a) - 1)\n        res[left_index : right_index+1] = [1] * (right_index - left_index + 1)\n        a = a[:left_index] + a[right_index+1:]\n        if a:\n            max_a = max(a)\n            max_a_index = a.index(max_a)\n            left_index = max(max_a_index - k, 0)\n            right_index = min(max_a_index + k, len(a) - 1)\n            res[left_index : right_index+1] = [2] * (right_index - left_index + 1)\n            a = a[:left_index] + a[right_index+1:]\n    print(''.join(map(str, res)))\n\nmain()"
}
2022-04-13 18:45:58.995897 REASON stop
2022-04-13 18:45:58.996357 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# a[i] is the skill of ith student\n# a[i] is the index of the student who has skill i\n# a[a[i]] is the skill of the student who has skill i\n\n# First, get the index of the student with the maximum skill\nmax_skill = max(a)\nmax_index = a.index(max_skill)\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nans = [0]*n\n\nfor i in range(left_bound, right_bound+1):\n    ans[i] = 1\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nfor i in range(left_bound, right_bound+1):\n    if ans[i] == 0:\n        ans[i] = 2\n    else:\n        ans[i] = 1\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nfor i in range(left_bound, right_bound+1):\n    if ans[i] == 0:\n        ans[i] = 1\n    else:\n        ans[i] = 2\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\n# Then, get the closest k students to the left and the right of him\nleft_bound = max(0, max_index - k)\nright_bound = min(n-1, max_index + k)\n\n# All students that are chosen leave the row and join the first team.\n# Then, the second coach will make the same move (but all students chosen by him join the second team).\n# Then again the first coach will make such move, and so on.\n\n# This repeats until the row becomes empty (i. e. the process ends when each student becomes to some team).\n\nfor i in range(left_bound, right_bound+1):\n    if ans[i] == 0:\n        ans[i] = 2\n    else:\n        ans[i] = 1\n\n# for i in range(n):\n#     print(i, a[i], ans[i])\n\nfor i in range(n):\n    print(ans[i], end=\"\")\nprint()"
}
2022-04-13 18:45:58.996416 REASON stop
2022-04-13 18:45:59.026690 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = list(zip(a, range(n)))\n    a.sort(reverse=True)\n    a = [i[1] for i in a]\n    ans = [0 for i in range(n)]\n    for i in range(n):\n        if i % 2 == 0:\n            ans[a[i]] = 1\n        else:\n            ans[a[i]] = 2\n        if i < n - 1:\n            if a[i] - a[i + 1] >= 2 * k:\n                a = a[:i + 1] + a[i + 1:][::-1]\n    print(''.join(map(str, ans)))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 18:45:59.026791 REASON stop
2022-04-13 18:45:59.034564 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().strip().split())\n    skills = map(int, sys.stdin.readline().strip().split())\n    skills = [skills[i] - 1 for i in range(n)]\n    teams = [1] * n\n\n    for i in range(n):\n        max_skill = max(skills)\n        max_skill_pos = skills.index(max_skill)\n\n        left_range = max(0, max_skill_pos - k)\n        right_range = min(n, max_skill_pos + k + 1)\n\n        for j in range(left_range, right_range):\n            if teams[j] == 1:\n                teams[j] = 2\n\n        skills = [skills[j] for j in range(n) if j not in range(left_range, right_range)]\n        teams = [teams[j] for j in range(n) if j not in range(left_range, right_range)]\n\n    print ''.join([str(team) for team in teams])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 18:45:59.034664 REASON stop
2022-04-13 18:45:59.048035 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# This problem is solved using a greedy algorithm\n# The first coach will always choose the student with the maximum programming skill\n# If there are multiple students with the maximum programming skill, then the coach will choose the student that is closest to the right\n# The second coach will always choose the student with the second highest programming skill\n# If there are multiple students with the second highest programming skill, then the coach will choose the student that is closest to the right\n# This is repeated until all students are chosen\n\n# Note that the second coach will never choose the student with the maximum programming skill\n# This is because the first coach will always choose the student with the maximum programming skill\n\n# Function to get the maximum programming skill\ndef maxSkill(skills):\n    maximum = 0\n    for i in range(len(skills)):\n        if skills[i] > maximum:\n            maximum = skills[i]\n    return maximum\n\n# Function to get the second highest programming skill\ndef secondMaxSkill(skills):\n    secondMax = 0\n    for i in range(len(skills)):\n        if skills[i] > secondMax and skills[i] < maxSkill(skills):\n            secondMax = skills[i]\n    return secondMax\n\n# Function to get the index of the student with the maximum programming skill\ndef maxSkillIndex(skills):\n    index = 0\n    for i in range(len(skills)):\n        if skills[i] == maxSkill(skills):\n            index = i\n    return index\n\n# Function to get the index of the student with the second highest programming skill\ndef secondMaxSkillIndex(skills):\n    index = 0\n    for i in range(len(skills)):\n        if skills[i] == secondMaxSkill(skills):\n            index = i\n    return index\n\n# Function to get the indices of the students that are closest to the student with the maximum programming skill\ndef closestStudents(skills, k, index):\n    closest = []\n    for i in range(len(skills)):\n        if i != index:\n            closest.append(i)\n    closest.sort(key=lambda x: abs(x - index))\n    return closest[:k]\n\n# Function to get the indices of the students that are closest to the student with the second highest programming skill\ndef secondClosestStudents(skills, k, index):\n    closest = []\n    for i in range(len(skills)):\n        if i != index:\n            closest.append(i)\n    closest.sort(key=lambda x: abs(x - index))\n    return closest[:k]\n\n# Function to remove the student with the maximum programming skill\ndef removeMaxSkill(skills):\n    skills.remove(maxSkill(skills))\n\n# Function to remove the student with the second highest programming skill\ndef removeSecondMaxSkill(skills):\n    skills.remove(secondMaxSkill(skills))\n\n# Function to remove the indices of the students that are closest to the student with the maximum programming skill\ndef removeClosestStudents(skills, index):\n    closest = closestStudents(skills, k, index)\n    for i in range(len(closest)):\n        skills.remove(skills[closest[i]])\n\n# Function to remove the indices of the students that are closest to the student with the second highest programming skill\ndef removeSecondClosestStudents(skills, index):\n    closest = secondClosestStudents(skills, k, index)\n    for i in range(len(closest)):\n        skills.remove(skills[closest[i]])\n\n# Function to determine which students will be taken into the first team\ndef firstTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(1)\n    while len(skills) > 0:\n        index = maxSkillIndex(skills)\n        removeMaxSkill(skills)\n        removeClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 2\n    return team\n\n# Function to determine which students will be taken into the second team\ndef secondTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(2)\n    while len(skills) > 0:\n        index = secondMaxSkillIndex(skills)\n        removeSecondMaxSkill(skills)\n        removeSecondClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 1\n    return team\n\n# Function to determine which students will be taken into the first team\ndef firstTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(1)\n    while len(skills) > 0:\n        index = maxSkillIndex(skills)\n        removeMaxSkill(skills)\n        removeClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 2\n    return team\n\n# Function to determine which students will be taken into the second team\ndef secondTeam(skills, k):\n    team = []\n    for i in range(len(skills)):\n        team.append(2)\n    while len(skills) > 0:\n        index = secondMaxSkillIndex(skills)\n        removeSecondMaxSkill(skills)\n        removeSecondClosestStudents(skills, index)\n        for i in range(len(skills)):\n            team[i] = 1\n    return team\n\n# Main function\ndef main():\n    # Get the number of students and the value determining the range of chosen students during each move\n    n, k = map(int, input().split())\n\n    # Get the programming skill of each student\n    skills = list(map(int, input().split()))\n\n    # Determine which students will be taken into the first team\n    team = firstTeam(skills, k)\n\n    # Print the team\n    print(''.join(map(str, team)))\n\n# Run program\nmain()"
}
2022-04-13 18:45:59.048172 REASON stop
2022-04-13 18:45:59.049529 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# SOLUTION\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nans = [0] * n\n\ncur = 0\n\nfor i in range(n):\n    l = max(0, cur - k)\n    r = min(cur + k, n - 1)\n\n    if i % 2 == 0:\n        ans[a.index(cur + 1)] = 1\n        cur = a[l:r + 1].index(cur + 1) + l\n    else:\n        ans[a.index(cur + 1)] = 2\n        cur = a[l:r + 1].index(cur + 1) + l\n\nprint(''.join(map(str, ans)))"
}
2022-04-13 18:45:59.049609 REASON stop
