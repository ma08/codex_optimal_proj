["\n\n#Python3\n#Importing math library for floor division\nimport math\n\n#Number of test cases\nt = int(input())\n\nfor i in range(t):\n    \n    #Getting the input\n    n,k = map(int,input().split())\n    \n    #Initializing the string\n    s = ''\n    \n    #Using the formula (n-2) * (n-1) / 2 to find the number of strings with (n-2) a's and 2 b's\n    #Floor division is used\n    n_2_a_2_b = math.floor((n-2)*(n-1)/2)\n\n    #If k is less than or equal to n_2_a_2_b, it means that the string starts with 'a'\n    if k <= n_2_a_2_b:\n        s = 'a'*(n-2)\n        #The number of strings with (n-2) a's and 2 b's is n_2_a_2_b\n        #We have to find the number of strings with (n-3) a's and 2 b's, which is (n-3)*(n-2)/2\n        #This is the index of the string in the list of strings with (n-2) a's and 2 b's\n        idx = math.floor((k*2)/(n-1))\n        #If k is odd, the string ends with 'b'\n        if k%2 != 0:\n            s = s + 'b' + 'a'*idx + 'b'\n        #If k is even, the string ends with 'a'\n        else:\n            s = s + 'a' + 'b'*idx + 'a'\n    #If k is greater than n_2_a_2_b, it means that the string starts with 'b'\n    else:\n        s = 'b'*(n-2)\n        #The number of strings with (n-2) a's and 2 b's is n_2_a_2_b\n        #We have to find the number of strings with (n-3) b's and 2 a's, which is (n-3)*(n-2)/2\n        #This is the index of the string in the list of strings with (n-2) b's and 2 a's\n        idx = math.floor(((k-n_2_a_2_b)*2)/(n-1))\n        #If k is odd, the string ends with 'a'\n        if k%2 != 0:\n            s = s + 'a' + 'b'*idx + 'a'\n        #If k is even, the string ends with 'b'\n        else:\n            s = s + 'b' + 'a'*idx + 'b'\n            \n    #Printing the string\n    print(s)", "\n\n#import sys\n#sys.stdin = open(\"input.txt\",\"rt\")\n\n#import sys\n#sys.stdout = open(\"output.txt\",\"wt\")\n\ndef n_strings(n):\n    return n*(n-1)/2\n\ndef get_pos(n,k):\n    if k==0:\n        return 'b'\n    elif k==1:\n        return 'a'\n    else:\n        k-=2\n        pos = 1\n        while k>=n_strings(pos+1):\n            k-=n_strings(pos+1)\n            pos+=1\n        return get_pos(pos,k)\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        n,k = map(int,input().split())\n        print(get_pos(n,k-1))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    num_cases = int(sys.stdin.readline().strip())\n    for i in range(num_cases):\n        n, k = map(int, sys.stdin.readline().strip().split(' '))\n        print(kth_string(n, k))\n\ndef kth_string(n, k):\n    \"\"\"\n    Returns the kth string in lexicographical order\n    \"\"\"\n    # The number of strings with a given number of b's\n    num_strings = lambda b: b * (n - b)\n    # The number of strings with at least b b's\n    num_strings_least = lambda b: sum(num_strings(i) for i in range(b, n + 1))\n    # The number of strings with at most b b's\n    num_strings_most = lambda b: sum(num_strings(i) for i in range(1, b + 1))\n    # The number of strings with exactly b b's\n    num_strings_exact = lambda b: num_strings_most(b) - num_strings_most(b - 1)\n\n    # Find the number of b's in the kth string\n    b = 1\n    while num_strings_least(b) < k:\n        b += 1\n\n    # Find the index of the kth string in the list of strings with b b's\n    k -= num_strings_least(b) - num_strings_exact(b)\n\n    # Find the index of the kth string in the list of all strings\n    index = 0\n    for i in range(b):\n        index += k // (n - b - i)\n        if k % (n - b - i) == 0:\n            break\n        k -= k // (n - b - i)\n\n    # Construct the string\n    string = ['a'] * n\n    string[index] = 'b'\n    string[index + 1] = 'b'\n    return ''.join(string)\n\nif __name__ == '__main__':\n    main()", "\n\n# Solution\n\n# Python3 program to find k'th lexicographical string \n# of all n-digit strings with k-bits set \n\n# Function to return k'th string with k-bits set \ndef kthLexicographicString(n, k): \n\t\n\t# To store current string \n\tcurr = [0 for i in range(n)] \n\n\t# To store number of set bits in current string \n\tcountOnes = 0\n\n\t# To store number of strings whose number of \n\t# set bits is less than countOnes \n\tcount = [0 for i in range(n + 1)] \n\n\t# To store total number of strings of length n \n\ttotal = pow(2, n) \n\n\t# If k > n(n - 1)/2, then kth string cannot be \n\t# generated. \n\tif (k > n * (n - 1) / 2): \n\t\treturn \"\" \n\n\t# Find count of strings with set bits less than n \n\tcount[0] = 1\n\tfor i in range(1, n + 1): \n\t\tcount[i] = count[i - 1] * 2\n\n\t# Find total number of strings with set bits less \n\t# than or equal to n \n\tfor i in range(1, n + 1): \n\t\tcount[i] = count[i - 1] + count[i] \n\n\t# Subtract total number of strings with set bits \n\t# less than countOnes from k \n\tk = k - 1\n\n\t# Find the string \n\tfor i in range(n - 1, -1, -1): \n\t\t\n\t\t# Find total number of strings with set bits \n\t\t# less than or equal to countOnes \n\t\ttotal = count[countOnes] \n\n\t\t# Find total number of strings with set bits \n\t\t# less than countOnes \n\t\ttotal = total - count[countOnes - 1] \n\n\t\t# Update k \n\t\tif (k >= total): \n\t\t\tk = k - total \n\t\t\tcurr[i] = 1\n\t\t\tcountOnes = countOnes + 1\n\n\t# print string \n\tfor i in range(n): \n\t\tif (curr[i] == 1): \n\t\t\tprint(\"a\", end = \"\") \n\t\telse: \n\t\t\tprint(\"b\", end = \"\") \n\n# Driver code \nn = 5\nk = 10\nkthLexicographicString(n, k) \n\n# This code is contributed by mits", "\n\nimport math\n\ndef solve(n, k):\n    \"\"\"\n    >>> solve(5, 1)\n    'aaabb'\n    >>> solve(5, 2)\n    'aabab'\n    >>> solve(5, 8)\n    'baaba'\n    >>> solve(5, 10)\n    'bbaaa'\n    >>> solve(3, 1)\n    'abb'\n    >>> solve(3, 2)\n    'bab'\n    >>> solve(20, 100)\n    'aaaaabaaaaabaaaaaaaa'\n    \"\"\"\n    if n == 3:\n        if k == 1:\n            return 'abb'\n        else:\n            return 'bab'\n    if k == 1:\n        return 'a' * (n-2) + 'bb'\n    if k == n * (n-1) // 2:\n        return 'b' * (n-2) + 'aa'\n    row = math.ceil(math.sqrt(2 * k))\n    if row == 1:\n        return 'a' * (n-2) + 'bb'\n    if row == n:\n        return 'b' * (n-2) + 'aa'\n    if k <= row * (row - 1) // 2:\n        val = k - (row - 1) * (row - 2) // 2\n        return 'a' * (n - row) + 'b' * (row - val) + 'a' * (val - 1) + 'b'\n    else:\n        val = k - row * (row - 1) // 2\n        return 'a' * (n - val) + 'b' * (val - 1) + 'a'\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        print(solve(n, k))", "\n\n\ndef solve(n, k):\n    if k <= n - 2:\n        return 'a' * (n - 2) + 'b' * 2\n    k -= n - 2\n    if k <= n - 1:\n        return 'a' * (n - 1 - k) + 'b' + 'a' * k + 'b'\n    k -= n - 1\n    return 'a' * (k // 2) + 'b' * (3 - k % 2) + 'a' * (n - 2 - k // 2)\n\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        n, k = map(int, input().split())\n        print(solve(n, k))\n\n\nif __name__ == \"__main__\":\n    main()"]