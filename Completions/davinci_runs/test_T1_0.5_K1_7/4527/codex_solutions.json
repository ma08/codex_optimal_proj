["\n\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        yield segments\n\ndef solve(segments):\n    segments = sorted(segments)\n    result = [segments[0]]\n    for l, r in segments[1:]:\n        if l <= result[-1][1]:\n            result[-1] = (result[-1][0], max(result[-1][1], r))\n        else:\n            result.append((l, r))\n    return len(result)\n\nif __name__ == '__main__':\n    for segments in get_input():\n        print(solve(segments))", "\n\n#-----Solution-----\n\n#from sys import stdin\n#from collections import namedtuple\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    segments = []\n    for _ in range(N):\n        segments.append(list(map(int, input().split())))\n    segments.sort(key=lambda x: x[0])\n    dp = [1]*N\n    for i in range(1,N):\n        for j in range(i):\n            if segments[i][0]>=segments[j][1]:\n                dp[i] = max(dp[i], dp[j]+1)\n    print(max(dp))", "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        segments.sort(key=lambda x: x[1])\n        curr_right = segments[0][1]\n        ans = 1\n        for l, r in segments[1:]:\n            if l > curr_right:\n                ans += 1\n                curr_right = r\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n#Solution:\n\nimport sys\n\ndef solve(n, segments):\n    segments.sort(key=lambda x: x[1])\n    last = segments[0][1]\n    count = 1\n    for i in range(1, n):\n        if segments[i][0] > last:\n            count += 1\n            last = segments[i][1]\n    return count\n\nif __name__ == '__main__':\n    t = int(sys.stdin.readline())\n    for i in range(t):\n        n = int(sys.stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = map(int, sys.stdin.readline().split())\n            segments.append([l, r])\n        print(solve(n, segments))", "\n\ndef max_subset(segments):\n    # sort segments by left border\n    segments.sort(key=lambda s: s[0])\n    # add right border of the first segment to right_borders\n    right_borders = [segments[0][1]]\n    for segment in segments[1:]:\n        # if the segment lies inside one of the segments in right_borders,\n        # then continue\n        if segment[1] <= right_borders[-1]:\n            continue\n        # if the segment is non-intersecting with all segments in right_borders,\n        # then add it to right_borders\n        if segment[0] > right_borders[-1]:\n            right_borders.append(segment[1])\n        # if the segment is intersecting with at least one segment in right_borders,\n        # then replace the right border of the last segment in right_borders\n        # with the right border of the segment\n        else:\n            right_borders[-1] = segment[1]\n    return len(right_borders)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        print(max_subset(segments))\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef segment_intersection(segments):\n    segments.sort(key=lambda x: x[1])\n    result = []\n    current = segments[0]\n    for segment in segments[1:]:\n        if segment[0] > current[1]:\n            result.append(current)\n            current = segment\n    result.append(current)\n    return result\n\n\ndef solve(segments):\n    return len(segment_intersection(segments))\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        print(solve(segments))", "\n\n# SOLUTION\n\n# We will use a greedy approach, sorting the segments and then taking the maximum segment that doesn't intersect with the previous one.\n\n# We sort the segments by their left coordinate and then we iterate through them.\n# We will keep a variable curr_max that will be the maximum segment that we have chosen so far.\n# We will keep a variable ans that will be our final answer.\n\n# If the current segment doesn't intersect with curr_max, we update curr_max to be the current segment.\n# Otherwise, we will only update curr_max if the current segment is bigger than curr_max.\n# In either case, we will update our answer by adding 1.\n\n# See the code below for a more formal implementation.\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n    segments = sorted(segments, key=lambda x: x[0])\n    ans = 0\n    curr_max = segments[0]\n    for l, r in segments:\n        if l > curr_max[1]:\n            curr_max = (l, r)\n        else:\n            curr_max = max(curr_max, (l, r), key=lambda x: x[1])\n        ans += 1\n    print(ans)"]