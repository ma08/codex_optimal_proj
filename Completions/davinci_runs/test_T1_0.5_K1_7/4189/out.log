2022-04-13 19:07:46.386709 """
Not to be confused with chessboard.

 [Image] 


-----Input-----

The first line of input contains a single integer N (1 ≤ N ≤ 100) — the number of cheeses you have.

The next N lines describe the cheeses you have. Each line contains two space-separated strings: the name of the cheese and its type. The name is a string of lowercase English letters between 1 and 10 characters long. The type is either "soft" or "hard. All cheese names are distinct.


-----Output-----

Output a single number.


-----Examples-----
Input
9
brie soft
camembert soft
feta soft
goat soft
muenster soft
asiago hard
cheddar hard
gouda hard
swiss hard

Output
3

Input
6
parmesan hard
emmental hard
edam hard
colby hard
gruyere hard
asiago hard

Output
4
"""
2022-04-13 19:07:46.386718 --------------------------
2022-04-13 19:08:12.184484 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# SOLUTION\nn = int(input())\n\nsoft = []\nhard = []\n\nfor i in range(n):\n    cheese, type = input().split()\n    if type == 'soft':\n        soft.append(cheese)\n    else:\n        hard.append(cheese)\n\nprint(min(len(soft), len(hard)))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n#-----main-----\nn = int(input())\n\ncheeses = {}\n\nfor i in range(n):\n    cheese = input().split()\n    cheeses[cheese[0]] = cheese[1]\n\nnum_of_hard = 0\nnum_of_soft = 0\n\nfor cheese in cheeses:\n    if cheeses[cheese] == 'hard':\n        num_of_hard += 1\n    else:\n        num_of_soft += 1\n\nif num_of_hard > num_of_soft:\n    print(num_of_soft)\nelse:\n    print(num_of_hard)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(input())\n    cheeses = []\n    for i in range(n):\n        cheeses.append(input().split())\n    soft = 0\n    hard = 0\n    for c in cheeses:\n        if c[1] == \"soft\":\n            soft += 1\n        else:\n            hard += 1\n    print(min(soft, hard))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef classify(cheeses):\n    soft = []\n    hard = []\n    for cheese in cheeses:\n        if cheese[1] == \"soft\":\n            soft.append(cheese[0])\n        else:\n            hard.append(cheese[0])\n    return (soft, hard)\n\ndef main():\n    numCheeses = int(input())\n    cheeses = []\n    for i in range(numCheeses):\n        cheeses.append(input().split())\n    cheeses = classify(cheeses)\n    print(len(cheeses[0])+len(cheeses[1])-1)\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\n#-----Function-----\n\n#-----Main-----\n\n#-----Input-----\n\n#-----Output-----\n\n#-----Examples-----"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n\"\"\"\n-----Solution-----\n\nWe can think of this problem as a bipartite graph. Each vertex is either a cheese type or a cheese name. There is an edge between a cheese type and a cheese name if the name is of the type.\n\nWe can use a simple bipartite matching algorithm to solve this.\n\"\"\"\n\nimport sys\n\ndef get_cheeses():\n    n = int(sys.stdin.readline().strip())\n    cheeses = dict()\n    for _ in range(n):\n        name, type = sys.stdin.readline().strip().split()\n        if type in cheeses:\n            cheeses[type].append(name)\n        else:\n            cheeses[type] = [name]\n    return cheeses\n\ndef bipartite_matching(cheeses):\n    # convert to adjacency list\n    adj_list = dict()\n    for type in cheeses:\n        adj_list[type] = cheeses[type]\n        for cheese in cheeses[type]:\n            adj_list[cheese] = [type]\n    \n    # perform matching\n    matches = dict()\n    for type in cheeses:\n        matches[type] = []\n\n    for cheese in cheeses['soft']:\n        if cheese not in matches:\n            matches[cheese] = 'soft'\n            matches['soft'].append(cheese)\n            break\n\n    for cheese in cheeses['hard']:\n        if cheese not in matches:\n            matches[cheese] = 'hard'\n            matches['hard'].append(cheese)\n            break\n\n    return matches\n\ndef main():\n    cheeses = get_cheeses()\n    matches = bipartite_matching(cheeses)\n    print(len(matches['soft']) + len(matches['hard']))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    cheese = {}\n    for _ in range(n):\n        name, kind = input().split()\n        if kind not in cheese:\n            cheese[kind] = []\n        cheese[kind].append(name)\n    print(len(cheese))\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649876866,
  "id": "cmpl-4wcd8ECFLRjWLmgMVt3NJhLJM3Iwy",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 19:08:12.184784 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# SOLUTION\nn = int(input())\n\nsoft = []\nhard = []\n\nfor i in range(n):\n    cheese, type = input().split()\n    if type == 'soft':\n        soft.append(cheese)\n    else:\n        hard.append(cheese)\n\nprint(min(len(soft), len(hard)))"
}
2022-04-13 19:08:12.184819 REASON stop
2022-04-13 19:08:12.185324 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n#-----main-----\nn = int(input())\n\ncheeses = {}\n\nfor i in range(n):\n    cheese = input().split()\n    cheeses[cheese[0]] = cheese[1]\n\nnum_of_hard = 0\nnum_of_soft = 0\n\nfor cheese in cheeses:\n    if cheeses[cheese] == 'hard':\n        num_of_hard += 1\n    else:\n        num_of_soft += 1\n\nif num_of_hard > num_of_soft:\n    print(num_of_soft)\nelse:\n    print(num_of_hard)"
}
2022-04-13 19:08:12.185498 REASON stop
2022-04-13 19:08:12.185901 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(input())\n    cheeses = []\n    for i in range(n):\n        cheeses.append(input().split())\n    soft = 0\n    hard = 0\n    for c in cheeses:\n        if c[1] == \"soft\":\n            soft += 1\n        else:\n            hard += 1\n    print(min(soft, hard))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:08:12.185951 REASON stop
2022-04-13 19:08:12.202784 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef classify(cheeses):\n    soft = []\n    hard = []\n    for cheese in cheeses:\n        if cheese[1] == \"soft\":\n            soft.append(cheese[0])\n        else:\n            hard.append(cheese[0])\n    return (soft, hard)\n\ndef main():\n    numCheeses = int(input())\n    cheeses = []\n    for i in range(numCheeses):\n        cheeses.append(input().split())\n    cheeses = classify(cheeses)\n    print(len(cheeses[0])+len(cheeses[1])-1)\n\nmain()"
}
2022-04-13 19:08:12.202880 REASON stop
2022-04-13 19:08:12.212222 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\n#-----Function-----\n\n#-----Main-----\n\n#-----Input-----\n\n#-----Output-----\n\n#-----Examples-----"
}
2022-04-13 19:08:12.212316 REASON stop
2022-04-13 19:08:12.213407 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n\"\"\"\n-----Solution-----\n\nWe can think of this problem as a bipartite graph. Each vertex is either a cheese type or a cheese name. There is an edge between a cheese type and a cheese name if the name is of the type.\n\nWe can use a simple bipartite matching algorithm to solve this.\n\"\"\"\n\nimport sys\n\ndef get_cheeses():\n    n = int(sys.stdin.readline().strip())\n    cheeses = dict()\n    for _ in range(n):\n        name, type = sys.stdin.readline().strip().split()\n        if type in cheeses:\n            cheeses[type].append(name)\n        else:\n            cheeses[type] = [name]\n    return cheeses\n\ndef bipartite_matching(cheeses):\n    # convert to adjacency list\n    adj_list = dict()\n    for type in cheeses:\n        adj_list[type] = cheeses[type]\n        for cheese in cheeses[type]:\n            adj_list[cheese] = [type]\n    \n    # perform matching\n    matches = dict()\n    for type in cheeses:\n        matches[type] = []\n\n    for cheese in cheeses['soft']:\n        if cheese not in matches:\n            matches[cheese] = 'soft'\n            matches['soft'].append(cheese)\n            break\n\n    for cheese in cheeses['hard']:\n        if cheese not in matches:\n            matches[cheese] = 'hard'\n            matches['hard'].append(cheese)\n            break\n\n    return matches\n\ndef main():\n    cheeses = get_cheeses()\n    matches = bipartite_matching(cheeses)\n    print(len(matches['soft']) + len(matches['hard']))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:08:12.213517 REASON stop
2022-04-13 19:08:12.214162 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    cheese = {}\n    for _ in range(n):\n        name, kind = input().split()\n        if kind not in cheese:\n            cheese[kind] = []\n        cheese[kind].append(name)\n    print(len(cheese))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 19:08:12.214236 REASON stop
