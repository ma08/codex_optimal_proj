["\n\ndef subsequence(s, t):\n    if len(t) == 0:\n        return True\n    if len(s) == 0:\n        return False\n    if s[0] == t[0]:\n        return subsequence(s[1:], t[1:])\n    else:\n        return subsequence(s[1:], t)\n\ndef solve(s, t):\n    for i in range(len(s)):\n        if subsequence(s[:i] + s[i+1:], t):\n            return len(s) - len(t)\n    return 0\n\nprint(solve(input(), input()))", "\n\ns = input()\nt = input()\n\n# brute force solution\n# def is_subseq(s, t):\n#     \"\"\"\n#     s: str\n#     t: str\n#     \"\"\"\n#     if len(t) == 0:\n#         return True\n#     if len(s) == 0:\n#         return False\n#     if t[0] == s[0]:\n#         return is_subseq(s[1:], t[1:])\n#     return is_subseq(s[1:], t)\n\n# def solve(s, t):\n#     \"\"\"\n#     s: str\n#     t: str\n#     \"\"\"\n#     max_len = 0\n#     for i in range(len(s)):\n#         for j in range(i, len(s)):\n#             if is_subseq(s[:i] + s[j+1:], t):\n#                 max_len = max(max_len, j-i+1)\n#     return max_len\n\n# O(n^2) solution\n# def solve(s, t):\n#     \"\"\"\n#     s: str\n#     t: str\n#     \"\"\"\n#     max_len = 0\n#     for i in range(len(s)):\n#         for j in range(i, len(s)):\n#             if not is_subseq(s[:i] + s[j+1:], t):\n#                 break\n#             max_len = max(max_len, j-i+1)\n#     return max_len\n\n# O(n^2) solution\ndef solve(s, t):\n    \"\"\"\n    s: str\n    t: str\n    \"\"\"\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if not is_subseq(s[i:j+1], t):\n                break\n            max_len = max(max_len, j-i+1)\n    return max_len\n\nprint(solve(s, t))", "\n\ndef solve(s, t):\n    \"\"\"\n    >>> solve('bbaba', 'bb')\n    3\n    >>> solve('baaba', 'ab')\n    2\n    >>> solve('abcde', 'abcde')\n    0\n    >>> solve('asdfasdf', 'fasd')\n    3\n    \"\"\"\n    t_len = len(t)\n    s_len = len(s)\n    dp = [[0] * (s_len + 1) for _ in range(t_len + 1)]\n    for i in range(1, t_len + 1):\n        for j in range(1, s_len + 1):\n            if t[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    return s_len - dp[-1][-1]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    print(solve(input(), input()))", "\n\nimport sys\n\ndef get_suffix_array(s):\n    \"\"\"\n    Returns the suffix array of the string text and\n    its suffix array function\n    \"\"\"\n    suffixes = []\n    for i in range(len(s)):\n        suffixes.append((s[i:], i))\n    suffixes.sort()\n    return [suf[1] for suf in suffixes]\n\ndef get_lcp_array(s, suffix_array):\n    \"\"\"\n    Longest common prefixes between adjacent sorted suffixes.\n    \"\"\"\n    lcp = [0] * len(s)\n    inv_suff = [0] * len(s)\n    for i in range(len(s)):\n        inv_suff[suffix_array[i]] = i\n    k = 0\n    for i in range(len(s)):\n        if inv_suff[i] == len(s) - 1:\n            k = 0\n            continue\n        j = suffix_array[inv_suff[i] + 1]\n        while i + k < len(s) and j + k < len(s) and s[i + k] == s[j + k]:\n            k += 1\n        lcp[inv_suff[i]] = k\n        if k > 0:\n            k -= 1\n    return lcp\n\ndef get_substring(lcp_array, suffix_array, s, t):\n    \"\"\"\n    Get the substring of s that will give t after removal.\n    \"\"\"\n    s_index = suffix_array.index(0)\n    t_index = 0\n    lcp_index = 0\n    lcp_max = 0\n    while s_index < len(s) and t_index < len(t):\n        if s[s_index] == t[t_index]:\n            if lcp_array[lcp_index] > lcp_max:\n                lcp_max = lcp_array[lcp_index]\n            t_index += 1\n        s_index += 1\n        lcp_index += 1\n    return lcp_max\n\ndef main():\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    suffix_array = get_suffix_array(s)\n    lcp_array = get_lcp_array(s, suffix_array)\n    print(get_substring(lcp_array, suffix_array, s, t))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef subsequence(s, t):\n    if len(t) == 0:\n        return 0\n    if len(s) < len(t):\n        return -1\n    if s[0] != t[0]:\n        return subsequence(s[1:], t)\n    return max(subsequence(s[1:], t), 1 + subsequence(s[1:], t[1:]))\n\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\nprint(len(s) - subsequence(s, t))", "\n\ns = input()\nt = input()\n\ndef solve(s, t):\n    n = len(s)\n    m = len(t)\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return len(s) - dp[n][m]\n\nprint(solve(s, t))", "\n\ns = input()\nt = input()\n\n# We will use dynamic programming to solve this problem.\n# Let's define dp[i][j] as the maximum length of the substring we can remove from s[:i] so that t[:j] is still a subsequence of s[:i].\n# Then dp[i][0] = i, dp[0][j] = 0 for all j.\n# dp[i][j] = dp[i - 1][j] if s[i - 1] != t[j - 1]\n# dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) otherwise.\n\ndp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\nfor i in range(len(s) + 1):\n    dp[i][0] = i\nfor i in range(1, len(s) + 1):\n    for j in range(1, len(t) + 1):\n        if s[i - 1] != t[j - 1]:\n            dp[i][j] = dp[i - 1][j]\n        else:\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1])\nprint(dp[len(s)][len(t)])"]