["n = int(input())\na = list(map(int, input().split()))\na.sort()\n\ninc = list()\ndec = list()\nfor x in a:\n    if inc and inc[-1] == x:\n        if dec and dec[-1] == x:\n            print('NO')\n            return\n        dec.append(x)\n    else:\n        inc.append(x)\n\nprint('YES')\nprint(len(inc))\nfor x in inc:\n    print(x, end=' ')\nprint()\nprint(len(dec))\nfor x in reversed(dec):\n    print(x, end=' ')\nprint()", "def solve():\n    N = int(input())\n    \n    A = [int(k) for k in input().split()]\n    A.sort()\n    \n    B = [A[0]]\n    C = []\n    \n    cnt = 1\n    \n    for i in range(1,N):\n        if A[i] == A[i-1]:\n            cnt += 1\n            if cnt > 2:\n                print (\"NO\")\n                return\n        else:\n            cnt = 1\n            \n        if B[-1] != A[i]:\n            B.append(A[i])\n        else:\n            C.append(A[i])\n            \n    print (\"YES\")\n    print (len(B))\n    print (' '.join(str(k) for k in B))\n    print (len(C))\n    print (' '.join(str(k) for k in reversed(C)))\n        \ndef __starting_point():\n    solve()\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\ninc = set([])\ndec = set([])\nfor i in a:\n    if i not in inc:\n        inc.add(i)\n    elif i not in dec:\n        dec.add(i)\n    else:\n        print(\"NO\")\n        return\ninc = list(inc)\ndec = list(dec)\ninc.sort(reverse = True)\ndec.sort()\nprint(\"YES\")\nprint(len(dec))\nprint(*dec)\nprint(len(inc))\nprint(*inc)", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\nsys.setrecursionlimit(1000000)\n#sys.stdin = open(\"input.txt\", \"r\")\n\nn = int(input())\na = list(map(int, input().split()))\ninc = set()\ndec = set()\n\nfor ai in a:\n    if ai not in inc:\n        inc.add(ai)\n    elif ai not in dec:\n        dec.add(ai)\n    else:\n        print(\"NO\")\n        return\n\ninc = sorted(inc)\ndec = sorted(dec, reverse=True)\nprint(\"YES\")\nprint(len(inc))\nprint(*inc)\nprint(len(dec))\nprint(*dec)\n", "n = int(input())\nA = list(map(int, input().split()))\n\nB = set()\nC = set()\nyes = True\n\nfor i in A:\n    if i not in B:\n        B.add(i)\n    elif i not in C:\n        C.add(i)\n    else:\n        print('NO')\n        yes = False\n        break\n\nif yes:\n    print('YES')\n\n    print(len(B))\n    print(*sorted(list(B)))\n\n    print(len(C))\n    print(*sorted(list(C), reverse=True))\n", "import sys\n\nn=int(input())\nA=list(map(int,input().split()))\nA.sort()\n\nANS0=[A[0]]\nANS1=[]\nfor i in range(1,n):\n    if A[i]==ANS0[-1]:\n        ANS1.append(A[i])\n\n    else:\n        ANS0.append(A[i])\n\nfor i in range(1,len(ANS1)):\n    if ANS1[i]==ANS1[i-1]:\n        print(\"NO\")\n        return\n\nprint(\"YES\")\nprint(len(ANS0))\nprint(*ANS0)\nprint(len(ANS1))\nprint(*ANS1[::-1])\n    \n", "from collections import defaultdict\nn = int(input())\na = list(map(int,input().split()))\nl1 = []\nl2 = []\nda = defaultdict(int)\ndb = defaultdict(int)\nwork = True\nfor i in a:\n    if da[i]==0:\n        l1.append(i)\n        da[i] = 1\n    elif db[i]==0:\n        l2.append(i)\n        db[i] = 1\n    else:\n        work = False\n\nif work:\n    print(\"YES\")\n    print(len(l1))\n    print(*sorted(l1))\n    print(len(l2))\n    l2 = sorted(l2)\n    l2 = l2[::-1]\n    print(*l2)\nelse:\n    print(\"NO\")", "import sys\n\nn = int(input())\na = [int(x) for x in input().split()]\nd = {}\nfor x in a:\n    c = d.get(x, 0) + 1\n    if c == 3:\n        print('NO')\n        return\n    d[x] = c\n\nr1 = []\nr2 = []\nfor key, value in d.items():\n    r1.append(key)\n    if value > 1: r2.append(key)\n\nr1.sort()\nr2.sort(reverse=True)\n\nprint('YES')\nprint(len(r1))\nfor x in r1:\n    print(x, end=' ')\nprint()\nprint(len(r2))\nfor x in r2:\n    print(x, end=' ')\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\n\ndef main():\n    n = get_int()\n    li = get_list()\n    li.sort()\n    prev = -2\n    a,b = [],[]\n    for i in li:\n        if i!=prev:\n            a.append(i)\n        else:\n            b.append(i)\n        prev = i\n    if len(set(b))!=len(b):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(len(a))\n    display_list(a)\n    print(len(b))\n    b.reverse()\n    display_list(b)\n    \n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "N = int(input())\nA = sorted([int(a) for a in input().split()])\n\npre = -1\nc = 0\nI = []\nD = []\nfor i in range(N):\n    if A[i] == pre:\n        c += 1\n        if c > 2:\n            print(\"NO\")\n            break\n        D.append(A[i])\n    else:\n        I.append(A[i])\n        pre = A[i]\n        c = 1\nelse:\n    print(\"YES\")\n    print(len(I))\n    print(*I)\n    print(len(D))\n    print(*sorted(D)[::-1])\n", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nimport random\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN(x = \" \"):\n    return(map(int,sys.stdin.readline().strip().split(x)))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\ndef dis(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\n\n\n\nn = int(input())\nl = list(numIN())\nd = defaultdict(int)\n\nfor i in l:\n    d[i]+=1\n    if d[i]>2:\n        print('NO')\n        return\n\nl.sort()\nans1 = []\nans2 = []\nfor i in l:\n    if d[i]==2:\n        ans1.append(i)\n        ans2.append(i)\n        d[i] = 0\n    elif d[i]==1:\n        ans1.append(i)\n        d[i] = 0\nans1.sort()\nans2.sort(reverse=True)\n\nprint('YES')\nprint(len(ans1))\nprint(*ans1)\nprint(len(ans2))\nprint(*ans2)", "import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\n\na = sorted(map(int, input().split()))\n\nup = [a[0]]\na[0] = -1\n\nfor i in range(len(a)):\n    if a[i] != -1 and a[i] > up[-1]:\n        up.append(a[i])\n        a[i] = -1\n    \ndown = sorted([x for x in a if x != -1], reverse = True)\n\nvalid = True\nfor i in range(1, len(down)):\n    if down[i] == down[i-1]:\n        valid = False\n        break\n\nif valid:\n    print('YES')\n    print(len(up))\n    print(' '.join([str(x) for x in up]))\n    print(len(down))\n    print(' '.join([str(x) for x in down]))\nelse:\n    print('NO')\n", "'''input\n5\n0 1 2 3 \n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nn=ri(1)\n\na=ri()\n\na.sort()\n\nk=dd(int)\n\nfor i in a:\n\tk[i]+=1\n\nf=1\nfor i in k:\n\tif k[i]>2:\n\t\tf=0\n\none=[]\ntwo=[]\n\nfor i in k:\n\tif k[i]==1:\n\t\tone.append(i)\n\n\telif k[i]==2:\n\t\tone.append(i)\n\t\ttwo.append(i)\n\nif f:\n\tprint(\"YES\")\n\tprint(len(one))\n\tone.sort()\n\tprint(*one)\n\tprint(len(two))\n\ttwo.sort(reverse=True)\n\tprint(*two)\nelse:\n\tprint(\"NO\")", "from collections import Counter\n\nn = int(input())\narr = list(map(int, input().split()))\narr.sort()\n\nC = Counter(arr)\nflag = 0\n\nfor keys in C:\n    if C[keys]>=3:\n        flag = 1\n        print(\"NO\")\n        break\n\nif flag==0:\n    print(\"YES\")\n    es = []\n    ds = []\n    for keys in C:\n        if C[keys]==2:\n            es.append(keys)\n            ds.append(keys)\n        else:\n            es.append(keys)\n\n    es.sort()\n    ds.sort()\n    ds = ds[::-1]\n\n    print(len(es))\n    print(*es)\n    print(len(ds))\n    print(*ds)\n", "# -*- coding: utf-8 -*-\n\n\ndef __starting_point():\n    _ = int(input())\n\n    array = sorted(list(map(int, input().split())))\n    inc = []\n    dec = []\n    for elem in array:\n        if elem in inc[-1:] and elem in dec[-1:]:\n            inc = None\n            dec = None\n            break;\n\n        if elem in inc[-1:]:\n            dec.append(elem)\n        else:\n            inc.append(elem)\n\n    if inc is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(inc))\n        print(\" \".join(str(e) for e in inc))\n        print(len(dec))\n        print(\" \".join(str(e) for e in dec[::-1]))\n\n__starting_point()", "n = int(input())\n\none = set()\ntwo = set()\nban = 0\nfor i in input().split():\n    i = int(i)\n    if i not in one:\n        one.add(i)\n    else:\n        if i not in two:\n            two.add(i)\n        else:\n            ban = 1\n            break\n\nif ban:\n    print('NO')\nelse:\n    print('YES')\n    one = list(one)\n    print(len(one))\n    one.sort()\n    for i in one:\n        print(i, end=' ')\n    print()\n\n    two = list(two)\n    print(len(two))\n    two.sort(reverse=True)\n    for i in two:\n        print(i, end=' ')\n    print()", "from collections import Counter\nn = int(input())\nl = list(map(int,input().split()))\n\nd = Counter(l)\n\nif max(d.values()) > 2:\n    print(\"NO\")\nelse:\n    inc = []\n    dec = []\n\n    for i in d:\n        if d[i] == 2:\n            inc.append(i)\n            dec.append(i)\n        else:\n            inc.append(i)\n\n\n    n1 = len(inc)\n    n2 = len(dec)\n    print(\"YES\")\n    if n1:\n        print(n1)\n        inc.sort()\n        print(*inc)\n    else:\n        print(n1)\n        print()\n\n    if n2:\n        print(n2)\n        dec.sort(reverse = True)\n        print(*dec)\n    else:\n        print(n2)\n        print()\n", "n=int(input())\nl=[int(i) for i in input().split()]\nl.sort()\nfrom collections import Counter \nc=Counter(l)\nif any(c[i]>2 for i in c):\n    print('NO')\n    return\nseq1=[]\nseq2=[]\nfor i in sorted(set(l)):\n    if c[i]==1:\n        seq1.append(i)\n    else:\n        seq1.append(i)\n        seq2.append(i)\nprint('YES')\nprint(len(seq1))\nprint(*seq1)\nprint(len(seq2))\nseq2=seq2[::-1]\nprint(*seq2)\n", "import math\ndef na():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\treturn n,b\n\n\ndef nab():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tc = [int(x) for x in input().split()]\n\treturn n,b,c\n\n\ndef dv():\n\tn, m = list(map(int, input().split()))\n\treturn n,m\n\n\ndef dva():\n\tn, m = list(map(int, input().split()))\n\tb = [int(x) for x in input().split()]\n\treturn n,m,b\n\n\ndef nm():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tm = int(input())\n\tc = [int(x) for x in input().split()]\n\treturn n,b,m,c\n\n\ndef dvs():\n\tn = int(input())\n\tm = int(input())\n\treturn n, m\n\n\nn,a = na()\nd = {}\nfor i in a:\n\td[i] = d.get(i, 0) + 1\nls = list(d.keys())\nfor i in ls:\n\tif d[i] > 2:\n\t\tprint('NO')\n\t\treturn\na1 = []\na2 = []\na = sorted(a)\nfor i in range(0, n - 1, 2):\n\tif len(a1) != 0:\n\t\tlst1 = a1[len(a1) - 1]\n\telse:\n\t\tlst1 = -1\n\tif len(a2) != 0:\n\t\tlst2 = a2[len(a2) - 1]\n\telse:\n\t\tlst2 = -1\n\tif a[i] != lst1:\n\t\tif a[i] != a[i + 1]:\n\t\t\ta1.append(a[i])\n\t\t\ta1.append(a[i + 1])\n\t\telse:\n\t\t\ta1.append(a[i])\n\t\t\ta2.append(a[i + 1])\n\telse:\n\t\ta1.append(a[i + 1])\n\t\ta2.append(a[i])\nif n % 2 == 1:\n\tif a[n - 1] not in set(a1):\n\t\ta1.append(a[n-1])\n\telse:\n\t\ta2.append(a[n - 1])\na2 = a2[::-1]\nprint('YES')\nprint(len(a1))\nif len(a1) == 0:\n\tprint()\nelse:\n\tprint(*a1)\nprint(len(a2))\nif len(a2) == 0:\n\tprint()\nelse:\n\tprint(*a2)\n\n", "n = int(input())\na = list(map(int,input().split()))\nf = [0 for i in range(200010)]\ninc = []\ndec = []\nfor i in a:\n    if f[i]==0:\n        inc.append(i)\n        f[i]+=1\n    elif f[i]==1:\n        dec.append(i)\n        f[i]+=1\n    elif f[i]>1:\n        print(\"NO\")\n        return\nprint(\"YES\")\nprint(len(inc))\nprint(*(sorted(inc)))\nprint(len(dec))\nprint(*(sorted(dec,reverse=True)))"]