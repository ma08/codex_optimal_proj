["\n\n# This solution is based on the idea of the following link:\n# https://qiita.com/drken/items/a5e6fe22863b7992efdb\n\nimport sys\nsys.setrecursionlimit(1000000)\n\nN, M = map(int, input().split())\n\n# Graph\n# g[i] = [j, k, ...]\n# i: vertex\n# j, k, ...: adjacent vertices\ng = [[] for i in range(N)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\n# Visited\n# v[i] = 1\n# i: vertex\nv = [0] * N\n\n# Bridges\n# b[i] = 1\n# i: vertex\nb = [0] * M\n\n# DFS\ndef dfs(current, parent):\n    # Mark current vertex as visited\n    v[current] = 1\n    for next in g[current]:\n        if next == parent:\n            continue\n        if v[next] == 0:\n            dfs(next, current)\n        if b[next] == 0:\n            b[current] = 1\n\ndfs(0, -1)\n\nprint(b.count(1))", "\n\nfrom sys import stdin\nfrom collections import deque\n\ndef dfs(v, p, t, g):\n    t[v] = 1\n    for e in g[v]:\n        if t[e] == 0:\n            if dfs(e, v, t, g):\n                return True\n        elif e != p:\n            return True\n    return False\n\ndef main():\n    n,m = map(int, stdin.readline().split())\n    g = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a,b = map(int, stdin.readline().split())\n        g[a].append(b)\n        g[b].append(a)\n    t = [0]*(n+1)\n    c = 0\n    for i in range(1,n+1):\n        if t[i] == 0:\n            if dfs(i, -1, t, g):\n                c += 1\n    print(c)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport copy\n\ndef dfs(v,edges,visited,pre,low,bridge,timer):\n    visited[v] = True\n    pre[v] = timer\n    low[v] = timer\n    timer += 1\n    for to in edges[v]:\n        if not visited[to]:\n            dfs(to,edges,visited,pre,low,bridge,timer)\n            low[v] = min(low[v],low[to])\n            if pre[v] < low[to]:\n                bridge.append([v,to])\n        else:\n            low[v] = min(low[v],low[to])\n\ndef find_bridge(edges):\n    visited = [False]*(N+1)\n    pre = [0]*(N+1)\n    low = [0]*(N+1)\n    timer = 1\n    bridge = []\n    dfs(1,edges,visited,pre,low,bridge,timer)\n    return bridge\n\ndef main():\n    global N\n    N,M = map(int,sys.stdin.readline().split())\n    edges = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a,b = map(int,sys.stdin.readline().split())\n        edges[a].append(b)\n        edges[b].append(a)\n    bridge = find_bridge(edges)\n    print(len(bridge))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nn, m = map(int, input().split())\n\n# \u96a3\u63a5\u30ea\u30b9\u30c8\nadj_list = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    adj_list[a-1].append(b-1)\n    adj_list[b-1].append(a-1)\n\n# \u65e2\u306b\u8a2a\u554f\u6e08\u307f\u304b\u3069\u3046\u304b\nvisited = [False]*n\n# \u6839\u3068\u306e\u9593\u306b\u6a4b\u304c\u3042\u308b\u304b\u3069\u3046\u304b\nis_bridge = [False]*m\n\ndef dfs(v, p, depth):\n    visited[v] = True\n    for u in adj_list[v]:\n        if u == p:\n            continue\n        if not visited[u]:\n            dfs(u, v, depth+1)\n        else:\n            if depth == 0:\n                is_bridge[v] = True\n\ndfs(0, -1, 0)\n\nprint(sum(is_bridge))", "\n\nimport sys\n\ndef find_root(parent, i):\n    if parent[i] == i:\n        return i\n    return find_root(parent, parent[i])\n\ndef unite(parent, rank, i, j):\n    i_root = find_root(parent, i)\n    j_root = find_root(parent, j)\n    if rank[i_root] < rank[j_root]:\n        parent[i_root] = j_root\n    else:\n        parent[j_root] = i_root\n        if rank[i_root] == rank[j_root]:\n            rank[i_root] += 1\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(N+1)]\n    rank = [0 for i in range(N+1)]\n    for i in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        unite(parent, rank, a, b)\n    res = 0\n    for i in range(1, N+1):\n        if parent[i] == i:\n            res += 1\n    print(M - res)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nsys.setrecursionlimit(10**8)\n\nN, M = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n# \u96a3\u63a5\u30ea\u30b9\u30c8\nadjacent_list = [[] for _ in range(N)]\nfor a, b in edges:\n    adjacent_list[a-1].append(b-1)\n    adjacent_list[b-1].append(a-1)\n\n# \u63a2\u7d22\u6e08\u307f\u304b\u3069\u3046\u304b\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nvisited = [False] * N\n\n# DFS\ndef dfs(s):\n    # \u63a2\u7d22\u6e08\u307f\u306b\u3059\u308b\n    visited[s] = True\n    for u in adjacent_list[s]:\n        if not visited[u]:\n            dfs(u)\n\n# \u6728\u306e\u76f4\u5f84\u3092\u6c42\u3081\u308b\n# \u518d\u5e30\u3092\u4f7f\u3046\u3068\u30b9\u30bf\u30c3\u30af\u304c\u6ea2\u308c\u308b\u306e\u3067\u3001while\u3092\u4f7f\u3046\ndef diameter(s):\n    # \u63a2\u7d22\u6e08\u307f\u306b\u3059\u308b\n    visited[s] = True\n    # \u76f4\u5f84\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    dia = []\n    # \u76f4\u5f84\u3092\u6c42\u3081\u308b\u305f\u3081\u306b\u3001\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u9806\u756a\u306b\u63a2\u7d22\u3059\u308b\n    for u in adjacent_list[s]:\n        # \u672a\u63a2\u7d22\u306e\u5834\u5408\n        if not visited[u]:\n            # \u518d\u5e30\u7684\u306b\u76f4\u5f84\u3092\u6c42\u3081\u308b\n            dia.append(diameter(u))\n        # \u63a2\u7d22\u6e08\u307f\u306e\u5834\u5408\u306f\u7121\u8996\n    # \u76f4\u5f84\u3092\u6c42\u3081\u308b\n    # \u96a3\u63a5\u30ea\u30b9\u30c8\u304c\u7a7a\u306e\u5834\u5408\u306f\u76f4\u5f84\u306f0\n    if len(dia) == 0:\n        return 0\n    # \u96a3\u63a5\u30ea\u30b9\u30c8\u304c1\u3064\u306e\u5834\u5408\u306f\u76f4\u5f84\u306f1\n    elif len(dia) == 1:\n        return dia[0] + 1\n    # \u96a3\u63a5\u30ea\u30b9\u30c8\u304c2\u3064\u4ee5\u4e0a\u306e\u5834\u5408\u306f\u30012\u756a\u76ee\u306b\u9577\u3044\u76f4\u5f84\u30681\u756a\u76ee\u306b\u9577\u3044\u76f4\u5f84\u3092\u8db3\u3057\u305f\u3082\u306e\n    else:\n        dia.sort()\n        return dia[-1] + dia[-2] + 1\n\n# \u521d\u671f\u5316\nvisited = [False] * N\n# \u6700\u521d\u306e\u30ce\u30fc\u30c9\u304b\u3089DFS\u3067\u63a2\u7d22\u3059\u308b\ndfs(0)\n# \u63a2\u7d22\u6e08\u307f\u304b\u3069\u3046\u304b\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nvisited = [False] * N\n# \u6700\u521d\u306e\u30ce\u30fc\u30c9\u304b\u3089\u76f4\u5f84\u3092\u6c42\u3081\u308b\ndia = diameter(0)\n# \u76f4\u5f84\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\ndias = []\n\n# \u4ed6\u306e\u30ce\u30fc\u30c9\u304b\u3089\u76f4\u5f84\u3092\u6c42\u3081\u308b\nfor i in range(N):\n    # \u672a\u63a2\u7d22\u306e\u5834\u5408\n    if not visited[i]:\n        # \u63a2\u7d22\u6e08\u307f\u304b\u3069\u3046\u304b\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n        visited = [False] * N\n        # \u76f4\u5f84\u3092\u6c42\u3081\u308b\n        dia = diameter(i)\n        # \u76f4\u5f84\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\n        dias.append(dia)\n\n# \u76f4\u5f84\u304c2\u4ee5\u4e0a\u306e\u5834\u5408\u306f\u6a4b\u3067\u306f\u306a\u3044\nans = 0\nfor d in dias:\n    if d < 2:\n        ans += 1\nprint(ans)", "\n\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef main():\n    n, m = map(int, input().split())\n    edges = [tuple(map(lambda x: int(x)-1, input().split())) for _ in range(m)]\n    uf = UnionFind(n)\n    ans = 0\n    for i in range(m):\n        if uf.same(edges[i][0], edges[i][1]):\n            ans += 1\n        else:\n            uf.unite(edges[i][0], edges[i][1])\n    print(ans)\n\nif __name__ == '__main__':\n    main()"]