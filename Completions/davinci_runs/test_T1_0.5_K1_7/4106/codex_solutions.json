["", "\n\nimport sys\n\ndef get_input():\n    line = sys.stdin.readline()\n    return line.strip()\n\ndef get_list_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    n, k, x = get_list_input()\n    a = get_list_input()\n    # print(n, k, x, a)\n\n    if x < k:\n        print(-1)\n        return\n\n    # DP\n    # dp[i][j] = max sum of the first i items with j items selected\n    dp = [[0 for _ in range(x+1)] for _ in range(n+1)]\n\n    # dp[i][j] = max(dp[i-1][j], dp[i-k][j-1] + sum(a[i-k:i]))\n    for i in range(1, n+1):\n        for j in range(1, x+1):\n            if j > i:\n                break\n            dp[i][j] = max(dp[i-1][j], dp[i-k][j-1] + sum(a[i-k:i]))\n\n    print(dp[n][x])\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, k, x = map(int, sys.stdin.readline().split())\n    a = map(int, sys.stdin.readline().split())\n    if x < k:\n        print -1\n        return\n    if x == n:\n        print sum(a)\n        return\n    if k == 1:\n        print -1\n        return\n    if x == k:\n        print max(a[:k])\n        return\n    if x == k + 1:\n        print max(a[:k]) + max(a[k:])\n        return\n    if x > n - k + 1:\n        print -1\n        return\n    if x == n - k + 1:\n        print sum(a[:k]) + max(a[k:])\n        return\n    if x < n - k + 1:\n        print sum(a[:k]) + max(a[k:-k+1]) + max(a[-k+1:])\n        return\n    print -1\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(n, k, x, a):\n    if x < k:\n        return -1\n    if x == k:\n        return sum(a[:k])\n    if n == k:\n        return sum(a)\n    if n == x:\n        return sum(a)\n\n    # DP\n    dp = [[0 for _ in range(x+1)] for _ in range(n+1)]\n    for j in range(1, x+1):\n        dp[0][j] = -1\n    for i in range(1, n+1):\n        for j in range(1, x+1):\n            if j < k:\n                dp[i][j] = -1\n            elif i < k:\n                dp[i][j] = max(dp[i-1][j], a[i-1])\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-k] + a[i-1])\n\n    return dp[n][x]\n\n\nif __name__ == '__main__':\n    n, k, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, x, a))", "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif x < k:\n    print(-1)\nelse:\n    dp = [[0 for _ in range(n+1)] for _ in range(x+1)]\n    for i in range(1, x+1):\n        for j in range(k, n+1):\n            dp[i][j] = max(dp[i][j-1], dp[i-1][j-k] + sum(a[j-k:j]))\n    print(dp[x][n])", "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif x < k:\n    print(-1)\n    exit()\n\n# Dynamic Programming\n# dp[i] = max sum of beauty values of pictures from 1 to i\ndp = [0] * (n + 1)\n\n# dp[i] = max(dp[i-1], dp[i-k] + sum(a[i-k+1:i+1]))\nfor i in range(1, n + 1):\n    if i < k:\n        dp[i] = sum(a[:i])\n    else:\n        dp[i] = max(dp[i - 1], dp[i - k] + sum(a[i - k:i]))\n\nif dp[n] < x:\n    print(-1)\nelse:\n    print(dp[n])\n\n# # Brute Force\n# # We can try all the possible combinations of reposted pictures\n# def solve(n, k, x, a):\n#     # max sum of beauty values of pictures from 1 to i\n#     dp = [0] * (n + 1)\n#     # dp[i] = max(dp[i-1], dp[i-k] + sum(a[i-k+1:i+1]))\n#     for i in range(1, n + 1):\n#         if i < k:\n#             dp[i] = sum(a[:i])\n#         else:\n#             dp[i] = max(dp[i - 1], dp[i - k] + sum(a[i - k:i]))\n#     if dp[n] < x:\n#         return -1\n#     else:\n#         return dp[n]\n#\n#\n# def solve2(n, k, x, a):\n#     # try all possible combinations of reposted pictures\n#     # start from the first picture\n#     # each picture can be reposted or not\n#     # if the picture is not reposted, then the next picture must be reposted\n#     # otherwise, the next picture can be reposted or not\n#     # the last picture must be reposted\n#     res = -1\n#     for i in range(1 << n):\n#         if bin(i).count('1') != x:\n#             continue\n#         # i is the combination of reposted pictures\n#         # i >> j & 1 is the j-th bit of i\n#         # if i >> j & 1 == 1, then the j-th picture is reposted\n#         # if i >> j & 1 == 0, then the j-th picture is not reposted\n#         # check if the j-th picture is reposted\n#         if (i >> 0 & 1) == 0 or (i >> (n - 1) & 1) == 0:\n#             continue\n#         for j in range(1, n - 1):\n#             # if the j-th picture is not reposted, the (j+1)-th picture must be reposted\n#             if (i >> j & 1) == 0 and (i >> (j + 1) & 1) == 0:\n#                 break\n#         else:\n#             # check if all the constraints are satisfied\n#             for j in range(n):\n#                 # the j-th picture is reposted\n#                 if i >> j & 1 == 1:\n#                     # check if the segment of at least k consecutive pictures contains this picture\n#                     if j < k - 1 or any(i >> (j - k + 1 + t) & 1 == 1 for t in range(k - 1)):\n#                         continue\n#                     else:\n#                         break\n#             else:\n#                 # all constraints are satisfied\n#                 res = max(res, sum(a[j] for j in range(n) if i >> j & 1 == 1))\n#     return res\n#\n#\n# print(solve(n, k, x, a))\n# print(solve2(n, k, x, a))"]