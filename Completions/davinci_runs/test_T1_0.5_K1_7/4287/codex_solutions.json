["\n\n# Solution:\n\nimport sys\nimport math\n\ndef main():\n    a, n, m = map(int, sys.stdin.readline().split())\n    rain = []\n    for _ in range(n):\n        rain.append(list(map(int, sys.stdin.readline().split())))\n    umb = []\n    for _ in range(m):\n        umb.append(list(map(int, sys.stdin.readline().split())))\n    dp = [[math.inf] * (a + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n    for i in range(m):\n        for j in range(a):\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])\n            if is_in_rain(j, rain):\n                dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + umb[i][1])\n            else:\n                dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j])\n    if dp[m][a] == math.inf:\n        print(-1)\n    else:\n        print(dp[m][a])\n\ndef is_in_rain(x, rain):\n    for i in range(len(rain)):\n        if x >= rain[i][0] and x < rain[i][1]:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    main()", "\n\na,n,m = map(int,input().split())\n\nrain = []\nfor _ in range(n):\n    rain.append(list(map(int,input().split())))\n\numbrellas = []\nfor _ in range(m):\n    umbrellas.append(list(map(int,input().split())))\n\n# print(rain)\n# print(umbrellas)\n\ndef check(rain, umbrellas):\n    # print(rain, umbrellas)\n    if len(rain) == 0:\n        return 0\n    # print(rain[0][0], rain[0][1])\n    u = [x for x in umbrellas if x[0] >= rain[0][0] and x[0] < rain[0][1]]\n    # print(u)\n    if len(u) == 0:\n        return -1\n    else:\n        return min([check(rain[1:], umbrellas[umbrellas.index(x)+1:]) for x in u]) + sum([x[1] for x in u])\n\nprint(check(rain, umbrellas))", "\n\n\nfrom collections import defaultdict\nfrom heapq import *\n\ndef dijkstra(s, n, graph):\n    d = [float('inf')] * n\n    d[s] = 0\n    q = []\n    heappush(q, (0, s))\n    while q:\n        u = heappop(q)\n        for v in graph[u[1]]:\n            if d[v[0]] > d[u[1]] + v[1]:\n                d[v[0]] = d[u[1]] + v[1]\n                heappush(q, (d[v[0]], v[0]))\n    return d\n\ndef main():\n    a, n, m = map(int, input().split())\n    rain = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        rain.append((l, r))\n    rain.sort()\n    umbrellas = []\n    for i in range(m):\n        x, p = map(int, input().split())\n        umbrellas.append((x, p))\n    umbrellas.sort()\n    graph = defaultdict(list)\n    for i in range(m):\n        graph[i].append((m, umbrellas[i][1]))\n        graph[m].append((i, umbrellas[i][1]))\n    for i in range(m):\n        for j in range(i + 1, m):\n            if umbrellas[j][0] - umbrellas[i][0] > 1:\n                break\n            graph[i].append((j, umbrellas[j][1]))\n            graph[j].append((i, umbrellas[j][1]))\n    d = dijkstra(m, m + 1, graph)\n    if d[0] == float('inf'):\n        print(-1)\n        return\n    for i in range(n):\n        l, r = rain[i]\n        if umbrellas[0][0] >= l and umbrellas[0][0] <= r:\n            continue\n        if umbrellas[-1][0] >= l and umbrellas[-1][0] <= r:\n            continue\n        for j in range(m):\n            if umbrellas[j][0] >= l and umbrellas[j][0] <= r:\n                break\n        for k in range(m - 1, -1, -1):\n            if umbrellas[k][0] >= l and umbrellas[k][0] <= r:\n                break\n        graph = defaultdict(list)\n        for p in range(m + 1):\n            graph[p].append((m + 1, 0))\n            graph[m + 1].append((p, 0))\n        for p in range(j, k + 1):\n            graph[p].append((m + 1, umbrellas[p][1]))\n            graph[m + 1].append((p, umbrellas[p][1]))\n        for p in range(j):\n            graph[p].append((m + 1, d[p] - umbrellas[p][1]))\n            graph[m + 1].append((p, d[p] - umbrellas[p][1]))\n        for p in range(k + 1, m):\n            graph[p].append((m + 1, d[p] - umbrellas[p][1]))\n            graph[m + 1].append((p, d[p] - umbrellas[p][1]))\n        d = dijkstra(m + 1, m + 2, graph)\n        if d[0] == float('inf'):\n            print(-1)\n            return\n    print(d[0])\n\nif __name__ == '__main__':\n    main()", "\n\n##############################\n\ndef min_fatigue(a, n, m, rain, umbrellas):\n    \"\"\"\n    Given a, n, m, rain, umbrellas, find the minimum fatigue Polycarp can have when\n    he makes the journey from 0 to a, taking into account the rain and umbrellas.\n    If Polycarp cannot make the journey, return -1.\n\n    Input:\n        a: int, the destination point\n        n: int, number of segments in rain\n        m: int, number of umbrellas\n        rain: list of 2-tuples (l_i, r_i) representing the segments in rain\n        umbrellas: list of 2-tuples (x_i, p_i) representing the umbrellas on the line\n\n    Output:\n        int, the minimum fatigue Polycarp can have after making the journey\n    \"\"\"\n    # Base case: no rain or no umbrellas\n    if n == 0:\n        return 0\n    if m == 0:\n        return -1\n\n    # Create a list of umbrellas that Polycarp can take\n    # (i.e. umbrellas that are not in the rain)\n    takeable_umbrellas = []\n    for umbrella in umbrellas:\n        umbrella_location = umbrella[0]\n        umbrella_weight = umbrella[1]\n\n        # If the umbrella is in the rain, skip it\n        if umbrella_location in range(rain[0][0], rain[0][1]):\n            continue\n\n        # Otherwise, add the umbrella to the list of takeable umbrellas\n        takeable_umbrellas.append(umbrella)\n\n    # If there are no takeable umbrellas, Polycarp cannot make the journey\n    if len(takeable_umbrellas) == 0:\n        return -1\n\n    # Otherwise, Polycarp can make the journey\n    # Find the minimum fatigue\n    min_fatigue = float(\"inf\")\n    for umbrella in takeable_umbrellas:\n        umbrella_location = umbrella[0]\n        umbrella_weight = umbrella[1]\n\n        # If Polycarp takes the umbrella, he must take it to the end\n        # of the rain segment\n        # Find the end of the rain segment\n        rain_end = -1\n        for segment in rain:\n            if umbrella_location in range(segment[0], segment[1]):\n                rain_end = segment[1]\n                break\n\n        # Find the minimum fatigue if Polycarp takes the umbrella\n        # to the end of the rain segment\n        fatigue = (rain_end - umbrella_location) * umbrella_weight\n        fatigue += min_fatigue(a, n - 1, m, rain[1:], umbrellas)\n\n        # If the minimum fatigue is better, update the minimum fatigue\n        if fatigue < min_fatigue:\n            min_fatigue = fatigue\n\n    return min_fatigue\n\n##############################\n\na, n, m = [int(x) for x in input().split()]\n\nrain = []\nfor i in range(n):\n    rain.append([int(x) for x in input().split()])\n\numbrellas = []\nfor i in range(m):\n    umbrellas.append([int(x) for x in input().split()])\n\nprint(min_fatigue(a, n, m, rain, umbrellas))", "\n\n\ndef main():\n\ta, n, m = map(int, input().split())\n\train = []\n\tfor i in range(n):\n\t\train.append(list(map(int, input().split())))\n\tumbrellas = []\n\tfor i in range(m):\n\t\tumbrellas.append(list(map(int, input().split())))\n\n\t# create a list of umbrellas that can be used in the rain\n\tumbrellas_in_rain = []\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif rain[i][0] <= umbrellas[j][0] <= rain[i][1]:\n\t\t\t\tumbrellas_in_rain.append(umbrellas[j])\n\n\t# create a list of umbrellas that can be used in the rain and that have a weight of 1\n\tumbrellas_in_rain_weight_1 = []\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif rain[i][0] <= umbrellas[j][0] <= rain[i][1] and umbrellas[j][1] == 1:\n\t\t\t\tumbrellas_in_rain_weight_1.append(umbrellas[j])\n\n\t# find the number of umbrellas with a weight of 1 that can be used in the rain\n\tnumber_of_umbrellas_weight_1 = len(umbrellas_in_rain_weight_1)\n\n\t# if there is no umbrella with a weight of 1 that can be used in the rain, then print -1\n\tif number_of_umbrellas_weight_1 == 0:\n\t\tprint(-1)\n\t\treturn\n\n\t# if there is only 1 umbrella with a weight of 1 that can be used in the rain, then print the distance to the umbrella multiplied by the weight of the umbrella\n\tif number_of_umbrellas_weight_1 == 1:\n\t\tprint(umbrellas_in_rain_weight_1[0][0] * umbrellas_in_rain_weight_1[0][1])\n\t\treturn\n\n\t# if there is more than 1 umbrella with a weight of 1 that can be used in the rain, then find the distance to each umbrella with a weight of 1\n\t# and find the sum of the distances\n\tif number_of_umbrellas_weight_1 > 1:\n\t\tdistances = []\n\t\tfor i in range(number_of_umbrellas_weight_1):\n\t\t\tdistances.append(umbrellas_in_rain_weight_1[i][0])\n\t\tprint(sum(distances))\n\t\treturn\n\n\nif __name__ == \"__main__\":\n\tmain()", "\n\n#------------------------------------------------------------------------------#\n\ndef polycarp_and_umbrellas():\n    \"\"\"\n    Solve the problem.\n    \"\"\"\n    # read input\n    a, n, m = [int(x) for x in input().split()]\n    rains = []\n    for _ in range(n):\n        rains.append([int(x) for x in input().split()])\n    rains.sort()\n    umbrellas = []\n    for _ in range(m):\n        umbrellas.append([int(x) for x in input().split()])\n    umbrellas.sort()\n    \n    # initialize\n    dp = [[float('inf') for _ in range(a+1)] for _ in range(m+1)]\n    dp[0][0] = 0\n    \n    # update dp table\n    for i in range(m):\n        x, p = umbrellas[i]\n        for j in range(a+1):\n            if j < x:\n                dp[i+1][j] = dp[i][j]\n            else:\n                dp[i+1][j] = min(dp[i][j], dp[i][j-x] + p)\n    \n    # check if Polycarp can make it\n    for rain in rains:\n        l, r = rain\n        if min(dp[-1][l:r]) == float('inf'):\n            return -1\n    \n    # compute answer\n    ans = 0\n    i = 0\n    for j in range(a+1):\n        while i < len(rains) and rains[i][1] <= j:\n            i += 1\n        if i > 0:\n            l = rains[i-1][0]\n        else:\n            l = 0\n        ans += min(dp[-1][l:j])\n    \n    return ans\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    print(polycarp_and_umbrellas())\n\n#------------------------------------------------------------------------------#\n\nif __name__ == \"__main__\":\n    main()"]