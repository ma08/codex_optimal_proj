["\n\nimport sys\n\ndef get_input():\n    n = int(input())\n    colors = [int(x) for x in input().split()]\n    edges = []\n    for i in range(n-1):\n        edges.append([int(x) for x in input().split()])\n    return n, colors, edges\n\ndef main():\n    n, colors, edges = get_input()\n    print(n, colors, edges)\n\nif __name__ == '__main__':\n    main()", "\n\nn = int(input())\n\ncolors = list(map(int, input().split()))\n\ntree = [ [] for _ in range(n) ]\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    tree[a - 1].append(b - 1)\n    tree[b - 1].append(a - 1)\n\nred = colors.count(1)\nblue = colors.count(2)\n\ndef dfs(v, p, c):\n    global colors, tree, red, blue\n    if colors[v] == c:\n        red -= 1\n        blue -= 1\n    for u in tree[v]:\n        if u == p:\n            continue\n        dfs(u, v, c)\n\ndef check_edge(v, p):\n    global colors, tree, red, blue\n    r = red\n    b = blue\n    dfs(v, p, 1)\n    r -= red\n    red = b\n    blue = b\n    dfs(v, p, 2)\n    b -= blue\n    return (r == 0 or b == 0)\n\nans = 0\n\nfor v in range(n):\n    for u in tree[v]:\n        if check_edge(u, v):\n            ans += 1\n\nprint(ans)", "\n\ndef main():\n    n = int(input())\n    colors = map(int, input().split())\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n\n    def dfs(node, parent):\n        if colors[node - 1] == 0:\n            return False, False\n        elif colors[node - 1] == 1:\n            red = True\n        else:\n            blue = True\n        for child in tree[node]:\n            if child != parent:\n                child_red, child_blue = dfs(child, node)\n                red = red or child_red\n                blue = blue or child_blue\n        return red, blue\n\n    ans = 0\n    for node in range(1, n + 1):\n        for child in tree[node]:\n            red, blue = dfs(node, child)\n            red2, blue2 = dfs(child, node)\n            if (red and not blue2) or (red2 and not blue):\n                ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    # read number of vertices\n    n = int(input())\n    # read color of vertices\n    a = list(map(int, input().split()))\n    # read edges\n    edges = []\n    for _ in range(n-1):\n        edges.append(tuple(map(int, input().split())))\n    # print(n, a, edges)\n    # build adjacency list\n    adj = [[] for _ in range(n+1)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    # print(adj)\n    # count nice edges\n    nice_edges = 0\n    for edge in edges:\n        # check if the edge is nice\n        # color of the vertex on the left side\n        color_l = a[edge[0]-1]\n        # color of the vertex on the right side\n        color_r = a[edge[1]-1]\n        # colors of vertices on the left side\n        colors_l = [color_l]\n        # colors of vertices on the right side\n        colors_r = [color_r]\n        # check colors of vertices on the left side\n        if color_l == 0:\n            colors_l = check_colors(adj, edge[0], colors_l)\n        # check colors of vertices on the right side\n        if color_r == 0:\n            colors_r = check_colors(adj, edge[1], colors_r)\n        # print(edge, colors_l, colors_r)\n        # check if the edge is nice\n        if (1 not in colors_l and 2 not in colors_r) or (1 not in colors_r and 2 not in colors_l):\n            nice_edges += 1\n    # print result\n    print(nice_edges)\n\n# check colors of vertices\ndef check_colors(adj, v, colors):\n    for u in adj[v]:\n        if a[u-1] != 0:\n            colors.append(a[u-1])\n        else:\n            colors = check_colors(adj, u, colors)\n    return colors\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\n#sys.stdin = open(\"in1.txt\")\n\ninput = sys.stdin.readline\n\nn = int(input())\nc = list(map(int, input().split()))\n\ng = defaultdict(list)\nfor i in range(n-1):\n    v, u = map(int, input().split())\n    g[v].append(u)\n    g[u].append(v)\n\n\ndef dfs(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs(u, v)\n    if c[v] == 1:\n        return 1 + cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return 0\n\n\ndef dfs2(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs2(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return 1 + cnt\n    else:\n        return 0\n\n\ndef dfs3(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs3(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return 1 + cnt\n\n\ndef dfs4(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs4(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return cnt\n\n\ndef dfs5(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs5(u, v)\n    if c[v] == 1:\n        return 1 + cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return cnt\n\n\ndef dfs6(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs6(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return 1 + cnt\n    else:\n        return cnt\n\n\nans = 0\nfor v in range(1, n+1):\n    for u in g[v]:\n        if dfs(v, u) == 0 or dfs2(u, v) == 0:\n            ans += 1\n        elif dfs3(v, u) == 0 or dfs4(u, v) == 0:\n            ans += 1\n        elif dfs5(v, u) == 0 or dfs6(u, v) == 0:\n            ans += 1\nprint(ans)", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    colors = list(map(int, input().split()))\n    edges = []\n    for i in range(n-1):\n        edges.append(list(map(int, input().split())))\n    print(edges)\n    print(colors)\n\nif __name__ == '__main__':\n    sys.exit(main())", "\n\ndef find_parent(parent, a):\n    if parent[a] != a:\n        parent[a] = find_parent(parent, parent[a])\n    return parent[a]\n\ndef union(parent, a, b):\n    a = find_parent(parent, a)\n    b = find_parent(parent, b)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\ndef solution(n, a, edges):\n    parent = [0] * (n + 1)\n    for i in range(1, n + 1):\n        parent[i] = i\n    for v, u in edges:\n        union(parent, v, u)\n    count = [0] * (n + 1)\n    for i in range(1, n + 1):\n        count[find_parent(parent, i)] += 1\n    red = [0] * (n + 1)\n    blue = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if a[i - 1] == 1:\n            red[find_parent(parent, i)] += 1\n        elif a[i - 1] == 2:\n            blue[find_parent(parent, i)] += 1\n    ans = 0\n    for i in range(1, n + 1):\n        if red[i] == 0 or blue[i] == 0:\n            ans += count[i] - 1\n    return ans\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    edges = []\n    for i in range(n - 1):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n    print(solution(n, a, edges))"]