2022-04-13 20:04:34.429504 """
Takahashi wants to be a member of some web service.
He tried to register himself with the ID S, which turned out to be already used by another user.
Thus, he decides to register using a string obtained by appending one character at the end of S as his ID.
He is now trying to register with the ID T. Determine whether this string satisfies the property above.

-----Constraints-----
 - S and T are strings consisting of lowercase English letters.
 - 1 \leq |S| \leq 10
 - |T| = |S| + 1

-----Input-----
Input is given from Standard Input in the following format:
S
T

-----Output-----
If T satisfies the property in Problem Statement, print Yes; otherwise, print No.

-----Sample Input-----
chokudai
chokudaiz

-----Sample Output-----
Yes

chokudaiz can be obtained by appending z at the end of chokudai.
"""
2022-04-13 20:04:34.429511 --------------------------
2022-04-13 20:04:49.053707 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nS = input()\nT = input()\n\nif T[:-1] == S:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ns = input()\nt = input()\n\nif s == t[:-1]:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    s = input()\n    t = input()\n    if s == t[:-1]:\n        print('Yes')\n    else:\n        print('No')\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ns = input()\nt = input()\n\nif len(s) + 1 == len(t):\n    if t[:len(s)] == s:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ns = input()\nt = input()\n\nif s == t[:-1]:\n    print('Yes')\nelse:\n    print('No')"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef is_subsequence(sub, full):\n    \"\"\"\n    :param sub: subsequence\n    :param full: full string\n    :return: True if sub is a subsequence of full\n    \"\"\"\n    full_index = 0\n    for sub_index in range(len(sub)):\n        while sub[sub_index] != full[full_index]:\n            full_index += 1\n        full_index += 1\n    return True\n\ndef is_subsequence_recursive(sub, full):\n    if len(sub) == 0:\n        return True\n    elif len(full) == 0:\n        return False\n    elif sub[0] == full[0]:\n        return is_subsequence_recursive(sub[1:], full[1:])\n    else:\n        return is_subsequence_recursive(sub, full[1:])\n\ndef main():\n    sub = input()\n    full = input()\n    if is_subsequence_recursive(sub, full):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ns = input()\nt = input()\n\nprint('Yes' if s == t[:-1] else 'No')"
    }
  ],
  "created": 1649880274,
  "id": "cmpl-4wdW6QCzuIbDj8ZJoqvtf3GsG984X",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:04:49.053978 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nS = input()\nT = input()\n\nif T[:-1] == S:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
}
2022-04-13 20:04:49.054008 REASON stop
2022-04-13 20:04:49.054445 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ns = input()\nt = input()\n\nif s == t[:-1]:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
}
2022-04-13 20:04:49.054555 REASON stop
2022-04-13 20:04:49.054909 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    s = input()\n    t = input()\n    if s == t[:-1]:\n        print('Yes')\n    else:\n        print('No')\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 20:04:49.054952 REASON stop
2022-04-13 20:04:49.066837 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ns = input()\nt = input()\n\nif len(s) + 1 == len(t):\n    if t[:len(s)] == s:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"
}
2022-04-13 20:04:49.066923 REASON stop
2022-04-13 20:04:49.067615 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ns = input()\nt = input()\n\nif s == t[:-1]:\n    print('Yes')\nelse:\n    print('No')"
}
2022-04-13 20:04:49.067686 REASON stop
2022-04-13 20:04:49.089176 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef is_subsequence(sub, full):\n    \"\"\"\n    :param sub: subsequence\n    :param full: full string\n    :return: True if sub is a subsequence of full\n    \"\"\"\n    full_index = 0\n    for sub_index in range(len(sub)):\n        while sub[sub_index] != full[full_index]:\n            full_index += 1\n        full_index += 1\n    return True\n\ndef is_subsequence_recursive(sub, full):\n    if len(sub) == 0:\n        return True\n    elif len(full) == 0:\n        return False\n    elif sub[0] == full[0]:\n        return is_subsequence_recursive(sub[1:], full[1:])\n    else:\n        return is_subsequence_recursive(sub, full[1:])\n\ndef main():\n    sub = input()\n    full = input()\n    if is_subsequence_recursive(sub, full):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nmain()"
}
2022-04-13 20:04:49.089268 REASON stop
2022-04-13 20:04:49.089981 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ns = input()\nt = input()\n\nprint('Yes' if s == t[:-1] else 'No')"
}
2022-04-13 20:04:49.090052 REASON stop
