["n,m=list(map(int,input().split()))\nM=[[] for i in range(n)]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    a-=1;b-=1\n    M[a].append(b)\n    M[b].append(a)\nyes=\"POSSIBLE\";no=\"IMPOSSIBLE\"\n\nfor i in M[0]:\n    if n-1 in M[i]:\n        print(yes);return\nprint(no)\n\n", "import sys\n\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\nx = set()\ny = set()\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    if a == 1:\n        x.add(b)\n    if b == n:\n        y.add(a)\nprint(((\"POSSIBLE\", \"IMPOSSIBLE\")[len(x & y) == 0]))\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \tC\n# CreatedDate:  2020-09-13 15:43:14 +0900\n# LastModified: 2020-09-13 15:49:14 +0900\n#\n\n\nimport os\nimport sys\n# import numpy as np\n# import pandas as pd\nfrom collections import deque\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    path = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = list(map(int, input().split()))\n        path[a].append(b)\n        path[b].append(a)\n    Q = deque(path[1])\n    flag = False\n    while Q and flag is False:\n        u = Q.popleft()\n        for v in path[u]:\n            if v == N:\n                flag = True\n    if flag:\n        print(\"POSSIBLE\")\n    else:\n        print(\"IMPOSSIBLE\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python\nfrom collections import deque\n\n# input\nn, m = list(map(int, input().split()))\na = [0 for _ in range(m)]\nb = [0 for _ in range(m)]\nfor i in range(m):\n    a[i], b[i] = list(map(int, input().split()))\n\nif m == 1:\n    print('IMPOSSIBLE')\n    return\n\nto = [[] for _ in range(n+1)]\nfor i in range(m):\n    to[a[i]].append(b[i])\n    to[b[i]].append(a[i])\n#print('to =', to)\n\n# BFS\ninf = 200200\ndist = [inf for _ in range(n+1)]\nq = deque()\nq.append(1)\ndist[1] = 0 \n\nwhile q:\n    v = q.popleft()\n    for u in to[v]:\n        if dist[u] == inf:\n            dist[u] = dist[v]+1\n            q.append(u)\n\nif dist[n] == 2:\n    print('POSSIBLE')\nelse:\n    print('IMPOSSIBLE')\n", "import collections as c\nn,m=map(int,input().split())\nprint(['POSSIBLE','IMPOSSIBLE'][not [1 for c in c.Counter([[a,b][a==1] for a,b in [[i,j] for i,j in [list(map(int,input().split())) for _ in range(m)] if i==1 or j==n]]).values() if c>1]])", "n, m = [int(x) for x in input().split()]\na = []\nfor i in range(m):\n  a.append([int(x) for x in input().split()])\n  \nres = \"IMPOSSIBLE\"\nflag = []\n\nfor i in range(m):\n  if a[i][0] == 1:\n    flag.append(a[i][1])\nflag = set(flag)\n\nfor i in range(m):\n  if a[i][0] in flag and a[i][1] == n:\n    res = \"POSSIBLE\"\nprint(res)", "import collections\n\nn,m=list(map(int,input().split()))\na,b,c=[],[],[]\nfor i in range(m):\n    A=list(map(int,input().split()))\n    a.append(A)\nfor i in range(m):\n    if a[i][1]==n:\n        b.append(a[i][0])\n    elif a[i][0]==1:\n        c.append(a[i][1])\nif len(set(b)&set(c))>0:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n", "n,m=map(int,input().split())\nedge=[[] for _ in range(n)]\nfor i in range(m):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\nfor i in edge[0]:\n    if n-1 in edge[i]:\n        print(\"POSSIBLE\")\n        return\nprint(\"IMPOSSIBLE\")", "import math\nimport collections\nimport fractions\nimport itertools\nimport functools\nimport operator\nimport bisect\n\ndef solve():\n    n, m = map(int, input().split())\n    course = [[] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        course[a-1].append(b)\n        course[b-1].append(a)\n    for i in course[0]:\n        if n in course[i-1]:\n            print(\"POSSIBLE\")\n            break\n    else:\n        print(\"IMPOSSIBLE\")\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "n, m = map(int, input().split())\narr_ = [tuple(map(int, input().split())) for _ in range(m)]\none = set([b for a, b in arr_ if a == 1])\nlast = set([a for a, b in arr_ if b == n])\nprint(\"POSSIBLE\" if len(one & last) >= 1 else \"IMPOSSIBLE\")", "import heapq\nimport sys\ninput = lambda :sys.stdin.readline().rstrip()\n\ndef INPUT(mode=int):\n    return list(map(mode, input().split()))\n\ndef Dijkstra_heap(s, edge):\n    # \u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2#\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    d = [10**20] * n\n    used = [False] * n\n    d[s] = 0\n    used[s] = True\n    edgelist = []\n    for i, j in edge[s]:\n        heapq.heappush(edgelist, i+j*(10**6))\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        v = minedge % (10**6)\n        # \u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n        if used[v]: continue\n        d[v] = minedge // (10**6)\n        used[v] = True\n        for e in edge[v]:\n            if not used[e[0]]:\n                heapq.heappush(edgelist, e[0]+(e[1]+d[v]) * (10**6))\n    return d\n\nn, m = INPUT()\nAB = [INPUT() for _ in range(m)]\nedge = [[] for _ in range(n)]\nfor a, b in AB:\n    a -= 1\n    b -= 1\n    edge[a].append((b, 1))\n    edge[b].append((a, 1))\n\ndist = Dijkstra_heap(0, edge)\nif dist[-1] <= 2:\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")", "n, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\nini_1 = []\nend_n = []\nfor i in range(m):\n    if ab[i][0] == 1:\n        ini_1.append(ab[i][1])\n    elif ab[i][1] == n:\n        end_n.append(ab[i][0])\nif set(ini_1) & set(end_n):\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "n, m = map(int,input().split())\nl1 = set()\nl2 = set()\nfor i in range(m):\n    a,b = map(int,input().split())\n    if a==1:\n        l1.add(b)\n    elif b==n:\n        l2.add(a)\nprint('POSSIBLE' if len(l1&l2) >=1 else 'IMPOSSIBLE')", "N, M = map(int, input().split())\nship = [list(map(int, input().split())) for _ in range(M)]\n\ns1 = [False] * N\nsN = [False] * N\n\nfor i, s in enumerate(ship):\n    if s[0] == 1:\n        s1[s[1] - 1] = True\n\n    if s[1] == N:\n        sN[s[0] - 1] = True\n\nans = 'IMPOSSIBLE'\nif any([p1 * pN for p1, pN in zip(s1, sN)]):\n    ans = 'POSSIBLE'\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\ndef read():\n    N, M = list(map(int, input().strip().split()))\n    AB = []\n    for i in range(M):\n        a, b = list(map(int, input().strip().split()))\n        AB.append((a, b))\n    return N, M, AB\n\n\ndef solve(N, M, AB):\n    S = [False for i in range(N+1)]\n    T = [False for i in range(N+1)]\n    for a, b in AB:\n        if a > b:\n            a, b = b, a\n        if a == 1:\n            S[b] = True\n        elif b == N:\n            T[a] = True\n    for s, t in zip(S, T):\n        if s and t:\n            return \"POSSIBLE\"\n    return \"IMPOSSIBLE\"\n\n\ndef __starting_point():\n    inputs = read()\n    print((\"%s\" % solve(*inputs)))\n\n__starting_point()", "#n = int(input())\nn, m = list(map(int, input().split()))\n#l = list(map(int,input().split()))\n#l = [list(map(int,input().split())) for i in range(n)]\n\ndic = {}\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    dic[(a, b)] = True\n    dic[(b, a)] = True\nans = 'IMPOSSIBLE'\nfor i in range(2, n):\n    if dic.get((1, i), False):\n        if dic.get((i, n), False):\n            ans = 'POSSIBLE'\n            break\nprint(ans)\n", "N, M = list(map(int, input().split()))\na = []\nb = []\nfor i in range(M):\n    x, y = list(map(int, input().split()))\n    a.append(x)\n    b.append(y)\n\nc = []\nd = []\n\nfor i in range(M):\n    if a[i] == 1:\n        c.append(b[i])\n\nfor i in range(M):\n    if b[i] == N:\n        d.append(a[i])\n\ne = set(c) & set(d)\n\nif len(e) != 0:\n    print('POSSIBLE')\nelse:\n    print('IMPOSSIBLE')\n\n\n", "n, m = map(int, input().split())\na1 = []\nbn = []\n\nfor i in range(m):\n  a, b = map(int, input().split())\n  if a == 1:\n    a1.append(b)\n  elif b == n:\n    bn.append(a)\nla = len(a1)\nlb = len(bn)\nsa = set(a1)\nsb = set(bn)\nif len(sa | sb) < la + lb:\n  print('POSSIBLE')\n  return\nprint('IMPOSSIBLE')", "n, m = map(int,input().split())\n \nl1 = []\nl2 = []\nfor i in range(m):\n    a,b = map(int,input().split())\n    if a==1:\n        l1.append(b)\n    elif b==n:\n        l2.append(a)\n\nif len(set(l1)&set(l2)) >=1:\n  print('POSSIBLE')\nelse:\n  print('IMPOSSIBLE')", "import sys\nn, m = map(int, input().split())\n \ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n\nN = n-1\nfor i in g[0]:\n    if N in g[i]:\n        print('POSSIBLE')\n        return\n\nprint('IMPOSSIBLE')", "N,M = map(int,input().split())\nisland = [[] for i in range(N+1)]\nfor i in range(M):\n    a,b = map(int,input().split())\n    island[a].append(b)\n\nfor i in island[1]:\n    if N in island[i]:\n        print('POSSIBLE')\n        return\nprint('IMPOSSIBLE')", "n, m = map(int, input().split())\narr = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    arr.append((a,b))\n\none = set([b for a, b in arr if a == 1])\nlast = set([a for a, b in arr if b == n])\nconnect = one & last\nif len(connect) >= 1:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "N,M=list(map(int,input().split()))\nG=[list() for _ in range(N)]\nfor _ in range(M):\n    a,b=list(map(int,input().split()))\n    a-=1\n    b-=1\n    G[a].append(b)\n    G[b].append(a)\nG[0].sort()\nG[N-1].sort()\ni=0\nj=0\nwhile i<len(G[0]) and j<len(G[N-1]):\n    if G[0][i]==G[N-1][j]:\n        print(\"POSSIBLE\")\n        break\n    elif G[0][i]<G[N-1][j]:\n        i+=1\n    else:\n        j+=1\nelse:\n    print(\"IMPOSSIBLE\")\n", "n, m = list(map(int, input().split()))\nroot_map = dict()\nroot_map[1] = set()\nroot_map[n] = set()\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    if a == 1 or a == n:\n        root_map[a].add(b)\n    if b == 1 or b == n:\n        root_map[b].add(a)\n\nif root_map[1] & root_map[n]:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n", "N,M=list(map(int,input().split()))\nnekotyann=[0]*N\nwanntyann=[0]*N\nans=\"IMPOSSIBLE\"\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    if a==1:\n        nekotyann[b-1]+=1\n    if b==N:\n        wanntyann[a-1]+=1\nfor k in range(N):\n    if nekotyann[k]!=0 and wanntyann[k]!=0:\n        ans=\"POSSIBLE\"\n        break\nprint(ans)\n", "N,M = map(int,input().split())\nans = ('IMPOSSIBLE')\nf1tob = []\nfbtoN = []\nfor i in range(M):\n    a,b = map(int,input().split())\n    if a == 1:\n        f1tob.append(b)\n    elif b == N:\n        fbtoN.append(a)\nf1toba = set(f1tob)\nfbtoNa = set(fbtoN)\nif bool(fbtoNa & f1toba):\n    ans = 'POSSIBLE'\nprint(ans)", "n, m = list(map(int, input().split()))\nroot_map = dict()\nroot_map[1] = set()\nroot_map[n] = set()\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    if a not in root_map:\n        root_map[a] = set()\n        root_map[a].add(b)\n    else:\n        root_map[a].add(b)\n    if b not in root_map:\n        root_map[b] = set()\n        root_map[b].add(a)\n    else:\n        root_map[b].add(a)\n\nfor i in root_map[1]:\n    if i in root_map[n]:\n        print(\"POSSIBLE\")\n        break\nelse:\n    print(\"IMPOSSIBLE\")\n", "n, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nG = [[] for j in range(n + 1)]\n\nfor a, b in edges:\n    G[a].append(b)\n    G[b].append(a)\n\nfor b in G[1]:\n    if n in G[b]:\n        print('POSSIBLE')\n        return\nprint('IMPOSSIBLE')", "n,m = list(map(int,input().split()))\n#a_to = []\n#a_from = []\ndic = {}\nisOK = False\nfor i in range(m):\n    a,b = list(map(int,input().split()))\n    if a in [1,n]:\n        dic.setdefault(b,0)\n        dic[b] += 1\n        if dic[b]==2:\n            isOK = True\n            break\n    elif b in [1,n]:\n        dic.setdefault(a,0)\n        dic[a] += 1\n        if dic[a]==2:\n            isOK = True\n            break\n#    if a==1:\n#        a_to.append(b)\n#    if b==1:\n#        a_to.append(a)\n#    if a==n:\n#        a_from.append(b)\n#    if b==n:\n#        a_from.append(a)\n\n#for j in range(len(a_to)):\n#    if a_to[j] in a_from:\n#        isOK = True\n#        break\n#print(a_to)\n#print(a_from)\nif isOK:\n    print('POSSIBLE')\nelse:\n    print('IMPOSSIBLE')\n", "N,M = map(int,input().split())\n#\u96a3\u63a5\u30ea\u30b9\u30c8\ng = [[] for i in range(N)]\nfor i in range(M):\n  a,b = map(int,input().split())\n  g[a-1].append(b)\n  g[b-1].append(a)\nls = g[0]\nflag = 0\nfor i in range(len(g[0])):\n  ls2 = g[ls[i]-1]\n  for j in range(len(ls2)):\n    if ls2[j] == N:\n      flag += 1\n      print(\"POSSIBLE\")\n      break\nif flag == 0:\n  print(\"IMPOSSIBLE\")", "N, M = list(map(int, input().split()))\nfrom_one = []\nto_n = []\nfor _ in range(M):\n  a, b = [int(x)-1 for x in input().split()]\n  if a == 0:\n    from_one += [b]\n  elif b == 0:\n    from_one += [a]\n  elif a == N-1:\n    to_n += [b]\n  elif b == N-1:\n    to_n += [a]\n\nfrom_one = set(from_one)\nto_n = set(to_n)\nif len(from_one & to_n) >= 1:\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")\n", "N,M = map(int,input().split())\nI = set()\nn = set()\nfor i in range(M):\n    a,b = map(int,input().split())\n    if a == 1:\n        I.add(b)\n    if b == N:\n        n.add(a)\nif  I & n == set():\n    print(\"IMPOSSIBLE\")\nelse:\n    print(\"POSSIBLE\")", "N,M=map(int,input().split())\nl,r=[0]*N,[0]*N\nfor i in range(M):\n    a,b=map(int,input().split())\n    if a==1:\n        l[b-1]=1\n    if b==N:\n        r[a-1]=1\nfor i in range(N):\n    if l[i]+r[i]==2:\n        print('POSSIBLE')\n        return\nprint('IMPOSSIBLE')", "N, M = map(int, input().split())\ngraph = [[] for _ in range(N)] \nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\ndef bfs(goal, graph, seen, next_v):\n    for x in graph[next_v[0][0]]:\n        if x == goal:\n            return True\n        if x in seen:\n            continue\n        next_v.append((x,next_v[0][1]+1))\n        seen.add(x)\n    return False\n\n\nnext_v = [(0,0)]\nseen = {0}\n#bfs\nwhile True:\n    if len(next_v) == 0 or next_v[0][1] == 2:\n        ans = \"IMPOSSIBLE\"\n        break\n    if bfs(N-1, graph, seen, next_v):\n        ans = \"POSSIBLE\"\n        break\n    next_v.pop(0)\nprint(ans)", "N, M = [int(x) for x in input().split(\" \")]\nnext_to_1 = []\nnext_to_last = []\n\nfor i in range(M):\n  tmp = input().split(\" \")\n  if int(tmp[0]) == 1:\n    next_to_1.append(int(tmp[1]))\n  if int(tmp[1]) == N:\n    next_to_last.append(int(tmp[0]))\n\nif len(list(set(next_to_1) & set(next_to_last))) > 0:\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")\n", "from collections import deque\nn, m = list(map(int, input().split()))\nedges = [[]*n for _ in range(n)]\n\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n#print(edges)\nd = deque()\nd.append(0)\nvisited = [False]*n\nvisited[0] = True\nfrom_0 = [0]*n\nwhile d:\n    x = d.popleft()\n    for child in edges[x]:\n        if visited[child]:\n            continue\n        else:\n            visited[child] = True\n            d.append(child)\n            from_0[child] = from_0[x] + 1\n#print(from_0)\nif from_0[n-1] == 2:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n\n", "n,m = map(int,input().split())\nvoyage = [set() for i in range(n+1)]\nfor i in range(m):\n  a,b = map(int,input().split())\n  voyage[a].add(b)\n  voyage[b].add(a)\nans = 0\nfor v in voyage[1]:\n  if v in voyage[n]:\n    ans = 1\nprint('POSSIBLE' if ans else 'IMPOSSIBLE')", "n,m = list(map(int,input().split()))\nab = [list(map(int,input().split())) for i in range(m)]\n\nren = []\n\nfor i in range(m) :\n    if ab[i][0] == 1 :\n        ren.append(ab[i][1])\n    elif ab[i][1] == n :\n        ren.append(ab[i][0])\n\ncnt = len(ren)\n\nif len(set(ren)) == cnt :\n    print(\"IMPOSSIBLE\")\nelse :\n    print(\"POSSIBLE\")\n", "N,M = map(int,input().split())\nA = set()\nB = set()\nfor i in range(M):\n  a,b = input().split()\n  if a =='1':\n    A.add(b)\n  if b == str(N):\n    B.add(a)\nif A&B:\n  print('POSSIBLE')\nelse:\n  print('IMPOSSIBLE')", "from collections import deque\n\nn, m = map(int,input().split())\n\ne = [[] for i in range(n)]\nfor i in range(m):\n    f, t = map(int,input().split())\n    f -= 1\n    t -= 1\n    e[f].append(t)\n    e[t].append(f)\n\nINF = 10**9\ndist = [INF] * n\ndist[0] = 0\nd = deque()\nd.append([0, 0])\n\nwhile d:\n    f, c = d.pop()\n    if c >= 2:\n        break\n    for t in e[f]:\n        if c + 1 < dist[t]:\n            dist[t] = c + 1\n            d.appendleft([t, c+1])\nprint('POSSIBLE') if dist[n-1] <= 2 else print('IMPOSSIBLE')", "n, m = list(map(int, input().split()))\nab  = list(list(map(int, input().split())) for _ in range(m))\n\ngoal = [0] * n\nstart = [0] * n\n\nfor a, b in ab:\n    if a == 1:\n        start[b] = 1\n    if b == n:\n        goal[a] = 1\n\nflg = False\nfor i in range(n):\n    if start[i] and goal[i]:\n        flg = True\n\nprint(('POSSIBLE' if flg else 'IMPOSSIBLE'))\n", "n, m = map(int, input().split())\nli = [0]*200001\ns = \"IMPOSSIBLE\"\nfor i in range(m):\n    a, b = map(int, input().split())\n    if a == 1:\n        if li[b] == 0:\n            li[b] = 1\n        else:\n            s = \"POSSIBLE\"\n    \n    if b == n:\n        if li[a] == 0:\n            li[a] = 1\n        else:\n            s = \"POSSIBLE\"\n\nprint(s)", "#!/usr/bin/env python3\n# cython: profile=True\nimport sys\n\nYES = \"POSSIBLE\"  # type: str\nNO = \"IMPOSSIBLE\"  # type: str\n\n\ndef solve(N: int, M: int, a: \"List[int]\", b: \"List[int]\"):\n    AB = sorted(zip(a, b))\n    s = set([b for a, b in AB if a == 1])\n    g = set([a for a, b in AB if b == N])\n    return YES if s & g else NO\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    a = [int()] * (M)  # type: \"List[int]\"\n    b = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n    print((solve(N, M, a, b)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef perf():\n    import cProfile\n    cProfile.run(\"main()\")\n\ndef __starting_point():\n    #test()\n    #perf()\n    main()\n\n__starting_point()", "N,M = map(int,input().split())\nA = []\nB = []\n\nfor i in range(M):\n  a,b = map(int,input().split())\n  if a == 1:\n    B.append(b)\n  if b == N:\n    A.append(a)\n\nif len(set(A) & set(B)) != 0:\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")", "import sys\ninput = sys.stdin.readline\n\n\ndef read():\n    N, M = list(map(int, input().strip().split()))\n    AB = []\n    for i in range(M):\n        a, b = list(map(int, input().strip().split()))\n        AB.append((a, b))\n    return N, M, AB\n\n\ndef solve(N, M, AB):\n    is_ok = True\n    mid_b = set()\n    mid_a = set()\n    for a, b in AB:\n        if a == 1:\n            mid_b.add(b)\n        elif b == N:\n            mid_a.add(a)\n    is_ok = len(mid_a.intersection(mid_b)) > 0\n    return \"POSSIBLE\" if is_ok else \"IMPOSSIBLE\"\n\n\ndef __starting_point():\n    inputs = read()\n    print((solve(*inputs)))\n\n__starting_point()", "n,m=map(int,input().split())\nA=[]\nB=[]\nfor i in range(m):\n  a,b=map(int,input().split())\n  if a==1:\n    A.append(b)\n  if b==n:\n    B.append(a)\nif len(set(A) & set(B))>0:\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")", "N, M = [int(x) for x in input().split()]\nAB = [[int(x) for x in input().split()] for _ in range(M)]\n\n\nx = set()\nfor a, b in AB:\n    if a == 1:\n        x.add(b)\n    if b == 1:\n        x.add(a)\n\nf = False\n\nfor a, b in AB:\n    if (a in x and b == N) or (b in x and a == N):\n        f = True\n\nif f:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n", "import sys\n\nN, M = [int(i) for i in input().split()]\nmap = {k: [] for k in range(1, N + 1)}\n\nfor _ in range(M):\n  a, b = (int(i) for i in input().split())\n  map[a].append(b)\n\n\nfor i in map[1]:\n  if N in map[i]:\n    print('POSSIBLE')\n    return\n\n\nprint('IMPOSSIBLE')\n", "from collections import deque\n\nn,m = map(int, input().split())\nG = [[] for _ in range(n)]\nfor i in range(m):\n    a,b = map(int, input().split())\n    a-=1\n    b-=1\n    G[a].append(b)\n    G[b].append(a)\n\nok = False\nfor v in G[0]:\n    s = G[v]\n    if n-1 in s:\n        ok = True\n\nif ok:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "n, m = map(int, input().split())\narr_ = [tuple(map(int, input().split())) for _ in range(m)]\n\none = set([b for a, b in arr_ if a == 1])\nlast = set([a for a, b in arr_ if b == n])\nconnect = one & last\nif len(connect) >= 1:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "n, m = map(int,input().split())\ninit_island = set()\nlast_island = set()\nfor _ in range(m):\n    a,b = map(int,input().split())\n    a,b = min(a,b), max(a,b)\n    if a == 1:\n        init_island.add(b)\n    elif b == n:\n        last_island.add(a)\n    else:\n        continue\ncommon = init_island.intersection(last_island)\nif len(common) >= 1:\n    print('POSSIBLE')\nelse:\n    print('IMPOSSIBLE')", "N, M = list(map(int, input().split()))\nL = [list(map(int, input().split())) for i in range(M)]\ns = []\ng = []\nfor i in range(M):\n    if 1 == L[i][0]:\n        s.append(L[i][1])\n    if 1 == L[i][1]:\n        s.append(L[i][0])\n        \nfor i in range(M):\n    if N == L[i][0]:\n        g.append(L[i][1])\n    if N == L[i][1]:\n        g.append(L[i][0])\n        \nif set(g)&set(s):\n    print('POSSIBLE')\nelse:\n    print('IMPOSSIBLE')\n", "n, m, *AB = map(int, open(0).read().split())\n\nC, D = set(), set()\nfor a, b in zip(AB[::2], AB[1::2]):\n  if a == 1:\n    C.add(b)\n  if b == n:\n    D.add(a)\n\nif len(C & D):\n  print('POSSIBLE')\nelse:\n  print('IMPOSSIBLE')", "def main():\n  N, M = map(int,input().split())\n  fromOne = set()\n  toM = set()\n  for i in range(M):\n    a, b = map(int,input().split())\n    if a == 1:\n      fromOne.add(b)\n    elif b == N:\n      toM.add(a)\n  return 'POSSIBLE' if fromOne & toM else 'IMPOSSIBLE'\nprint(main())", "N, M = list(map(int, input().split()))\nstart = set()\ngoal = set()\n\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    if(a == 1):\n        start.add(b)\n    elif(b == N):\n        goal.add(a)\nprint((\"IMPOSSIBLE\" if(len(start & goal) == 0) else \"POSSIBLE\"))\n", "N, M = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for _ in range(M)]\nres = []\nfor a, b in AB:\n    if a == 1:\n        res.append(b)\n    if b == N:\n        res.append(a)\nprint(('IMPOSSIBLE' if len(res) == len(set(res)) else 'POSSIBLE'))\n", "#\n# abc068 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3 2\n1 2\n2 3\"\"\"\n        output = \"\"\"POSSIBLE\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"4 3\n1 2\n2 3\n3 4\"\"\"\n        output = \"\"\"IMPOSSIBLE\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"100000 1\n1 99999\"\"\"\n        output = \"\"\"IMPOSSIBLE\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_4(self):\n        input = \"\"\"5 5\n1 3\n4 5\n2 3\n2 4\n1 4\"\"\"\n        output = \"\"\"POSSIBLE\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N, M = list(map(int, input().split()))\n    S = [0] * N\n    E = [0] * N\n    for i in range(M):\n        a, b = list(map(int, input().split()))\n        if a == 1:\n            S[b-1] = 1\n        if b == N:\n            E[a-1] = 1\n\n    ans = \"IMPOSSIBLE\"\n    for i in range(N):\n        if S[i] == E[i] == 1:\n            ans = \"POSSIBLE\"\n            break\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\n\n# n, m = 3, 2\n# a = [[1, 2], [2, 3]]\n\npot_starts = []\npot_ends = []\n\nfor i in a:\n    if i[0] == 1:\n        pot_starts.append(i[1])\n    elif i[1] == n:\n        pot_ends.append(i[0])\n\nif set(pot_starts).intersection(set(pot_ends)):\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "def main():\n    n, m = map(int, input().split())\n    ab_lst = []\n    for i in range(m):\n        ab_lst.append(list(map(int, input().split())))\n\n    flag = False\n    lst = []\n    for i in range(m):\n        a = ab_lst[i][0]\n        b = ab_lst[i][1]\n\n        if a == 1:\n            lst.append(b)\n    st = set(lst)\n\n    for i in range(m):\n        a = ab_lst[i][0]\n        b = ab_lst[i][1]\n\n        if b == n:\n            if a in st:\n                flag = True\n                break\n\n    if flag:\n        print('POSSIBLE')\n    else:\n        print('IMPOSSIBLE')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N,M = map(int,input().split())\n\nki = [list() for i in range(N)]\nfor _ in range(M):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    ki[a].append(b)\n\nK = [-1] * N\ndef dfs(now,time):\n    K[now] = time\n    for i in ki[now]:\n        time += 1\n        dfs(i,time)\n        time -= 1\n\ndfs(0,0)\nprint('POSSIBLE' if K[N-1] == 2 else 'IMPOSSIBLE')", "N,M = map(int,input().split())\nI = set()\nn = set()\nfor i in range(M):\n    a,b = map(int,input().split())\n    if a == 1:\n        I.add(b)\n    if b == 1:\n        I.add(a)\n    if a == N:\n        n.add(b)\n    if b == N:\n        n.add(a)\nif  I & n == set():\n    print(\"IMPOSSIBLE\")\nelse:\n    print(\"POSSIBLE\")", "n,m = map(int,input().split())\nX = [list(map(int,input().split())) for i in range(m)]\na_list = []\nb_list = []\nfor i in range(m):\n  if X[i][0] == 1:\n    a_list.append(X[i][1])\n  elif X[i][1] == n:\n    b_list.append(X[i][0])\nc_set = set(a_list) & set(b_list)\nif len(c_set) ==0:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "n,m = map(int, input().split())\n\nre = [[] for i in range(n+1)]\nfor i in range(m):\n  a,b = map(int, input().split())\n  re[a].append(b)\n  re[b].append(a)\n  \nreach = [0]*(n+1)\nreach[1] = 1\nfor i in re[1]:\n  if reach[i] == 0:\n    for j in re[i]:\n      reach[j] = 1\n\nif reach[n] == 1:\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")", "import typing\nfrom typing import Deque, Set, Dict\n\nclass Island:\n    def __init__(self, id: int) -> None:\n        self.id: int = id\n        self.connection: List['Island'] = []\n        self.rank: int = 0\n    \n    def addConnection(self, other: 'Island') -> None:\n        self.connection.append(other)\n        other.connection.append(self)\n\n    def setRank(self, other: 'Island') -> None:\n        self.rank = other.rank +1\n\nclass Islands(Dict[int, Island]):\n    def __init__(self, num: int):\n        for id in range(1, num+1):\n            self[id] = Island(id)\n\ndef bfs(root: Island, max_depth: int) -> None:\n    reserved: Deque[Island] = Deque([root])\n    seen: Set[int] = {root.id}\n    while len(reserved) != 0:\n        current: Island = reserved.popleft()\n        if current.rank > max_depth:\n            break\n        for connected in current.connection:\n            if connected.id in seen:\n                continue\n            connected.setRank(current)\n            seen.add(connected.id)\n            reserved.append(connected)\n\ndef main() -> None:\n    with open(0) as f:\n        N, M = map(int, f.readline().split())\n        ab = [map(int, line.split()) for line in f.readlines()]\n    #\u8af8\u5cf6\u751f\u6210\n    islands: Islands = Islands(N)\n    #\u8af8\u5cf6\u9593\u5b9a\u671f\u4fbf\u751f\u6210\n    for a, b in ab:\n        islands[a].addConnection(islands[b])\n    #bfs\n    bfs(islands[1], 2)\n    #\u51fa\u529b\n    print('POSSIBLE' if islands[N].rank in (1, 2) else 'IMPOSSIBLE')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import typing\nfrom typing import Deque, Set, Dict\n\nclass Island:\n    def __init__(self, id: int) -> None:\n        self.id: int = id\n        self.connection: List['Island'] = []\n        self.parent: 'Island' = None\n        self.rank: int = 0\n    \n    def addConnection(self, other: 'Island') -> None:\n        self.connection.append(other)\n        other.connection.append(self)\n\n    def setAsRoot(self):\n        self.parent = self\n    \n    def setParent(self, other: 'Island') -> None:\n        self.parent = other\n        self.rank = other.rank +1\n\nclass Islands(Dict[int, Island]):\n    def __init__(self, num: int):\n        for id in range(1, num+1):\n            self[id] = Island(id)\n\ndef bfs(root: Island, max_depth: int) -> None:\n    root.setAsRoot()\n    reserved: Deque[Island] = Deque([root])\n    seen: Set[int] = {root.id}\n    while len(reserved) != 0:\n        current: Island = reserved.popleft()\n        if current.rank > max_depth:\n            break\n        for connected in current.connection:\n            if connected.id in seen:\n                continue\n            connected.setParent(current)\n            seen.add(connected.id)\n            reserved.append(connected)\n\ndef main() -> None:\n    with open(0) as f:\n        N, M = map(int, f.readline().split())\n        ab = [map(int, line.split()) for line in f.readlines()]\n    #\u8af8\u5cf6\u751f\u6210\n    islands: Islands = Islands(N)\n    #\u8af8\u5cf6\u9593\u5b9a\u671f\u4fbf\u751f\u6210\n    for a, b in ab:\n        islands[a].addConnection(islands[b])\n    #bfs\n    bfs(islands[1], 2)\n    #\u51fa\u529b\n    print('POSSIBLE' if islands[N].rank in (1, 2) else 'IMPOSSIBLE')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m = map(int, input().split())\nab = [list(map(int, input().split())) for i in range(m)]\nl = [[] for i in range(n)]\nab.sort()\nfor i in range(m):\n    x = ab[i]\n    l[x[0]-1].append(x[1]-1)\n    l[x[1]-1].append(x[0]-1)\nfor i in l[0]:\n    if n-1 in l[i]:\n        print(\"POSSIBLE\")\n        return\nprint(\"IMPOSSIBLE\")", "N,M=map(int,input().strip().split())\ndp=[0 for _ in range(N)]\nfind=False\nfor _ in range(M):\n    a,b=map(int,input().strip().split())\n    if a==1:\n        dp[b-1]+=1\n    elif a==N:\n        dp[b-1]+=1\n    if b==1:\n        dp[a-1]+=1\n    elif b==N:\n        dp[a-1]+=1\n    if dp[a-1]==2 or dp[b-1]==2:\n        find=True\n        break\n\nprint(\"POSSIBLE\" if find==True else \"IMPOSSIBLE\")", "N, M = map(int, input().split())\n\nA = set()\nB = set()\n\nfor _ in range(M):\n  a, b = map(int, input().split())\n  if a == 1:\n    A.add(b)\n  if b == N:\n    B.add(a)\n\nif len(A&B):\n  print(\"POSSIBLE\")\nelse:\n  print(\"IMPOSSIBLE\")", "from collections import deque\nn, m = map(int, input().split())\nE = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\ndis = [200000 for i in range(n)]\ndis[0] = 0\nQ = deque([0])\nwhile Q:\n    now = deque.popleft(Q)\n    for i in E[now]:\n        if dis[i] == 200000:\n            dis[i] = dis[now]+1\n            deque.append(Q, i)\nprint(\"POSSIBLE\" if dis[-1] == 2 else \"IMPOSSIBLE\")", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 27 02:05:32 2020\n\n@author: liang\n\"\"\"\n\nN, M = map(int, input().split())\nfirst = list()\nsecond = set()\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    if a == 1:\n        first.append(b)\n    if b == N:\n        second.add(a)\n        \nfor a in first:\n    if a in second:\n        print(\"POSSIBLE\")\n        break\nelse:\n    print(\"IMPOSSIBLE\")", "n, m = map(int, input().split())\nn -= 1\nx = [[] for _ in range(200000)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    x[a].append(b)\n\ncnt = 0\nfor i in x[0]:\n    if n in x[i]:\n        print(\"POSSIBLE\")\n        return\nprint(\"IMPOSSIBLE\")", "from collections import defaultdict\nN, M = [int(x) for x in input().split()]\ndict = defaultdict(bool)  # int/bool/list....\nfor i in range(M):\n    a, b = [int(x) for x in input().split()]\n    dict[(a, b)] = True\n\nfor j in range(1, N + 1):\n    if dict[(1, j)] and dict[(j, N)]:\n        print('POSSIBLE')\n        break\nelse:\n    print('IMPOSSIBLE')", "n, m = list(map(int, input().split()))\ns1 = {}\nsn = []\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    if a == 1:\n        s1[b] = 1\n    elif b == n:\n        sn.append(a)\n\nres = False\nfor s in sn:\n    if s in s1:\n        res = True\n        break\n\nprint(\"POSSIBLE\" if res else \"IMPOSSIBLE\")", "n,m=map(int,input().split())\nd=[[] for i in range(n)]\nfor i in range(m):\n  a,b=map(int,input().split())\n  if a==1 or b==1 or a==n or b==n:\n    d[a-1].append(b)\n    d[b-1].append(a)\nfor i in d[n-1]:\n  if 1 in d[i-1]:\n    print('POSSIBLE')\n    return\nprint('IMPOSSIBLE')", "from collections import deque\n\nINF=10**20\n\nN,M=map(int,input().split())\nG=[[] for _ in range(N+1)]\nfor i in range(M):\n  a,b=map(int,input().split())\n  G[a].append(b)\n  G[b].append(a)\n\ndef bfs(s):\n    seen = [0 for i in range(N+1)]\n    d = [0 for i in range(N+1)]\n    todo = deque()\n    seen[s]=1\n    todo.append(s)\n    while 1:\n      if len(todo)==0:break\n      a = todo.popleft()\n      if d[a] >= 2:continue\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          d[b] += d[a] + 1\n    return d\n\nd = bfs(1)\nif d[N] != 0 and d[N] <= 2:print('POSSIBLE')\nelse:print('IMPOSSIBLE')", "n,m = list(map(int,input().split()))\nab = [list(map(int,input().split())) for i in range(m)]\n\nren = []\n\nfor i in range(m) :\n    if ab[i][0] == 1 :\n        ren.append(ab[i][1])\n    elif ab[i][1] == n :\n        ren.append(ab[i][0])\n\nren.sort()\nif ren[0] == 1 and ren[-1] == n :\n    print(\"POSSIBLE\")\nelse :\n    for i in range(len(ren)-1) :\n        if ren[i] == ren[i+1] :\n            print(\"POSSIBLE\")\n            break\n    else :\n        print(\"IMPOSSIBLE\")\n", "N,M=list(map(int,input().split()))\nA=[[] for _ in range(N+1)]\nfor _ in range(M):\n    a,b=list(map(int,input().split()))\n    A[a].append(b)\n\nans=False\nfor i in A[1]:\n    if i==N:\n        ans=True\n        break\n    for j in A[i]:\n        if j==N:\n            ans=True\n            break\nprint((\"POSSIBLE\" if ans else \"IMPOSSIBLE\" ))\n", "n,m=map(int,input().split())\ndata=[0]*n\nfor i in range(m):\n  a,b=map(int,input().split())\n  if a==1:\n    data[b-1]+=1\n    if data[b-1]==2:\n      print('POSSIBLE')\n      return\n  if b==n:\n    data[a-1]+=1\n    if data[a-1]==2:\n      print('POSSIBLE')\n      return\n\nprint('IMPOSSIBLE')", "from _collections import deque\nn,m=list(map(int,input().split()))\nedg=[[] for i in range(n+1)]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    edg[a].append(b)\n    edg[b].append(a)\ndep=[-1]*(n+1)\ndep[1]=0\ndata=deque([1])\nwhile len(data)>0:\n    p=data.popleft()\n    for i in edg[p]:\n        if dep[i]==-1:\n            dep[i]=dep[p]+1\n            data.append(i)\nprint((\"POSSIBLE\" if dep[n]==2 else \"IMPOSSIBLE\"))\n\n", "n,m=[int(i) for i in input().split()]\n\nhyou=[]\n\nfor i in range(m):\n    hyou.append([int(i) for i in input().split()])\n\n\nnext_island=set()\npre_island=set()\nfor go in hyou:\n    one,two=go\n    newone=min(one,two)\n    newtwo=max(one,two)\n\n    if newone==1:\n        next_island.add(newtwo)\n    if newtwo==n:\n        pre_island.add(newone)\n\nans=next_island&pre_island\n\nif len(ans)==0:\n    print(\"IMPOSSIBLE\")\nelse:\n    print(\"POSSIBLE\")\n", "# -*- coding: utf-8 -*-\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    n, m = list(map(int, input().split()))\n    first = list()\n    second = list()\n\n    for i in range(m):\n        ai, bi = list(map(int, input().split()))\n\n        if ai == 1:\n            first.append(bi)\n\n        if bi == n:\n            second.append(ai)\n\n    ans = set(first) & set(second)\n\n    if len(ans) > 0:\n        print('POSSIBLE')\n    else:\n        print('IMPOSSIBLE')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\nx=[0]*n\ns=0\nfor i in range(m):\n    a,b=map(int,input().split())\n    if a==1:\n        if x[b-1]==0:\n            x[b-1]=1\n        elif x[b-1]==-1:\n            s+=1\n    elif b==n:\n        if x[a-1]==0:\n            x[a-1]=-1\n        elif x[a-1]==1:\n            s+=1\nif s>0:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\n\ns1 = set()\nsn = set()\nfor a,b in AB:\n    if a==1:\n        s1.add(b)\n    if b==N:\n        sn.add(a)\n\nprint('POSSIBLE' if s1&sn else 'IMPOSSIBLE')", "n,m = list(map(int,input().split()))\ne = [list() for _ in range(n)]\nfor i in range(m):\n    a,b = list(map(int,input().split()))\n    e[a-1].append(b-1)\n    e[b-1].append(a-1)\n\nvisited = [float(\"inf\")]*n\nvisited[0]=0\nfrom collections import deque\nqueue = deque()\nqueue.append([0,0])\n\nwhile queue:\n    v,d = queue.popleft()\n    for k in e[v]:\n        if visited[k]==float(\"inf\"):\n            visited[k]=d+1\n            queue.append([k,d+1])\n            #print(visited)\nif visited[n-1]<=2:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n\n", "N,M = map(int,input().split())\nab = [list(map(int,input().split())) for _ in range(M)]\n\ndic = {}\nfor (a, b) in ab:\n  if a in dic.keys():\n    dic[a].append(b)\n  else:\n    dic[a] = [b]\n  \ncheck = False\nfor i in dic[1]:\n  if i in dic.keys():\n    for j in dic[i]:\n      if j == N:\n        check = True\n\nprint(\"POSSIBLE\" if check else \"IMPOSSIBLE\")  ", "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\n\n# n, m = 3, 2\n# a = [[1, 2], [2, 3]]\n\npot_starts = []\npot_ends = []\n\nfor i in a:\n    if i[0] == 1:\n        pot_starts.append(i[1])\n    elif i[1] == n:\n        pot_ends.append(i[0])\n\nif set(pot_starts).intersection(pot_ends):\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "L=list()\nR=list()\nN,M=map(int,input().split())\nfor i in range(M):\n  a,b=map(int,input().split())\n  if a==1:\n    L.append(b)\n  elif b==1:\n    L.append(a)\n  if a==N:\n    R.append(b)\n  elif b==N:\n    R.append(a)\nL=set(L)\nR=set(R)\nif len(L&R)==0:\n  print(\"IMPOSSIBLE\")\nelse:\n  print(\"POSSIBLE\")", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nG = [[] for i in range(N)]\n\nfor i in range(M):\n  a,b = map(int,readline().split())\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n  \nfor child in G[0]:\n  for gchild in G[child]:\n    if gchild == N - 1:\n      print(\"POSSIBLE\")\n      return\nprint(\"IMPOSSIBLE\")  ", "n, m = list(map(int, input().split()))\na = [0] * m\nb = [0] * m\nfor i in range(m):\n    a[i], b[i] = list(map(int, input().split()))\n'''\ncheck = 0\n\n\nfor i in range(m):\n    if a[i] == 1:\n        check = b[i]\n        for j in range(m):\n            if a[j] == check and b[j] == n:\n                print(\"POSSIBLE\")\n                return\n\nprint(\"IMPOSSIBLE\")\n\n'''\nstart = []\nleave = []\nfor i in range(m):\n    if a[i] == 1:\n        start.append(b[i])\n    elif b[i] == n:\n        leave.append(a[i])\n\nif set(start) & set(leave):\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")\n", "n, m = list(map(int, input().split()))\nroot_map = dict()\nroot_map[1] = set()\nroot_map[n] = set()\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    if a == 1 or a == n:\n        root_map[a].add(b)\n    if b == 1 or b == n:\n        root_map[b].add(a)\n\nfor i in root_map[1]:\n    if i in root_map[n]:\n        print(\"POSSIBLE\")\n        break\nelse:\n    print(\"IMPOSSIBLE\")\n", "N,M = map(int,input().split())\nN_List = []\nO_List = []\n\nfor i in range(M):\n    a,b = map(int,input().split())\n    if a == 1:\n        N_List.append(b)\n    if b == 1:\n        N_List.append(a)\n    if a == N:\n        O_List.append(b)\n    if b == N:\n        O_List.append(a)\n\nprint((\"IMPOSSIBLE\",\"POSSIBLE\")[len(set(N_List) & set(O_List)) > 0])", "n,m = map(int,input().split())\ns=[False]*n\nt=[False]*n\nfor i in range(m):\n  a,b=map(int,input().split())\n  if a==1:\n    s[b-1]=True\n  if b==n:\n    t[a-1]=True\nfor i in range(n):\n  if s[i]==True and t[i]==True:\n    print('POSSIBLE')\n    return\nprint('IMPOSSIBLE')", "import collections\nn, m = list(map(int, input().split()))\nvisited = [False]*n\nships = [set() for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    ships[a-1].add(b-1)\n    ships[b-1].add(a-1)\n\nfor i in range(1,n-1):\n    if 0 in ships[i] and n-1 in ships[i]:\n        print('POSSIBLE')\n        return\nprint('IMPOSSIBLE')\n", "n,m=map(int,input().split())\nans1=[]\nans2=[]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  if a==1:\n    ans1.append(b)\n  if b==n:\n    ans2.append(a)\n    \nans=set(ans1)&set(ans2)\nif len(ans)>0:\n  print('POSSIBLE')\nelse:\n  print('IMPOSSIBLE')", "n,m=map(int,input().split())\ndata=[0]*n\nfor i in range(m):\n  a,b=map(int,input().split())\n  if a==1:\n    data[b-1]+=1\n    if data[b-1]==2:\n      print('POSSIBLE')\n      return\n  if b==n:\n    data[a-1]+=1\n    if data[a-1]==2:\n      print('POSSIBLE')\n      return\nprint('IMPOSSIBLE')", "#!/usr/bin/env python3\n\ndef main():\n    n, m = list(map(int, input().split()))\n    ab = [list(map(int, input().split())) for i in range(m)]\n    ans = \"IMPOSSIBLE\"\n    list_1 = []\n    list_n = []\n    for i in range(m):\n        if ab[i][0] == 1:\n            list_1.append(ab[i][1])\n        elif ab[i][1] == n:\n            list_n.append(ab[i][0])\n    if len(set(list_1) & set(list_n)) > 0:\n        ans = \"POSSIBLE\"\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nn,m=list(map(int,input().split()))\nl=[[] for i in range(n)]\n\nfor i in range(m):\n  a,b=list(map(int,input().split()))\n  l[a-1].append(b)\n# print(l)\n\n\nfor i in l[0]:\n  for j in l[i-1]:\n    if j==n:\n      print(\"POSSIBLE\")\n      return\n\nprint(\"IMPOSSIBLE\")\n\n", "n,m = map(int, input().split())\nb1 = []\nb2 = []\nfor i in range(m):\n    a,b = map(int, input().split())\n    if a == 1:\n        b1.append(b)\n    if b == n:\n        b2.append(a)\nif len(b1) + len(b2) == len(list(set(b1+b2))):\n    print('IMPOSSIBLE')\nelse:\n    print('POSSIBLE')", "n,m = list(map(int,input().split()))\ngraph= dict()\nfor i in range(m):\n    a,b  = list(map(int,input().split()))\n    if(graph.get(a,-1)==-1):\n        graph[a] = [b]\n    else:\n        graph[a].append(b)\n    if (graph.get(b, -1) == -1):\n        graph[b] = [a]\n    else:\n        graph[b].append(a)\n\nq=[]\nq.append((1,0))\nvisited = dict()\nvisited[1] = 1\nans = \"IMPOSSIBLE\"\nwhile(len(q) != 0):\n    front,d = q[0]\n    q.pop(0)\n    if(d>2):\n        break\n    if(front == n):\n        ans = \"POSSIBLE\"\n        break\n    lst = graph.get(front,0)\n    if(lst == 0):\n        continue\n    else:\n        for i in lst:\n            if(visited.get(i,-1)==-1):\n                q.append((i,d+1))\nprint(ans)\n\n\n\n\n", "n,m = map(int,input().split())\nstart = [0]*200001\ngoal = [0]*200001\n\nfor i in range(m):\n  a,b = map(int,input().split())\n  if a == 1:\n    if goal[b] == 1:\n      print(\"POSSIBLE\")\n      return\n    start[b] = 1\n    a\n  elif b == n:\n    if start[a] == 1:\n      print(\"POSSIBLE\")\n      return\n    goal[a] = 1\nprint(\"IMPOSSIBLE\")"]