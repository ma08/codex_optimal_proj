2022-04-13 23:09:41.199513 """
You are given two segments $[l_1; r_1]$ and $[l_2; r_2]$ on the $x$-axis. It is guaranteed that $l_1 < r_1$ and $l_2 < r_2$. Segments may intersect, overlap or even coincide with each other. [Image] The example of two segments on the $x$-axis. 

Your problem is to find two integers $a$ and $b$ such that $l_1 \le a \le r_1$, $l_2 \le b \le r_2$ and $a \ne b$. In other words, you have to choose two distinct integer points in such a way that the first point belongs to the segment $[l_1; r_1]$ and the second one belongs to the segment $[l_2; r_2]$.

It is guaranteed that the answer exists. If there are multiple answers, you can print any of them.

You have to answer $q$ independent queries.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) — the number of queries.

Each of the next $q$ lines contains four integers $l_{1_i}, r_{1_i}, l_{2_i}$ and $r_{2_i}$ ($1 \le l_{1_i}, r_{1_i}, l_{2_i}, r_{2_i} \le 10^9, l_{1_i} < r_{1_i}, l_{2_i} < r_{2_i}$) — the ends of the segments in the $i$-th query.


-----Output-----

Print $2q$ integers. For the $i$-th query print two integers $a_i$ and $b_i$ — such numbers that $l_{1_i} \le a_i \le r_{1_i}$, $l_{2_i} \le b_i \le r_{2_i}$ and $a_i \ne b_i$. Queries are numbered in order of the input.

It is guaranteed that the answer exists. If there are multiple answers, you can print any.


-----Example-----
Input
5
1 2 1 2
2 6 3 4
2 4 1 3
1 2 1 3
1 4 5 8

Output
2 1
3 4
3 2
1 2
3 7
"""
2022-04-13 23:09:41.199531 --------------------------
2022-04-13 23:09:57.813452 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# Read input\nq = int(input())\n\n# Solve problem\nfor i in range(q):\n    l1, r1, l2, r2 = [int(x) for x in input().split(\" \")]\n    if l1 == r1:\n        print(\"{0} {1}\".format(l1, l2))\n    elif l2 == r2:\n        print(\"{0} {1}\".format(l1, l2))\n    else:\n        print(\"{0} {1}\".format(l1, l2))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# Read input\nq = int(input())\nqueries = []\nfor _ in range(q):\n    l1, r1, l2, r2 = [int(x) for x in input().split()]\n    queries.append((l1, r1, l2, r2))\n\n# Write output\nfor (l1, r1, l2, r2) in queries:\n    if l1 == r1:\n        print(r1, l2)\n    elif l2 == r2:\n        print(l1, r2)\n    else:\n        print(l1, l2)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        l1, r1, l2, r2 = [int(x) for x in input().split()]\n        if l1 < l2:\n            print(l1, l2)\n        else:\n            print(l2, l1)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nq = int(input())\n\nfor _ in range(q):\n    a, b, c, d = map(int, input().split())\n    print(a, c) if a != c else print(a, d)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n# The solution is to print the minimum value of the first segment and the maximum value of the second segment.\n# The answer is guaranteed to exist because the segments are not empty.\n\nq = int(input())\nfor i in range(q):\n    l1, r1, l2, r2 = map(int, input().split())\n    print(l1, r2)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        l1, r1, l2, r2 = map(int, input().split())\n        if l1 == r1:\n            print(l1, l2)\n        elif l2 == r2:\n            print(l1, l2)\n        elif l1 == l2:\n            print(l1, r2)\n        elif r1 == r2:\n            print(l1, r2)\n        elif l1 < l2:\n            print(l1, l2)\n        elif l1 > l2:\n            print(l1, r2)\n        else:\n            print(\"Error\")\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nq = int(input())\nfor i in range(q):\n    l1, r1, l2, r2 = map(int, input().split())\n    if l1 == r1:\n        print(l1, l2)\n    elif l2 == r2:\n        print(l1, l2)\n    else:\n        print(l1, l2)"
    }
  ],
  "created": 1649891381,
  "id": "cmpl-4wgPF22w1WlJlUsD4jn7RZnh3Oa7g",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 23:09:57.813795 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# Read input\nq = int(input())\n\n# Solve problem\nfor i in range(q):\n    l1, r1, l2, r2 = [int(x) for x in input().split(\" \")]\n    if l1 == r1:\n        print(\"{0} {1}\".format(l1, l2))\n    elif l2 == r2:\n        print(\"{0} {1}\".format(l1, l2))\n    else:\n        print(\"{0} {1}\".format(l1, l2))"
}
2022-04-13 23:09:57.813859 REASON stop
2022-04-13 23:09:57.814433 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# Read input\nq = int(input())\nqueries = []\nfor _ in range(q):\n    l1, r1, l2, r2 = [int(x) for x in input().split()]\n    queries.append((l1, r1, l2, r2))\n\n# Write output\nfor (l1, r1, l2, r2) in queries:\n    if l1 == r1:\n        print(r1, l2)\n    elif l2 == r2:\n        print(l1, r2)\n    else:\n        print(l1, l2)"
}
2022-04-13 23:09:57.814603 REASON stop
2022-04-13 23:09:57.815247 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        l1, r1, l2, r2 = [int(x) for x in input().split()]\n        if l1 < l2:\n            print(l1, l2)\n        else:\n            print(l2, l1)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 23:09:57.815322 REASON stop
2022-04-13 23:09:57.838882 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nq = int(input())\n\nfor _ in range(q):\n    a, b, c, d = map(int, input().split())\n    print(a, c) if a != c else print(a, d)"
}
2022-04-13 23:09:57.838984 REASON stop
2022-04-13 23:09:57.839736 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n# The solution is to print the minimum value of the first segment and the maximum value of the second segment.\n# The answer is guaranteed to exist because the segments are not empty.\n\nq = int(input())\nfor i in range(q):\n    l1, r1, l2, r2 = map(int, input().split())\n    print(l1, r2)"
}
2022-04-13 23:09:57.839844 REASON stop
2022-04-13 23:09:57.852535 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        l1, r1, l2, r2 = map(int, input().split())\n        if l1 == r1:\n            print(l1, l2)\n        elif l2 == r2:\n            print(l1, l2)\n        elif l1 == l2:\n            print(l1, r2)\n        elif r1 == r2:\n            print(l1, r2)\n        elif l1 < l2:\n            print(l1, l2)\n        elif l1 > l2:\n            print(l1, r2)\n        else:\n            print(\"Error\")\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 23:09:57.852637 REASON stop
2022-04-13 23:09:57.853506 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nq = int(input())\nfor i in range(q):\n    l1, r1, l2, r2 = map(int, input().split())\n    if l1 == r1:\n        print(l1, l2)\n    elif l2 == r2:\n        print(l1, l2)\n    else:\n        print(l1, l2)"
}
2022-04-13 23:09:57.853625 REASON stop
