2022-04-13 20:51:22.090159 """
Polycarp has an array $a$ consisting of $n$ integers.

He wants to play a game with this array. The game consists of several moves. On the first move he chooses any element and deletes it (after the first move the array contains $n-1$ elements). For each of the next moves he chooses any element with the only restriction: its parity should differ from the parity of the element deleted on the previous move. In other words, he alternates parities (even-odd-even-odd-... or odd-even-odd-even-...) of the removed elements. Polycarp stops if he can't make a move.

Formally:   If it is the first move, he chooses any element and deletes it;  If it is the second or any next move:   if the last deleted element was odd, Polycarp chooses any even element and deletes it;  if the last deleted element was even, Polycarp chooses any odd element and deletes it.   If after some move Polycarp cannot make a move, the game ends. 

Polycarp's goal is to minimize the sum of non-deleted elements of the array after end of the game. If Polycarp can delete the whole array, then the sum of non-deleted elements is zero.

Help Polycarp find this value.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 2000$) — the number of elements of $a$.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($0 \le a_i \le 10^6$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print one integer — the minimum possible sum of non-deleted elements of the array after end of the game.


-----Examples-----
Input
5
1 5 7 8 2

Output
0

Input
6
5 1 2 4 6 3

Output
0

Input
2
1000000 1000000

Output
1000000
"""
2022-04-13 20:51:22.090174 --------------------------
2022-04-13 20:51:57.821424 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\nn = int(input())\na = list(map(int,input().split()))\neven,odd = 0,0\nfor i in a:\n    if i%2==0:\n        even+=1\n    else:\n        odd+=1\nif even%2==0 and odd%2==0:\n    print(0)\nelse:\n    print(1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef solve(arr):\n    even = 0\n    odd = 0\n    for a in arr:\n        if a % 2 == 0:\n            even += a\n        else:\n            odd += a\n\n    return min(even, odd)\n\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    l = [int(x) for x in sys.stdin.readline().split()]\n    print(solve(l))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = [int(i) for i in input().split()]\n\nif n == 1:\n    print(a[0])\n    exit()\nif n == 2:\n    print(0)\n    exit()\n\n# if the first and last elements are the same parity, then we can only delete one of them\nif a[0] % 2 == a[-1] % 2:\n    # if the first and last element are odd, then we can only delete one of them\n    if a[0] % 2 == 1:\n        # if the second and second-to-last elements are even, then we can only delete one of them\n        if a[1] % 2 == 0 and a[-2] % 2 == 0:\n            # if the second and second-to-last elements are the same, then we can only delete one of them\n            if a[1] == a[-2]:\n                # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n                print(min(a[0], a[-1]))\n            else:\n                # since we can only delete one of the second or second-to-last element, we want to delete the one with the smaller value\n                print(min(a[1], a[-2]))\n        else:\n            # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n            print(min(a[0], a[-1]))\n    # if the first and last element are even, then we can only delete one of them\n    else:\n        # if the second and second-to-last elements are odd, then we can only delete one of them\n        if a[1] % 2 == 1 and a[-2] % 2 == 1:\n            # if the second and second-to-last elements are the same, then we can only delete one of them\n            if a[1] == a[-2]:\n                # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n                print(min(a[0], a[-1]))\n            else:\n                # since we can only delete one of the second or second-to-last element, we want to delete the one with the smaller value\n                print(min(a[1], a[-2]))\n        else:\n            # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n            print(min(a[0], a[-1]))\n# if the first and last elements are not the same parity, then we can delete both of them\nelse:\n    print(0)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef min_sum(arr):\n    if len(arr) == 0:\n        return 0\n    else:\n        return min(arr) + min_sum([x for x in arr if x != min(arr)])\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(min_sum(arr))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nodd_count = 0\neven_count = 0\nfor i in range(n):\n    if a[i] % 2 == 0:\n        even_count += 1\n    else:\n        odd_count += 1\n\nif even_count % 2 == 0:\n    print(sum(a))\nelse:\n    print(sum(a) - min(a))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport os\nimport math\nimport random\nimport heapq \nimport time\nsys.setrecursionlimit(10**7)\nfrom queue import PriorityQueue\n\n#def printGrid(arr):\n#    for i in range(9):\n#        print(*arr[i])\n#    print()\n\n#def fast_input():\n#    return sys.stdin.readline()\n\n#def get_ints():\n#    return list(map(int, fast_input().split()))\n\n#def get_array(dtype=int):\n#    return list(map(dtype, fast_input().split()))\n\n#def get_integer():\n#    return int(fast_input())\n\ndef isEven(num):\n    return num % 2 == 0\n\ndef getOdd(arr):\n    return [num for num in arr if not isEven(num)]\n\ndef getEven(arr):\n    return [num for num in arr if isEven(num)]\n\ndef getSum(arr):\n    return sum(arr)\n\n\ndef get_min_sum(arr):\n    # if the array is all odd or all even, return the sum\n    if len(getOdd(arr)) == 0 or len(getEven(arr)) == 0:\n        return getSum(arr)\n\n    # if the array has both even and odd, return the minimum of the sum of the evens and the sum of the odds\n    else:\n        return min(getSum(getOdd(arr)), getSum(getEven(arr)))\n\n# fast I/O\nraw_input = sys.stdin.readline\nn = int(raw_input())\narr = list(map(int, raw_input().split()))\nprint(get_min_sum(arr))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# python3\nimport sys\n\ndef optimal_sequence(n):\n    sequence = []\n    while n >= 1:\n        sequence.append(n)\n        if n % 3 == 0:\n            n = n // 3\n        elif n % 2 == 0:\n            n = n // 2\n        else:\n            n = n - 1\n    return reversed(sequence)\n\nn = int(input())\nsequence = list(optimal_sequence(n))\nprint(len(sequence) - 1)\nfor x in sequence:\n    print(x, end=' ')"
    }
  ],
  "created": 1649883082,
  "id": "cmpl-4weFOkfMCBYmwLNIp4cyIpEV8hBep",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:51:57.821751 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\nn = int(input())\na = list(map(int,input().split()))\neven,odd = 0,0\nfor i in a:\n    if i%2==0:\n        even+=1\n    else:\n        odd+=1\nif even%2==0 and odd%2==0:\n    print(0)\nelse:\n    print(1)"
}
2022-04-13 20:51:57.821807 REASON stop
2022-04-13 20:51:57.822337 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef solve(arr):\n    even = 0\n    odd = 0\n    for a in arr:\n        if a % 2 == 0:\n            even += a\n        else:\n            odd += a\n\n    return min(even, odd)\n\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    l = [int(x) for x in sys.stdin.readline().split()]\n    print(solve(l))"
}
2022-04-13 20:51:57.822555 REASON stop
2022-04-13 20:51:57.823145 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = [int(i) for i in input().split()]\n\nif n == 1:\n    print(a[0])\n    exit()\nif n == 2:\n    print(0)\n    exit()\n\n# if the first and last elements are the same parity, then we can only delete one of them\nif a[0] % 2 == a[-1] % 2:\n    # if the first and last element are odd, then we can only delete one of them\n    if a[0] % 2 == 1:\n        # if the second and second-to-last elements are even, then we can only delete one of them\n        if a[1] % 2 == 0 and a[-2] % 2 == 0:\n            # if the second and second-to-last elements are the same, then we can only delete one of them\n            if a[1] == a[-2]:\n                # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n                print(min(a[0], a[-1]))\n            else:\n                # since we can only delete one of the second or second-to-last element, we want to delete the one with the smaller value\n                print(min(a[1], a[-2]))\n        else:\n            # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n            print(min(a[0], a[-1]))\n    # if the first and last element are even, then we can only delete one of them\n    else:\n        # if the second and second-to-last elements are odd, then we can only delete one of them\n        if a[1] % 2 == 1 and a[-2] % 2 == 1:\n            # if the second and second-to-last elements are the same, then we can only delete one of them\n            if a[1] == a[-2]:\n                # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n                print(min(a[0], a[-1]))\n            else:\n                # since we can only delete one of the second or second-to-last element, we want to delete the one with the smaller value\n                print(min(a[1], a[-2]))\n        else:\n            # since we can only delete one of the first or last element, we want to delete the one with the smaller value\n            print(min(a[0], a[-1]))\n# if the first and last elements are not the same parity, then we can delete both of them\nelse:\n    print(0)"
}
2022-04-13 20:51:57.823228 REASON stop
2022-04-13 20:51:57.844149 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef min_sum(arr):\n    if len(arr) == 0:\n        return 0\n    else:\n        return min(arr) + min_sum([x for x in arr if x != min(arr)])\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(min_sum(arr))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:51:57.844261 REASON stop
2022-04-13 20:51:57.844853 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nodd_count = 0\neven_count = 0\nfor i in range(n):\n    if a[i] % 2 == 0:\n        even_count += 1\n    else:\n        odd_count += 1\n\nif even_count % 2 == 0:\n    print(sum(a))\nelse:\n    print(sum(a) - min(a))"
}
2022-04-13 20:51:57.844946 REASON stop
2022-04-13 20:51:57.863543 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport os\nimport math\nimport random\nimport heapq \nimport time\nsys.setrecursionlimit(10**7)\nfrom queue import PriorityQueue\n\n#def printGrid(arr):\n#    for i in range(9):\n#        print(*arr[i])\n#    print()\n\n#def fast_input():\n#    return sys.stdin.readline()\n\n#def get_ints():\n#    return list(map(int, fast_input().split()))\n\n#def get_array(dtype=int):\n#    return list(map(dtype, fast_input().split()))\n\n#def get_integer():\n#    return int(fast_input())\n\ndef isEven(num):\n    return num % 2 == 0\n\ndef getOdd(arr):\n    return [num for num in arr if not isEven(num)]\n\ndef getEven(arr):\n    return [num for num in arr if isEven(num)]\n\ndef getSum(arr):\n    return sum(arr)\n\n\ndef get_min_sum(arr):\n    # if the array is all odd or all even, return the sum\n    if len(getOdd(arr)) == 0 or len(getEven(arr)) == 0:\n        return getSum(arr)\n\n    # if the array has both even and odd, return the minimum of the sum of the evens and the sum of the odds\n    else:\n        return min(getSum(getOdd(arr)), getSum(getEven(arr)))\n\n# fast I/O\nraw_input = sys.stdin.readline\nn = int(raw_input())\narr = list(map(int, raw_input().split()))\nprint(get_min_sum(arr))"
}
2022-04-13 20:51:57.863646 REASON stop
2022-04-13 20:51:57.864342 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# python3\nimport sys\n\ndef optimal_sequence(n):\n    sequence = []\n    while n >= 1:\n        sequence.append(n)\n        if n % 3 == 0:\n            n = n // 3\n        elif n % 2 == 0:\n            n = n // 2\n        else:\n            n = n - 1\n    return reversed(sequence)\n\nn = int(input())\nsequence = list(optimal_sequence(n))\nprint(len(sequence) - 1)\nfor x in sequence:\n    print(x, end=' ')"
}
2022-04-13 20:51:57.864431 REASON stop
