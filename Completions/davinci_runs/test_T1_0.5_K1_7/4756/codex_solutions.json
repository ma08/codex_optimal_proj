["\n\nN = int(input())\npoints = []\nfor _ in range(N):\n    points.append(list(map(int, input().split())))\n\npoints.sort(key=lambda x: x[1])\n\n# print(points)\n\na = float('inf')\nfor i in range(len(points)):\n    if i == len(points) - 1:\n        break\n    y1 = points[i][1]\n    y2 = points[i + 1][1]\n    x1 = points[i][0]\n    x2 = points[i + 1][0]\n    # print(y1, y2, x1, x2)\n    if y1 == y2:\n        a = min(a, 0)\n    else:\n        a_ = (x2 - x1) / (y2 - y1)\n        a = min(a, a_)\n\n# print(a)\n\nfor i in range(len(points)):\n    points[i][0] = points[i][0] - points[i][1] * a\n\n# print(points)\n\npoints.sort(key=lambda x: x[0])\n\n# print(points)\n\nb = float('inf')\nfor i in range(len(points)):\n    if i == len(points) - 1:\n        break\n    x1 = points[i][0]\n    x2 = points[i + 1][0]\n    b = min(b, abs(x1 - x2))\n\n# print(b)\n\nprint(a * a + b * b)", "\n\n# solution\n\nN = int(input())\nx = []\ny = []\nfor i in range(N):\n    a, b = [int(j) for j in input().split()]\n    x.append(a)\n    y.append(b)\n\nx = sorted(x)\ny = sorted(y)\n\nif N % 2 == 1:\n    a = x[N // 2] - y[N // 2]\nelse:\n    a = (x[N // 2] + x[N // 2 - 1] - y[N // 2] - y[N // 2 - 1]) / 2\n\nprint(a)", "\ndef main():\n\tn = int(input())\n\tpoints = []\n\tfor i in range(n):\n\t\tx, y = [int(s) for s in input().split()]\n\t\tpoints.append((x,y))\n\tpoints.sort()\n\t#print(points)\n\tmin_unusefulness = float('inf')\n\tfor i in range(1, n):\n\t\tprev_x, prev_y = points[i-1]\n\t\tx, y = points[i]\n\t\ta = (y-prev_y)/(x-prev_x)\n\t\tb = prev_y - a*prev_x\n\t\t#print(a,b)\n\t\tunusefulness = 0\n\t\tfor point in points:\n\t\t\tx, y = point\n\t\t\tdistance = abs(a*x - y + b)/math.sqrt(a**2 + 1)\n\t\t\tunusefulness += distance**2\n\t\tmin_unusefulness = min(min_unusefulness, unusefulness)\n\t\t#print(unusefulness)\n\tprint(min_unusefulness)\n\nif __name__ == '__main__':\n\tmain()", "\n\ndef distance(a,b,c,d):\n    return ((a-c)**2 + (b-d)**2)**0.5\n\ndef closest_point(a,b,c,d):\n    if b == d:\n        return (a+c)/2,b\n    elif a == c:\n        return a,(b+d)/2\n    else:\n        m = (b-d)/(a-c)\n        x = (a+c)/2\n        y = (b+d)/2\n        x_ = (m*x + y - m*m*x + m*y)/(m*m+1)\n        y_ = m*(x_ - x) + y\n        return x_,y_\n\ndef unusefulness(a,b,c,d):\n    x,y = closest_point(a,b,c,d)\n    return distance(x,y,a,b)**2\n\ndef main():\n    N = int(input())\n    total = 0\n    xs = []\n    ys = []\n    for i in range(N):\n        x,y = map(int,input().split())\n        xs.append(x)\n        ys.append(y)\n    xs.sort()\n    ys.sort()\n    x_ = xs[N//2]\n    y_ = ys[N//2]\n    for i in range(N):\n        total += unusefulness(x_,y_,xs[i],ys[i])\n    print(total)\n\nif __name__ == \"__main__\":\n    main()", "\n\n#CODE\n\nimport sys\nimport math\n\nlines = sys.stdin.readlines()\n\nn = int(lines[0])\n\npoints = []\nfor line in lines[1:]:\n    x, y = map(int, line.split())\n    points.append((x, y))\n\npoints.sort()\n\nmin_y = points[0][1]\nmax_y = points[-1][1]\n\na = min_y - points[0][0]\nb = max_y - points[-1][0]\n\nif a < b:\n    c = a\n    d = b\nelse:\n    c = b\n    d = a\n\nans = d\n\nif c < 0:\n    ans += c\n\nprint(ans)", "\n\nimport sys\nimport math\n\ndef get_distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\ndef main():\n    N = int(sys.stdin.readline())\n    points = []\n    for i in range(N):\n        x, y = [int(j) for j in sys.stdin.readline().split()]\n        points.append((x, y))\n    points = sorted(points, key=lambda x: x[0])\n\n    max_distance = 0\n    for i in range(N-1):\n        x1, y1 = points[i]\n        x2, y2 = points[i+1]\n        distance = get_distance(x1, y1, x2, y2)\n        if distance > max_distance:\n            max_distance = distance\n\n    print(max_distance/2)\n\nif __name__ == '__main__':\n    main()", "\n\ndef unusefulness(citizen_home,a):\n    return ((citizen_home[0]-citizen_home[1]+a)**2)/2\n\ndef min_unusefulness(citizen_homes):\n    citizen_homes = sorted(citizen_homes,key=lambda x: x[0]-x[1])\n    start = citizen_homes[0]\n    end = citizen_homes[-1]\n    def f(a):\n        return unusefulness(start,a) + unusefulness(end,a)\n    a_opt = optimize.minimize_scalar(f,bounds=(-1000000,1000000),method='bounded').x\n    return a_opt\n\ndef main():\n    N = int(input())\n    citizen_homes = []\n    for _ in range(N):\n        x,y = [int(x) for x in input().split()]\n        citizen_homes.append((x,y))\n    print(min_unusefulness(citizen_homes))\n\nif __name__ == \"__main__\":\n    main()"]