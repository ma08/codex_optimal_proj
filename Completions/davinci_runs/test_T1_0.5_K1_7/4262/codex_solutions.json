["\n\nfrom itertools import permutations\n\nN = int(input())\nP = [int(i) for i in input().split()]\nQ = [int(i) for i in input().split()]\n\nperms = list(permutations(range(1, N+1)))\n\nprint(abs(perms.index(tuple(P)) - perms.index(tuple(Q))))", "\n\nfrom itertools import permutations\n\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n\n    perm_list = list(permutations(range(1, N+1)))\n    perm_list.sort()\n    a = perm_list.index(P)\n    b = perm_list.index(Q)\n    print(abs(a - b))\n\nif __name__ == '__main__':\n    main()", "\n\n\"\"\"\nPermutations of size N are all the possible unique arrangements of the numbers 1 to N.\nFor example, the permutations of size 3 are:\n(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)\n\nThe permutations of size N are all the possible unique arrangements of the numbers 1 to N.\nFor example, the permutations of size 3 are:\n(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)\n\nFor two sequences X and Y, X is said to be lexicographically smaller than Y if and only if there exists an integer k such that\nX_i = Y_i~(1 \\leq i < k) and X_k < Y_k.\n\nFor example, (1, 2, 3) is lexicographically smaller than (1, 3, 2) since the first sequence does not have any element that is larger than the corresponding element of the second sequence.\n\nIn lexicographical order, the permutations of size 3 are:\n(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)\n\nIn this problem, you are given two permutations P and Q of size N.\nLet P and Q be the a-th and b-th lexicographically smallest permutations, respectively.\nFind |a - b|.\n\"\"\"\n\nimport itertools\nimport sys\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\npermutations = list(itertools.permutations(range(1, N + 1)))\n\n# print(permutations)\n\na = permutations.index(tuple(P))\nb = permutations.index(tuple(Q))\n\nprint(abs(a - b))", "\n\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    p_index = 0\n    q_index = 0\n    for i, j in enumerate(p):\n        if j == 1:\n            p_index = i\n        if j == 2:\n            q_index = i\n    print(abs(p_index - q_index))\n\nif __name__ == \"__main__\":\n    main()", "\n\n# \u5165\u529b\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# \u9806\u5217\u306e\u30ea\u30b9\u30c8\npermutations = list(itertools.permutations(range(1, N + 1)))\n\n# \u9806\u5217P\u3068Q\u304c\u4f55\u756a\u76ee\u306b\u5c0f\u3055\u3044\u304b\u3092\u6c42\u3081\u308b\na, b = permutations.index(tuple(P)), permutations.index(tuple(Q))\n\n# \u51fa\u529b\nprint(abs(a - b))", "\n\ndef main():\n    n = int(input())\n    p_list = list(map(int, input().split()))\n    q_list = list(map(int, input().split()))\n\n    p_index = 0\n    q_index = 0\n    for i in range(n):\n        p_index += p_list[i] * math.factorial(n - i - 1)\n        q_index += q_list[i] * math.factorial(n - i - 1)\n    print(abs(p_index - q_index))\n\nif __name__ == '__main__':\n    main()", "\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef permutation_index(arr):\n    # arr = [1,3,2]\n    # p = 6\n    # p = p * 1/2 * 2/3\n    # p = 3\n    p = factorial(len(arr))\n    for i in range(len(arr)):\n        p = p * (arr[i] - 1) / (len(arr) - i)\n    return p\n\np_index = permutation_index(p)\nq_index = permutation_index(q)\n\nprint(int(abs(p_index - q_index)))"]