2022-04-13 19:46:37.991816 """
There are $n$ kids, numbered from $1$ to $n$, dancing in a circle around the Christmas tree. Let's enumerate them in a clockwise direction as $p_1$, $p_2$, ..., $p_n$ (all these numbers are from $1$ to $n$ and are distinct, so $p$ is a permutation). Let the next kid for a kid $p_i$ be kid $p_{i + 1}$ if $i < n$ and $p_1$ otherwise. After the dance, each kid remembered two kids: the next kid (let's call him $x$) and the next kid for $x$. Each kid told you which kids he/she remembered: the kid $i$ remembered kids $a_{i, 1}$ and $a_{i, 2}$. However, the order of $a_{i, 1}$ and $a_{i, 2}$ can differ from their order in the circle. [Image] Example: 5 kids in a circle, $p=[3, 2, 4, 1, 5]$ (or any cyclic shift). The information kids remembered is: $a_{1,1}=3$, $a_{1,2}=5$; $a_{2,1}=1$, $a_{2,2}=4$; $a_{3,1}=2$, $a_{3,2}=4$; $a_{4,1}=1$, $a_{4,2}=5$; $a_{5,1}=2$, $a_{5,2}=3$. 

You have to restore the order of the kids in the circle using this information. If there are several answers, you may print any. It is guaranteed that at least one solution exists.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.


-----Input-----

The first line of the input contains one integer $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of the kids.

The next $n$ lines contain $2$ integers each. The $i$-th line contains two integers $a_{i, 1}$ and $a_{i, 2}$ ($1 \le a_{i, 1}, a_{i, 2} \le n, a_{i, 1} \ne a_{i, 2}$) — the kids the $i$-th kid remembered, given in arbitrary order.


-----Output-----

Print $n$ integers $p_1$, $p_2$, ..., $p_n$ — permutation of integers from $1$ to $n$, which corresponds to the order of kids in the circle. If there are several answers, you may print any (for example, it doesn't matter which kid is the first in the circle). It is guaranteed that at least one solution exists.


-----Examples-----
Input
5
3 5
1 4
2 4
1 5
2 3

Output
3 2 4 1 5 

Input
3
2 3
3 1
1 2

Output
3 1 2
"""
2022-04-13 19:46:37.991833 --------------------------
2022-04-13 19:47:00.224286 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    \n    # Try to find a kid that is remembered by at least two other kids\n    for i in range(1,n+1):\n        count = 0\n        for j in range(n):\n            if i in a[j]:\n                count += 1\n        if count > 1:\n            break\n\n    # Pick the first kid that remembers the kid i\n    for j in range(n):\n        if i in a[j]:\n            p = [0] * n\n            p[0] = j + 1\n            break\n\n    # Find the first kid that remembers the kid p[0]\n    for j in range(n):\n        if p[0] in a[j]:\n            p[1] = j + 1\n            break\n\n    # Find the second kid that remembers the kid p[0]\n    for j in range(n):\n        if p[0] in a[j] and p[1] != j + 1:\n            p[2] = j + 1\n            break\n\n    # Now, we have three kids that are in a cycle\n    # We can use this to find the rest of the kids\n    for i in range(3,n):\n        for j in range(n):\n            if p[i-1] in a[j] and p[i-2] != j + 1:\n                p[i] = j + 1\n                break\n    \n    # Print the solution\n    for i in range(n):\n        print(p[i], end=' ')\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    p = [None] * n\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][0] == a[j][1]:\n                p[i] = a[j][0]\n                break\n\n    for i in range(n):\n        if p[i] is None:\n            p[i] = a[i][0]\n\n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    a = [[int(i) for i in input().split()] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][0] == a[j][1]:\n                a[i][0] = j + 1\n            if a[i][1] == a[j][0]:\n                a[i][1] = j + 1\n    \n    for i in range(n):\n        if a[i][0] > a[i][1]:\n            a[i][0], a[i][1] = a[i][1], a[i][0]\n\n    a.sort()\n\n    for i in range(n):\n        print(a[i][0], end=' ')\n\nif __name__ == \"__main__\":\n    main('dance')"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# TODO: solve the problem\n\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\n\nfor i in range(n):\n    a[i].sort()\n\nd = {}\nfor i in range(n):\n    for j in range(2):\n        if a[i][j] not in d:\n            d[a[i][j]] = []\n        d[a[i][j]].append(i+1)\n\np = [0]*n\nfor i in range(n):\n    if len(d[i+1]) == 1:\n        p[0] = i+1\n\nfor i in range(1, n):\n    p[i] = d[p[i-1]][0] if d[p[i-1]][0] != p[i-2] else d[p[i-1]][1]\n\nprint(*p)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    # Read in the number of kids\n    n = int(input())\n    \n    # Create a list of sets\n    adj_list = [set() for i in range(n)]\n    for i in range(n):\n        # Read in the values and add them to the set\n        ai1, ai2 = input().split()\n        ai1, ai2 = int(ai1), int(ai2)\n        adj_list[i].add(ai1)\n        adj_list[i].add(ai2)\n\n    # Create a list of visited nodes\n    visited = [False for i in range(n)]\n\n    # Create a list of the order of the nodes\n    # Initialize the first node to be 1\n    order = [1]\n    visited[0] = True\n\n    # Traverse the graph and add the nodes to the order\n    order = traverse_graph(adj_list, order, visited)\n\n    # Print out the order\n    print(' '.join(map(str, order)))\n\n\ndef traverse_graph(adj_list, order, visited):\n    \"\"\"\n    Traverse the graph, adding the nodes to the order\n    \"\"\"\n    curr_node = order[-1]\n    for node in adj_list[curr_node - 1]:\n        if not visited[node - 1]:\n            visited[node - 1] = True\n            order.append(node)\n            order = traverse_graph(adj_list, order, visited)\n    return order\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n\n    p = [0]*n\n    p[0] = 1\n    p[1] = a[0][0]\n    p[2] = a[1][1] if a[1][0] == p[1] else a[1][0]\n    for i in range(3, n):\n        if a[p[i-1]-1][0] == p[i-2]:\n            p[i] = a[p[i-1]-1][1]\n        else:\n            p[i] = a[p[i-1]-1][0]\n    print(' '.join(map(str, p)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n#!/usr/bin/python\n\nimport sys\nimport math\nimport queue\n\nn = int(sys.stdin.readline())\n\nadj = [set() for i in range(n)]\nfor i in range(n):\n    a, b = map(int, sys.stdin.readline().split())\n    adj[a-1].add(b-1)\n    adj[b-1].add(a-1)\n\nvisited = [False] * n\n\ndef dfs(i):\n    visited[i] = True\n    for j in adj[i]:\n        if not visited[j]:\n            dfs(j)\n    sys.stdout.write(str(i+1) + ' ')\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)"
    }
  ],
  "created": 1649879198,
  "id": "cmpl-4wdEkuBKwfzTjSP9An3qwWpbSkmCk",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 19:47:00.224569 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    \n    # Try to find a kid that is remembered by at least two other kids\n    for i in range(1,n+1):\n        count = 0\n        for j in range(n):\n            if i in a[j]:\n                count += 1\n        if count > 1:\n            break\n\n    # Pick the first kid that remembers the kid i\n    for j in range(n):\n        if i in a[j]:\n            p = [0] * n\n            p[0] = j + 1\n            break\n\n    # Find the first kid that remembers the kid p[0]\n    for j in range(n):\n        if p[0] in a[j]:\n            p[1] = j + 1\n            break\n\n    # Find the second kid that remembers the kid p[0]\n    for j in range(n):\n        if p[0] in a[j] and p[1] != j + 1:\n            p[2] = j + 1\n            break\n\n    # Now, we have three kids that are in a cycle\n    # We can use this to find the rest of the kids\n    for i in range(3,n):\n        for j in range(n):\n            if p[i-1] in a[j] and p[i-2] != j + 1:\n                p[i] = j + 1\n                break\n    \n    # Print the solution\n    for i in range(n):\n        print(p[i], end=' ')\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 19:47:00.224676 REASON stop
2022-04-13 19:47:00.225066 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    p = [None] * n\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][0] == a[j][1]:\n                p[i] = a[j][0]\n                break\n\n    for i in range(n):\n        if p[i] is None:\n            p[i] = a[i][0]\n\n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 19:47:00.225203 REASON stop
2022-04-13 19:47:00.225704 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    a = [[int(i) for i in input().split()] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][0] == a[j][1]:\n                a[i][0] = j + 1\n            if a[i][1] == a[j][0]:\n                a[i][1] = j + 1\n    \n    for i in range(n):\n        if a[i][0] > a[i][1]:\n            a[i][0], a[i][1] = a[i][1], a[i][0]\n\n    a.sort()\n\n    for i in range(n):\n        print(a[i][0], end=' ')\n\nif __name__ == \"__main__\":\n    main('dance')"
}
2022-04-13 19:47:00.225766 REASON stop
2022-04-13 19:47:00.236083 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# TODO: solve the problem\n\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\n\nfor i in range(n):\n    a[i].sort()\n\nd = {}\nfor i in range(n):\n    for j in range(2):\n        if a[i][j] not in d:\n            d[a[i][j]] = []\n        d[a[i][j]].append(i+1)\n\np = [0]*n\nfor i in range(n):\n    if len(d[i+1]) == 1:\n        p[0] = i+1\n\nfor i in range(1, n):\n    p[i] = d[p[i-1]][0] if d[p[i-1]][0] != p[i-2] else d[p[i-1]][1]\n\nprint(*p)"
}
2022-04-13 19:47:00.236188 REASON stop
2022-04-13 19:47:00.237239 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    # Read in the number of kids\n    n = int(input())\n    \n    # Create a list of sets\n    adj_list = [set() for i in range(n)]\n    for i in range(n):\n        # Read in the values and add them to the set\n        ai1, ai2 = input().split()\n        ai1, ai2 = int(ai1), int(ai2)\n        adj_list[i].add(ai1)\n        adj_list[i].add(ai2)\n\n    # Create a list of visited nodes\n    visited = [False for i in range(n)]\n\n    # Create a list of the order of the nodes\n    # Initialize the first node to be 1\n    order = [1]\n    visited[0] = True\n\n    # Traverse the graph and add the nodes to the order\n    order = traverse_graph(adj_list, order, visited)\n\n    # Print out the order\n    print(' '.join(map(str, order)))\n\n\ndef traverse_graph(adj_list, order, visited):\n    \"\"\"\n    Traverse the graph, adding the nodes to the order\n    \"\"\"\n    curr_node = order[-1]\n    for node in adj_list[curr_node - 1]:\n        if not visited[node - 1]:\n            visited[node - 1] = True\n            order.append(node)\n            order = traverse_graph(adj_list, order, visited)\n    return order\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:47:00.237318 REASON stop
2022-04-13 19:47:00.256413 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n\n    p = [0]*n\n    p[0] = 1\n    p[1] = a[0][0]\n    p[2] = a[1][1] if a[1][0] == p[1] else a[1][0]\n    for i in range(3, n):\n        if a[p[i-1]-1][0] == p[i-2]:\n            p[i] = a[p[i-1]-1][1]\n        else:\n            p[i] = a[p[i-1]-1][0]\n    print(' '.join(map(str, p)))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:47:00.256508 REASON stop
2022-04-13 19:47:00.257428 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n#!/usr/bin/python\n\nimport sys\nimport math\nimport queue\n\nn = int(sys.stdin.readline())\n\nadj = [set() for i in range(n)]\nfor i in range(n):\n    a, b = map(int, sys.stdin.readline().split())\n    adj[a-1].add(b-1)\n    adj[b-1].add(a-1)\n\nvisited = [False] * n\n\ndef dfs(i):\n    visited[i] = True\n    for j in adj[i]:\n        if not visited[j]:\n            dfs(j)\n    sys.stdout.write(str(i+1) + ' ')\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)"
}
2022-04-13 19:47:00.257529 REASON stop
