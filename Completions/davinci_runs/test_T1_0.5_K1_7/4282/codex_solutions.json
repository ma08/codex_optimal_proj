["\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n\n    p = [0]*n\n    p[0] = 1\n    p[1] = a[0][0]\n    p[2] = a[1][1] if a[1][0] == p[1] else a[1][0]\n    for i in range(3, n):\n        if a[p[i-1]-1][0] == p[i-2]:\n            p[i] = a[p[i-1]-1][1]\n        else:\n            p[i] = a[p[i-1]-1][0]\n    print(' '.join(map(str, p)))\n\nif __name__ == '__main__':\n    main()", "\n\n#!/usr/bin/python\n\nimport sys\nimport math\nimport queue\n\nn = int(sys.stdin.readline())\n\nadj = [set() for i in range(n)]\nfor i in range(n):\n    a, b = map(int, sys.stdin.readline().split())\n    adj[a-1].add(b-1)\n    adj[b-1].add(a-1)\n\nvisited = [False] * n\n\ndef dfs(i):\n    visited[i] = True\n    for j in adj[i]:\n        if not visited[j]:\n            dfs(j)\n    sys.stdout.write(str(i+1) + ' ')\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    \n    # Try to find a kid that is remembered by at least two other kids\n    for i in range(1,n+1):\n        count = 0\n        for j in range(n):\n            if i in a[j]:\n                count += 1\n        if count > 1:\n            break\n\n    # Pick the first kid that remembers the kid i\n    for j in range(n):\n        if i in a[j]:\n            p = [0] * n\n            p[0] = j + 1\n            break\n\n    # Find the first kid that remembers the kid p[0]\n    for j in range(n):\n        if p[0] in a[j]:\n            p[1] = j + 1\n            break\n\n    # Find the second kid that remembers the kid p[0]\n    for j in range(n):\n        if p[0] in a[j] and p[1] != j + 1:\n            p[2] = j + 1\n            break\n\n    # Now, we have three kids that are in a cycle\n    # We can use this to find the rest of the kids\n    for i in range(3,n):\n        for j in range(n):\n            if p[i-1] in a[j] and p[i-2] != j + 1:\n                p[i] = j + 1\n                break\n    \n    # Print the solution\n    for i in range(n):\n        print(p[i], end=' ')\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    a = [[int(i) for i in input().split()] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][0] == a[j][1]:\n                a[i][0] = j + 1\n            if a[i][1] == a[j][0]:\n                a[i][1] = j + 1\n    \n    for i in range(n):\n        if a[i][0] > a[i][1]:\n            a[i][0], a[i][1] = a[i][1], a[i][0]\n\n    a.sort()\n\n    for i in range(n):\n        print(a[i][0], end=' ')\n\nif __name__ == \"__main__\":\n    main('dance')", "\n\ndef main():\n    n = int(input())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    p = [None] * n\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][0] == a[j][1]:\n                p[i] = a[j][0]\n                break\n\n    for i in range(n):\n        if p[i] is None:\n            p[i] = a[i][0]\n\n    print(' '.join(map(str, p)))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    # Read in the number of kids\n    n = int(input())\n    \n    # Create a list of sets\n    adj_list = [set() for i in range(n)]\n    for i in range(n):\n        # Read in the values and add them to the set\n        ai1, ai2 = input().split()\n        ai1, ai2 = int(ai1), int(ai2)\n        adj_list[i].add(ai1)\n        adj_list[i].add(ai2)\n\n    # Create a list of visited nodes\n    visited = [False for i in range(n)]\n\n    # Create a list of the order of the nodes\n    # Initialize the first node to be 1\n    order = [1]\n    visited[0] = True\n\n    # Traverse the graph and add the nodes to the order\n    order = traverse_graph(adj_list, order, visited)\n\n    # Print out the order\n    print(' '.join(map(str, order)))\n\n\ndef traverse_graph(adj_list, order, visited):\n    \"\"\"\n    Traverse the graph, adding the nodes to the order\n    \"\"\"\n    curr_node = order[-1]\n    for node in adj_list[curr_node - 1]:\n        if not visited[node - 1]:\n            visited[node - 1] = True\n            order.append(node)\n            order = traverse_graph(adj_list, order, visited)\n    return order\n\n\nif __name__ == '__main__':\n    main()", "\n\n# TODO: solve the problem\n\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\n\nfor i in range(n):\n    a[i].sort()\n\nd = {}\nfor i in range(n):\n    for j in range(2):\n        if a[i][j] not in d:\n            d[a[i][j]] = []\n        d[a[i][j]].append(i+1)\n\np = [0]*n\nfor i in range(n):\n    if len(d[i+1]) == 1:\n        p[0] = i+1\n\nfor i in range(1, n):\n    p[i] = d[p[i-1]][0] if d[p[i-1]][0] != p[i-2] else d[p[i-1]][1]\n\nprint(*p)"]