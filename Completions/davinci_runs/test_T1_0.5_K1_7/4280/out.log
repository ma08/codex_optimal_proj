2022-04-13 19:44:11.181239 """
Treeland consists of $n$ cities and $n-1$ roads. Each road is bidirectional and connects two distinct cities. From any city you can get to any other city by roads. Yes, you are right — the country's topology is an undirected tree.

There are some private road companies in Treeland. The government decided to sell roads to the companies. Each road will belong to one company and a company can own multiple roads.

The government is afraid to look unfair. They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city. The government wants to make such privatization that the number of such cities doesn't exceed $k$ and the number of companies taking part in the privatization is minimal.

Choose the number of companies $r$ such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most $k$. In other words, if for a city all the roads belong to the different companies then the city is good. Your task is to find the minimal $r$ that there is such assignment to companies from $1$ to $r$ that the number of cities which are not good doesn't exceed $k$. [Image] The picture illustrates the first example ($n=6, k=2$). The answer contains $r=2$ companies. Numbers on the edges denote edge indices. Edge colors mean companies: red corresponds to the first company, blue corresponds to the second company. The gray vertex (number $3$) is not good. The number of such vertices (just one) doesn't exceed $k=2$. It is impossible to have at most $k=2$ not good cities in case of one company. 


-----Input-----

The first line contains two integers $n$ and $k$ ($2 \le n \le 200000, 0 \le k \le n - 1$) — the number of cities and the maximal number of cities which can have two or more roads belonging to one company.

The following $n-1$ lines contain roads, one road per line. Each line contains a pair of integers $x_i$, $y_i$ ($1 \le x_i, y_i \le n$), where $x_i$, $y_i$ are cities connected with the $i$-th road.


-----Output-----

In the first line print the required $r$ ($1 \le r \le n - 1$). In the second line print $n-1$ numbers $c_1, c_2, \dots, c_{n-1}$ ($1 \le c_i \le r$), where $c_i$ is the company to own the $i$-th road. If there are multiple answers, print any of them.


-----Examples-----
Input
6 2
1 4
4 3
3 5
3 6
5 2

Output
2
1 2 1 1 2 
Input
4 2
3 1
1 4
1 2

Output
1
1 1 1 
Input
10 2
10 3
1 2
1 3
1 4
2 5
2 6
2 7
3 8
3 9

Output
3
1 1 2 3 2 3 1 3 1
"""
2022-04-13 19:44:11.181253 --------------------------
2022-04-13 19:46:09.118474 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef get_root(v):\n    if v == parents[v]:\n        return v\n    parents[v] = get_root(parents[v])\n    return parents[v]\n\ndef union(a, b):\n    a = get_root(a)\n    b = get_root(b)\n    if a != b:\n        if sizes[a] < sizes[b]:\n            a, b = b, a\n        parents[b] = a\n        sizes[a] += sizes[b]\n\nn, k = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(n-1)]\n\nparents = [i for i in range(n+1)]\nsizes = [1 for _ in range(n+1)]\n\nfor u, v in edges:\n    if get_root(u) != get_root(v):\n        union(u, v)\n\ngroups = set()\nfor i in range(1, n+1):\n    groups.add(get_root(i))\n\nif len(groups) <= k + 1:\n    print(len(groups))\n    for u, v in edges:\n        if get_root(u) != get_root(v):\n            union(u, v)\n            print(len(groups))\n        else:\n            print(len(groups)-1)\nelse:\n    print(-1)"
    },
    {
      "finish_reason": "length",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\n\nclass FastIO(object):\n    def __init__(self):\n        self.buffer = []\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = []\n            return ''.join(chunk)\n        chunk = []\n        while size > 0:\n            if len(self.buffer) == self.offset:\n                self.buffer = list(sys.stdin.read(4096))\n                self.offset = 0\n            chunk.append(self.buffer[self.offset])\n            self.offset += 1\n            size -= 1\n        return ''.join(chunk)\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO1(object):\n    def __init__(self):\n        self.buffer = []\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = []\n            return ''.join(chunk)\n        chunk = []\n        while size > 0:\n            if len(self.buffer) == self.offset:\n                self.buffer = list(sys.stdin.read(4096))\n                self.offset = 0\n            chunk.append(self.buffer[self.offset])\n            self.offset += 1\n            size -= 1\n        return ''.join(chunk)\n\n    def write(self, string):\n        self.buffer.append(string)\n\n\nclass FastIO2(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        self.buffer += string\n\n\nclass FastIO3(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        self.buffer += string\n        while len(self.buffer) >= 4096:\n            sys.stdout.write(self.buffer[:4096])\n            self.buffer = self.buffer[4096:]\n\n\nclass FastIO4(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        self.buffer += string\n        while len(self.buffer) >= 4096:\n            sys.stdout.write(self.buffer[:4096])\n            self.buffer = self.buffer[4096:]\n\n\nclass FastIO5(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO6(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO7(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO8(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO9(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO10(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO11(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO12(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO13(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO14(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO15(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO16(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO17(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO18(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO19(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO20(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO21(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO22(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO23(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO24(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO25(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO26(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO27(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO28(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO29(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO30(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO31(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO32(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO33(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n        self.parent = None\n        self.color = 0\n        self.num_children = 0\n\ndef dfs(node, color):\n    node.color = color\n    for child in node.children:\n        dfs(child, color)\n\ndef solve(nodes, k):\n    if k == 0:\n        return 1\n    if len(nodes) <= k:\n        return len(nodes)\n    nodes = sorted(nodes, key=lambda node: node.num_children)\n    node = nodes.pop()\n    color = node.color\n    dfs(node, color + 1)\n    return solve(nodes, k - 1)\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    nodes = [Node(i + 1) for i in range(n)]\n    for i in range(n - 1):\n        x, y = [int(i) for i in sys.stdin.readline().split()]\n        node_x = nodes[x - 1]\n        node_y = nodes[y - 1]\n        node_x.children.append(node_y)\n        node_y.children.append(node_x)\n        node_x.num_children += 1\n        node_y.num_children += 1\n    for node in nodes:\n        if len(node.children) == 1:\n            node.parent = node.children[0]\n    root = [node for node in nodes if node.parent is None][0]\n    dfs(root, 1)\n    r = solve(nodes, k)\n    print(r)\n    for node in nodes:\n        print(node.color, end=' ')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nn, k = map(int, sys.stdin.readline().split())\nedges = [list(map(int, sys.stdin.readline().split())) for _ in range(n-1)]\n\n# build graph\ng = defaultdict(list)\nfor x, y in edges:\n    g[x].append(y)\n    g[y].append(x)\n\n# dfs coloring\ncolor = defaultdict(int)\ncolor[1] = 1\nstack = [1]\nwhile stack:\n    cur = stack.pop()\n    for nxt in g[cur]:\n        if color[nxt] == 0:\n            color[nxt] = color[cur]\n            stack.append(nxt)\n\n# count the number of companies\ncnt = defaultdict(int)\nfor i in range(1, n+1):\n    cnt[color[i]] += 1\n\n# count the number of cities with two or more roads of one company\ncities = defaultdict(int)\nfor x, y in edges:\n    if color[x] == color[y]:\n        cities[x] += 1\n        cities[y] += 1\n\n# output\nif len(cities) > k:\n    print(0)\nelse:\n    print(len(cnt))\n    for x, y in edges:\n        print(color[x], end=' ')\n    print()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\ndef dfs(u, p):\n    size[u] = 1\n    for v in tree[u]:\n        if v != p:\n            dfs(v, u)\n            size[u] += size[v]\n\ndef dfs2(u, p, keep):\n    mx = -1\n    bigChild = -1\n    for v in tree[u]:\n        if v != p and size[v] > mx:\n            mx = size[v]\n            bigChild = v\n    for v in tree[u]:\n        if v != p and v != bigChild:\n            dfs2(v, u, False)\n    if bigChild != -1:\n        dfs2(bigChild, u, True)\n        bigTree[bigChild] = True\n    add(u, 1)\n    if not keep:\n        bigTree[u] = False\n        cnt[ color[u] ] = 0\n\ndef add(u, val):\n    cnt[ color[u] ] += val\n    if cnt[ color[u] ] == 1:\n        ans[0] += 1\n    elif cnt[ color[u] ] == 2:\n        ans[0] -= 1\n\ndef paint(u, p, c):\n    color[u] = c\n    for v in tree[u]:\n        if v != p and not bigTree[v]:\n            paint(v, u, c)\n\nn, k = map(int, input().split())\ntree = defaultdict(list)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    tree[x].append(y)\n    tree[y].append(x)\n\nsize = [0] * (n + 1)\ndfs(1, -1)\n\ncolor = [0] * (n + 1)\ncnt = [0] * (n + 1)\nbigTree = [False] * (n + 1)\nans = [0]\ndfs2(1, -1, True)\n\nprint(ans[0])\nprint(*color[2:])"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef find_root(parent, x):\n    # find representative of x\n    if parent[x] != x:\n        parent[x] = find_root(parent, parent[x])\n    return parent[x]\n\ndef union_set(parent, rank, x, y):\n    # union by rank\n    xroot = find_root(parent, x)\n    yroot = find_root(parent, y)\n    # x and y are already in same set\n    if xroot == yroot:\n        return\n    # x and y are not in same set, so we merge them\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else :\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal(parent, rank, graph):\n    mst = []\n    for x, y, w in graph:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        # x and y are already in same set\n        if xroot == yroot:\n            continue\n        # x and y are not in same set, so we merge them\n        mst.append((x, y, w))\n        union_set(parent, rank, xroot, yroot)\n    return mst\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = []\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n    for _ in range(n-1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph.append((x, y, 0))\n    mst = kruskal(parent, rank, graph)\n    color = 1\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n    for x, y, _ in mst:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        # x and y are already in same set\n        if xroot == yroot:\n            color += 1\n            continue\n        # x and y are not in same set, so we merge them\n        union_set(parent, rank, xroot, yroot)\n    print(color)\n    for x, y, _ in mst:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        if xroot == yroot:\n            print(color, end=' ')\n            color -= 1\n        else:\n            print(1, end=' ')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n#sys.stdin = open('C:\\\\Users\\\\user\\\\Downloads\\\\input.txt')\n\nn, k = map(int, input().split())\n\nroads = [list(map(int, input().split())) for _ in range(n-1)]\n\n#print(n, k)\n#print(roads)\n\ndef find_root(x, parent):\n    if parent[x] == x:\n        return x\n    return find_root(parent[x], parent)\n\ndef union(x, y, parent, rank):\n    x_root = find_root(x, parent)\n    y_root = find_root(y, parent)\n\n    if x_root == y_root:\n        return\n\n    if rank[x_root] < rank[y_root]:\n        parent[x_root] = y_root\n    elif rank[x_root] > rank[y_root]:\n        parent[y_root] = x_root\n    else:\n        parent[y_root] = x_root\n        rank[x_root] += 1\n\nparent = list(range(n+1))\nrank = [0]*(n+1)\n\n#print(parent)\n#print(rank)\n\nfor road in roads:\n    union(road[0], road[1], parent, rank)\n\n#print(parent)\n#print(rank)\n\ncomponents = {}\nfor i in range(1, n+1):\n    root = find_root(i, parent)\n    if root not in components:\n        components[root] = []\n    components[root].append(i)\n\n#print(components)\n\ncomponents = list(components.values())\n\n#print(components)\n\nans = 0\nfor component in components:\n    if len(component) > 1:\n        ans += 1\n\nans = min(ans, k)\n\nprint(ans)\n\nfor i in range(n-1):\n    print(i%(ans+1)+1, end=' ')"
    }
  ],
  "created": 1649879051,
  "id": "cmpl-4wdCNhXkmp25S5MacP3OqzOLqPeaX",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 19:46:09.118927 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef get_root(v):\n    if v == parents[v]:\n        return v\n    parents[v] = get_root(parents[v])\n    return parents[v]\n\ndef union(a, b):\n    a = get_root(a)\n    b = get_root(b)\n    if a != b:\n        if sizes[a] < sizes[b]:\n            a, b = b, a\n        parents[b] = a\n        sizes[a] += sizes[b]\n\nn, k = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(n-1)]\n\nparents = [i for i in range(n+1)]\nsizes = [1 for _ in range(n+1)]\n\nfor u, v in edges:\n    if get_root(u) != get_root(v):\n        union(u, v)\n\ngroups = set()\nfor i in range(1, n+1):\n    groups.add(get_root(i))\n\nif len(groups) <= k + 1:\n    print(len(groups))\n    for u, v in edges:\n        if get_root(u) != get_root(v):\n            union(u, v)\n            print(len(groups))\n        else:\n            print(len(groups)-1)\nelse:\n    print(-1)"
}
2022-04-13 19:46:09.118969 REASON stop
2022-04-13 19:46:09.119375 1 {
  "finish_reason": "length",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\n\nclass FastIO(object):\n    def __init__(self):\n        self.buffer = []\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = []\n            return ''.join(chunk)\n        chunk = []\n        while size > 0:\n            if len(self.buffer) == self.offset:\n                self.buffer = list(sys.stdin.read(4096))\n                self.offset = 0\n            chunk.append(self.buffer[self.offset])\n            self.offset += 1\n            size -= 1\n        return ''.join(chunk)\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO1(object):\n    def __init__(self):\n        self.buffer = []\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = []\n            return ''.join(chunk)\n        chunk = []\n        while size > 0:\n            if len(self.buffer) == self.offset:\n                self.buffer = list(sys.stdin.read(4096))\n                self.offset = 0\n            chunk.append(self.buffer[self.offset])\n            self.offset += 1\n            size -= 1\n        return ''.join(chunk)\n\n    def write(self, string):\n        self.buffer.append(string)\n\n\nclass FastIO2(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        self.buffer += string\n\n\nclass FastIO3(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        self.buffer += string\n        while len(self.buffer) >= 4096:\n            sys.stdout.write(self.buffer[:4096])\n            self.buffer = self.buffer[4096:]\n\n\nclass FastIO4(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        self.buffer += string\n        while len(self.buffer) >= 4096:\n            sys.stdout.write(self.buffer[:4096])\n            self.buffer = self.buffer[4096:]\n\n\nclass FastIO5(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO6(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO7(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO8(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO9(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO10(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO11(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO12(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO13(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO14(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO15(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO16(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO17(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO18(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO19(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO20(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO21(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO22(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO23(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO24(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO25(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO26(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO27(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO28(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO29(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO30(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO31(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO32(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset = 0\n\n    def read(self, size=None):\n        if size is None:\n            chunk = self.buffer\n            self.buffer = ''\n            return chunk\n        chunk = self.buffer[self.offset:self.offset + size]\n        self.offset += size\n        return chunk\n\n    def write(self, string):\n        sys.stdout.write(string)\n\n\nclass FastIO33(object):\n    def __init__(self):\n        self.buffer = ''\n        self.offset"
}
2022-04-13 19:46:09.119589 REASON length
2022-04-13 19:46:09.119597 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n        self.parent = None\n        self.color = 0\n        self.num_children = 0\n\ndef dfs(node, color):\n    node.color = color\n    for child in node.children:\n        dfs(child, color)\n\ndef solve(nodes, k):\n    if k == 0:\n        return 1\n    if len(nodes) <= k:\n        return len(nodes)\n    nodes = sorted(nodes, key=lambda node: node.num_children)\n    node = nodes.pop()\n    color = node.color\n    dfs(node, color + 1)\n    return solve(nodes, k - 1)\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    nodes = [Node(i + 1) for i in range(n)]\n    for i in range(n - 1):\n        x, y = [int(i) for i in sys.stdin.readline().split()]\n        node_x = nodes[x - 1]\n        node_y = nodes[y - 1]\n        node_x.children.append(node_y)\n        node_y.children.append(node_x)\n        node_x.num_children += 1\n        node_y.num_children += 1\n    for node in nodes:\n        if len(node.children) == 1:\n            node.parent = node.children[0]\n    root = [node for node in nodes if node.parent is None][0]\n    dfs(root, 1)\n    r = solve(nodes, k)\n    print(r)\n    for node in nodes:\n        print(node.color, end=' ')\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:46:09.119631 REASON stop
2022-04-13 19:46:09.120027 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\nn, k = map(int, sys.stdin.readline().split())\nedges = [list(map(int, sys.stdin.readline().split())) for _ in range(n-1)]\n\n# build graph\ng = defaultdict(list)\nfor x, y in edges:\n    g[x].append(y)\n    g[y].append(x)\n\n# dfs coloring\ncolor = defaultdict(int)\ncolor[1] = 1\nstack = [1]\nwhile stack:\n    cur = stack.pop()\n    for nxt in g[cur]:\n        if color[nxt] == 0:\n            color[nxt] = color[cur]\n            stack.append(nxt)\n\n# count the number of companies\ncnt = defaultdict(int)\nfor i in range(1, n+1):\n    cnt[color[i]] += 1\n\n# count the number of cities with two or more roads of one company\ncities = defaultdict(int)\nfor x, y in edges:\n    if color[x] == color[y]:\n        cities[x] += 1\n        cities[y] += 1\n\n# output\nif len(cities) > k:\n    print(0)\nelse:\n    print(len(cnt))\n    for x, y in edges:\n        print(color[x], end=' ')\n    print()"
}
2022-04-13 19:46:09.120075 REASON stop
2022-04-13 19:46:09.153107 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\ndef dfs(u, p):\n    size[u] = 1\n    for v in tree[u]:\n        if v != p:\n            dfs(v, u)\n            size[u] += size[v]\n\ndef dfs2(u, p, keep):\n    mx = -1\n    bigChild = -1\n    for v in tree[u]:\n        if v != p and size[v] > mx:\n            mx = size[v]\n            bigChild = v\n    for v in tree[u]:\n        if v != p and v != bigChild:\n            dfs2(v, u, False)\n    if bigChild != -1:\n        dfs2(bigChild, u, True)\n        bigTree[bigChild] = True\n    add(u, 1)\n    if not keep:\n        bigTree[u] = False\n        cnt[ color[u] ] = 0\n\ndef add(u, val):\n    cnt[ color[u] ] += val\n    if cnt[ color[u] ] == 1:\n        ans[0] += 1\n    elif cnt[ color[u] ] == 2:\n        ans[0] -= 1\n\ndef paint(u, p, c):\n    color[u] = c\n    for v in tree[u]:\n        if v != p and not bigTree[v]:\n            paint(v, u, c)\n\nn, k = map(int, input().split())\ntree = defaultdict(list)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    tree[x].append(y)\n    tree[y].append(x)\n\nsize = [0] * (n + 1)\ndfs(1, -1)\n\ncolor = [0] * (n + 1)\ncnt = [0] * (n + 1)\nbigTree = [False] * (n + 1)\nans = [0]\ndfs2(1, -1, True)\n\nprint(ans[0])\nprint(*color[2:])"
}
2022-04-13 19:46:09.153247 REASON stop
2022-04-13 19:46:09.156683 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef find_root(parent, x):\n    # find representative of x\n    if parent[x] != x:\n        parent[x] = find_root(parent, parent[x])\n    return parent[x]\n\ndef union_set(parent, rank, x, y):\n    # union by rank\n    xroot = find_root(parent, x)\n    yroot = find_root(parent, y)\n    # x and y are already in same set\n    if xroot == yroot:\n        return\n    # x and y are not in same set, so we merge them\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else :\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal(parent, rank, graph):\n    mst = []\n    for x, y, w in graph:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        # x and y are already in same set\n        if xroot == yroot:\n            continue\n        # x and y are not in same set, so we merge them\n        mst.append((x, y, w))\n        union_set(parent, rank, xroot, yroot)\n    return mst\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = []\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n    for _ in range(n-1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph.append((x, y, 0))\n    mst = kruskal(parent, rank, graph)\n    color = 1\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n    for x, y, _ in mst:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        # x and y are already in same set\n        if xroot == yroot:\n            color += 1\n            continue\n        # x and y are not in same set, so we merge them\n        union_set(parent, rank, xroot, yroot)\n    print(color)\n    for x, y, _ in mst:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        if xroot == yroot:\n            print(color, end=' ')\n            color -= 1\n        else:\n            print(1, end=' ')\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:46:09.156781 REASON stop
2022-04-13 19:46:09.157451 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n#sys.stdin = open('C:\\\\Users\\\\user\\\\Downloads\\\\input.txt')\n\nn, k = map(int, input().split())\n\nroads = [list(map(int, input().split())) for _ in range(n-1)]\n\n#print(n, k)\n#print(roads)\n\ndef find_root(x, parent):\n    if parent[x] == x:\n        return x\n    return find_root(parent[x], parent)\n\ndef union(x, y, parent, rank):\n    x_root = find_root(x, parent)\n    y_root = find_root(y, parent)\n\n    if x_root == y_root:\n        return\n\n    if rank[x_root] < rank[y_root]:\n        parent[x_root] = y_root\n    elif rank[x_root] > rank[y_root]:\n        parent[y_root] = x_root\n    else:\n        parent[y_root] = x_root\n        rank[x_root] += 1\n\nparent = list(range(n+1))\nrank = [0]*(n+1)\n\n#print(parent)\n#print(rank)\n\nfor road in roads:\n    union(road[0], road[1], parent, rank)\n\n#print(parent)\n#print(rank)\n\ncomponents = {}\nfor i in range(1, n+1):\n    root = find_root(i, parent)\n    if root not in components:\n        components[root] = []\n    components[root].append(i)\n\n#print(components)\n\ncomponents = list(components.values())\n\n#print(components)\n\nans = 0\nfor component in components:\n    if len(component) > 1:\n        ans += 1\n\nans = min(ans, k)\n\nprint(ans)\n\nfor i in range(n-1):\n    print(i%(ans+1)+1, end=' ')"
}
2022-04-13 19:46:09.157554 REASON stop
