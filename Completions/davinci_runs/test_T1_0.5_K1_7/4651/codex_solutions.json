["\n\n\ndef find_min_permutation(permutation):\n    n = len(permutation)\n    for i in range(n):\n        if i == n - 1:\n            break\n        if permutation[i] > permutation[i + 1]:\n            permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n    return permutation\n\n\nif __name__ == \"__main__\":\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        permutation = list(map(int, input().split()))\n        print(*find_min_permutation(permutation))", "\n\n# Solution 1\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = sorted(a)\n    ans = ['1'] * n\n    for i in range(n):\n        if a[i] == b[i]:\n            ans[i] = '0'\n    print(''.join(ans))\n\n# Solution 2\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = sorted(a)\n    ans = ['1'] * n\n    for i in range(n):\n        if a[i] == b[i]:\n            ans[i] = '0'\n    print(''.join(ans))", "\n\ndef min_permutation(n, permutation):\n    \"\"\"\n    >>> min_permutation(5, [5, 4, 1, 3, 2])\n    [1, 5, 2, 4, 3]\n    >>> min_permutation(4, [1, 2, 4, 3])\n    [1, 2, 3, 4]\n    >>> min_permutation(1, [1])\n    [1]\n    >>> min_permutation(4, [4, 3, 2, 1])\n    [1, 4, 3, 2]\n    \"\"\"\n    permutation = list(permutation)\n    for i in range(n-1):\n        if permutation[i] > permutation[i+1]:\n            permutation[i], permutation[i+1] = permutation[i+1], permutation[i]\n    return permutation\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        permutation = list(map(int, input().split()))\n        print(\" \".join(map(str, min_permutation(n, permutation))))", "\n\n\ndef solve(permutation):\n    swap_count = 0\n    for i in range(len(permutation) - 1):\n        if permutation[i] > permutation[i + 1]:\n            permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n            swap_count += 1\n    return swap_count\n\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        permutation = list(map(int, input().split()))\n        print(*permutation)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    for i in range(n-1):\n        if a[i] > a[i+1]:\n            a[i],a[i+1] = a[i+1],a[i]\n    print(*a)", "\n\nimport sys\nfrom copy import deepcopy\nfrom heapq import heappop, heappush\n\nclass Node:\n    def __init__(self, state, parent, op):\n        self.state = state\n        self.parent = parent\n        self.op = op\n\ndef swap(state, i):\n    state[i], state[i + 1] = state[i + 1], state[i]\n    return state\n\ndef get_children(parent):\n    children = []\n    for i in range(len(parent.state) - 1):\n        if parent.op is None or i > parent.op:\n            new_state = deepcopy(parent.state)\n            new_state = swap(new_state, i)\n            children.append(Node(new_state, parent, i))\n    return children\n\ndef bfs(start):\n    frontier = [start]\n    visited = [start]\n    while frontier:\n        current = frontier.pop(0)\n        if current.state == sorted(current.state):\n            return current\n        for child in get_children(current):\n            if child not in visited:\n                frontier.append(child)\n                visited.append(child)\n\ndef ucs(start):\n    frontier = [(0, start)]\n    visited = []\n    while frontier:\n        cost, current = heappop(frontier)\n        if current.state == sorted(current.state):\n            return current\n        visited.append(current)\n        for child in get_children(current):\n            if child not in visited:\n                heappush(frontier, (cost + 1, child))\n\ndef dfs(start):\n    frontier = [start]\n    visited = [start]\n    while frontier:\n        current = frontier.pop()\n        if current.state == sorted(current.state):\n            return current\n        for child in get_children(current):\n            if child not in visited:\n                frontier.append(child)\n                visited.append(child)\n\ndef get_path(node):\n    path = []\n    while node:\n        path.append(node.state)\n        node = node.parent\n    return path[::-1]\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        _ = input()\n        start = Node(list(map(int, input().split())), None, None)\n        # solution = bfs(start)\n        # solution = dfs(start)\n        solution = ucs(start)\n        print(\" \".join(map(str, solution.state)))\n\nif __name__ == '__main__':\n    sys.setrecursionlimit(100000)\n    main()", "\n\nimport sys\nimport math\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = [int(x) for x in input().split()]\n        ans = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] > p[j]:\n                    ans[i] = 1\n                else:\n                    ans[j] = 1\n        for i in range(n):\n            if i > 0:\n                sys.stdout.write(\" \")\n            sys.stdout.write(str(p[i] + ans[i]))\n        sys.stdout.write(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()"]