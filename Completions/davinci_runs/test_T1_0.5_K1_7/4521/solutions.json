["\ndef bitadd(a,w,bit):\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit):\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\n\nn = int(input())\n\nx = list(map(int,input().split()))\nv = list(map(int,input().split()))\n\nvlis = []\nfor i in v:\n    vlis.append(i)\nvlis.sort()\nvdic = {}\n\nfor i in range(n):\n    vdic[vlis[i]] = i+1\n#print (vdic)\n\n\n\nxv = []\nfor i in range(n):\n    xv.append([x[i],v[i]])\nxv.sort()\n\nans = 0\nBIT = [0] * (n+1)\nBIT2 = [0] * (n+1)\nfor i in range(n):\n\n    x,v = xv[i]\n\n    ans += x * bitsum(vdic[v],BIT2) - bitsum(vdic[v],BIT)\n    bitadd(vdic[v] , x , BIT)\n    bitadd(vdic[v] , 1 , BIT2)\n\nprint (ans)", "\nimport math\nimport bisect\n\nclass Fenwick:\n    def __init__(self, n):\n        self.data = [[0,0] for i in range(n)] \n    \n    def update(self, pos, dist):\n        while pos<len(self.data):\n            self.data[pos][0] += 1\n            self.data[pos][1] += dist\n            pos = pos | (pos+1)\n    \n    def query(self, pos):\n        ans = [0,0]\n        while pos > 0:\n            ans[0] += self.data[pos-1][0]\n            ans[1] += self.data[pos-1][1]\n            pos = pos & (pos-1)\n        return ans\n\n\ndef rints():\n    return list(map(int,input().split()))\n\n\nn = int(input())\n\nx = rints()\nv = rints()\n\nascDist = list(range(n))\nascDist.sort(key=lambda i: x[i])\n\nuniqueSpeeds = sorted(list(set(v)))\n\ntree = Fenwick(len(uniqueSpeeds))\n\n\nans = 0\nfor i in ascDist:\n    speedId = bisect.bisect_left(uniqueSpeeds, v[i])\n    count, dsum = tree.query(speedId+1)\n    ans += count*x[i] - dsum\n    tree.update(speedId, x[i])\n\nprint(ans)\n\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nX=list(map(int,input().split()))\nV=list(map(int,input().split()))\n\nXV=[(X[i],V[i]) for i in range(n)]\n\n#compression_dict_x={a: ind for ind, a in enumerate(sorted(set(X)))}\ncompression_dict_v={a: ind+2 for ind, a in enumerate(sorted(set(V)))}\n\nXV=[(XV[i][0], compression_dict_v[XV[i][1]]) for i in range(n)]\nXV.sort(reverse=True)\n\nLEN=len(compression_dict_v)+3\n\nBIT1=[0]*(LEN+1)\n\ndef update1(v,w):\n    while v<=LEN:\n        BIT1[v]+=w\n        v+=(v&(-v))\n\ndef getvalue1(v):\n    ANS=0\n    while v!=0:\n        ANS+=BIT1[v]\n        v-=(v&(-v))\n    return ANS\n\nBIT2=[0]*(LEN+1)\n\ndef update2(v,w):\n    while v<=LEN:\n        BIT2[v]+=w\n        v+=(v&(-v))\n\ndef getvalue2(v):\n    ANS=0\n    while v!=0:\n        ANS+=BIT2[v]\n        v-=(v&(-v))\n    return ANS\n\nANS=0\nfor x,v in XV:\n    ANS+=(getvalue2(LEN)-getvalue2(v-1))-(getvalue1(LEN)-getvalue1(v-1))*x\n    #print(getvalue2(LEN),getvalue2(v-1),getvalue1(LEN),getvalue1(v-1))\n    #print(x,v,ANS)\n\n    update1(v,1)\n    update2(v,x)\n\nprint(ANS)\n"]