2022-04-13 19:16:12.883711 """
This problem is given in two editions, which differ exclusively in the constraints on the number $n$.

You are given an array of integers $a[1], a[2], \dots, a[n].$ A block is a sequence of contiguous (consecutive) elements $a[l], a[l+1], \dots, a[r]$ ($1 \le l \le r \le n$). Thus, a block is defined by a pair of indices $(l, r)$.

Find a set of blocks $(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$ such that:  They do not intersect (i.e. they are disjoint). Formally, for each pair of blocks $(l_i, r_i)$ and $(l_j, r_j$) where $i \neq j$ either $r_i < l_j$ or $r_j < l_i$.  For each block the sum of its elements is the same. Formally, $$a[l_1]+a[l_1+1]+\dots+a[r_1]=a[l_2]+a[l_2+1]+\dots+a[r_2]=$$ $$\dots =$$ $$a[l_k]+a[l_k+1]+\dots+a[r_k].$$  The number of the blocks in the set is maximum. Formally, there does not exist a set of blocks $(l_1', r_1'), (l_2', r_2'), \dots, (l_{k'}', r_{k'}')$ satisfying the above two requirements with $k' > k$.  $\left. \begin{array}{|l|l|l|l|l|l|} \hline 4 & {1} & {2} & {2} & {1} & {5} & {3} \\ \hline \end{array} \right.$ The picture corresponds to the first example. Blue boxes illustrate blocks. 

Write a program to find such a set of blocks.


-----Input-----

The first line contains integer $n$ ($1 \le n \le 1500$) — the length of the given array. The second line contains the sequence of elements $a[1], a[2], \dots, a[n]$ ($-10^5 \le a_i \le 10^5$).


-----Output-----

In the first line print the integer $k$ ($1 \le k \le n$). The following $k$ lines should contain blocks, one per line. In each line print a pair of indices $l_i, r_i$ ($1 \le l_i \le r_i \le n$) — the bounds of the $i$-th block. You can print blocks in any order. If there are multiple answers, print any of them.


-----Examples-----
Input
7
4 1 2 2 1 5 3

Output
3
7 7
2 3
4 5

Input
11
-5 -4 -3 -2 -1 0 1 2 3 4 5

Output
2
3 4
1 1

Input
4
1 1 1 1

Output
4
4 4
1 1
2 2
3 3
"""
2022-04-13 19:16:12.883726 --------------------------
2022-04-13 19:18:11.453767 {
  "choices": [
    {
      "finish_reason": "length",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\ndp = [[0]*(n+1) for _ in range(n+1)]\nfor i in range(n):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = dp[i][j-1] + a[j-1]\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\nfor i in range(n-1, -1, -1):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i+1, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i+1, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int,input().split()))\n\nprefix_sum = [a[0]]\nfor i in range(1,len(a)):\n    prefix_sum.append(prefix_sum[-1] + a[i])\n\nd = {}\nfor i in range(len(prefix_sum)):\n    if prefix_sum[i] not in d:\n        d[prefix_sum[i]] = [i+1]\n    else:\n        d[prefix_sum[i]].append(i+1)\n\nl = []\nfor k,v in d.items():\n    for i in range(len(v)):\n        for j in range(i,len(v)):\n            l.append((v[i],v[j]))\nl.sort(key=lambda x:x[1]-x[0],reverse=True)\n\nans = []\nfor i in range(len(l)):\n    if not ans:\n        ans.append(l[i])\n    else:\n        if l[i][0] > ans[-1][1]:\n            ans.append(l[i])\n\nprint(len(ans))\nfor i in ans:\n    print(str(i[0])+\" \"+str(i[1]))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef get_blocks(n, a):\n    blocks = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            blocks.append((i, j))\n    return blocks\n\ndef check_blocks(blocks, a):\n    for i in range(len(blocks)):\n        for j in range(i + 1, len(blocks)):\n            if blocks[i][0] <= blocks[j][0] <= blocks[i][1] or blocks[i][0] <= blocks[j][1] <= blocks[i][1]:\n                return False\n    return True\n\ndef block_sum(block, a):\n    return sum(a[block[0]:block[1]])\n\ndef get_valid_blocks(blocks, a):\n    valid_blocks = []\n    for block in blocks:\n        if block_sum(block, a) == block_sum((0, len(a)), a):\n            valid_blocks.append(block)\n    return valid_blocks\n\ndef get_max_blocks(blocks):\n    max_blocks = []\n    max_len = 0\n    for block in blocks:\n        if block[1] - block[0] > max_len:\n            max_blocks = [block]\n            max_len = block[1] - block[0]\n        elif block[1] - block[0] == max_len:\n            max_blocks.append(block)\n    return max_blocks\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    blocks = get_blocks(n, a)\n    blocks = get_valid_blocks(blocks, a)\n    blocks = get_max_blocks(blocks)\n    print(len(blocks))\n    for block in blocks:\n        print(block[0]+1, block[1])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\ns = 0\nfor i in range(n):\n    s += a[i]\n\nif s % n == 0:\n    print(n)\n    for i in range(n):\n        print(i+1, i+1)\nelse:\n    print(n-1)\n    print(1, n)\n    for i in range(1, n):\n        print(i, i)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = sum(a[i:j])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    for i in d:\n        d[i] = sorted(d[i])\n    for i in d:\n        if len(d[i]) == 1:\n            d.pop(i)\n    lst = []\n    for i in d:\n        for j in d[i]:\n            lst.append(j)\n    lst = sorted(lst)\n    ans = []\n    while lst:\n        x = lst.pop()\n        ans.append(x)\n        temp = []\n        for i in lst:\n            if x[1] <= i[0]:\n                temp.append(i)\n        lst = temp\n    print(len(ans))\n    for i in ans:\n        print(i[0]+1, i[1])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\ndef find_sets(a, n):\n    sets = []\n    set_sum = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = sum(a[i:j])\n            if s not in set_sum:\n                sets.append((i, j))\n                set_sum.append(s)\n    return sets\n\ndef check_sets(sets):\n    for i in range(len(sets)):\n        for j in range(i+1, len(sets)):\n            if sets[i][1] >= sets[j][0]:\n                return False\n    return True\n\nsets = find_sets(a, n)\nsets = list(filter(check_sets, sets))\nsets = sorted(sets, key=lambda x: x[1]-x[0], reverse=True)\n\nprint(len(sets))\nfor s in sets:\n    print(s[0]+1, s[1])"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\ns = 0\nfor i in range(n):\n    s += a[i]\n\nif s % n == 0:\n    print(n)\n    for i in range(n):\n        print(i+1, i+1)\nelse:\n    print(n-1)\n    for i in range(n):\n        if a[i] == s // n:\n            print(i+1, i+1)\n        else:\n            print(i+1, n)"
    }
  ],
  "created": 1649877373,
  "id": "cmpl-4wclJIsCTIoIiUfhNQeMtmMqct2Bk",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 19:18:11.454143 0 {
  "finish_reason": "length",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\ndp = [[0]*(n+1) for _ in range(n+1)]\nfor i in range(n):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = dp[i][j-1] + a[j-1]\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\nfor i in range(n-1, -1, -1):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i+1, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i+1, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\nfor i in range(n-1, -1, -1):\n    dp[i][i+1] = a[i]\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i, j+1))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\nfor i in range(n-1, -1, -1):\n    for j in range(i+2, n+1):\n        dp[i][j] = min(dp[i][k] for k in range(i, j))\n\n# dp[i][j] = the minimum sum of a contiguous subarray of a[i:j]\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i < k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] + dp[k][j] | i <= k <= j }\n# dp[i][j] = min { dp[i][k] | i <= k < j }\n# dp[i][j] = min { dp[i][k] + dp[k"
}
2022-04-13 19:18:11.454239 REASON length
2022-04-13 19:18:11.454244 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int,input().split()))\n\nprefix_sum = [a[0]]\nfor i in range(1,len(a)):\n    prefix_sum.append(prefix_sum[-1] + a[i])\n\nd = {}\nfor i in range(len(prefix_sum)):\n    if prefix_sum[i] not in d:\n        d[prefix_sum[i]] = [i+1]\n    else:\n        d[prefix_sum[i]].append(i+1)\n\nl = []\nfor k,v in d.items():\n    for i in range(len(v)):\n        for j in range(i,len(v)):\n            l.append((v[i],v[j]))\nl.sort(key=lambda x:x[1]-x[0],reverse=True)\n\nans = []\nfor i in range(len(l)):\n    if not ans:\n        ans.append(l[i])\n    else:\n        if l[i][0] > ans[-1][1]:\n            ans.append(l[i])\n\nprint(len(ans))\nfor i in ans:\n    print(str(i[0])+\" \"+str(i[1]))"
}
2022-04-13 19:18:11.454350 REASON stop
2022-04-13 19:18:11.454767 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef get_blocks(n, a):\n    blocks = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            blocks.append((i, j))\n    return blocks\n\ndef check_blocks(blocks, a):\n    for i in range(len(blocks)):\n        for j in range(i + 1, len(blocks)):\n            if blocks[i][0] <= blocks[j][0] <= blocks[i][1] or blocks[i][0] <= blocks[j][1] <= blocks[i][1]:\n                return False\n    return True\n\ndef block_sum(block, a):\n    return sum(a[block[0]:block[1]])\n\ndef get_valid_blocks(blocks, a):\n    valid_blocks = []\n    for block in blocks:\n        if block_sum(block, a) == block_sum((0, len(a)), a):\n            valid_blocks.append(block)\n    return valid_blocks\n\ndef get_max_blocks(blocks):\n    max_blocks = []\n    max_len = 0\n    for block in blocks:\n        if block[1] - block[0] > max_len:\n            max_blocks = [block]\n            max_len = block[1] - block[0]\n        elif block[1] - block[0] == max_len:\n            max_blocks.append(block)\n    return max_blocks\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    blocks = get_blocks(n, a)\n    blocks = get_valid_blocks(blocks, a)\n    blocks = get_max_blocks(blocks)\n    print(len(blocks))\n    for block in blocks:\n        print(block[0]+1, block[1])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:18:11.454817 REASON stop
2022-04-13 19:18:11.455183 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\ns = 0\nfor i in range(n):\n    s += a[i]\n\nif s % n == 0:\n    print(n)\n    for i in range(n):\n        print(i+1, i+1)\nelse:\n    print(n-1)\n    print(1, n)\n    for i in range(1, n):\n        print(i, i)"
}
2022-04-13 19:18:11.455234 REASON stop
2022-04-13 19:18:11.478157 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = sum(a[i:j])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    for i in d:\n        d[i] = sorted(d[i])\n    for i in d:\n        if len(d[i]) == 1:\n            d.pop(i)\n    lst = []\n    for i in d:\n        for j in d[i]:\n            lst.append(j)\n    lst = sorted(lst)\n    ans = []\n    while lst:\n        x = lst.pop()\n        ans.append(x)\n        temp = []\n        for i in lst:\n            if x[1] <= i[0]:\n                temp.append(i)\n        lst = temp\n    print(len(ans))\n    for i in ans:\n        print(i[0]+1, i[1])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:18:11.478267 REASON stop
2022-04-13 19:18:11.497440 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\nn = int(input())\na = list(map(int, input().split()))\n\ndef find_sets(a, n):\n    sets = []\n    set_sum = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = sum(a[i:j])\n            if s not in set_sum:\n                sets.append((i, j))\n                set_sum.append(s)\n    return sets\n\ndef check_sets(sets):\n    for i in range(len(sets)):\n        for j in range(i+1, len(sets)):\n            if sets[i][1] >= sets[j][0]:\n                return False\n    return True\n\nsets = find_sets(a, n)\nsets = list(filter(check_sets, sets))\nsets = sorted(sets, key=lambda x: x[1]-x[0], reverse=True)\n\nprint(len(sets))\nfor s in sets:\n    print(s[0]+1, s[1])"
}
2022-04-13 19:18:11.497540 REASON stop
2022-04-13 19:18:11.498324 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\ns = 0\nfor i in range(n):\n    s += a[i]\n\nif s % n == 0:\n    print(n)\n    for i in range(n):\n        print(i+1, i+1)\nelse:\n    print(n-1)\n    for i in range(n):\n        if a[i] == s // n:\n            print(i+1, i+1)\n        else:\n            print(i+1, n)"
}
2022-04-13 19:18:11.498397 REASON stop
