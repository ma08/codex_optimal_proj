2022-04-13 20:39:32.549385 """
Easy and hard versions are actually different problems, so read statements of both problems completely and carefully.

Summer vacation has started so Alice and Bob want to play and joy, but... Their mom doesn't think so. She says that they have to read some amount of books before all entertainments. Alice and Bob will read each book together to end this exercise faster.

There are $n$ books in the family library. The $i$-th book is described by three integers: $t_i$ — the amount of time Alice and Bob need to spend to read it, $a_i$ (equals $1$ if Alice likes the $i$-th book and $0$ if not), and $b_i$ (equals $1$ if Bob likes the $i$-th book and $0$ if not).

So they need to choose some books from the given $n$ books in such a way that:

  Alice likes at least $k$ books from the chosen set and Bob likes at least $k$ books from the chosen set;  the total reading time of these books is minimized (they are children and want to play and joy as soon a possible). 

The set they choose is the same for both Alice an Bob (it's shared between them) and they read all books together, so the total reading time is the sum of $t_i$ over all books that are in the chosen set.

Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$).

The next $n$ lines contain descriptions of books, one description per line: the $i$-th line contains three integers $t_i$, $a_i$ and $b_i$ ($1 \le t_i \le 10^4$, $0 \le a_i, b_i \le 1$), where:

  $t_i$ — the amount of time required for reading the $i$-th book;  $a_i$ equals $1$ if Alice likes the $i$-th book and $0$ otherwise;  $b_i$ equals $1$ if Bob likes the $i$-th book and $0$ otherwise. 


-----Output-----

If there is no solution, print only one integer -1. Otherwise print one integer $T$ — the minimum total reading time of the suitable set of books.


-----Examples-----
Input
8 4
7 1 1
2 1 1
4 0 1
8 1 1
1 0 1
1 1 1
1 0 1
3 0 0

Output
18

Input
5 2
6 0 0
9 0 0
1 0 1
2 1 1
5 1 0

Output
8

Input
5 3
3 0 0
2 1 0
3 1 0
5 0 1
3 0 1

Output
-1
"""
2022-04-13 20:39:32.549408 --------------------------
2022-04-13 20:41:30.219036 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfirst_line = input().split(\" \")\nn = int(first_line[0])\nk = int(first_line[1])\n\nbooks = []\nfor i in range(n):\n    line = input().split(\" \")\n    t = int(line[0])\n    a = int(line[1])\n    b = int(line[2])\n    books.append((t, a, b))\n\nbooks_by_a = sorted(books, key=lambda book: book[1])\nbooks_by_b = sorted(books, key=lambda book: book[2])\n\n#print(\"books_by_a\", books_by_a)\n#print(\"books_by_b\", books_by_b)\n\na_books = []\nb_books = []\n\nfor i in range(k):\n    a_books.append(books_by_a[i])\n    b_books.append(books_by_b[i])\n\nif a_books == b_books:\n    print(sum([book[0] for book in a_books]))\n    exit(0)\n\na_books.sort(key=lambda book: book[0])\nb_books.sort(key=lambda book: book[0])\n\n#print(\"a_books\", a_books)\n#print(\"b_books\", b_books)\n\na_books_set = set(a_books)\nb_books_set = set(b_books)\n\nif a_books_set.intersection(b_books_set):\n    print(sum([book[0] for book in a_books]))\n    exit(0)\n\na_books_set = set(a_books)\nb_books_set = set(b_books)\n\nfor i in range(k):\n    a_books_set.remove(a_books[i])\n    b_books_set.remove(b_books[i])\n\na_books_set = list(a_books_set)\nb_books_set = list(b_books_set)\n\n#print(\"a_books_set\", a_books_set)\n#print(\"b_books_set\", b_books_set)\n\na_books_set.sort(key=lambda book: book[0])\nb_books_set.sort(key=lambda book: book[0])\n\n#print(\"a_books_set\", a_books_set)\n#print(\"b_books_set\", b_books_set)\n\na_books_set_set = set(a_books_set)\nb_books_set_set = set(b_books_set)\n\nif a_books_set_set.intersection(b_books_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] + a_books_set[0][0])\n    exit(0)\n\nif a_books_set_set.intersection(b_books_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] + a_books_set[0][0])\n    exit(0)\n\na_books_set_set = set(a_books_set)\nb_books_set_set = set(b_books_set)\n\nfor i in range(k):\n    a_books_set_set.remove(a_books_set[i])\n    b_books_set_set.remove(b_books_set[i])\n\na_books_set_set = list(a_books_set_set)\nb_books_set_set = list(b_books_set_set)\n\na_books_set_set.sort(key=lambda book: book[0])\nb_books_set_set.sort(key=lambda book: book[0])\n\n#print(\"a_books_set_set\", a_books_set_set)\n#print(\"b_books_set_set\", b_books_set_set)\n\na_books_set_set_set = set(a_books_set_set)\nb_books_set_set_set = set(b_books_set_set)\n\nif a_books_set_set_set.intersection(b_books_set_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] - a_books_set[k-1][0] + a_books_set_set[k-1][0] + a_books_set_set[0][0])\n    exit(0)\n\nprint(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# Solution\n\nimport sys\nimport heapq\n\nclass Node:\n    def __init__(self, time, alice, bob):\n        self.time = time\n        self.alice = alice\n        self.bob = bob\n\ndef solve(n, k, books):\n    heap = []\n    heapq.heapify(heap)\n    heapq.heappush(heap, (0, Node(0, 0, 0)))\n    best = []\n    for _ in range(k + 1):\n        best.append(None)\n    while len(heap) > 0:\n        time, node = heapq.heappop(heap)\n        if node.alice >= k and node.bob >= k:\n            if best[node.alice] is None or best[node.alice] > node.time:\n                best[node.alice] = node.time\n            continue\n        if node.alice >= n or node.bob >= n:\n            continue\n        heapq.heappush(heap, (node.time + books[node.alice].time, Node(node.time + books[node.alice].time, node.alice + 1, node.bob)))\n        heapq.heappush(heap, (node.time + books[node.bob].time, Node(node.time + books[node.bob].time, node.alice, node.bob + 1)))\n    if best[k] is None:\n        print(-1)\n    else:\n        print(best[k])\n\nn, k = map(int, input().split())\nbooks = []\nfor _ in range(n):\n    books.append(Node(*map(int, input().split())))\nbooks.sort(key=lambda x: x.time)\nsolve(n, k, books)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    n, k = map(int, input().split())\n    t = []\n    a = []\n    b = []\n    for i in range(n):\n        tt, aa, bb = map(int, input().split())\n        t.append(tt)\n        a.append(aa)\n        b.append(bb)\n\n    # a_b = [(a[i], b[i], t[i]) for i in range(n)]\n    # a_b.sort(key=lambda x: x[2])\n    # print(a_b)\n\n    ta = [0] * n\n    tb = [0] * n\n    ta[0] = a[0]\n    tb[0] = b[0]\n    for i in range(1, n):\n        ta[i] = ta[i-1] + a[i]\n        tb[i] = tb[i-1] + b[i]\n    # print(ta)\n    # print(tb)\n\n    ta_tb = [(ta[i], tb[i], t[i]) for i in range(n)]\n    ta_tb.sort()\n    # print(ta_tb)\n\n    ans = float('inf')\n    for i in range(n):\n        if ta_tb[i][0] >= k:\n            j = i\n            while j < n and ta_tb[j][0] == ta_tb[i][0]:\n                j += 1\n            # print(i, j)\n            for x in range(i, j):\n                if ta_tb[x][1] >= k:\n                    ans = min(ans, ta_tb[x][2])\n                    break\n            else:\n                for x in range(i, j):\n                    if ta_tb[x][1] + ta_tb[i][0] - k >= k:\n                        ans = min(ans, ta_tb[x][2])\n                        break\n                else:\n                    ans = -1\n                    break\n        else:\n            ans = -1\n            break\n    print(ans)\n\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    books = []\n    for i in range(n):\n        books.append(list(map(int, sys.stdin.readline().split())))\n    books.sort()\n    a_count, b_count = 0, 0\n    a_books, b_books = [], []\n    for i in range(n):\n        a_books.append(books[i][1])\n        b_books.append(books[i][2])\n        a_count += books[i][1]\n        b_count += books[i][2]\n        if a_count >= k and b_count >= k:\n            break\n    if a_count < k or b_count < k:\n        print(-1)\n    else:\n        a_count, b_count, t = 0, 0, 0\n        for i in range(n):\n            if a_count < k and a_books[i] == 1:\n                a_count += 1\n                t += books[i][0]\n            elif b_count < k and b_books[i] == 1:\n                b_count += 1\n                t += books[i][0]\n            elif a_count >= k and b_count >= k:\n                break\n        print(t)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom collections import namedtuple\n\nBook = namedtuple(\"Book\", \"time alice bob\")\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    books = []\n    for i in range(n):\n        t, a, b = [int(x) for x in input().split()]\n        books.append(Book(time=t, alice=a, bob=b))\n\n    # sort by time\n    books.sort(key=lambda x: x.time)\n\n    # set up a list of all books that alice likes\n    alice_books = [x.time for x in books if x.alice == 1]\n    # set up a list of all books that bob likes\n    bob_books = [x.time for x in books if x.bob == 1]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books ="
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys, math\n\ndef main():\n    # read input\n    num_books, num_likes = [int(x) for x in sys.stdin.readline().split()]\n    books = [[int(x) for x in sys.stdin.readline().split()] for _ in range(num_books)]\n    # sort by time\n    books.sort(key=lambda x: x[0])\n    # check if possible\n    if num_likes > sum(x[1] for x in books) or num_likes > sum(x[2] for x in books):\n        print(-1)\n        return\n    # find the best solution\n    likes_a, likes_b = 0, 0\n    time = 0\n    for book in books:\n        if likes_a < num_likes and likes_b < num_likes:\n            if book[1] == 1 and book[2] == 1:\n                likes_a += 1\n                likes_b += 1\n                time += book[0]\n            elif likes_a < num_likes and book[1] == 1:\n                likes_a += 1\n                time += book[0]\n            elif likes_b < num_likes and book[2] == 1:\n                likes_b += 1\n                time += book[0]\n        elif likes_a < num_likes and book[1] == 1:\n            likes_a += 1\n            time += book[0]\n        elif likes_b < num_likes and book[2] == 1:\n            likes_b += 1\n            time += book[0]\n    print(time)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef books():\n    n, k = map(int, input().split())\n    t = []\n    a = []\n    b = []\n    for _ in range(n):\n        ta, aa, ba = map(int, input().split())\n        t.append(ta)\n        a.append(aa)\n        b.append(ba)\n    a_sum = [0] * (n + 1)\n    b_sum = [0] * (n + 1)\n    for i in range(n):\n        a_sum[i + 1] = a_sum[i] + a[i]\n        b_sum[i + 1] = b_sum[i] + b[i]\n    if a_sum[n] < k or b_sum[n] < k:\n        return -1\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            if a_sum[i] - a_sum[j] >= k and b_sum[i] - b_sum[j] >= k:\n                dp[i] = min(dp[i], dp[j] + sum(t[j:i]))\n    return dp[n]\n\nprint(books())"
    }
  ],
  "created": 1649882372,
  "id": "cmpl-4we3w6nw78LmLpmQ9rr601bJ42fYz",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:41:30.219488 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfirst_line = input().split(\" \")\nn = int(first_line[0])\nk = int(first_line[1])\n\nbooks = []\nfor i in range(n):\n    line = input().split(\" \")\n    t = int(line[0])\n    a = int(line[1])\n    b = int(line[2])\n    books.append((t, a, b))\n\nbooks_by_a = sorted(books, key=lambda book: book[1])\nbooks_by_b = sorted(books, key=lambda book: book[2])\n\n#print(\"books_by_a\", books_by_a)\n#print(\"books_by_b\", books_by_b)\n\na_books = []\nb_books = []\n\nfor i in range(k):\n    a_books.append(books_by_a[i])\n    b_books.append(books_by_b[i])\n\nif a_books == b_books:\n    print(sum([book[0] for book in a_books]))\n    exit(0)\n\na_books.sort(key=lambda book: book[0])\nb_books.sort(key=lambda book: book[0])\n\n#print(\"a_books\", a_books)\n#print(\"b_books\", b_books)\n\na_books_set = set(a_books)\nb_books_set = set(b_books)\n\nif a_books_set.intersection(b_books_set):\n    print(sum([book[0] for book in a_books]))\n    exit(0)\n\na_books_set = set(a_books)\nb_books_set = set(b_books)\n\nfor i in range(k):\n    a_books_set.remove(a_books[i])\n    b_books_set.remove(b_books[i])\n\na_books_set = list(a_books_set)\nb_books_set = list(b_books_set)\n\n#print(\"a_books_set\", a_books_set)\n#print(\"b_books_set\", b_books_set)\n\na_books_set.sort(key=lambda book: book[0])\nb_books_set.sort(key=lambda book: book[0])\n\n#print(\"a_books_set\", a_books_set)\n#print(\"b_books_set\", b_books_set)\n\na_books_set_set = set(a_books_set)\nb_books_set_set = set(b_books_set)\n\nif a_books_set_set.intersection(b_books_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] + a_books_set[0][0])\n    exit(0)\n\nif a_books_set_set.intersection(b_books_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] + a_books_set[0][0])\n    exit(0)\n\na_books_set_set = set(a_books_set)\nb_books_set_set = set(b_books_set)\n\nfor i in range(k):\n    a_books_set_set.remove(a_books_set[i])\n    b_books_set_set.remove(b_books_set[i])\n\na_books_set_set = list(a_books_set_set)\nb_books_set_set = list(b_books_set_set)\n\na_books_set_set.sort(key=lambda book: book[0])\nb_books_set_set.sort(key=lambda book: book[0])\n\n#print(\"a_books_set_set\", a_books_set_set)\n#print(\"b_books_set_set\", b_books_set_set)\n\na_books_set_set_set = set(a_books_set_set)\nb_books_set_set_set = set(b_books_set_set)\n\nif a_books_set_set_set.intersection(b_books_set_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] - a_books_set[k-1][0] + a_books_set_set[k-1][0] + a_books_set_set[0][0])\n    exit(0)\n\nprint(-1)"
}
2022-04-13 20:41:30.219547 REASON stop
2022-04-13 20:41:30.219929 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# Solution\n\nimport sys\nimport heapq\n\nclass Node:\n    def __init__(self, time, alice, bob):\n        self.time = time\n        self.alice = alice\n        self.bob = bob\n\ndef solve(n, k, books):\n    heap = []\n    heapq.heapify(heap)\n    heapq.heappush(heap, (0, Node(0, 0, 0)))\n    best = []\n    for _ in range(k + 1):\n        best.append(None)\n    while len(heap) > 0:\n        time, node = heapq.heappop(heap)\n        if node.alice >= k and node.bob >= k:\n            if best[node.alice] is None or best[node.alice] > node.time:\n                best[node.alice] = node.time\n            continue\n        if node.alice >= n or node.bob >= n:\n            continue\n        heapq.heappush(heap, (node.time + books[node.alice].time, Node(node.time + books[node.alice].time, node.alice + 1, node.bob)))\n        heapq.heappush(heap, (node.time + books[node.bob].time, Node(node.time + books[node.bob].time, node.alice, node.bob + 1)))\n    if best[k] is None:\n        print(-1)\n    else:\n        print(best[k])\n\nn, k = map(int, input().split())\nbooks = []\nfor _ in range(n):\n    books.append(Node(*map(int, input().split())))\nbooks.sort(key=lambda x: x.time)\nsolve(n, k, books)"
}
2022-04-13 20:41:30.220033 REASON stop
2022-04-13 20:41:30.220383 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    n, k = map(int, input().split())\n    t = []\n    a = []\n    b = []\n    for i in range(n):\n        tt, aa, bb = map(int, input().split())\n        t.append(tt)\n        a.append(aa)\n        b.append(bb)\n\n    # a_b = [(a[i], b[i], t[i]) for i in range(n)]\n    # a_b.sort(key=lambda x: x[2])\n    # print(a_b)\n\n    ta = [0] * n\n    tb = [0] * n\n    ta[0] = a[0]\n    tb[0] = b[0]\n    for i in range(1, n):\n        ta[i] = ta[i-1] + a[i]\n        tb[i] = tb[i-1] + b[i]\n    # print(ta)\n    # print(tb)\n\n    ta_tb = [(ta[i], tb[i], t[i]) for i in range(n)]\n    ta_tb.sort()\n    # print(ta_tb)\n\n    ans = float('inf')\n    for i in range(n):\n        if ta_tb[i][0] >= k:\n            j = i\n            while j < n and ta_tb[j][0] == ta_tb[i][0]:\n                j += 1\n            # print(i, j)\n            for x in range(i, j):\n                if ta_tb[x][1] >= k:\n                    ans = min(ans, ta_tb[x][2])\n                    break\n            else:\n                for x in range(i, j):\n                    if ta_tb[x][1] + ta_tb[i][0] - k >= k:\n                        ans = min(ans, ta_tb[x][2])\n                        break\n                else:\n                    ans = -1\n                    break\n        else:\n            ans = -1\n            break\n    print(ans)\n\n\nmain()"
}
2022-04-13 20:41:30.220431 REASON stop
2022-04-13 20:41:30.254350 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    books = []\n    for i in range(n):\n        books.append(list(map(int, sys.stdin.readline().split())))\n    books.sort()\n    a_count, b_count = 0, 0\n    a_books, b_books = [], []\n    for i in range(n):\n        a_books.append(books[i][1])\n        b_books.append(books[i][2])\n        a_count += books[i][1]\n        b_count += books[i][2]\n        if a_count >= k and b_count >= k:\n            break\n    if a_count < k or b_count < k:\n        print(-1)\n    else:\n        a_count, b_count, t = 0, 0, 0\n        for i in range(n):\n            if a_count < k and a_books[i] == 1:\n                a_count += 1\n                t += books[i][0]\n            elif b_count < k and b_books[i] == 1:\n                b_count += 1\n                t += books[i][0]\n            elif a_count >= k and b_count >= k:\n                break\n        print(t)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:41:30.254454 REASON stop
2022-04-13 20:41:30.275896 4 {
  "finish_reason": "length",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom collections import namedtuple\n\nBook = namedtuple(\"Book\", \"time alice bob\")\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    books = []\n    for i in range(n):\n        t, a, b = [int(x) for x in input().split()]\n        books.append(Book(time=t, alice=a, bob=b))\n\n    # sort by time\n    books.sort(key=lambda x: x.time)\n\n    # set up a list of all books that alice likes\n    alice_books = [x.time for x in books if x.alice == 1]\n    # set up a list of all books that bob likes\n    bob_books = [x.time for x in books if x.bob == 1]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books = [x.time for x in books if x.alice == 0 and x.bob == 0]\n\n    # set up a list of all books that only alice likes\n    only_alice_books = alice_books.copy()\n    for i in both_books:\n        only_alice_books.remove(i)\n\n    # set up a list of all books that only bob likes\n    only_bob_books = bob_books.copy()\n    for i in both_books:\n        only_bob_books.remove(i)\n\n    # if there are more books that only alice likes than k, then we can just take the first k of them\n    if len(only_alice_books) >= k:\n        alice_books = only_alice_books[0:k]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n    # otherwise, we need to take the first k-len(only_alice_books) books that both alice and bob like\n    else:\n        alice_books = both_books[0:k-len(only_alice_books)]\n        # if there are more books that only bob likes than k, then we can just take the first k of them\n        if len(only_bob_books) >= k:\n            bob_books = only_bob_books[0:k]\n        # otherwise, we need to take the first k-len(only_bob_books) books that both alice and bob like\n        else:\n            bob_books = both_books[0:k-len(only_bob_books)]\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # if we can't find k books that both alice and bob like, then we can't find a solution\n    if len(alice_books) < k or len(bob_books) < k:\n        print(-1)\n        return\n\n    # take the first k books that both alice and bob like\n    both_books = both_books[0:k]\n\n    # take the first k books that only alice likes\n    only_alice_books = only_alice_books[0:k]\n\n    # take the first k books that only bob likes\n    only_bob_books = only_bob_books[0:k]\n\n    # take the first k books that neither alice nor bob like\n    neither_books = neither_books[0:k]\n\n    # set up a list of all books that alice and bob like\n    both_books = [x.time for x in books if x.alice == 1 and x.bob == 1]\n\n    # set up a list of all books that alice likes but bob doesn't\n    alice_only_books = [x.time for x in books if x.alice == 1 and x.bob == 0]\n\n    # set up a list of all books that bob likes but alice doesn't\n    bob_only_books = [x.time for x in books if x.alice == 0 and x.bob == 1]\n\n    # set up a list of all books that neither alice nor bob like\n    neither_books ="
}
2022-04-13 20:41:30.276074 REASON length
2022-04-13 20:41:30.276081 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys, math\n\ndef main():\n    # read input\n    num_books, num_likes = [int(x) for x in sys.stdin.readline().split()]\n    books = [[int(x) for x in sys.stdin.readline().split()] for _ in range(num_books)]\n    # sort by time\n    books.sort(key=lambda x: x[0])\n    # check if possible\n    if num_likes > sum(x[1] for x in books) or num_likes > sum(x[2] for x in books):\n        print(-1)\n        return\n    # find the best solution\n    likes_a, likes_b = 0, 0\n    time = 0\n    for book in books:\n        if likes_a < num_likes and likes_b < num_likes:\n            if book[1] == 1 and book[2] == 1:\n                likes_a += 1\n                likes_b += 1\n                time += book[0]\n            elif likes_a < num_likes and book[1] == 1:\n                likes_a += 1\n                time += book[0]\n            elif likes_b < num_likes and book[2] == 1:\n                likes_b += 1\n                time += book[0]\n        elif likes_a < num_likes and book[1] == 1:\n            likes_a += 1\n            time += book[0]\n        elif likes_b < num_likes and book[2] == 1:\n            likes_b += 1\n            time += book[0]\n    print(time)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:41:30.276113 REASON stop
2022-04-13 20:41:30.276708 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef books():\n    n, k = map(int, input().split())\n    t = []\n    a = []\n    b = []\n    for _ in range(n):\n        ta, aa, ba = map(int, input().split())\n        t.append(ta)\n        a.append(aa)\n        b.append(ba)\n    a_sum = [0] * (n + 1)\n    b_sum = [0] * (n + 1)\n    for i in range(n):\n        a_sum[i + 1] = a_sum[i] + a[i]\n        b_sum[i + 1] = b_sum[i] + b[i]\n    if a_sum[n] < k or b_sum[n] < k:\n        return -1\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            if a_sum[i] - a_sum[j] >= k and b_sum[i] - b_sum[j] >= k:\n                dp[i] = min(dp[i], dp[j] + sum(t[j:i]))\n    return dp[n]\n\nprint(books())"
}
2022-04-13 20:41:30.276779 REASON stop
