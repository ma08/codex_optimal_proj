2022-04-13 17:22:08.965274 """
You are given a long decimal number $a$ consisting of $n$ digits from $1$ to $9$. You also have a function $f$ that maps every digit from $1$ to $9$ to some (possibly the same) digit from $1$ to $9$.

You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $a$, and replace each digit $x$ from this segment with $f(x)$. For example, if $a = 1337$, $f(1) = 1$, $f(3) = 5$, $f(7) = 3$, and you choose the segment consisting of three rightmost digits, you get $1553$ as the result.

What is the maximum possible number you can obtain applying this operation no more than once?


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) â€” the number of digits in $a$.

The second line contains a string of $n$ characters, denoting the number $a$. Each character is a decimal digit from $1$ to $9$.

The third line contains exactly $9$ integers $f(1)$, $f(2)$, ..., $f(9)$ ($1 \le f(i) \le 9$).


-----Output-----

Print the maximum number you can get after applying the operation described in the statement no more than once.


-----Examples-----
Input
4
1337
1 2 5 4 6 6 3 1 9

Output
1557

Input
5
11111
9 8 7 6 5 4 3 2 1

Output
99999

Input
2
33
1 1 1 1 1 1 1 1 1

Output
33
"""
2022-04-13 17:22:08.965283 --------------------------
2022-04-13 17:22:32.064041 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# SOLUTION\nn = int(input())\na = list(map(int, input()))\nf = list(map(int, input().split()))\n\ndef solve(a, f):\n    left = 0\n    right = 0\n    while left < len(a) and a[left] == f[a[left] - 1]:\n        left += 1\n    while right < len(a) and a[-right - 1] == f[a[-right - 1] - 1]:\n        right += 1\n    if left + right >= len(a):\n        return \"\".join(map(str, a))\n    else:\n        return \"\".join(map(str, a[:left] + [f[a[left] - 1]] + a[left+1:-right] + [f[a[-right-1] - 1]] + a[-right:]))\n\nprint(solve(a, f))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\nimport sys\n\nsys.stdin = open('input.txt', 'r')\nn = int(input())\na = input()\nf = [int(x) for x in input().split()]\n\nl = [0] * n\nr = [0] * n\n\nfor i in range(n):\n    if a[i] != '9':\n        l[i] = '9'\n    else:\n        l[i] = a[i]\n\nfor i in range(n - 1, -1, -1):\n    if a[i] != '1':\n        r[i] = '1'\n    else:\n        r[i] = a[i]\n\nans = ''\nfor i in range(n):\n    if l[i] == a[i]:\n        ans += a[i]\n    else:\n        ans += l[i]\n        break\n\nfor i in range(n - 1, -1, -1):\n    if r[i] == a[i]:\n        ans = a[i] + ans\n    else:\n        ans = r[i] + ans\n        break\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input()]\n    f = [int(x) for x in input().split()]\n\n    # Use a greedy approach to find the max number\n    # First, find the max number in a\n    max_num = max(a)\n    max_num_idx = a.index(max_num)\n\n    # Second, find the max number that can be obtained by using function f\n    max_f = max(f)\n    max_f_idx = f.index(max_f)\n\n    # Check if we should change the number\n    if max_f > max_num:\n        # If so, find where the max number occurs in a\n        a[max_num_idx] = max_f\n\n    # Use the function to change the rest of the numbers\n    a = [str(f[x-1]) for x in a]\n    print(\"\".join(a))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = input()\nf = [int(i) for i in input().split()]\n\na = list(map(int, a))\n\nfor i in range(n):\n    a[i] = f[a[i] - 1]\n\na = list(map(str, a))\n\nfor i in range(n):\n    if a[i] != '9':\n        for j in range(i+1, n):\n            if a[j] == '9':\n                a[i], a[j] = a[j], a[i]\n                break\n\nprint(''.join(a))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\ndef max_number(a,f):\n    a = list(a)\n    for i in range(len(a)):\n        a[i] = f[int(a[i])-1]\n    a = ''.join(a)\n    return a\n\nn = int(input())\na = input()\nf = list(map(int,input().split()))\n\n# the max number can be obtained by replacing the segment with the largest possible digit\n# the segment can be either the leftmost or rightmost segment\n# the segment can be either the whole number or a contiguous subsegment\n# the segment can be either a segment of the same digit or a segment of different digits\n\n# try replacing the leftmost segment\na_left = a[0]\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        break\n    a_left += a[i]\na_left = max_number(a_left,f)\n\n# try replacing the rightmost segment\na_right = a[-1]\nfor i in range(n-2,-1,-1):\n    if a[i] != a[i+1]:\n        break\n    a_right = a[i] + a_right\na_right = max_number(a_right,f)\n\n# try replacing the whole number\na_whole = max_number(a,f)\n\n# try replacing the whole number but with the largest possible digit\na_whole_max = ''\nfor i in range(n):\n    a_whole_max += str(f[-1])\n\nprint(max(a_left,a_right,a_whole,a_whole_max))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = list(input())\n    f = list(map(int, input().split()))\n    f = [f[int(i)-1] for i in a]\n    a = list(map(int, a))\n    for i in range(n-1):\n        if f[i] < f[i+1]:\n            a[i] = f[i]\n        else:\n            break\n    for i in reversed(range(1,n)):\n        if f[i-1] < f[i]:\n            a[i] = f[i]\n        else:\n            break\n    print(''.join(map(str, a)))\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# If a map is a bijection, then the result is the same as the input\nif len(set(f)) == 9:\n    print(a)\n    exit()\n\n# If a map is not a bijection, then the result is the same as the input except the maximum digit is replaced by the maximum digit in the map\nelse:\n    print(int(a.replace(str(max(a)), str(max(f)))))"
    }
  ],
  "created": 1649870529,
  "id": "cmpl-4wayvEskxRuy7be9c6kfvWwYxhn4Q",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 17:22:32.064330 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# SOLUTION\nn = int(input())\na = list(map(int, input()))\nf = list(map(int, input().split()))\n\ndef solve(a, f):\n    left = 0\n    right = 0\n    while left < len(a) and a[left] == f[a[left] - 1]:\n        left += 1\n    while right < len(a) and a[-right - 1] == f[a[-right - 1] - 1]:\n        right += 1\n    if left + right >= len(a):\n        return \"\".join(map(str, a))\n    else:\n        return \"\".join(map(str, a[:left] + [f[a[left] - 1]] + a[left+1:-right] + [f[a[-right-1] - 1]] + a[-right:]))\n\nprint(solve(a, f))"
}
2022-04-13 17:22:32.064365 REASON stop
2022-04-13 17:22:32.064813 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\nimport sys\n\nsys.stdin = open('input.txt', 'r')\nn = int(input())\na = input()\nf = [int(x) for x in input().split()]\n\nl = [0] * n\nr = [0] * n\n\nfor i in range(n):\n    if a[i] != '9':\n        l[i] = '9'\n    else:\n        l[i] = a[i]\n\nfor i in range(n - 1, -1, -1):\n    if a[i] != '1':\n        r[i] = '1'\n    else:\n        r[i] = a[i]\n\nans = ''\nfor i in range(n):\n    if l[i] == a[i]:\n        ans += a[i]\n    else:\n        ans += l[i]\n        break\n\nfor i in range(n - 1, -1, -1):\n    if r[i] == a[i]:\n        ans = a[i] + ans\n    else:\n        ans = r[i] + ans\n        break\n\nprint(ans)"
}
2022-04-13 17:22:32.064929 REASON stop
2022-04-13 17:22:32.065334 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input()]\n    f = [int(x) for x in input().split()]\n\n    # Use a greedy approach to find the max number\n    # First, find the max number in a\n    max_num = max(a)\n    max_num_idx = a.index(max_num)\n\n    # Second, find the max number that can be obtained by using function f\n    max_f = max(f)\n    max_f_idx = f.index(max_f)\n\n    # Check if we should change the number\n    if max_f > max_num:\n        # If so, find where the max number occurs in a\n        a[max_num_idx] = max_f\n\n    # Use the function to change the rest of the numbers\n    a = [str(f[x-1]) for x in a]\n    print(\"\".join(a))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 17:22:32.065486 REASON stop
2022-04-13 17:22:32.066685 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = input()\nf = [int(i) for i in input().split()]\n\na = list(map(int, a))\n\nfor i in range(n):\n    a[i] = f[a[i] - 1]\n\na = list(map(str, a))\n\nfor i in range(n):\n    if a[i] != '9':\n        for j in range(i+1, n):\n            if a[j] == '9':\n                a[i], a[j] = a[j], a[i]\n                break\n\nprint(''.join(a))"
}
2022-04-13 17:22:32.066747 REASON stop
2022-04-13 17:22:32.068758 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\ndef max_number(a,f):\n    a = list(a)\n    for i in range(len(a)):\n        a[i] = f[int(a[i])-1]\n    a = ''.join(a)\n    return a\n\nn = int(input())\na = input()\nf = list(map(int,input().split()))\n\n# the max number can be obtained by replacing the segment with the largest possible digit\n# the segment can be either the leftmost or rightmost segment\n# the segment can be either the whole number or a contiguous subsegment\n# the segment can be either a segment of the same digit or a segment of different digits\n\n# try replacing the leftmost segment\na_left = a[0]\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        break\n    a_left += a[i]\na_left = max_number(a_left,f)\n\n# try replacing the rightmost segment\na_right = a[-1]\nfor i in range(n-2,-1,-1):\n    if a[i] != a[i+1]:\n        break\n    a_right = a[i] + a_right\na_right = max_number(a_right,f)\n\n# try replacing the whole number\na_whole = max_number(a,f)\n\n# try replacing the whole number but with the largest possible digit\na_whole_max = ''\nfor i in range(n):\n    a_whole_max += str(f[-1])\n\nprint(max(a_left,a_right,a_whole,a_whole_max))"
}
2022-04-13 17:22:32.068830 REASON stop
2022-04-13 17:22:32.070257 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = list(input())\n    f = list(map(int, input().split()))\n    f = [f[int(i)-1] for i in a]\n    a = list(map(int, a))\n    for i in range(n-1):\n        if f[i] < f[i+1]:\n            a[i] = f[i]\n        else:\n            break\n    for i in reversed(range(1,n)):\n        if f[i-1] < f[i]:\n            a[i] = f[i]\n        else:\n            break\n    print(''.join(map(str, a)))\n\nmain()"
}
2022-04-13 17:22:32.070317 REASON stop
2022-04-13 17:22:32.093645 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# If a map is a bijection, then the result is the same as the input\nif len(set(f)) == 9:\n    print(a)\n    exit()\n\n# If a map is not a bijection, then the result is the same as the input except the maximum digit is replaced by the maximum digit in the map\nelse:\n    print(int(a.replace(str(max(a)), str(max(f)))))"
}
2022-04-13 17:22:32.093766 REASON stop
