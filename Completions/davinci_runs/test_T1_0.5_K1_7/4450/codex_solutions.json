["\n\nimport heapq\n\ndef dijkstra(graph, start, end):\n    \"\"\"\n    Function to find the shortest path between two nodes in a graph using Dijkstra's algorithm\n    :param graph: a dictionary of dictionaries representing the graph\n    :param start: the starting node\n    :param end: the ending node\n    :return: a tuple of the shortest distance and the path\n    \"\"\"\n    # Create a priority queue to be used in the algorithm\n    queue = [(0, start)]\n\n    # Create a dictionary to store the shortest distance to each node\n    dist = {start: 0}\n\n    # Create a dictionary to store the previous node in the shortest path to each node\n    prev = {start: None}\n\n    # Create a dictionary to store if a node has been visited\n    visited = {start: False}\n\n    # While the queue is not empty\n    while queue:\n        # Pop the first node in the queue\n        dist_u, u = heapq.heappop(queue)\n\n        # If the node has not been visited\n        if not visited[u]:\n            # Mark the node as visited\n            visited[u] = True\n\n            # For each of the adjacent nodes\n            for v, dist_uv in graph[u].items():\n                # If the node has not been visited\n                if not visited[v]:\n                    # If the distance to the node is less than the shortest distance to the node\n                    if dist_u + dist_uv < dist.get(v, float('inf')):\n                        # Update the shortest distance to the node and the previous node\n                        dist[v] = dist_u + dist_uv\n                        prev[v] = u\n                        # Push the node onto the queue\n                        heapq.heappush(queue, (dist[v], v))\n\n    # Create a list to store the path\n    path = []\n\n    # Set the current node to the end node\n    u = end\n\n    # While the current node is not the start node\n    while prev[u]:\n        # Add the current node to the path\n        path.append(u)\n\n        # Set the current node to the previous node\n        u = prev[u]\n\n    # Add the start node to the path\n    path.append(start)\n\n    # Return the shortest distance and the path\n    return dist[end], path[::-1]\n\n\ndef main():\n    # Get the input\n    n, m, k = [int(x) for x in input().split()]\n\n    # Create a dictionary to store the graph\n    graph = {}\n\n    # For each of the edges\n    for _ in range(m):\n        # Get the edge\n        x, y, w = [int(x) for x in input().split()]\n\n        # If the edge is not in the graph\n        if x not in graph:\n            # Add the edge to the graph\n            graph[x] = {y: w}\n        else:\n            # Update the edge in the graph\n            graph[x][y] = w\n\n        # If the edge is not in the graph\n        if y not in graph:\n            # Add the edge to the graph\n            graph[y] = {x: w}\n        else:\n            # Update the edge in the graph\n            graph[y][x] = w\n\n    # Create a list to store the shortest paths\n    shortest_paths = []\n\n    # For each of the nodes\n    for i in range(1, n + 1):\n        # For each of the other nodes\n        for j in range(i + 1, n + 1):\n            # If the nodes are not the same\n            if i != j:\n                # Get the shortest path between the nodes\n                shortest_path, _ = dijkstra(graph, i, j)\n\n                # Add the shortest path to the list\n                shortest_paths.append(shortest_path)\n\n    # Sort the shortest paths\n    shortest_paths.sort()\n\n    # Print the kth shortest path\n    print(shortest_paths[k - 1])\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.V = len(vertices)\n        self.adj = [[] for i in range(self.V)]\n        \n    def addEdge(self, u, v, w):\n        self.adj[u].append((v, w))\n        self.adj[v].append((u, w))\n        \n    def dijkstra(self, s):\n        dist = [sys.maxsize]*self.V\n        dist[s] = 0\n        pq = []\n        heapq.heappush(pq, (0, s))\n        \n        while pq:\n            u = heapq.heappop(pq)\n            for v, w in self.adj[u[1]]:\n                if dist[u[1]] + w < dist[v]:\n                    dist[v] = dist[u[1]] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n    \n    def kthSmallest(self, k):\n        dist = []\n        for i in range(self.V):\n            dist.extend(self.dijkstra(i))\n        dist.sort()\n        return dist[k-1]\n        \nn, m, k = map(int, input().split())\nvertices = [i for i in range(n)]\ng = Graph(vertices)\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    g.addEdge(u-1, v-1, w)\n    \nprint(g.kthSmallest(k))", "\n\nimport heapq\n\nclass Solution(object):\n    def solve(self, n, m, k, edges):\n        graph = [[] for _ in range(n+1)]\n        for edge in edges:\n            x, y, w = edge\n            graph[x].append((y, w))\n            graph[y].append((x, w))\n\n        dist = [float('inf')] * (n+1)\n        dist[1] = 0\n        pq = [(0, 1)]\n        heapq.heapify(pq)\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if d + w < dist[v]:\n                    dist[v] = d + w\n                    heapq.heappush(pq, (d+w, v))\n\n        dist = sorted(dist[1:])\n        return dist[k-1]\n\nif __name__ == \"__main__\":\n    n, m, k = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        x, y, w = [int(x) for x in input().split()]\n        edges.append((x, y, w))\n    print(Solution().solve(n, m, k, edges))", "\n\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nn, m, k = map(int, input().split())\n\nedges = defaultdict(list)\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    edges[x].append((w, y))\n    edges[y].append((w, x))\n\ndistances = defaultdict(lambda: float('inf'))\ndistances[1] = 0\n\nheap = [(0, 1)]\nvisited = set()\n\nwhile heap:\n    d, v = heappop(heap)\n    if v in visited:\n        continue\n    visited.add(v)\n    for w, u in edges[v]:\n        if u not in visited and distances[u] > d + w:\n            distances[u] = d + w\n            heappush(heap, (d + w, u))\n\ndistances = sorted(distances.values())[1:]\nprint(distances[k - 1])", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def findShortestPaths(self, s):\n        dist = [math.inf] * self.V\n        dist[s] = 0\n        self.shortestPaths = []\n        self.traverse(s, dist)\n        self.shortestPaths.sort()\n\n    def traverse(self, s, dist):\n        for v, w in self.graph[s]:\n            if dist[v] > dist[s] + w:\n                dist[v] = dist[s] + w\n                self.traverse(v, dist)\n        for i in range(self.V):\n            if i != s:\n                self.shortestPaths.append(dist[i])\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    g = Graph(n)\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        g.addEdge(u - 1, v - 1, w)\n    g.findShortestPaths(0)\n    print(g.shortestPaths[k - 1])", "\nimport heapq\ndef dijkstra(s, n, graph):\n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    h = [(0, s)]\n    while h:\n        d, u = heapq.heappop(h)\n        if d > dist[u]: continue\n        for v, w in graph[u]:\n            if w + d < dist[v]:\n                dist[v] = w + d\n                heapq.heappush(h, (w + d, v))\n    return dist\n\n\ndef solve(n, m, k, graph):\n    dist = []\n    for i in range(1, n + 1):\n        dist += dijkstra(i, n, graph)[1:]\n    return sorted(dist)[k - 1]\n\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(m):\n        u, v, w = map(int, input().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    print(solve(n, m, k, graph))", "\n\nimport sys\nimport heapq\n\nclass Graph:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.graph = [[] for _ in range(n)]\n\t\n\tdef addEdge(self, u, v, w):\n\t\tself.graph[u].append((v, w))\n\t\tself.graph[v].append((u, w))\n\t\n\tdef dijkstra(self, src):\n\t\tdist = [sys.maxsize] * self.n\n\t\tdist[src] = 0\n\t\t\n\t\theap = [(0, src)]\n\t\twhile heap:\n\t\t\td, u = heapq.heappop(heap)\n\t\t\tif d > dist[u]:\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tfor v, w in self.graph[u]:\n\t\t\t\tif dist[u] + w < dist[v]:\n\t\t\t\t\tdist[v] = dist[u] + w\n\t\t\t\t\theapq.heappush(heap, (dist[v], v))\n\t\t\n\t\treturn dist\n\t\n\tdef kthShortestPath(self, k):\n\t\tdist = self.dijkstra(0)\n\t\tdist = sorted(dist[1:])\n\t\treturn dist[k-1]\n\ndef main():\n\tn, m, k = map(int, input().split())\n\tg = Graph(n)\n\t\n\tfor _ in range(m):\n\t\tu, v, w = map(int, input().split())\n\t\tg.addEdge(u-1, v-1, w)\n\t\n\tprint(g.kthShortestPath(k))\n\n\nif __name__ == \"__main__\":\n\tmain()"]