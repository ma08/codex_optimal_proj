["\n\nimport pprint\n\ndef solve(g):\n    \"\"\"\n    g is a graph represented as a dictionary:\n    {\n        node_1: [node_2, node_3, node_4],\n        node_2: [node_1, node_3],\n        node_3: [node_1, node_2],\n        node_4: [node_1]\n    }\n    \"\"\"\n    #print(\"Solving...\")\n    #pprint.pprint(g)\n    #print(\"\")\n    if len(g) == 1:\n        return \"\"\n    # find a leaf\n    for node, neighbours in g.items():\n        if len(neighbours) == 1:\n            # remove the leaf\n            del g[node]\n            # remove the leaf from the neighbours\n            g[neighbours[0]].remove(node)\n            # solve recursively\n            return \"0\" + solve(g)\n    # no leaf found\n    return \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    g = {}\n    for _ in range(m):\n        u, v = map(int, input().split())\n        if u not in g:\n            g[u] = []\n        if v not in g:\n            g[v] = []\n        g[u].append(v)\n        g[v].append(u)\n    print(solve(g))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, p, g, res):\n    for u in g[v]:\n        if u == p:\n            continue\n        if u in res:\n            return False\n        res.add(u)\n        dfs(u, v, g, res)\n    return True\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    g = defaultdict(set)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        g[u].add(v)\n        g[v].add(u)\n    res = set()\n    if dfs(1, -1, g, res):\n        print('YES')\n        for u, v in g.items():\n            for w in v:\n                if w > u and w in res:\n                    print('1', end='')\n                else:\n                    print('0', end='')\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().strip().split())\n    for _ in range(M):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        # ...\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    # read input\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    # solve problem\n    res = solve(n, edges)\n\n    # print output\n    if res is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(res)\n\n\ndef solve(n, edges):\n    # TODO: implement this function\n    return \"10100\"\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n\n\n\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    visited = [False for i in range(n)]\n    queue = deque([0])\n    visited[0] = True\n    ans = []\n    while queue:\n        u = queue.popleft()\n        for v in adj[u]:\n            if not visited[v]:\n                ans.append('0')\n                queue.append(v)\n                visited[v] = True\n            else:\n                ans.append('1')\n    if len(ans) == m:\n        print('YES')\n        print(''.join(ans))\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    main()", "\n\nfrom graphs import Graph, Edge\n\ndef main(graph: Graph):\n    def dfs(start, visited, parent=None):\n        visited[start] = True\n        for vertex in graph.adjacency_list[start]:\n            if vertex == parent:\n                continue\n            if visited[vertex]:\n                return False\n            if not dfs(vertex, visited, start):\n                return False\n        return True\n\n    visited = [False] * (graph.size + 1)\n    if not dfs(1, visited):\n        return \"NO\"\n\n    answer = \"\"\n    for edge in graph.edges:\n        if edge.from_vertex < edge.to_vertex:\n            answer += \"0\"\n        else:\n            answer += \"1\"\n    return \"YES\\n\" + answer\n\ndef parse_input(input_str: str) -> Graph:\n    lines = input_str.splitlines()\n    n, m = [int(x) for x in lines[0].split()]\n    edges = []\n    for line in lines[1:]:\n        u, v = [int(x) for x in line.split()]\n        edges.append(Edge(u, v))\n    return Graph(n, edges)\n\nif __name__ == '__main__':\n    graph = parse_input(input())\n    print(main(graph))", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        edges.append(list(map(int, input().split())))\n\n    result = [0] * m\n    for i in range(m):\n        if edges[i][0] == 1:\n            result[i] = 1\n        else:\n            break\n\n    print(\"YES\")\n    print(''.join(list(map(str, result))))\n\n\nif __name__ == \"__main__\":\n    main()"]