["A = input()\nB = input()\nC = input()\nturn = 'a'\nwhile True:\n  if turn == 'a':\n    if len(A) == 0:\n      print('A')\n      break\n    turn = A[0]\n    A = A[1:]\n  elif turn == 'b':\n    if len(B) == 0:\n      print('B')\n      break\n    turn = B[0]\n    B = B[1:]\n  else:\n    if len(C) == 0:\n      print('C')\n      break\n    turn = C[0]\n    C = C[1:]", "# ABC045\nfrom collections import deque\nS_A = deque(input())\nS_B = deque(input())\nS_C = deque(input())\n\n# \u6700\u521d\u306fA\u304b\u3089\nnext_turn = 'a'\n\nwhile True:\n    # \u52dd\u5229\u5224\u5b9a\n    if len(S_A) == 0 and next_turn == 'a':\n        print(\"A\")\n        return\n    elif len(S_B) == 0 and next_turn == 'b':\n        print(\"B\")\n        return\n    elif len(S_C) == 0 and next_turn == 'c':\n        print(\"C\")\n        return\n    else:\n        if next_turn == 'a':\n            next_turn = S_A.popleft()\n        elif next_turn == 'b':\n            next_turn = S_B.popleft()\n        elif next_turn == 'c':\n            next_turn = S_C.popleft()\n", "sa = list(input())\nsb = list(input())\nsc = list(input())\nmode = \"a\"\nwhile True:\n    if mode == \"a\":\n        if len(sa) == 0:\n            print(\"A\")\n            return\n        mode = sa.pop(0)\n    elif mode == \"b\":\n        if len(sb) == 0:\n            print(\"B\")\n            return\n        mode = sb.pop(0)\n    elif mode == \"c\":\n        if len(sc) == 0:\n            print(\"C\")\n            return\n        mode = sc.pop(0)\n", "from collections import deque\n\n\ndef discard(c: str, da: deque, db: deque, dc: deque) -> str:\n    if eval(f'len(d{c})'):\n        c = eval(f'd{c}.popleft()')\n    else:\n        return c.upper()\n\n    return discard(c, da, db, dc)\n\n\ndef answer(sa: str, sb: str, sc: str) -> str:\n    deque_a = deque(list(sa))\n    deque_b = deque(list(sb))\n    deque_c = deque(list(sc))\n    return discard(deque_a.popleft(), deque_a, deque_b, deque_c)\n\n\ndef main():\n    sa, sb, sc = [input() for _ in range(3)]\n    print(answer(sa, sb, sc))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "a=input()\nb=input()\nc=input()\ni=a\nwhile True:\n    if i[0]==\"a\":\n        if a==\"\" or (i==a and len(a)==1):\n            print(\"A\")\n            break\n        else:\n            if i==a:\n                a=a[1:]\n                i=a\n            elif i==b:\n                b=b[1:]\n                i=a\n            else:\n                c=c[1:]\n                i=a\n    elif i[0]==\"b\":\n        if b==\"\" or (i==b and len(b)==1):\n            print(\"B\")\n            break\n        else:\n            if i==a:\n                a=a[1:]\n                i=b\n            elif i==b:\n                b=b[1:]\n                i=b\n            else:\n                c=c[1:]\n                i=b\n    else:\n        if c==\"\" or (i==c and len(c)==1):\n            print(\"C\")\n            break\n        else:\n            if i==a:\n                a=a[1:]\n                i=c\n            elif i==b:\n                b=b[1:]\n                i=c\n            else:\n                c=c[1:]\n                i=c", "from collections import deque \nA=deque(list(input()))\nB=deque(input())\nC=deque(list(input()))\nnow='a'\nwhile len(A)>=0 and len(B)>=0 and len(C)>=0:\n  if now=='a':\n    if A:\n      now=A.popleft()\n    else:\n      print('A')\n      return\n  elif now=='b':\n    if B:\n      now=B.popleft()\n    else:\n      print('B')\n      return\n  else:\n    if C:\n      now=C.popleft()\n    else:\n      print('C')\n      return", "S = {}\nfor i in 'ABC':\n    S[i] = [w for w in input()]\nans = ''\njudge = True\nturn = S['A'].pop(0).upper()\nwhile judge:\n    if S[turn] == []:\n        ans = turn\n        judge = False\n    else:\n        turn = S[turn].pop(0).upper()\nprint(ans)", "a, b, c = input(), input(), input()\n\nif len(a) == 1:\n    print(\"A\")\n    return\n\nnext = a[0]\na = a[1:]\n\nwhile True:\n    try:\n        if next == \"a\":\n            next = a[0]\n            a = a[1:]\n        elif next == \"b\":\n            next = b[0]\n            b = b[1:]\n        elif next == \"c\":\n            next = c[0]\n            c = c[1:]\n    except:\n        if next == \"a\":\n            print(\"A\")\n        elif next == \"b\":\n            print(\"B\")\n        else:\n            print(\"C\")\n        return\n", "a,b,c = [input() for i in range(3)]\nsa = 'a'\nfor i in range(1796):\n  try:\n    if sa ==  'a':\n      sa = a[0]\n      a = a[1:]\n\n    elif sa ==  'b':\n      sa = b[0]\n      b = b[1:]\n\n    elif sa ==  'c':\n      sa = c[0]\n      c = c[1:]\n  except:\n    print(sa.upper())\n    break", "S_s = [input() for _ in range(3)]\nturn = 0\npos = [0, 0, 0]\ndic = {\"a\":0, \"b\":1, \"c\":2}\nwhile 1:\n    try:\n        n_turn = dic[S_s[turn][pos[turn]]]\n        pos[turn] += 1\n        turn = n_turn\n    except IndexError:\n        break\nprint(\"ABC\"[turn])", "SA = input()\nSB = input()\nSC = input()\n\npointer = SA[0]\nSA = SA[1:]\nd = {'a': SA, 'b': SB, 'c': SC}\n\nwhile True:\n    if d[pointer] == '':\n        ans = pointer\n        break\n    tmp = d[pointer][0]\n    d[pointer] = d[pointer][1:]\n    pointer = tmp\n\nprint(ans.upper())", "A = input()\nB = input()\nC = input()\nn = A[0]\nA = A[1:]\nwhile True:\n  if n == \"a\":\n    if len(A) == 0:\n      print(\"A\")\n      break\n    n = A[0]\n    A = A[1:]\n\n  elif n == \"b\":\n    if len(B) == 0:\n      print(\"B\") \n      break\n    n = B[0]\n    B = B[1:]\n  else:\n    if len(C) == 0:\n      print(\"C\")\n      break\n    n = C[0]\n    C = C[1:]\n            \n            \n            \n            \n            \n            \n      \n     \n", "a=list(input())\nb=list(input())\nc=list(input())\nabc=[a,b,c]\nname=['a','b','c']\nnow=0\nwhile True:\n\tif len(abc[now])==0:\n\t\tprint((name[now].upper()))\n\t\treturn\n\tnow=name.index(abc[now].pop(0))\n\n", "SA = input()\nSB = input()\nSC = input()\nR = SA[0]\nSA = SA[1:]\nwhile not R == \"\":\n    if R == \"a\":\n        R = SA[:1]\n        SA = SA[1:]\n        E = \"A\"\n    elif R == \"b\":\n        R = SB[:1]\n        SB = SB[1:]\n        E = \"B\"\n    else:\n        R = SC[:1]\n        SC = SC[1:]\n        E = \"C\"\nprint(E)\n", "from collections import deque\ns1 = str(input())\ns2 = str(input())\ns3 = str(input())\na = []\nb = []\nc = []\nfor i in range(len(s1)):\n    a.append(s1[i])\nfor i in range(len(s2)):\n    b.append(s2[i])\nfor i in range(len(s3)):\n    c.append(s3[i])\na = deque(a)\nb = deque(b)\nc = deque(c)\n\nx = a.popleft()\nwhile True:\n    if x == 'a':\n        if len(a) == 0:\n            print('A')\n            break\n        x = a.popleft()\n    elif x == 'b':\n        if len(b) == 0:\n            print('B')\n            break\n        x = b.popleft()\n    else:\n        if len(c) == 0:\n            print('C')\n            break\n        x = c.popleft()\n\n\n", "import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom functools import reduce\nfrom bisect import bisect_left, insort_left\nfrom heapq import heapify, heappush, heappop\n\nINPUT = lambda: sys.stdin.readline().rstrip()\nINT = lambda: int(INPUT())\nMAP = lambda: list(map(int, INPUT().split()))\nS_MAP = lambda: list(map(str, INPUT().split()))\nLIST = lambda: list(map(int, INPUT().split()))\nS_LIST = lambda: list(map(str, INPUT().split()))\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef main():\n    S = [INPUT() for _ in range(3)]\n    ctoi = lambda c: ord(c) - ord('a')\n\n    num = 0\n    while len(S[num]) > 0:\n        init = S[num][0]\n        S[num] = S[num][1:]\n        num = ctoi(init)\n\n    print((\"ABC\"[num]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "Sa = list(input())\nSb = list(input())\nSc = list(input())\nturn = Sa\nans =\"A\"\nwhile turn != []:\n  card =turn[0]\n  turn.pop(0)\n  if card ==\"a\":\n    turn =Sa\n    ans =\"A\"\n  elif card ==\"b\":\n    turn =Sb\n    ans =\"B\"\n  else:\n    turn =Sc\n    ans =\"C\"\nprint(ans)", "def check(n):\n  if n=='a':\n    if len(a)>0: check(a.pop())\n    else: print('A')\n  elif n=='b':\n    if len(b)>0: check(b.pop())\n    else: print('B')\n  elif n=='c':\n    if len(c)>0: check(c.pop())\n    else: print('C')\na,b,c=[[*input()][::-1] for _ in range(3)]\ncheck(a.pop())", "a=[input(),input(),input()]\nnow=0\nwhile a[now]:\n    y=a[now][0];a[now]=a[now][1:];now=ord(y)-ord('a')\nprint(\"ABC\"[now])", "S = {}\nS['a'] = input()\nS['b'] = input()\nS['c'] = input()\nturn = 'a'\nwhile True:\n    hand = S[turn]\n    if len(hand) == 0: break\n    S[turn] = hand[1:]\n    turn = hand[0]\n\nprint(turn.upper())", "s = {'a': input(), 'b': input(), 'c': input()}\n\nnow = 'a'\nwhile s[now] != '':\n    next = s[now][0]\n    s[now] = s[now][1:]\n    now = next\nprint(now.upper())", "import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\nfrom bisect import bisect, bisect_left, bisect_right\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef S_MAP(): return list(map(str, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\n \nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nA = deque(list(input()))\nB = deque(list(input()))\nC = deque(list(input()))\n\n# while len(A) == 0 or len(B) == 0 or len(C) == 0:\np = A.popleft()\nwhile 1:\n    if p == \"a\":\n        if len(A) == 0:\n            print(\"A\")\n            return\n        else:\n            p = A.popleft()\n    if p == \"b\":\n        if len(B) == 0:\n            print(\"B\")\n            return\n        else:\n            p = B.popleft()\n\n    if p == \"c\":\n        if len(C) == 0:\n            print(\"C\")\n            return\n        else:\n            p = C.popleft()\n    \n    \n\n", "a = list(input())\nb = list(input())\nc = list(input())\n\n\ndef check(x=\"a\"):\n    try:\n        if x == \"a\":\n            x = a.pop(0)\n            check(x)\n        elif x == \"b\":\n            x = b.pop(0)\n            check(x)\n        elif x == \"c\":\n            x = c.pop(0)\n            check(x)\n    except IndexError:\n        print((x.upper()))\n\n\ncheck()\n", "Sa = list(input())\nSb = list(input())\nSc = list(input())\nturn = Sa\nans = \"A\"\nwhile turn != []:\n    card = turn[0]\n    turn.pop(0)\n    if card == \"a\":\n        turn = Sa\n        ans = \"A\"\n    elif card == \"b\":\n        turn = Sb\n        ans = \"B\"\n    else:\n        turn = Sc\n        ans = \"C\"\nprint(ans)", "a = list(input())[::-1]\nb = list(input())[::-1]\nc = list(input())[::-1]\n\nabc = [a, b, c]\nnum1 = {'a':0, 'b':1, 'c':2}\nnum2 = ['A', 'B', 'C']\nd = 0\nwhile True:\n    if abc[d]:\n        d = num1[abc[d].pop()]\n    else:\n        break\nprint(num2[d])", "Cards = {'a':list(input()),'b':list(input()),'c':list(input())}\n\ndef solve(p):\n    nonlocal Cards\n    if len(Cards[p]) == 0:\n        return p.capitalize()\n    np = Cards[p].pop(0)\n    return solve(np)\n\nprint(solve('a'))", "a = list(input())\nb = list(input())\nc = list(input())\n\ntgt = a.pop(0)\n\nwhile True:\n    if tgt == 'a':\n        if a:\n            tgt = a.pop(0)\n        else:\n            ans = 'A'\n            break\n    elif tgt == 'b':\n        if b:\n            tgt = b.pop(0)\n        else:\n            ans = 'B'\n            break\n    else:\n        if c:\n            tgt = c.pop(0)\n        else:\n            ans = 'C'\n            break\nprint(ans)", "#\n# abc045 b\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"aca\naccc\nca\"\"\"\n        output = \"\"\"A\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"abcb\naacb\nbccc\"\"\"\n        output = \"\"\"C\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    A = list(input()) + [0]\n    B = list(input()) + [0]\n    C = list(input()) + [0]\n\n    T = \"a\"\n    while len(A) and len(B) and len(C):\n        if T == \"a\":\n            T = A.pop(0)\n        elif T == \"b\":\n            T = B.pop(0)\n        else:\n            T = C.pop(0)\n\n    if len(A) == 0:\n        print(\"A\")\n    elif len(B) == 0:\n        print(\"B\")\n    else:\n        print(\"C\")\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "d = { 'a':input(), 'b':input(), 'c':input() }\npointer = 'a'\nwhile True:\n    if 0 < len(d[pointer]):\n        tmp = d[pointer][0]\n        d[pointer] = d[pointer][1:]\n        pointer = tmp\n    else:\n        print((pointer.upper()))\n        break\n", "SA=str(input())+\"f\"\nSB=str(input())+\"f\"\nSC=str(input())+\"f\"\nA,B,C=1,0,0\ni=0\nx=SA[0]\n\nwhile i < len(SA + SB + SC):\n    if x == \"a\":\n        x = SA[A]\n        A+=1\n    elif x == \"b\":\n        x = SB[B]\n        B+=1\n    elif x == \"c\":\n        x = SC[C]\n        C+=1\n        \n    if A==len(SA):\n        ans=\"A\"\n        break\n    elif B==len(SB):\n        ans=\"B\"\n        break\n    elif C==len(SC):\n        ans=\"C\"\n        break\n    i+=1\nprint(ans)", "A,B,C = [input() for i in range(3)]\nturn=\"a\"\n\nwhile True:\n    if turn == \"a\":\n        if A == \"\":\n            print(\"A\")\n            break\n        turn = A[0]\n        A = A[1:]\n    elif turn == \"b\":\n        if B == \"\":\n            print(\"B\")\n            break\n        turn = B[0]\n        B = B[1:]\n    else:\n        if C == \"\":\n            print(\"C\")\n            break\n        turn = C[0]\n        C = C[1:] ", "Sa = input()\nSb = input()\nSc = input()\nS_dic = {0:'a', 1:'b', 2:'c'}\nS_dic_L = {0:'A', 1:'B', 2:'C'}\nS_dic_inv = {'a':0, 'b':1, 'c':2}\n\nS = [Sa, Sb, Sc]\n\ndef find_game(x):\n    if S[x] == '':\n        print((S_dic_L[x]))\n        return\n\n    else:\n        p = S[x][0]\n        S[x] = S[x][1:]\n\n        find_game(S_dic_inv[p])\n\nfind_game(0)\n", "S = {i:list(input()) for i in \"abc\"}\ns = \"a\"\nwhile S[s]:\n  s = S[s].pop(0)\nprint(s.upper())", "from collections import deque\n\ns = {}\n\ns = {\n    \"a\": deque(list(input())),\n    \"b\": deque(list(input())),\n    \"c\": deque(list(input())),\n}\n\nt = \"a\"\n\nwhile s[t]:\n    t = s[t].popleft()\n\nprint((t.upper()))\n", "A = [input() for _ in range(3)]\n\nnxt = A[0][0]\nA[0] = A[0][1:]\nwhile True:\n    now = ord(nxt) - ord('a')\n    if A[now] == '':\n        ans = chr(now + ord('A'))\n        break\n    nxt = A[now][0]\n    A[now] = A[now][1:]\n\nprint(ans)", "SA = input()\nSB = input()\nSC = input()\nS = {'a' : SA, 'b' : SB, 'c' : SC}\ncard = S['a'][0]\nwhile True:\n    if S[card] == '':\n        print(card.upper())\n        break\n    S[card], card = S[card][1:], S[card][0]", "from collections import deque\n\n\ndef main():\n    sas = deque(list(input()))\n    sbs = deque(list(input()))\n    scs = deque(list(input()))\n\n    deques = {\"A\": sas, \"B\": sbs, \"C\": scs}\n    player = \"A\"\n    while True:\n        if len(deques[player]) == 0:\n            ans = player\n            break\n        player_temp = deques[player].popleft()\n        player = player_temp.upper()\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a = list(input())\nb = list(input())\nc = list(input())\n\nA = len(a)\nB = len(b)\nC = len(c)\ncnta = 0\ncntb = 0\ncntc = 0\nfor i in range(A+B+C):\n    if i == 0:\n        cnta += 1\n        if cnta > A:\n            print(\"A\")\n            break\n        q = a[0]\n        a.pop(0)\n        continue\n    if q == \"b\":\n        cntb += 1\n        if cntb > B:\n            print(\"B\")\n            break\n        q = b[0]\n        b.pop(0)\n    \n    elif q == \"a\":\n        cnta += 1\n        if cnta > A:\n            print(\"A\")\n            break\n        q = a[0]\n        a.pop(0)\n\n    else:\n        cntc += 1\n        if cntc > C:\n            print(\"C\")\n            break\n        q = c[0]\n        c.pop(0)", "s = {'a': input(), 'b': input(), 'c': input()}\n \nnow = 'a'\nwhile s[now] != '':\n    next = s[now][0]\n    s[now] = s[now][1:]\n    now = next\nprint(now.upper())", "A = input()\nB = input()\nC = input()\n\nturn = 'a'\nwhile True:\n    num_card_A = len(A)\n    num_card_B = len(B)\n    num_card_C = len(C)\n    if turn == 'a':\n        if num_card_A == 0:\n            winner = 'A'\n            break\n        turn = A[0]\n        A = A[1:]\n    elif turn == 'b':\n        if num_card_B == 0:\n            winner = 'B'\n            break\n        turn = B[0]\n        B = B[1:]\n    elif turn == 'c':\n        if num_card_C == 0:\n            winner = 'C'\n            break\n        turn = C[0]\n        C = C[1:]\n\nprint(winner)", "def main():\n    SA = list(input())\n    SB = list(input())\n    SC = list(input())\n\n    SA.reverse()\n    SB.reverse()\n    SC.reverse()\n\n    turn = 'a'\n    for i in range(400):\n        if turn == 'a':\n            if len(SA) == 0:\n                print('A')\n                return\n            turn = SA.pop()\n        elif turn == 'b':\n            if len(SB) == 0:\n                print('B')\n                return\n            turn = SB.pop()\n        else:\n            if len(SC) == 0:\n                print('C')\n                return\n            turn = SC.pop()\n \ndef __starting_point():\n    main()\n\n__starting_point()", "S = {i:list(input()) for i in \"abc\"}\nn = \"a\"\nwhile S[n]:\n    n = S[n].pop(0)\n\nprint(n.upper())", "a, b, c = input(), input(), input()\nref = a[0]\na = a[1:]\nif len(a) == 0:\n    print(\"A\")\n    return\nfor _ in range(len(a)+len(b)+len(c)):\n    if ref == \"a\":\n        if len(a) == 0:\n            print(\"A\")\n            return\n        ref = a[0]\n        a = a[1:]\n\n    elif ref == \"b\":\n        if len(b) == 0:\n            print(\"B\")\n            return\n        ref = b[0]\n        b = b[1:]\n        \n    else:\n        if len(c) == 0:\n            print(\"C\")\n            return\n        ref = c[0]\n        c = c[1:]", "card = {c: list(input()) for c in \"abc\"}\ns = \"a\"\nwhile card[s]:\n  s = card[s].pop(0)\nprint(s.upper())", "S = {i: list(input()) for i in \"abc\"}\nn = \"a\"\nwhile S[n]:\n  n = S[n].pop(0)\n  \nprint(n.upper())", "A,B,C=[input() for i in range(0,3)]\n\nturn='a'\nwhile True:\n  if turn == 'a':\n    if A ==\"\":\n      print('A')\n      break\n    turn=A[0]\n    A=A[1:]\n  elif turn=='b':\n    if B==\"\":\n      print('B')\n      break\n    turn=B[0]\n    B=B[1:]\n  else:\n    if C==\"\":\n      print('C')\n      break\n    turn=C[0]\n    C=C[1:]", "s=[input() for i in range(3)]\nturn=[\"a\",\"b\",\"c\"]\nt=0\nwhile s[t]:\n    tt=turn.index(s[t][0])\n    s[t]=s[t][1:]\n    t=tt\nprint(turn[t].upper())", "S = [input() for _ in range(3)]\nnext = 0\ntemp = \"\"\nwin = \"\"\nwhile True:\n  if len(S[next]) == 0:\n    win = [\"A\",\"B\",\"C\"][next]\n    break\n  temp = S[next][0]\n  S[next] = S[next][1:]\n  next = ord(temp)-97\nprint(win)", "cards_map = {}\ncards_map['A'] = list(input().upper())\ncards_map['B'] = list(input().upper())\ncards_map['C'] = list(input().upper())\ncurrent = 'A'\nwhile True:\n    if len(cards_map[current]) == 0:\n        break\n    else:\n        current = cards_map[current].pop(0)\nprint(current)", "A=input()\nB=input()\nC=input()\nmoto=A\nsuji=\"a\"\nwhile True:\n  if len(moto)==0:\n    if suji==\"a\":\n      print(\"A\")\n      return\n    if suji==\"b\":\n      print(\"B\")\n      return\n    if suji==\"c\":\n      print(\"C\")\n      return\n  s=moto[0]\n  if suji==\"a\":\n    A=A[1:]\n  if suji==\"b\":\n    B=B[1:]\n  if suji==\"c\":\n    C=C[1:]\n  if s==\"a\":\n    moto=A\n    suji=\"a\"\n  if s==\"b\":\n    moto=B\n    suji=\"b\"\n  if s==\"c\":\n    moto=C\n    suji=\"c\"", "G = {}\nl =[\"a\",\"b\",\"c\"]\nfor i in l:\n  G[i] = list(input())\ns = l[0]\nwhile(True):\n  if len(G[s]) ==0:\n    print((s.upper()))\n    break\n  s = G[s].pop(0)\n", "a = list(input())\nb = list(input())\nc = list(input())\nnext = a.pop(0)\nwhile True:\n  if next == \"a\":\n    if a == []:\n      print(\"A\")\n      break\n    else:\n      next = a.pop(0)\n  elif next == \"b\":\n    if b == []:\n      print(\"B\")\n      break\n    else:\n      next = b.pop(0)\n  else:\n    if c == []:\n      print(\"C\")\n      break\n    else:\n      next =c.pop(0)", "a = input()\nb = input()\nc = input()\n\nd = 'A'\nwhile True:\n  if d == 'A':\n    if len(a) == 0:\n      break\n    s = a[0]\n    a = a[1:]\n  elif d == 'B':\n    if len(b) == 0:\n      break\n    s = b[0]\n    b = b[1:]\n  else:\n    if len(c) == 0:\n      break\n    s = c[0]\n    c = c[1:]\n  if s == 'a':\n    d = 'A'\n  elif s == 'b':\n    d = 'B'\n  else:\n    d = 'C'\nprint (d)\n", "a = input()\nb = input()\nc = input()\n\nturn = 'a'\nwhile True:\n    if turn == 'a':\n        if a == '':\n            print('A')\n            return\n        elif a[0] == 'a':\n            turn = 'a'\n        elif a[0] == 'b':\n            turn = 'b'\n        else:\n            turn = 'c'\n        a = a[1:]\n    elif turn == 'b':\n        if b == '':\n            print('B')\n            return\n        elif b[0] == 'a':\n            turn = 'a'\n        elif b[0] == 'b':\n            turn = 'b'\n        else:\n            turn = 'c'\n        b = b[1:]\n    else:\n        if c == '':\n            print('C')\n            return\n        elif c[0] == 'a':\n            turn = 'a'\n        elif c[0] == 'b':\n            turn = 'b'\n        else:\n            turn = 'c'\n        c = c[1:]\n", "a_line = input()\na_line = list(a_line)\n#print(a_line)\nb_line = input()\nb_line = list(b_line)\n\nc_line = input()\nc_line = list(c_line)\n\nend = 0\nturn = \"a\"\n\nwhile(end == 0):\n    if turn==\"a\":\n        if len(a_line) == 0:\n            end = \"A\"\n        else:\n            temp = a_line[0]\n            del a_line[0]\n            #print(a_line)\n            turn = temp\n        \n        \n    elif turn==\"b\":\n        if len(b_line) == 0:\n            end = \"B\"\n        else:\n            temp = b_line[0]\n            del b_line[0]\n            #print(b_line)\n            turn = temp    \n    \n    else:\n        if len(c_line) == 0:\n            end = \"C\"\n        else:\n            temp = c_line[0]\n            del c_line[0]\n            #print(b_line)\n            turn = temp    \n        \n        \nprint(end)        ", "s=[list(input()) for i in range(3)]\nturn=[\"a\",\"b\",\"c\"]\nt=0\nwhile s[t]:\n    t=turn.index(s[t].pop(0))\nprint(turn[t].upper())", "Sa = input()\nSb = input()\nSc = input()\n\nnow = 'a'\nwhile True:\n    # if len(Sa) == 0 or len(Sb) == 0 or len(Sc) == 0:\n    #     break\n    if now == 'a':\n        if len(Sa) == 0:\n            print((now.capitalize()))\n            return\n        now = Sa[0]\n        Sa = Sa[1:len(Sa) + 1]\n        continue\n\n    elif now == 'b':\n        if len(Sb) == 0:\n            print((now.capitalize()))\n            return\n        now = Sb[0]\n        Sb = Sb[1:len(Sb) + 1]\n        continue\n\n    elif now == 'c':\n        if len(Sc) == 0:\n            print((now.capitalize()))\n            return\n        now = Sc[0]\n        Sc = Sc[1:len(Sc) + 1]\n        continue\n", "a=input()\nb=input()\nc=input()\na+=\"A\"\nb+=\"B\"\nc+=\"C\"\nn=a\nwhile True:\n  if len(n)>1:\n    k=n[0]\n    if n==a:\n      a=a[1:]\n    elif n==b:\n      b=b[1:]\n    else:\n      c=c[1:]\n    if k==\"a\":\n      n=a\n    elif k==\"b\":\n      n=b\n    else:\n      n=c\n  else:\n    print(n[-1])\n    break", "from collections import deque\na=deque(input())\nb=deque(input())\nc=deque(input())\n\ns={\"a\":a,\"b\":b,\"c\":c}\nt=\"a\"\nwhile 1:\n    if s[t]==deque():\n        ans=t\n        break\n    t=s[t].popleft()\nprint(ans.upper())", "A=list(input())\nB=list(input())\nC=list(input())\nli=[A,B,C]\nsw=True\nk=0\nwhile sw==True:\n    if li[k][0]==\"a\":\n        del li[k][0]\n        k=0\n    elif li[k][0]==\"b\":\n        del li[k][0]\n        k=1\n    elif li[k][0]==\"c\":\n        del li[k][0]\n        k=2\n    if li[k]==[]:\n        sw=False\nans=[\"A\",\"B\",\"C\"]\nprint((ans[k]))\n", "a = list(str(input()))\nb = list(str(input()))\nc = list(str(input()))\nn = a.pop(0)\nm = 0\nwhile True:\n    if n == 'a':\n        if len(a) == 0:\n            break\n        n = a.pop(0)\n    elif n == 'b':\n        if len(b) == 0:\n            break\n        n = b.pop(0)\n    else:\n        if len(c) == 0:\n            break\n        n = c.pop(0)\nprint(n.upper())", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(S_A: str, S_B: str, S_C: str):\n    d = dict(list(zip(\"abc\", list(map(iter, [S_A, S_B, S_C])))))\n    try:\n        u = \"a\"\n        while True:\n            u = next(d[u])\n    except StopIteration:\n        return u.upper()\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S_A = next(tokens)  # type: str\n    S_B = next(tokens)  # type: str\n    S_C = next(tokens)  # type: str\n    print((solve(S_A, S_B, S_C)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "s=[input() for i in range(3)]\nturn=[\"a\",\"b\",\"c\"]\nt=0\nfor i in range(300):\n    if len(s[t])==0:\n        print((turn[t].upper()))\n        break\n    if turn[t]==s[t][0]:\n        s[t]=s[t][1:]\n        #print(s)\n    else:\n        tt=turn.index(s[t][0])\n        s[t]=s[t][1:]\n        t=tt\n        #print(s)\n", "sa = input()\nsb = input()\nsc = input()\ns = []\ns.append(sa.replace('a', '0').replace('b', '1').replace('c', '2'))\ns.append(sb.replace('a', '0').replace('b', '1').replace('c', '2'))\ns.append(sc.replace('a', '0').replace('b', '1').replace('c', '2'))\ni = 0\nwhile s[i]!='':\n    j = int(s[i][0])\n    s[i] = s[i][1:]\n    i = j\nans = 'ABC'\n\nprint(ans[i])", "Sa = input()\nSb = input()\nSc = input()\n\ntmp = Sa[0]\nSa = Sa[1:]\nwhile True:\n    if tmp == \"a\":\n        if not Sa:\n            print(\"A\")\n            return\n\n        tmp = Sa[0]\n        Sa = Sa[1:]\n\n    if tmp == \"b\":\n        if not Sb:\n            print(\"B\")\n            return\n\n        tmp = Sb[0]\n        Sb = Sb[1:]\n\n    if tmp == \"c\":\n        if not Sc:\n            print(\"C\")\n            return\n        tmp = Sc[0]\n        Sc = Sc[1:]", "from collections import deque\na = list(input())\nb = list(input())\nc = list(input())\n\na = deque(a)\nb = deque(b)\nc = deque(c)\n\nx = 'a'\nwhile True:\n    if x == 'a':\n        if a:\n            x = a.popleft()\n        else:\n            print('A')\n            return\n    elif x == 'b':\n        if b:\n            x = b.popleft()\n        else:\n            print('B')\n            return\n    else:\n        if c:\n            x = c.popleft()\n        else:\n            print('C')\n            return\n", "code_A = ord('A')\ncode_a = ord('a')\nA = [input() for _ in range(3)]\n\nnxt = A[0][0]\nA[0] = A[0][1:]\nwhile True:\n    now = ord(nxt) - code_a\n    if A[now] == '':\n        ans = chr(now + code_A)\n        break\n    nxt = A[now][0]\n    A[now] = A[now][1:]\n\nprint(ans)", "from collections import deque\na = deque(reversed(input()))\nb = deque(reversed(input()))\nc = deque(reversed(input()))\nne = a.pop()\nwhile(True):\n    if ne == 'a':\n        if not a: break\n        ne = a.pop()\n    elif ne == 'b':\n        if not b: break\n        ne = b.pop()\n    else:\n        if not c: break\n        ne = c.pop()\nprint(ne.upper())", "S = [\"\"] * 3\nS[0] = input()\nS[1] = input()\nS[2] = input()\nindex = [0] * 3\nturn = 0\n\nwhile True:\n    if index[turn] == len(S[turn]):\n        print((chr(ord('A') + turn)))\n        break\n    else:\n        nextTurn = ord(S[turn][index[turn]]) - ord('a')\n        index[turn] += 1\n        turn = nextTurn\n", "a = list(input())\nb = list(input())\nc = list(input())\n\nt = a.pop(0)\nl = 0\nwhile True:\n    if t == 'a':\n        if len(a) == 0:\n            break\n        t = a.pop(0)\n    elif t == 'b':\n        if len(b) == 0:\n            break\n        t = b.pop(0)\n    elif t == 'c':\n        if len(c) == 0:\n            break\n        t = c.pop(0)\n\nprint(t.upper())", "import numpy\na = list(input())\nb = list(input())\nc = list(input())\n\n\ndef check(x=\"a\"):\n    try:\n        if x == \"a\":\n            x = a.pop(0)\n            check(x)\n        elif x == \"b\":\n            x = b.pop(0)\n            check(x)\n        elif x == \"c\":\n            x = c.pop(0)\n            check(x)\n    except IndexError:\n        print((x.upper()))\n\n\ncheck()\n", "sa = input().replace('a', '0').replace('b', '1').replace('c', '2')\nsb = input().replace('a', '0').replace('b', '1').replace('c', '2')\nsc = input().replace('a', '0').replace('b', '1').replace('c', '2')\nsl = [sa, sb, sc]\nabc = ['A', 'B',' C']\nturn = 0\n\nwhile True:\n    if len(sl[turn]) == 0:\n        print(abc[turn])\n        return\n    else:\n        sl[turn], turn = sl[turn][1:], int(sl[turn][0])\n\nprint(sl)", "sa=input()+'a'\nsb=input()+'b'\nsc=input()+'c'\nst='a'\na=0\nb=0\nc=0\nwhile a<len(sa) and b<len(sb) and c<len(sc):\n  if st=='a':\n    st=sa[a]\n    a+=1\n  elif st=='b':\n    st=sb[b]\n    b+=1\n  else:\n    st=sc[c]\n    c+=1\nif a==len(sa):\n  print('A')\nelif b==len(sb):\n  print('B')\nelse:\n  print('C')", "s=[list(input()) for i in range(3)]\nn=[len(s[0]), len(s[1]), len(s[2])]\ncount = [0, 0, 0]\nturn = 0\n\nwhile(True):\n  #print(count, n)\n  count[turn] += 1\n  if count[0] > n[0]:\n    print(\"A\")\n    break\n  elif count[1] > n[1]:\n    print(\"B\")\n    break\n  elif count[2] > n[2]:\n    print(\"C\")\n    break\n  turn = ord(s[turn][count[turn]-1])-97\n  #print(count, turn)\n\n", "import sys\nimport re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nS = [deque(input().replace('a', '0').replace('b', '1').replace('c', '2')) for _ in range(3)]\n\nnext = '0'\nwhile True:\n    tmp = S[int(next)]\n    if len(tmp) == 0:\n        ans = next\n        break\n    else:\n        next = tmp.popleft()\n\nif ans == '0':\n    print('A')\nelif ans == '1':\n    print('B')\nelse:\n    print('C')\n", "a,b,c = [str(input()) for i in range(3)]\ncurrent = 'a'\nwhile True:\n  try:\n    cur = current[len(current)-1]\n    if cur == 'a':\n      current+=a[0]\n      a=a[1:]\n    elif cur == 'b':\n      current+=b[0]\n      b=b[1:]\n    elif cur == 'c':\n      current+=c[0]\n      c=c[1:]\n  except:\n      print(current[len(current)-1].upper())\n      break", "sa = list(input())\nsb = list(input())\nsc = list(input())\nturn = \"a\"\nfor i in range(len(sa+sb+sc)):\n    if turn == \"a\":\n        if len(sa) == 0:\n            print(\"A\")\n            break\n        else:\n            turn = sa[0]\n            sa.remove(sa[0])\n    elif turn == \"b\":\n        if len(sb) == 0:\n            print(\"B\")\n            break\n        else:\n            turn = sb[0]\n            sb.remove(sb[0])\n    else:\n        if len(sc) == 0:\n            print(\"C\")\n            break\n        else:\n            turn = sc[0]\n            sc.remove(sc[0])", "SA = list(input())\nSB = list(input())\nSC = list(input())\n\nx = 'a'\n\nwhile True:\n    if x == 'a':\n        if len(SA)==0:\n            print('A')\n            return\n        x = SA[0]\n        SA.remove(x)\n    if x == 'b':\n        if len(SB)==0:\n            print('B')\n            return\n        x = SB[0]\n        SB.remove(x)\n    if x == 'c':\n        if len(SC)==0:\n            print('C')\n            return\n        x = SC[0]\n        SC.remove(x)\n\n", "#68 B - 3\u4eba\u3067\u30ab\u30fc\u30c9\u30b2\u30fc\u30e0\u30a4\u30fc\u30b8\u30fc\nfrom collections import deque\nSa = deque(input())\nSb = deque(input())\nSc = deque(input())\n\nturn = 0\nwhile True:\n    if turn == 0:\n        if len(Sa) == 0:\n            ans = 'A'\n            break\n        tgt = Sa.popleft()\n        if tgt == 'b':\n            turn = 1\n        elif tgt == 'c':\n            turn = 2\n    if turn == 1:\n        if len(Sb) == 0:\n            ans = 'B'\n            break\n        tgt = Sb.popleft()\n        if tgt == 'a':\n            turn = 0\n        elif tgt == 'c':\n            turn = 2\n    if turn == 2:\n        if len(Sc) == 0:\n            ans = 'C'\n            break\n        tgt = Sc.popleft()\n        if tgt == 'a':\n            turn = 0\n        elif tgt == 'b':\n            turn = 1\nprint(ans)", "a = input()\nb = input()\nc = input()\nnext = a[0]\na = a[1:]\nwhile True:\n  if next == \"a\":\n    if a == \"\":\n      print(\"A\")\n      break\n    else:\n      next = a[0]\n      a = a[1:]\n  elif next == \"b\":\n    if b == \"\":\n      print(\"B\")\n      break\n    else:\n      next = b[0]\n      b = b[1:]\n  else:\n    if c == \"\":\n      print(\"C\")\n      break\n    else:\n      next = c[0]\n      c = c[1:]", "s = [input() for i in range(3)]\nt = [\"a\", \"b\", \"c\"]\ncur = 0\nwhile len(s[cur]) > 0:\n  next = s[cur][0]\n  s[cur] = s[cur][1:]\n  cur = t.index(next)\nprint(t[cur].upper())", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\ndef solve():\n    S = [deque(ins()) for _ in range(3)]\n    abc = {\"a\": 0, \"b\": 1, \"c\": 2}\n    i = 0\n    while True:\n        if not S[i]:\n            return i\n        x = S[i].popleft()\n        i = abc[x]\n    return\n\n\nprint(\"ABC\"[solve()])\n", "class Combination:\n    def __init__(self, n, mod):\n        self.n = n\n        self.mod = mod\n        self.fac = [1 for i in range(self.n + 1)]\n        self.finv = [1 for i in range(self.n + 1)]\n        for i in range(2, self.n+1):\n            self.fac[i] = (self.fac[i - 1] * i) % self.mod\n            self.finv[i] = (self.finv[i-1] * pow(i, -1, self.mod)) % self.mod\n\n    def comb(self, n, m):\n        return self.fac[n] * (self.finv[n-m] * self.finv[m] % self.mod) % self.mod\ndef iparse():\n    return list(map(int, input().split()))\n\ndef __starting_point():\n    s = [list(input()) for i in range(3)]\n    for e in s:\n        e.reverse()\n    \n    turn = 0\n    while True:\n        if len(s[turn]) == 0:\n            break\n        tmp = s[turn].pop()\n        if tmp == 'a':\n            turn = 0\n        elif tmp == 'b':\n            turn = 1\n        else:\n            turn = 2\n\n    if turn == 0:\n        print(\"A\")\n    elif turn == 1:\n        print(\"B\")\n    else:\n        print(\"C\")\n        \n    \n\n__starting_point()", "a = list(map(str,input()))\nb = list(map(str,input()))\nc = list(map(str,input()))\ns = a.pop(0)\nwhile True:\n  if a == [] and s == \"a\":\n    print(\"A\")\n    return\n  elif b == [] and s == \"b\":\n    print(\"B\")\n    return\n  elif c == [] and s == \"c\":\n    print(\"C\")\n    return\n  if s == \"a\":\n    s = a.pop(0)\n  elif s == \"b\":\n    s = b.pop(0)\n  elif s == \"c\":\n    s = c.pop(0)\n", "a=input()\nb=input()\nc=input()\ni=0\nj=0\nk=0\nt='a'\nwhile 1:\n    if t=='a':\n        if i==len(a):\n            print('A')\n            break\n        t=a[i]\n        i+=1\n    elif t=='b':\n        if j==len(b):\n            print('B')\n            break\n        t=b[j]\n        j+=1\n    elif t=='c':\n        if k==len(c):\n            print('C')\n            break\n        t=c[k]\n        k+=1\n", "s=[0,0,0]\ns[0]=list(input())\ns[1]=list(input())\ns[2]=list(input())\nn=0\nfor i in range(100000):\n    if len(s[n])==0:\n        break\n    tmp=s[n].pop(0)\n    if tmp==\"a\":\n        n=0\n    elif tmp==\"b\":\n        n=1\n    else:\n        n=2\n\nif n==0:\n    print(\"A\")\nelif n==1:\n    print(\"B\")\nelse:\n    print(\"C\")", "#!/usr/bin/env python3\nimport sys\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    A = input()\n    B = input()\n    C = input()\n\n    w = 'a'\n    while True:\n        if w == 'a':\n            if A == '':\n                print('A')\n                return\n            w = A[0]\n            A = A[1:]\n        if w == 'b':\n            if B == '':\n                print('B')\n                return\n            w = B[0]\n            B = B[1:]\n        if w == 'c':\n            if C == '':\n                print('C')\n                return\n            w = C[0]\n            C = C[1:]\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a=list(input())\nb=list(input())\nc=list(input())\nans=\"a\"\nwhile True:\n  try:\n    if ans == \"a\":\n      ans=a[0]\n      a=a[1:]\n    elif ans == \"b\":\n      ans = b[0]\n      b=b[1:]\n    elif ans == \"c\":\n      ans = c[0]\n      c=c[1:]\n  except:\n    print((ans.upper()))\n    break\n", "sa = input()\nsb = input()\nsc = input()\n\nturn = sa[0]\nsa = sa[1:]\nwhile True:\n    if turn == \"a\":\n        if sa == \"\":\n            print(\"A\")\n            break\n        else:\n            turn = sa[0]\n            sa = sa[1:]\n    elif turn == \"b\":\n        if sb == \"\":\n            print(\"B\")\n            break\n        else:\n            turn = sb[0]\n            sb = sb[1:]\n    elif turn == \"c\":\n        if sc == \"\":\n            print(\"C\")\n            break\n        else:\n            turn = sc[0]\n            sc = sc[1:]\n", "from collections import deque\n\ndef main():\n\n    players = {\n        'a': None,\n        'b': None,\n        'c': None\n    }\n\n    for i in players:\n        players[i] = deque(tuple(input()))\n\n    card = 'a'\n    while players[card]:\n        card = players[card].popleft()\n\n    print(card.upper())\n\n\ndef __starting_point():\n    main()\n__starting_point()", "SA = input()\nSB = input()\nSC = input()\n\nindexA = 0\nindexB = 0\nindexC = 0\nturn = 'A'\nwinner = ''\nwhile 1:\n    if turn == 'A':\n        if indexA == len(SA):\n            winner = 'A'\n            break\n        if SA[indexA] == 'a':\n            turn = 'A'\n        elif SA[indexA] == 'b':\n            turn = 'B'\n        elif SA[indexA] == 'c':\n            turn = 'C'\n        indexA += 1\n    elif turn == 'B':\n        if indexB == len(SB):\n            winner = 'B'\n            break\n        if SB[indexB] == 'a':\n            turn = 'A'\n        elif SB[indexB] == 'b':\n            turn = 'B'\n        elif SB[indexB] == 'c':\n            turn = 'C'\n        indexB += 1\n    elif turn == 'C':\n        if indexC == len(SC):\n            winner = 'C'\n            break\n        if SC[indexC] == 'a':\n            turn = 'A'\n        elif SC[indexC] == 'b':\n            turn = 'B'\n        elif SC[indexC] == 'c':\n            turn = 'C'\n        indexC += 1\nprint(winner)\n", "a = list(input())\nb = list(input())\nc = list(input())\n\nD = {'a':a, 'b':b, 'c':c}\ncurr = 'a'\nwhile True:\n  tmp = D[curr]\n  if tmp == []:\n    break\n  curr = tmp.pop(0)\nprint((curr.upper()))\n  \n  \n", "SA = input()\nSB = input()\nSC = input()\n\nindexA = 0\nindexB = 0\nindexC = 0\nturn = 'A'\nwinner = ''\nwhile 1:\n    if turn == 'A':\n        if indexA == len(SA):\n            winner = 'A'\n            break\n        if SA[indexA] == 'a':\n            turn = 'A'\n        elif SA[indexA] == 'b':\n            turn = 'B'\n        elif SA[indexA] == 'c':\n            turn = 'C'\n        indexA += 1\n    elif turn == 'B':\n        if indexB == len(SB):\n            winner = 'B'\n            break\n        if SB[indexB] == 'a':\n            turn = 'A'\n        elif SB[indexB] == 'b':\n            turn = 'B'\n        elif SB[indexB] == 'c':\n            turn = 'C'\n        indexB += 1\n    elif turn == 'C':\n        if indexC == len(SC):\n            winner = 'C'\n            break\n        if SC[indexC] == 'a':\n            turn = 'A'\n        elif SC[indexC] == 'b':\n            turn = 'B'\n        elif SC[indexC] == 'c':\n            turn = 'C'\n        indexC += 1\nprint(winner)", "import collections as col\n\nA = str(input())\nB = str(input())\nC = str(input())\n\nA_queue = col.deque()\nB_queue = col.deque()\nC_queue = col.deque()\n\nfor i in range (0, len(A)):\n\tA_queue.append(A[i])\nfor i in range (0, len(B)):\n\tB_queue.append(B[i])\nfor i in range (0, len(C)):\n\tC_queue.append(C[i])\n\nD = ['a','b','c']\n  \nstart = 0  \nfor i in range (0, 300):\n\tif start == 0:\n\t\tif len(A_queue) == 0:\n\t\t\tprint('A')\n\t\t\treturn\n\t\telse:\n\t\t\tV = A_queue.popleft()\n\t\t\tstart = D.index(V)\n\telif start == 1:\n\t\tif len(B_queue) == 0:\n\t\t\tprint('B')\n\t\t\treturn\n\t\telse:\n\t\t\tV = B_queue.popleft()\n\t\t\tstart = D.index(V)     \n\telse:\n\t\tif len(C_queue) == 0:\n\t\t\tprint('C')\n\t\t\treturn\n\t\telse:\n\t\t\tV = C_queue.popleft()\n\t\t\tstart = D.index(V) ", "import sys\nimport math\nfrom collections import deque\n\n\ninint = lambda: int(sys.stdin.readline())\ninintm = lambda: map(int, sys.stdin.readline().split())\ninintl = lambda: list(inintm())\ninstrm = lambda: map(str, sys.stdin.readline().split())\ninstrl = lambda: list(instrm())\n\ns_at = input()[::-1]\ns_bt = input()[::-1]\ns_ct = input()[::-1]\n\ns_a = deque()\ns_b = deque()\ns_c = deque()\n\nfor i in range(len(s_at)):\n    s_a.append(s_at[i])\n\nfor i in range(len(s_bt)):\n    s_b.append(s_bt[i])\n\nfor i in range(len(s_ct)):\n    s_c.append(s_ct[i])\n\nnow = \"a\"\n\nwhile True:\n    if now == \"a\":\n        if len(s_a) == 0:\n            print(\"A\")\n            return\n        now = s_a[-1]\n        s_a.pop()\n    elif now == \"b\":\n        if len(s_b) == 0:\n            print(\"B\")\n            return\n        now = s_b[-1]\n        s_b.pop()\n    else:\n        if len(s_c) == 0:\n            print(\"C\")\n            return\n        now = s_c[-1]\n        s_c.pop()", "Sa = list(input())\nSb = list(input())\nSc = list(input())\ncard = Sa.pop(0)\nwhile True:\n    if card == 'a':\n        S = Sa\n    if card == 'b':\n        S = Sb\n    if card == 'c':\n        S = Sc\n    try:\n        card = S.pop(0)\n    except:\n        print(card.upper())\n        break", "A,B,C = (list(input()) for T in range(0,3))\nNext = A.pop(0)\nwhile True:\n    if Next=='a':\n        if not len(A):\n            print('A')\n            break\n        Next = A.pop(0)\n    elif Next=='b':\n        if not len(B):\n            print('B')\n            break\n        Next = B.pop(0)\n    else:\n        if not len(C):\n            print('C')\n            break\n        Next = C.pop(0)", "A = input()\nB = input()\nC = input()\n\nnow = A[:1]\nA = A[1:]\n\nwhile(1):\n    if(now == 'a'):\n        if(len(A) == 0):\n            print(\"A\")\n            return\n        now = A[:1]\n        A = A[1:]\n    elif(now == 'b'):\n        if(len(B) == 0):\n            print(\"B\")\n            return\n        now = B[:1]\n        B = B[1:]\n    else:\n        if(len(C) == 0):\n            print(\"C\")\n            return\n        now = C[:1]\n        C = C[1:]\n", "from collections import deque\nsa = input()\nsb = input()\nsc = input()\n\nq = deque(sa[0])\nsa = sa[1:]\nwhile q:\n  t = q.pop()\n  if t == \"a\":\n    if not sa:\n      ans = \"A\"\n      break\n    q.append(sa[0])\n    sa = sa[1:]\n  elif t == \"b\":\n    if not sb:\n      ans = \"B\"\n      break\n    q.append(sb[0])\n    sb = sb[1:]\n  elif t == \"c\":\n    if not sc:\n      ans = \"C\"\n      break\n    q.append(sc[0])\n    sc = sc[1:]\nprint(ans)", "from collections import deque\nA = deque(list(input()))\nB = deque(list(input()))\nC = deque(list(input()))\n\ntern = \"a\"\nwhile True:\n  if tern == \"a\":\n    if A:\n      tern = A.popleft()\n      continue\n    win = \"A\"\n    break\n  elif tern == \"b\":\n    if B:\n      tern = B.popleft()\n      continue\n    win = \"B\"\n    break\n  elif tern == \"c\":\n    if C:\n      tern = C.popleft()\n      continue\n    win = \"C\"\n    break\n    \nprint(win)"]