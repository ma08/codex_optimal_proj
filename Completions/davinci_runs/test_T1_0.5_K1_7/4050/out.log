2022-04-13 17:48:49.353467 """
This problem is given in two editions, which differ exclusively in the constraints on the number $n$.

You are given an array of integers $a[1], a[2], \dots, a[n].$ A block is a sequence of contiguous (consecutive) elements $a[l], a[l+1], \dots, a[r]$ ($1 \le l \le r \le n$). Thus, a block is defined by a pair of indices $(l, r)$.

Find a set of blocks $(l_1, r_1), (l_2, r_2), \dots, (l_k, r_k)$ such that:

  They do not intersect (i.e. they are disjoint). Formally, for each pair of blocks $(l_i, r_i)$ and $(l_j, r_j$) where $i \neq j$ either $r_i < l_j$ or $r_j < l_i$.  For each block the sum of its elements is the same. Formally, $$a[l_1]+a[l_1+1]+\dots+a[r_1]=a[l_2]+a[l_2+1]+\dots+a[r_2]=$$ $$\dots =$$ $$a[l_k]+a[l_k+1]+\dots+a[r_k].$$  The number of the blocks in the set is maximum. Formally, there does not exist a set of blocks $(l_1', r_1'), (l_2', r_2'), \dots, (l_{k'}', r_{k'}')$ satisfying the above two requirements with $k' > k$. 

 $\left. \begin{array}{|l|l|l|l|l|l|} \hline 4 & {1} & {2} & {2} & {1} & {5} & {3} \\ \hline \end{array} \right.$ The picture corresponds to the first example. Blue boxes illustrate blocks. 

Write a program to find such a set of blocks.


-----Input-----

The first line contains integer $n$ ($1 \le n \le 50$) — the length of the given array. The second line contains the sequence of elements $a[1], a[2], \dots, a[n]$ ($-10^5 \le a_i \le 10^5$).


-----Output-----

In the first line print the integer $k$ ($1 \le k \le n$). The following $k$ lines should contain blocks, one per line. In each line print a pair of indices $l_i, r_i$ ($1 \le l_i \le r_i \le n$) — the bounds of the $i$-th block. You can print blocks in any order. If there are multiple answers, print any of them.


-----Examples-----
Input
7
4 1 2 2 1 5 3

Output
3
7 7
2 3
4 5

Input
11
-5 -4 -3 -2 -1 0 1 2 3 4 5

Output
2
3 4
1 1

Input
4
1 1 1 1

Output
4
4 4
1 1
2 2
3 3
"""
2022-04-13 17:48:49.353483 --------------------------
2022-04-13 17:49:22.828720 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\ns = []\nfor i in range(n):\n    for j in range(i, n):\n        s.append(sum(a[i:j+1]))\n\ns = list(set(s))\ns.sort()\n\nr = []\nfor x in s:\n    r.append(len([y for y in a if y == x]))\n\nprint(max(r))\nfor x in s:\n    if len([y for y in a if y == x]) == max(r):\n        print(a.index(x)+1, a[::-1].index(x)+1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sums = [0]\n    for i in range(n):\n        sums.append(sums[i] + a[i])\n    s = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s.add(sums[j] - sums[i])\n    s = sorted(s)\n    d = {s[i]: i+1 for i in range(len(s))}\n    dp = [[0]*(len(s)+1) for _ in range(n+1)]\n    prev = [[0]*(len(s)+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, len(s)+1):\n            dp[i][j] = dp[i-1][j]\n            prev[i][j] = prev[i-1][j]\n            if d[sums[i]] == j:\n                if dp[i][j] < dp[i-1][j-1] + 1:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                    prev[i][j] = i\n    k = dp[n][len(s)]\n    print(k)\n    j = len(s)\n    while k > 0:\n        i = prev[n][j]\n        print(i, n)\n        k -= 1\n        n = i-1\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\nn = int(input())\na = [int(x) for x in input().split()]\n\ndef solve(a):\n    n = len(a)\n    d = dict()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = sum(a[i:j])\n            if s not in d:\n                d[s] = []\n            d[s].append((i, j))\n    m = 0\n    for k, v in d.items():\n        if len(v) > m:\n            m = len(v)\n            r = v\n    return r\n\nr = solve(a)\nprint(len(r))\nfor i, j in r:\n    print(i+1, j)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\ns = [0] * (n + 1)\nfor i in range(1, n + 1):\n    s[i] = s[i - 1] + a[i - 1]\n\nd = {}\nfor i in range(1, n + 1):\n    for j in range(i, n + 1):\n        d[s[j] - s[i - 1]] = d.get(s[j] - s[i - 1], 0) + 1\n\nm = max(d.values())\n\nprint(m)\nfor i in range(1, n + 1):\n    for j in range(i, n + 1):\n        if d[s[j] - s[i - 1]] == m:\n            print(i, j)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\ndef solve(n, a):\n    # dp[i][j] = maximum number of blocks with the same sum,\n    # ending at a[i] and having sum j\n    dp = [[0]*(2*10**5+1) for _ in xrange(n+1)]\n    # index of the last element of the block\n    last = [[-1]*(2*10**5+1) for _ in xrange(n+1)]\n    # sum of the block\n    sum = [[0]*(2*10**5+1) for _ in xrange(n+1)]\n    for i in xrange(1, n+1):\n        for j in xrange(-10**5, 10**5+1):\n            dp[i][j] = dp[i-1][j]\n            last[i][j] = last[i-1][j]\n            sum[i][j] = sum[i-1][j]\n            if dp[i-1][j-a[i-1]] + 1 > dp[i][j]:\n                dp[i][j] = dp[i-1][j-a[i-1]] + 1\n                last[i][j] = i\n                sum[i][j] = j\n    # find the maximum number of blocks\n    max = 0\n    for i in xrange(1, n+1):\n        for j in xrange(-10**5, 10**5+1):\n            if dp[i][j] > max:\n                max = dp[i][j]\n    # find the blocks\n    blocks = []\n    for i in xrange(1, n+1):\n        for j in xrange(-10**5, 10**5+1):\n            if dp[i][j] == max:\n                blocks.append((last[i][j], j))\n    # print the answer\n    print max\n    for block in blocks:\n        print block[0], block[0]\n\nn = int(raw_input())\na = map(int, raw_input().split())\nsolve(n, a)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# Solution\n\nn = int(input())\na = list(map(int, input().split()))\n\n# dp[i][j] = number of blocks ending at index i with sum j\ndp = [[0 for x in range(2001)] for y in range(n+1)]\n\n# Pre-calculate prefix sums\nprefix_sums = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sums[i] = prefix_sums[i-1] + a[i-1]\n\n# dp[i][j] = number of blocks ending at index i-1 with sum j\n# dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i-1]] + 1)\n\n# Initialize dp for i = 0\nfor j in range(-1000, 1001):\n    dp[0][j+1000] = 0\n\nfor i in range(1, n+1):\n    for j in range(-1000, 1001):\n        if dp[i-1][j+1000] > 0:\n            dp[i][j+1000] = dp[i-1][j+1000]\n        if j-a[i-1]+1000 >= 0:\n            if dp[i-1][j-a[i-1]+1000] > 0:\n                dp[i][j+1000] = max(dp[i][j+1000], dp[i-1][j-a[i-1]+1000]+1)\n\n# Find the maximum number of blocks\nmax_blocks = 0\nfor j in range(-1000, 1001):\n    max_blocks = max(max_blocks, dp[n][j+1000])\n\n# Print the answer\nprint(max_blocks)\n\n# Find the blocks\nblocks = []\nfor j in range(-1000, 1001):\n    if dp[n][j+1000] == max_blocks:\n        blocks.append(j)\n\n# Find the bounds of the blocks\nfor block in blocks:\n    i = n\n    while i > 0:\n        if dp[i][block+1000] == max_blocks:\n            print(i, i)\n            max_blocks -= 1\n            break\n        elif dp[i-1][block-a[i-1]+1000] + 1 == dp[i][block+1000]:\n            print(i, n)\n            max_blocks -= 1\n            block -= a[i-1]\n            i -= 1\n            break"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    sumArr = [0] * n\n    for i in range(1, n):\n        sumArr[i] = sumArr[i-1] + arr[i]\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        dp[i] = 1\n        for j in range(0, i):\n            if sumArr[i] - sumArr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    print(dp[n-1])\n    i = n-1\n    while i >= 0:\n        if dp[i] > 1:\n            j = i-1\n            while j >= 0:\n                if sumArr[i] - sumArr[j] == 0:\n                    print(j+1, i+1)\n                    i = j\n                    break\n                j -= 1\n        i -= 1\n    \n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649872129,
  "id": "cmpl-4wbOjCy1YywoSWwx8VXXZoohgL0dO",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 17:49:22.829086 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\ns = []\nfor i in range(n):\n    for j in range(i, n):\n        s.append(sum(a[i:j+1]))\n\ns = list(set(s))\ns.sort()\n\nr = []\nfor x in s:\n    r.append(len([y for y in a if y == x]))\n\nprint(max(r))\nfor x in s:\n    if len([y for y in a if y == x]) == max(r):\n        print(a.index(x)+1, a[::-1].index(x)+1)"
}
2022-04-13 17:49:22.829130 REASON stop
2022-04-13 17:49:22.829657 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sums = [0]\n    for i in range(n):\n        sums.append(sums[i] + a[i])\n    s = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s.add(sums[j] - sums[i])\n    s = sorted(s)\n    d = {s[i]: i+1 for i in range(len(s))}\n    dp = [[0]*(len(s)+1) for _ in range(n+1)]\n    prev = [[0]*(len(s)+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, len(s)+1):\n            dp[i][j] = dp[i-1][j]\n            prev[i][j] = prev[i-1][j]\n            if d[sums[i]] == j:\n                if dp[i][j] < dp[i-1][j-1] + 1:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                    prev[i][j] = i\n    k = dp[n][len(s)]\n    print(k)\n    j = len(s)\n    while k > 0:\n        i = prev[n][j]\n        print(i, n)\n        k -= 1\n        n = i-1\n\nmain()"
}
2022-04-13 17:49:22.829773 REASON stop
2022-04-13 17:49:22.830148 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\nn = int(input())\na = [int(x) for x in input().split()]\n\ndef solve(a):\n    n = len(a)\n    d = dict()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = sum(a[i:j])\n            if s not in d:\n                d[s] = []\n            d[s].append((i, j))\n    m = 0\n    for k, v in d.items():\n        if len(v) > m:\n            m = len(v)\n            r = v\n    return r\n\nr = solve(a)\nprint(len(r))\nfor i, j in r:\n    print(i+1, j)"
}
2022-04-13 17:49:22.830195 REASON stop
2022-04-13 17:49:22.848191 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\ns = [0] * (n + 1)\nfor i in range(1, n + 1):\n    s[i] = s[i - 1] + a[i - 1]\n\nd = {}\nfor i in range(1, n + 1):\n    for j in range(i, n + 1):\n        d[s[j] - s[i - 1]] = d.get(s[j] - s[i - 1], 0) + 1\n\nm = max(d.values())\n\nprint(m)\nfor i in range(1, n + 1):\n    for j in range(i, n + 1):\n        if d[s[j] - s[i - 1]] == m:\n            print(i, j)"
}
2022-04-13 17:49:22.848295 REASON stop
2022-04-13 17:49:22.868626 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\ndef solve(n, a):\n    # dp[i][j] = maximum number of blocks with the same sum,\n    # ending at a[i] and having sum j\n    dp = [[0]*(2*10**5+1) for _ in xrange(n+1)]\n    # index of the last element of the block\n    last = [[-1]*(2*10**5+1) for _ in xrange(n+1)]\n    # sum of the block\n    sum = [[0]*(2*10**5+1) for _ in xrange(n+1)]\n    for i in xrange(1, n+1):\n        for j in xrange(-10**5, 10**5+1):\n            dp[i][j] = dp[i-1][j]\n            last[i][j] = last[i-1][j]\n            sum[i][j] = sum[i-1][j]\n            if dp[i-1][j-a[i-1]] + 1 > dp[i][j]:\n                dp[i][j] = dp[i-1][j-a[i-1]] + 1\n                last[i][j] = i\n                sum[i][j] = j\n    # find the maximum number of blocks\n    max = 0\n    for i in xrange(1, n+1):\n        for j in xrange(-10**5, 10**5+1):\n            if dp[i][j] > max:\n                max = dp[i][j]\n    # find the blocks\n    blocks = []\n    for i in xrange(1, n+1):\n        for j in xrange(-10**5, 10**5+1):\n            if dp[i][j] == max:\n                blocks.append((last[i][j], j))\n    # print the answer\n    print max\n    for block in blocks:\n        print block[0], block[0]\n\nn = int(raw_input())\na = map(int, raw_input().split())\nsolve(n, a)"
}
2022-04-13 17:49:22.868737 REASON stop
2022-04-13 17:49:22.869774 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# Solution\n\nn = int(input())\na = list(map(int, input().split()))\n\n# dp[i][j] = number of blocks ending at index i with sum j\ndp = [[0 for x in range(2001)] for y in range(n+1)]\n\n# Pre-calculate prefix sums\nprefix_sums = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sums[i] = prefix_sums[i-1] + a[i-1]\n\n# dp[i][j] = number of blocks ending at index i-1 with sum j\n# dp[i][j] = max(dp[i-1][j], dp[i-1][j-a[i-1]] + 1)\n\n# Initialize dp for i = 0\nfor j in range(-1000, 1001):\n    dp[0][j+1000] = 0\n\nfor i in range(1, n+1):\n    for j in range(-1000, 1001):\n        if dp[i-1][j+1000] > 0:\n            dp[i][j+1000] = dp[i-1][j+1000]\n        if j-a[i-1]+1000 >= 0:\n            if dp[i-1][j-a[i-1]+1000] > 0:\n                dp[i][j+1000] = max(dp[i][j+1000], dp[i-1][j-a[i-1]+1000]+1)\n\n# Find the maximum number of blocks\nmax_blocks = 0\nfor j in range(-1000, 1001):\n    max_blocks = max(max_blocks, dp[n][j+1000])\n\n# Print the answer\nprint(max_blocks)\n\n# Find the blocks\nblocks = []\nfor j in range(-1000, 1001):\n    if dp[n][j+1000] == max_blocks:\n        blocks.append(j)\n\n# Find the bounds of the blocks\nfor block in blocks:\n    i = n\n    while i > 0:\n        if dp[i][block+1000] == max_blocks:\n            print(i, i)\n            max_blocks -= 1\n            break\n        elif dp[i-1][block-a[i-1]+1000] + 1 == dp[i][block+1000]:\n            print(i, n)\n            max_blocks -= 1\n            block -= a[i-1]\n            i -= 1\n            break"
}
2022-04-13 17:49:22.869857 REASON stop
2022-04-13 17:49:22.870705 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    sumArr = [0] * n\n    for i in range(1, n):\n        sumArr[i] = sumArr[i-1] + arr[i]\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        dp[i] = 1\n        for j in range(0, i):\n            if sumArr[i] - sumArr[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    print(dp[n-1])\n    i = n-1\n    while i >= 0:\n        if dp[i] > 1:\n            j = i-1\n            while j >= 0:\n                if sumArr[i] - sumArr[j] == 0:\n                    print(j+1, i+1)\n                    i = j\n                    break\n                j -= 1\n        i -= 1\n    \n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 17:49:22.870763 REASON stop
