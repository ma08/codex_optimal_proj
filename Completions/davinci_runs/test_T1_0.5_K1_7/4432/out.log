2022-04-13 20:44:23.426059 """
Recall that the sequence $b$ is a a subsequence of the sequence $a$ if $b$ can be derived from $a$ by removing zero or more elements without changing the order of the remaining elements. For example, if $a=[1, 2, 1, 3, 1, 2, 1]$, then possible subsequences are: $[1, 1, 1, 1]$, $[3]$ and $[1, 2, 1, 3, 1, 2, 1]$, but not $[3, 2, 3]$ and $[1, 1, 1, 1, 2]$.

You are given a sequence $a$ consisting of $n$ positive and negative elements (there is no zeros in the sequence).

Your task is to choose maximum by size (length) alternating subsequence of the given sequence (i.e. the sign of each next element is the opposite from the sign of the current element, like positive-negative-positive and so on or negative-positive-negative and so on). Among all such subsequences, you have to choose one which has the maximum sum of elements.

In other words, if the maximum length of alternating subsequence is $k$ then your task is to find the maximum sum of elements of some alternating subsequence of length $k$.

You have to answer $t$ independent test cases.


-----Input-----

The first line of the input contains one integer $t$ ($1 \le t \le 10^4$) — the number of test cases. Then $t$ test cases follow.

The first line of the test case contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of elements in $a$. The second line of the test case contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^9 \le a_i \le 10^9, a_i \ne 0$), where $a_i$ is the $i$-th element of $a$.

It is guaranteed that the sum of $n$ over all test cases does not exceed $2 \cdot 10^5$ ($\sum n \le 2 \cdot 10^5$).


-----Output-----

For each test case, print the answer — the maximum sum of the maximum by size (length) alternating subsequence of $a$.


-----Example-----
Input
4
5
1 2 3 -1 -2
4
-1 -2 -1 -3
10
-2 8 3 8 -4 -15 5 -2 -3 1
6
1 -1000000000 1 -1000000000 1 -1000000000

Output
2
-1
6
-2999999997



-----Note-----

In the first test case of the example, one of the possible answers is $[1, 2, \underline{3}, \underline{-1}, -2]$.

In the second test case of the example, one of the possible answers is $[-1, -2, \underline{-1}, -3]$.

In the third test case of the example, one of the possible answers is $[\underline{-2}, 8, 3, \underline{8}, \underline{-4}, -15, \underline{5}, \underline{-2}, -3, \underline{1}]$.

In the fourth test case of the example, one of the possible answers is $[\underline{1}, \underline{-1000000000}, \underline{1}, \underline{-1000000000}, \underline{1}, \underline{-1000000000}]$.
"""
2022-04-13 20:44:23.426073 --------------------------
2022-04-13 20:44:57.782003 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# We are asked to find the maximum sum of the maximum by size alternating subsequence of a.\n# We can use dynamic programming to solve this problem.\n# Let's define two arrays dp_pos and dp_neg, where dp_pos[i] will store the maximum sum of the maximum by size alternating subsequence of a[0:i+1] that ends with a[i] and dp_neg[i] will store the maximum sum of the maximum by size alternating subsequence of a[0:i+1] that ends with a[i] and is negative.\n# We can use the following recurrence relations to compute the arrays dp_pos and dp_neg:\n# dp_pos[i] = max(dp_pos[i-1], dp_neg[i-1] + a[i])\n# dp_neg[i] = max(dp_neg[i-1], dp_pos[i-1] + a[i])\n# The base cases for the recurrence relations are:\n# dp_pos[0] = a[0]\n# dp_neg[0] = a[0]\n# The answer to the problem is max(dp_pos[i]) for all i.\n\n# Time: O(n)\n# Space: O(n)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp_pos = [float('-inf')] * n\n    dp_neg = [float('-inf')] * n\n    dp_pos[0] = a[0]\n    dp_neg[0] = a[0]\n    for i in range(1, n):\n        dp_pos[i] = max(dp_pos[i-1], dp_neg[i-1] + a[i])\n        dp_neg[i] = max(dp_neg[i-1], dp_pos[i-1] + a[i])\n    print(max(dp_pos))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split(\" \")))\n\tdp = [0] * n\n\tdp[0] = a[0]\n\tfor i in range(1, n):\n\t\tif a[i] * a[i - 1] < 0:\n\t\t\tdp[i] = dp[i - 1] + a[i]\n\t\telse:\n\t\t\tdp[i] = a[i]\n\tprint(max(dp))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef test():\n    assert(max_alt_subseq([1, 2, 3, -1, -2]) == 2)\n    assert(max_alt_subseq([-1, -2, -1, -3]) == -1)\n    assert(max_alt_subseq([-2, 8, 3, 8, -4, -15, 5, -2, -3, 1]) == 6)\n    assert(max_alt_subseq([1, -1000000000, 1, -1000000000, 1, -1000000000]) == -2999999997)\n\ndef max_alt_subseq(seq):\n    if len(seq) < 2:\n        return 0\n    elif len(seq) == 2:\n        return max(seq)\n    else:\n        max_pos = 0\n        max_neg = 0\n        for i in range(1,len(seq)):\n            if i % 2 == 0:\n                if seq[i] > max_pos:\n                    max_pos = seq[i]\n            else:\n                if seq[i] > max_neg:\n                    max_neg = seq[i]\n        if max_pos > max_neg:\n            return max_pos\n        else:\n            return max_neg\n\nt = int(input())\n\nfor i in range(t):\n    n = int(input())\n    seq = list(map(int, input().split()))\n    print(max_alt_subseq(seq))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\n\ndef max_alternating_sequence_sum(arr):\n    \"\"\"\n    :param arr: a list of positive and negative integers\n    :return: the maximum sum of the maximum by size (length) alternating subsequence of arr\n    \"\"\"\n    n = len(arr)\n    # dp[i][0] = maximum sum of alternating subsequence ending at arr[i] with last element being positive\n    # dp[i][1] = maximum sum of alternating subsequence ending at arr[i] with last element being negative\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = arr[0] if arr[0] > 0 else 0\n    dp[0][1] = arr[0] if arr[0] < 0 else 0\n    for i in range(1, n):\n        if arr[i] > 0:\n            dp[i][0] = dp[i - 1][1] + arr[i]\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0])\n        else:\n            dp[i][0] = max(dp[i - 1][1], dp[i - 1][0])\n            dp[i][1] = dp[i - 1][0] + arr[i]\n    return max(dp[n - 1])\n\n\nif __name__ == '__main__':\n    for _ in range(int(input())):\n        _ = input()\n        arr = list(map(int, input().split()))\n        print(max_alternating_sequence_sum(arr))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# This is a variation of the Longest Increasing Subsequence problem.\n# We can use the same approach here, where we build a list of subsequences and then\n# iterate through the list to find the longest subsequence which sums to the maximum.\n# The only difference is that we need to check for the sign of the current element\n# and make sure it is different from the sign of the previous element.\n\n# This is an O(n^2) solution.\n\n# This solution uses the same algorithm as the LIS problem, but checks for alternating signs.\n# This solution is also O(n^2).\ndef max_sum_alt_subsequence(arr):\n    # Initialize a list of subsequences.\n    subseq = [[arr[0]]]\n\n    # Iterate through the array to find the longest subsequence.\n    for i in range(1, len(arr)):\n        # Initialize a new subsequence.\n        new_subseq = []\n        # Iterate through all of the previous subsequences.\n        for j in range(len(subseq)):\n            # If the current element has an alternating sign from the previous element,\n            # then we can add it to the subsequence.\n            if subseq[j][-1] * arr[i] < 0:\n                # Add the current element to the current subsequence.\n                new_subseq.append(subseq[j] + [arr[i]])\n        # Add the new subsequence to the list of subsequences.\n        subseq.append(new_subseq)\n\n    # Find the longest subsequence.\n    max_subseq = max(map(len, subseq))\n\n    # Find the sum of the longest subsequence.\n    max_sum = 0\n    for sub in subseq:\n        if len(sub) == max_subseq:\n            max_sum = max(max_sum, sum(sub))\n\n    return max_sum\n\n\ndef main():\n    # Read the number of test cases.\n    T = int(input())\n    # Iterate through the test cases.\n    for _ in range(T):\n        # Read the number of elements.\n        n = int(input())\n        # Read the list of elements.\n        arr = list(map(int, input().split()))\n        # Print the maximum sum of the alternating subsequence.\n        print(max_sum_alt_subsequence(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    This problem can be solved using the dynamic programming approach.\n\n    Let's define a subsequence $s$ as a sequence of elements of $a$ that are in the same order as they are in $a$.\n    Let's denote $s_i$ as a subsequence that ends with $a_i$ and is a subsequence of $a$.\n    Let's denote $d_i$ as the maximum sum of the maximum by size alternating subsequence of $s_i$.\n\n    We can see that $d_1 = a_1$ and $d_{i+1} = \\max\\{d_i + a_{i+1}, a_{i+1}\\}$.\n\n    In other words, the maximum sum of the maximum by size alternating subsequence of $s_i$ is the maximum of the sum of the maximum by size alternating subsequence of $s_{i-1}$ and $a_i$ and the maximum by size alternating subsequence of $s_i$ that starts with $a_i$.\n\n    The maximum sum of the maximum by size alternating subsequence of $a$ is the maximum value of $d_i$.\n    \"\"\"\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        d = [0] * n\n        d[0] = a[0]\n        for i in range(1, n):\n            d[i] = max(d[i-1] + a[i], a[i])\n        print(max(d))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# Solution\n\nimport sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = [int(x) for x in sys.stdin.readline().strip().split()]\n    dp = [[0 for x in range(n)] for y in range(2)]\n    dp[0][0] = a[0]\n    dp[1][0] = -math.inf\n    for i in range(1,n):\n        if a[i] > 0:\n            dp[0][i] = max(dp[0][i-1] + a[i], dp[1][i-1] + a[i])\n            dp[1][i] = max(dp[0][i-1], dp[1][i-1])\n        else:\n            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + a[i])\n            dp[1][i] = max(dp[0][i-1] + a[i], dp[1][i-1])\n    print(max(dp[0][n-1], dp[1][n-1]))\n\nif __name__ == \"__main__\":\n    t = int(sys.stdin.readline().strip())\n    for i in range(t):\n        solve()"
    }
  ],
  "created": 1649882663,
  "id": "cmpl-4we8dfcZ1hZXFrebsb1qkNXReM1Gw",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:44:57.782375 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# We are asked to find the maximum sum of the maximum by size alternating subsequence of a.\n# We can use dynamic programming to solve this problem.\n# Let's define two arrays dp_pos and dp_neg, where dp_pos[i] will store the maximum sum of the maximum by size alternating subsequence of a[0:i+1] that ends with a[i] and dp_neg[i] will store the maximum sum of the maximum by size alternating subsequence of a[0:i+1] that ends with a[i] and is negative.\n# We can use the following recurrence relations to compute the arrays dp_pos and dp_neg:\n# dp_pos[i] = max(dp_pos[i-1], dp_neg[i-1] + a[i])\n# dp_neg[i] = max(dp_neg[i-1], dp_pos[i-1] + a[i])\n# The base cases for the recurrence relations are:\n# dp_pos[0] = a[0]\n# dp_neg[0] = a[0]\n# The answer to the problem is max(dp_pos[i]) for all i.\n\n# Time: O(n)\n# Space: O(n)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp_pos = [float('-inf')] * n\n    dp_neg = [float('-inf')] * n\n    dp_pos[0] = a[0]\n    dp_neg[0] = a[0]\n    for i in range(1, n):\n        dp_pos[i] = max(dp_pos[i-1], dp_neg[i-1] + a[i])\n        dp_neg[i] = max(dp_neg[i-1], dp_pos[i-1] + a[i])\n    print(max(dp_pos))"
}
2022-04-13 20:44:57.782423 REASON stop
2022-04-13 20:44:57.782783 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\ta = list(map(int, input().split(\" \")))\n\tdp = [0] * n\n\tdp[0] = a[0]\n\tfor i in range(1, n):\n\t\tif a[i] * a[i - 1] < 0:\n\t\t\tdp[i] = dp[i - 1] + a[i]\n\t\telse:\n\t\t\tdp[i] = a[i]\n\tprint(max(dp))"
}
2022-04-13 20:44:57.782889 REASON stop
2022-04-13 20:44:57.783226 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef test():\n    assert(max_alt_subseq([1, 2, 3, -1, -2]) == 2)\n    assert(max_alt_subseq([-1, -2, -1, -3]) == -1)\n    assert(max_alt_subseq([-2, 8, 3, 8, -4, -15, 5, -2, -3, 1]) == 6)\n    assert(max_alt_subseq([1, -1000000000, 1, -1000000000, 1, -1000000000]) == -2999999997)\n\ndef max_alt_subseq(seq):\n    if len(seq) < 2:\n        return 0\n    elif len(seq) == 2:\n        return max(seq)\n    else:\n        max_pos = 0\n        max_neg = 0\n        for i in range(1,len(seq)):\n            if i % 2 == 0:\n                if seq[i] > max_pos:\n                    max_pos = seq[i]\n            else:\n                if seq[i] > max_neg:\n                    max_neg = seq[i]\n        if max_pos > max_neg:\n            return max_pos\n        else:\n            return max_neg\n\nt = int(input())\n\nfor i in range(t):\n    n = int(input())\n    seq = list(map(int, input().split()))\n    print(max_alt_subseq(seq))"
}
2022-04-13 20:44:57.783269 REASON stop
2022-04-13 20:44:57.795058 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\n\ndef max_alternating_sequence_sum(arr):\n    \"\"\"\n    :param arr: a list of positive and negative integers\n    :return: the maximum sum of the maximum by size (length) alternating subsequence of arr\n    \"\"\"\n    n = len(arr)\n    # dp[i][0] = maximum sum of alternating subsequence ending at arr[i] with last element being positive\n    # dp[i][1] = maximum sum of alternating subsequence ending at arr[i] with last element being negative\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = arr[0] if arr[0] > 0 else 0\n    dp[0][1] = arr[0] if arr[0] < 0 else 0\n    for i in range(1, n):\n        if arr[i] > 0:\n            dp[i][0] = dp[i - 1][1] + arr[i]\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0])\n        else:\n            dp[i][0] = max(dp[i - 1][1], dp[i - 1][0])\n            dp[i][1] = dp[i - 1][0] + arr[i]\n    return max(dp[n - 1])\n\n\nif __name__ == '__main__':\n    for _ in range(int(input())):\n        _ = input()\n        arr = list(map(int, input().split()))\n        print(max_alternating_sequence_sum(arr))"
}
2022-04-13 20:44:57.795144 REASON stop
2022-04-13 20:44:57.808061 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# This is a variation of the Longest Increasing Subsequence problem.\n# We can use the same approach here, where we build a list of subsequences and then\n# iterate through the list to find the longest subsequence which sums to the maximum.\n# The only difference is that we need to check for the sign of the current element\n# and make sure it is different from the sign of the previous element.\n\n# This is an O(n^2) solution.\n\n# This solution uses the same algorithm as the LIS problem, but checks for alternating signs.\n# This solution is also O(n^2).\ndef max_sum_alt_subsequence(arr):\n    # Initialize a list of subsequences.\n    subseq = [[arr[0]]]\n\n    # Iterate through the array to find the longest subsequence.\n    for i in range(1, len(arr)):\n        # Initialize a new subsequence.\n        new_subseq = []\n        # Iterate through all of the previous subsequences.\n        for j in range(len(subseq)):\n            # If the current element has an alternating sign from the previous element,\n            # then we can add it to the subsequence.\n            if subseq[j][-1] * arr[i] < 0:\n                # Add the current element to the current subsequence.\n                new_subseq.append(subseq[j] + [arr[i]])\n        # Add the new subsequence to the list of subsequences.\n        subseq.append(new_subseq)\n\n    # Find the longest subsequence.\n    max_subseq = max(map(len, subseq))\n\n    # Find the sum of the longest subsequence.\n    max_sum = 0\n    for sub in subseq:\n        if len(sub) == max_subseq:\n            max_sum = max(max_sum, sum(sub))\n\n    return max_sum\n\n\ndef main():\n    # Read the number of test cases.\n    T = int(input())\n    # Iterate through the test cases.\n    for _ in range(T):\n        # Read the number of elements.\n        n = int(input())\n        # Read the list of elements.\n        arr = list(map(int, input().split()))\n        # Print the maximum sum of the alternating subsequence.\n        print(max_sum_alt_subsequence(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:44:57.808160 REASON stop
2022-04-13 20:44:57.808824 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    This problem can be solved using the dynamic programming approach.\n\n    Let's define a subsequence $s$ as a sequence of elements of $a$ that are in the same order as they are in $a$.\n    Let's denote $s_i$ as a subsequence that ends with $a_i$ and is a subsequence of $a$.\n    Let's denote $d_i$ as the maximum sum of the maximum by size alternating subsequence of $s_i$.\n\n    We can see that $d_1 = a_1$ and $d_{i+1} = \\max\\{d_i + a_{i+1}, a_{i+1}\\}$.\n\n    In other words, the maximum sum of the maximum by size alternating subsequence of $s_i$ is the maximum of the sum of the maximum by size alternating subsequence of $s_{i-1}$ and $a_i$ and the maximum by size alternating subsequence of $s_i$ that starts with $a_i$.\n\n    The maximum sum of the maximum by size alternating subsequence of $a$ is the maximum value of $d_i$.\n    \"\"\"\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        d = [0] * n\n        d[0] = a[0]\n        for i in range(1, n):\n            d[i] = max(d[i-1] + a[i], a[i])\n        print(max(d))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:44:57.808880 REASON stop
2022-04-13 20:44:57.809555 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# Solution\n\nimport sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = [int(x) for x in sys.stdin.readline().strip().split()]\n    dp = [[0 for x in range(n)] for y in range(2)]\n    dp[0][0] = a[0]\n    dp[1][0] = -math.inf\n    for i in range(1,n):\n        if a[i] > 0:\n            dp[0][i] = max(dp[0][i-1] + a[i], dp[1][i-1] + a[i])\n            dp[1][i] = max(dp[0][i-1], dp[1][i-1])\n        else:\n            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + a[i])\n            dp[1][i] = max(dp[0][i-1] + a[i], dp[1][i-1])\n    print(max(dp[0][n-1], dp[1][n-1]))\n\nif __name__ == \"__main__\":\n    t = int(sys.stdin.readline().strip())\n    for i in range(t):\n        solve()"
}
2022-04-13 20:44:57.809653 REASON stop
