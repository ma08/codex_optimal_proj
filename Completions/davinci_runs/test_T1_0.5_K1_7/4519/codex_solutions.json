["\n\n# cook your dish here\nimport sys\nimport math\ndef main():\n    t = int(input())\n    while t:\n        t-=1\n        n,k = map(int,input().split())\n        s = input()\n        k -= n\n        if k < 0:\n            print(s)\n        else:\n            i = 0\n            while i < n:\n                if s[i] == '1':\n                    if k > 0:\n                        s = s[:i] + '0' + s[i+1:]\n                        k -= 1\n                    else:\n                        break\n                i += 1\n            print(s)\n\nif __name__ == '__main__':\n    main()", "\n\nT = int(input())\nfor t in range(T):\n    n, k = map(int, input().split())\n    s = list(input())\n    for i in range(n-1):\n        if s[i] > s[i+1]:\n            k -= 1\n            s[i], s[i+1] = s[i+1], s[i]\n            if k <= 0:\n                break\n    print(\"\".join(s))", "\n\n\nq = int(input())\n\nfor _ in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = list(s)\n\n    # check if only 1s in the string\n    if s.count('1') == n:\n        print(''.join(s))\n        continue\n\n    # check if only 0s in the string\n    if s.count('0') == n:\n        print(''.join(s))\n        continue\n\n    # check if the string is already sorted\n    sorted_s = sorted(s)\n    if s == sorted_s:\n        print(''.join(s))\n        continue\n\n    # check if the string can be sorted with the given number of moves\n    if k >= n - 1:\n        print(''.join(sorted_s))\n        continue\n\n    # check if the string can be sorted with a number of moves less than the given number of moves\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            s[i], s[i + 1] = s[i + 1], s[i]\n            k -= 1\n            if k == 0:\n                break\n    print(''.join(s))", "\n\nimport sys\n\ndef swap(s, i):\n    \"\"\"Swap two adjacent characters at index i in s.\"\"\"\n    t = list(s)\n    t[i], t[i+1] = t[i+1], t[i]\n    return \"\".join(t)\n\ndef get_min_string(s, k):\n    \"\"\"Return the lexicographically minimum string that can be obtained from s by performing no more than k moves.\"\"\"\n    n = len(s)\n    if k >= n-1:\n        return \"\".join(sorted(s))\n    for i in range(n-1):\n        if s[i] > s[i+1]:\n            s = swap(s, i)\n            k -= 1\n            if k == 0:\n                return s\n    return s\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        print(get_min_string(s, k))\n\nif __name__ == \"__main__\":\n    sys.exit(main())", "\n\n# SOLUTION\n# There are two cases:\n# 1) if k >= n-1, then the answer is the sorted string\n# 2) if k < n-1, then the answer is the sorted string without the last character\n\nq = int(input())\n\nfor _ in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    \n    if k >= n-1:\n        print(''.join(sorted(s)))\n    else:\n        print(''.join(sorted(s))[:-1])", "\n\n#Solution\n\n# cook your dish here\nt=int(input())\nfor _ in range(t):\n    n,k=map(int,input().split())\n    s=input()\n    s=list(s)\n    for i in range(n-1):\n        if s[i]=='0':\n            if k>0:\n                s[i]='1'\n                k-=1\n    for i in range(n-1,0,-1):\n        if s[i]=='1':\n            if k>0:\n                s[i]='0'\n                k-=1\n    print(''.join(s))", "\n\ndef main():\n    #read input\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        #initialize variables\n        l = 0\n        r = k\n        #loop through string\n        for j in range(n):\n            #check if there are enough operations left to move the current character to the end of the string\n            if r >= n - j:\n                #check if the current character is a one\n                if s[j] == \"1\":\n                    #if so, move it to the end of the string\n                    s = s[:j] + s[j+1:] + \"1\"\n                    #update operation count\n                    r -= n - j\n                else:\n                    #if not, move the next one to the end of the string\n                    s = s[:j] + s[j+1:] + \"1\"\n                    #update operation count\n                    r -= n - j - 1\n            #check if there are enough operations left to move the current character to the beginning of the string\n            if l <= j:\n                #check if the current character is a zero\n                if s[j] == \"0\":\n                    #if so, move it to the beginning of the string\n                    s = \"0\" + s[:j] + s[j+1:]\n                    #update operation count\n                    l += j\n                else:\n                    #if not, move the next one to the beginning of the string\n                    s = \"0\" + s[:j] + s[j+1:]\n                    #update operation count\n                    l += j + 1\n        #print output\n        print(s)\n\nif __name__ == \"__main__\":\n    main()"]