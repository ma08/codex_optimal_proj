["\n\nimport sys\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport os\nimport math\nimport bisect\nimport numpy as np\n\ndef main():\n\tpass\n\nif __name__ == '__main__':\n\tmain()", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = [int(x) for x in sys.stdin.readline().split()]\n        adj[a].append(b)\n        adj[b].append(a)\n\n    ans = 0\n    res = [0, 0, 0]\n    for a in range(1, n + 1):\n        for b in adj[a]:\n            if b < a:\n                continue\n            for c in adj[b]:\n                if c < b:\n                    continue\n                if a in adj[c]:\n                    tmp = len(set(adj[a]) & set(adj[b])) + len(set(adj[a]) & set(adj[c])) + len(set(adj[b]) & set(adj[c]))\n                    if tmp > ans:\n                        ans = tmp\n                        res = [a, b, c]\n    print(ans)\n    print(' '.join([str(x) for x in res]))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport os\nimport math\nimport bisect\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass Node:\n    def __init__(self, idx):\n        self.idx = idx\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.nodes = [Node(i) for i in range(n)]\n\n    def add_edge(self, a, b):\n        self.nodes[a - 1].add_child(self.nodes[b - 1])\n        self.nodes[b - 1].add_child(self.nodes[a - 1])\n\n    def __str__(self):\n        s = \"\"\n        for node in self.nodes:\n            s += \"{}: {}\\n\".format(node.idx, node.children)\n        return s\n\n\ndef get_edge_counts(tree):\n    # return an array of tuples: (node, # of edges from root to node)\n    # for each node in the tree\n    edge_counts = [0] * tree.n\n    stack = [tree.nodes[0]]\n    while stack:\n        node = stack.pop()\n        for child in node.children:\n            if edge_counts[child.idx] == 0:\n                edge_counts[child.idx] = edge_counts[node.idx] + 1\n                stack.append(child)\n    return edge_counts\n\n\ndef get_max_edge_count(tree, edge_counts):\n    # return a tuple of three nodes with max edge count\n    # between any two nodes\n    max_edge_count = 0\n    a, b, c = None, None, None\n    for i in range(tree.n - 1):\n        for j in range(i + 1, tree.n):\n            for k in range(j + 1, tree.n):\n                # for each triple of nodes\n                edge_count = edge_counts[i] + edge_counts[j] + edge_counts[k]\n                if edge_count > max_edge_count:\n                    max_edge_count = edge_count\n                    a, b, c = i, j, k\n    return max_edge_count, a, b, c\n\n\ndef main():\n    n = int(input())\n    tree = Tree(n)\n    for i in range(n - 1):\n        a, b = [int(x) for x in input().split()]\n        tree.add_edge(a, b)\n\n    edge_counts = get_edge_counts(tree)\n    max_edge_count, a, b, c = get_max_edge_count(tree, edge_counts)\n\n    print(max_edge_count)\n    print(a + 1, b + 1, c + 1)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom collections import defaultdict\n\ndef dfs(v, p, g, dp):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v, g, dp)\n            dp[v] += dp[u]\n\ndef dfs2(v, p, g, dp, ans):\n    for u in g[v]:\n        if u != p:\n            dp[u] = dp[v] + (len(g) - 1) - 2 * dp[u]\n            dfs2(u, v, g, dp, ans)\n    ans[0] = max(ans[0], dp[v])\n\ndef solve(g):\n    dp = [1] * len(g)\n    ans = [0]\n    dfs(0, -1, g, dp)\n    dfs2(0, -1, g, dp, ans)\n    return ans[0]\n\ndef main():\n    n = int(input())\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    print(solve(g))\n\nif __name__ == '__main__':\n    main()"]