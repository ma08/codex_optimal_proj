["\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0 for _ in range(x+1)] for _ in range(n+1)]\n\nfor i in range(n):\n    for j in range(1, x+1):\n        dp[i+1][j] = max(dp[i][j], dp[i+1][j-1])\n        if i-k+1 >= 0:\n            dp[i+1][j] = max(dp[i+1][j], dp[i-k+1][j-1]+sum(a[i-k+1:i+1]))\n\nprint(dp[n][x] if dp[n][x] else -1)", "\n\nimport sys\n\ndef main():\n    n, k, x = [int(x) for x in sys.stdin.readline().split()]\n    a = [int(x) for x in sys.stdin.readline().split()]\n    \n    if x < n - k + 1:\n        print(-1)\n        return\n    \n    # dp[i][j] = maximum sum of the first i items\n    #            if there are j items in the last k items\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    \n    # Initialize\n    dp[0][0] = a[0]\n    \n    # The first k items\n    for i in range(1, k):\n        dp[i][i] = dp[i - 1][i - 1] + a[i]\n    \n    # The rest\n    for i in range(k, n):\n        for j in range(k):\n            dp[i][j] = max(dp[i - 1][j] + a[i], dp[i - 1][(j + 1) % k])\n    \n    print(dp[n - 1][(k - (n - x)) % k])\n\nmain()", "\n\n# Solution\n\n\"\"\"\nSolution idea:\n\nWe are going to use dynamic programming to solve this problem.\n\nFirst of all, let's think of the subproblems.\n\nLet's fix $i$ and $j$ ($i \\le j$). Let's denote by $dp[i][j][0]$ the maximum possible sum of values of reposted pictures, if Vova has to repost at least one picture in the segment $[i; j]$ and has already reposted $x$ pictures. Let's denote by $dp[i][j][1]$ the maximum possible sum of values of reposted pictures, if Vova doesn't have to repost any pictures in the segment $[i; j]$ and has already reposted $x$ pictures.\n\nThe answer to the problem is $dp[1][n][0]$.\n\nLet's try to find $dp[i][j][0]$. If $j - i + 1 < k$, then $dp[i][j][0] = -1$. Otherwise, Vova can repost the $i$-th picture. In this case, $dp[i][j][0] = a_i + dp[i + 1][j][1]$. Vova can also not repost the $i$-th picture. In this case, $dp[i][j][0] = dp[i + 1][j][0]$. Thus, $dp[i][j][0] = \\max(a_i + dp[i + 1][j][1], dp[i + 1][j][0])$.\n\nNow let's find $dp[i][j][1]$. If $j - i + 1 < k$, then $dp[i][j][1] = -1$. Otherwise, Vova can repost the $j$-th picture. In this case, $dp[i][j][1] = a_j + dp[i][j - 1][0]$. Vova can also not repost the $j$-th picture. In this case, $dp[i][j][1] = dp[i][j - 1][1]$. Thus, $dp[i][j][1] = \\max(a_j + dp[i][j - 1][0], dp[i][j - 1][1])$.\n\nLet's think about the order in which we want to find $dp[i][j][0]$ and $dp[i][j][1]$. It's easy to see that the answer will not change if we find $dp[i][j][0]$ and $dp[i][j][1]$ in any order, as long as we find them for all $i, j$ in increasing order of $j - i + 1$.\n\nThus, we can solve this problem in $O(n^2)$ time.\n\"\"\"\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[[-1 for _ in range(2)] for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    dp[i][i][0] = a[i - 1]\n    dp[i][i][1] = 0\n\nfor len in range(2, n + 1):\n    for i in range(1, n - len + 2):\n        j = i + len - 1\n        if j - i + 1 < k:\n            dp[i][j][0] = -1\n            dp[i][j][1] = -1\n        else:\n            dp[i][j][0] = max(a[i - 1] + dp[i + 1][j][1], dp[i + 1][j][0])\n            dp[i][j][1] = max(a[j - 1] + dp[i][j - 1][0], dp[i][j - 1][1])\n\nprint(dp[1][n][0])", "\n\ndef max_beauty(n, k, x, a):\n    \"\"\"\n    >>> max_beauty(5, 2, 3, [5, 1, 3, 10, 1])\n    18\n    >>> max_beauty(6, 1, 5, [10, 30, 30, 70, 10, 10])\n    -1\n    >>> max_beauty(4, 3, 1, [1, 100, 1, 1])\n    100\n    \"\"\"\n    if x < n - k + 1:\n        return -1\n    return sum(sorted(a)[-x:])\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\n\ndef _print():\n    n, k, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(max_beauty(n, k, x, a))\n\n\nif __name__ == '__main__':\n    _test()\n    _print()", "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# print(n, k, x)\n# print(a)\n\nif x < k:\n    print(-1)\n    exit()\n\n# set up a prefix sum array\nprefix_sum = [a[0]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + a[i])\n\n# print(prefix_sum)\n\n# set up a DP array, where the index is the number of pictures to repost,\n# and the value is the maximum possible sum of reposted pictures\ndp = [0] * (x + 1)\n\n# set up the maximum possible sum of reposted pictures for x = k\nfor i in range(1, k + 1):\n    dp[i] = prefix_sum[i - 1]\n\n# print(dp)\n\n# set up the maximum possible sum of reposted pictures for x > k\nfor i in range(k + 1, x + 1):\n    for j in range(1, k):\n        dp[i] = max(dp[i], dp[i - j] + prefix_sum[i - 1] - prefix_sum[i - j - 1])\n    dp[i] = max(dp[i], dp[i - k] + prefix_sum[i - 1] - prefix_sum[i - k - 1])\n\nprint(dp[-1])", "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0] * (x + 1) for _ in range(n)]\n\nfor i in range(n):\n    dp[i][1] = a[i]\n\nfor i in range(2, n):\n    for j in range(2, x + 1):\n        for p in range(max(0, i - k), i):\n            dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i])\n\nif max(dp[-1]) == 0:\n    print(-1)\nelse:\n    print(max(dp[-1]))", "\n\nn, k, x = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nif x < k:\n    print(-1)\n    exit()\n\ndp = [[0 for j in range(x+1)] for i in range(n+1)]\n\nfor i in range(1, n+1):\n    for j in range(1, x+1):\n        if i < k:\n            dp[i][j] = max(dp[i-1][j], a[i-1])\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i-k][j-1] + a[i-1])\n\nprint(dp[n][x])"]