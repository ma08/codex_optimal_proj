["\n\nf, s, g, u, d = [int(x) for x in input().split()]\n\nif (s == g):\n    print(0)\nelif (s < g):\n    if (g - s <= u):\n        print(g - s)\n    else:\n        print(\"use the stairs\")\nelse:\n    if (s - g <= d):\n        print(s - g)\n    else:\n        print(\"use the stairs\")", "\n\nimport sys\n\nf, s, g, u, d = [int(x) for x in sys.stdin.readline().split()]\n\nif s == g:\n    print(0)\nelif u == 0 and d == 0:\n    print(\"use the stairs\")\nelse:\n    # BFS\n    visited = [False for _ in range(f + 1)]\n    q = [s]\n    visited[s] = True\n    count = 0\n    while q:\n        count += 1\n        q_len = len(q)\n        for _ in range(q_len):\n            curr = q.pop(0)\n\n            if curr + u <= f and not visited[curr + u]:\n                if curr + u == g:\n                    print(count)\n                    sys.exit(0)\n                q.append(curr + u)\n                visited[curr + u] = True\n\n            if curr - d > 0 and not visited[curr - d]:\n                if curr - d == g:\n                    print(count)\n                    sys.exit(0)\n                q.append(curr - d)\n                visited[curr - d] = True\n\n    print(\"use the stairs\")", "\n\nimport sys\n\ndef main():\n    f, s, g, u, d = map(int, sys.stdin.readline().split())\n    s -= 1\n    g -= 1\n    dist = [float(\"inf\")]*f\n    dist[s] = 0\n    q = [s]\n    while q:\n        curr = q.pop(0)\n        if curr-d >= 0 and dist[curr-d] > dist[curr] + 1:\n            dist[curr-d] = dist[curr] + 1\n            q.append(curr-d)\n        if curr+u < f and dist[curr+u] > dist[curr] + 1:\n            dist[curr+u] = dist[curr] + 1\n            q.append(curr+u)\n    if dist[g] == float(\"inf\"):\n        print(\"use the stairs\")\n    else:\n        print(dist[g])\n\nmain()", "\n\nimport sys\n\ndef main():\n    f,s,g,u,d = map(int,sys.stdin.readline().strip().split())\n\n    if s == g:\n        print(0)\n        return\n\n    # We are going to use a BFS algorithm to solve this problem.\n    # We will build a graph where each node represents a floor, and each\n    # edge represents a button press.\n    # We will also initialize a \"distance\" array to store the distance\n    # to each node from the starting node.\n    graph = [[] for i in range(f+1)]\n    distance = [-1]*(f+1)\n\n    # We will now populate the graph. For each floor, we will add a\n    # directed edge to the floor that we would reach by pressing the\n    # UP or DOWN button.\n    for i in range(1,f+1):\n        if i - d > 0:\n            graph[i].append(i-d)\n        if i + u <= f:\n            graph[i].append(i+u)\n\n    # We will now perform a BFS to find the distance to the goal floor.\n    queue = [s]\n    distance[s] = 0\n    while len(queue) > 0:\n        current_floor = queue.pop(0)\n        for neighbor in graph[current_floor]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[current_floor] + 1\n                queue.append(neighbor)\n\n    # If the distance to the goal is -1, then we could not reach it.\n    if distance[g] == -1:\n        print(\"use the stairs\")\n    else:\n        print(distance[g])\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    f, s, g, u, d = [int(x) for x in sys.stdin.readline().split()]\n    visited = [False for _ in range(f+1)]\n    queue = []\n    queue.append(s)\n    visited[s] = True\n    dist = [0 for _ in range(f+1)]\n    dist[s] = 0\n    while queue:\n        curr = queue.pop(0)\n        if curr == g:\n            print(dist[curr])\n            return\n        if curr + u <= f and not visited[curr + u]:\n            queue.append(curr + u)\n            visited[curr + u] = True\n            dist[curr + u] = dist[curr] + 1\n        if curr - d > 0 and not visited[curr - d]:\n            queue.append(curr - d)\n            visited[curr - d] = True\n            dist[curr - d] = dist[curr] + 1\n    print(\"use the stairs\")\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom sys import stdin\n\nf, s, g, u, d = map(int, stdin.readline().split())\n\nif s == g:\n    print 0\n    exit()\n\nvisited = [False for _ in range(f + 1)]\ndistance = [f + 1 for _ in range(f + 1)]\n\nqueue = []\nqueue.append(s)\nvisited[s] = True\ndistance[s] = 0\n\nwhile queue:\n    current_floor = queue.pop(0)\n\n    if current_floor == g:\n        print distance[current_floor]\n        exit()\n\n    if current_floor + u <= f and not visited[current_floor + u]:\n        distance[current_floor + u] = distance[current_floor] + 1\n        visited[current_floor + u] = True\n        queue.append(current_floor + u)\n\n    if current_floor - d > 0 and not visited[current_floor - d]:\n        distance[current_floor - d] = distance[current_floor] + 1\n        visited[current_floor - d] = True\n        queue.append(current_floor - d)\n\nprint 'use the stairs'", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    f, s, g, u, d = [int(x) for x in line.split()]\n\n    # If we can't get there, we can't get there.\n    if s == g:\n        print(0)\n        return\n    if s > g and d == 0:\n        print(\"use the stairs\")\n        return\n    if s < g and u == 0:\n        print(\"use the stairs\")\n        return\n\n    # Create the array that represents the floors.\n    floors = [None] * f\n    floors[s - 1] = 0\n    q = [s - 1]\n\n    # Do a breadth-first search.\n    while len(q) > 0:\n        curr = q.pop(0)\n        for x in [curr - d, curr + u]:\n            if 0 <= x < f and floors[x] is None:\n                floors[x] = floors[curr] + 1\n                q.append(x)\n\n    if floors[g - 1] is not None:\n        print(floors[g - 1])\n    else:\n        print(\"use the stairs\")\n\n\nmain()"]