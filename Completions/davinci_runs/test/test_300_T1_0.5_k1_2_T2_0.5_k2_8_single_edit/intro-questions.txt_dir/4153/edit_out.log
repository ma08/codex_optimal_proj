2022-04-19 21:38:27.286674 num operations 1
2022-04-19 21:38:27.286684 size on input set 1
2022-04-19 21:38:27.286848 using api key sourya
2022-04-19 21:38:50.401779 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nN = int(raw_input())\nA = map(int, raw_input().split())\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones. Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones. The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes. The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes. The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string. \n\nzeroes = A.count(0)\nzeroes_at_beginning_or_end = N - (len(A) - len(A.lstrip(\"0\").rstrip(\"0\")))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 1,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "print sum([int(x) for x in raw_input().split()])\n"
    },
    {
      "index": 3,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 4,
      "text": "S = raw_input()\n\ndef main():\n    # The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n    # Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n    # The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n    # The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n    # The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n    # The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n    # This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\n    zeroes = S.count(\"0\")\n    zeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\n    print zeroes - zeroes_at_beginning_or_end\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 6,
      "text": "S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 7,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    }
  ],
  "created": 1650404307,
  "object": "edit"
}
2022-04-19 21:38:50.402142 fix syntax errors 8 ['\nN = int(raw_input())\nA = map(int, raw_input().split())\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones. Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones. The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes. The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes. The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string. \n\nzeroes = A.count(0)\nzeroes_at_beginning_or_end = N - (len(A) - len(A.lstrip("0").rstrip("0")))\nprint(zeroes - zeroes_at_beginning_or_end)\n', '\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', 'print sum([int(x) for x in raw_input().split()])\n', '\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', 'S = raw_input()\n\ndef main():\n    # The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n    # Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n    # The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n    # The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n    # The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n    # The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n    # This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\n    zeroes = S.count("0")\n    zeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\n    print zeroes - zeroes_at_beginning_or_end\n\nif __name__ == "__main__":\n    main()\n', '\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', 'S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n']
2022-04-19 21:38:50.402315 size on output set 6
2022-04-19 21:38:50.402329 num operations 1
2022-04-19 21:38:50.402335 size on input set 1
2022-04-19 21:38:50.402501 using api key soukgp
2022-04-19 21:39:07.495275 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\n\ndef main2():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tans = 1\n\tfor i in range(n):\n\t\tif a[i] == 0:\n\t\t\tans = 0\n\t\t\tbreak\n\t\telif a[i] == 2:\n\t\t\tans *= 2\n\t\telif a[i] == 3:\n\t\t\tans *= 3\n\t\telse:\n\t\t\tans *= 6\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain2()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 3,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1': # if stack is not empty and the last element is 1\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 5,
      "text": "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 7,
      "text": "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1650404330,
  "object": "edit"
}
2022-04-19 21:39:07.495586 fix syntax errors 8 ["\nimport sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\n\ndef main2():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tans = 1\n\tfor i in range(n):\n\t\tif a[i] == 0:\n\t\t\tans = 0\n\t\t\tbreak\n\t\telif a[i] == 2:\n\t\t\tans *= 2\n\t\telif a[i] == 3:\n\t\t\tans *= 3\n\t\telse:\n\t\t\tans *= 6\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain2()\n", "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1': # if stack is not empty and the last element is 1\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-19 21:39:07.495637 size on output set 6
