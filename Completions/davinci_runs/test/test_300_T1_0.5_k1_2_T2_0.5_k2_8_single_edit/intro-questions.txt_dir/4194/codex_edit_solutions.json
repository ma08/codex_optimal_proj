["\nimport heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Initialize a heap\nh = []\n\n# Put the last element of A into the heap\nheapq.heappush(h, -A[-1])\n\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "import heapq\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nA.sort()\n\nif N < A[-1]:\n    print(-1)\n    exit()\n\nh = []\n\nheapq.heappush(h, -A[-1])\n\nheapq.heappush(h, -A[-2])\n\nfor i in range(M-2):\n    a = -heapq.heappop(h)\n\n    if a > N:\n        print(-1)\n        exit()\n\n    heapq.heappush(h, -(a-1))\n\na = -heapq.heappop(h)\n\nif a > N:\n    print(-1)\n    exit()\n\nprint(N-(a-1))\n", "#\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "\nimport heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order.\nA.sort()\n\n# If N is smaller than A[-1], Takahashi cannot finish all of the assignments.\nif N < A[-1]:\n    print(-1)\n    exit()\n\n# Initialize a heap.\nh = []\n\n# Put the last element of A into the heap.\nheapq.heappush(h, -A[-1])\n\n# Put the second-last element of A into the heap.\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times.\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "\nimport heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order\nA.sort()\n\n# Initialize a heap\nh = []\n\n# Put the last element of A into the heap\nheapq.heappush(h, -A[-1])\n\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "\n\nn, m = map(int, input().split())  # input n and m\na = list(map(int, input().split()))  # input a\n\na.sort()  # sort a\n\nif a[-1] > n:  # check if a[-1] > n\n    print(-1)\n    exit()\n\ns = 0  # initialize s\nfor i in range(m):\n    s += a[i]  # add a[i] to s\n\nprint(n - s)  # print n - s\n", "import heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order\nA.sort()\n\n# If N is smaller than A[-1], Takahashi cannot finish all of the assignments\nif N < A[-1]:\n    print(-1)\n    exit()\n\n# Initialize a heap\nh = []\n\n# Put the last element of A into the heap\nheapq.heappush(h, -A[-1])\n\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "#\n# import heapq\n#\n# # Input\n# N, M = map(int, input().split())\n# A = list(map(int, input().split()))\n#\n# # Sort A in ascending order\n# A.sort()\n#\n# # If N is smaller than A[-1], Takahashi cannot finish all of the assignments\n# if N < A[-1]:\n#     print(-1)\n#     exit()\n#\n# # Initialize a heap\n# h = []\n#\n# # Put the last element of A into the heap\n# heapq.heappush(h, -A[-1])\n#\n# # Put the second-last element of A into the heap\n# heapq.heappush(h, -A[-2])\n#\n# # Repeat M-2 times\n# for i in range(M-2):\n#     # Pop the largest element in the heap\n#     a = -heapq.heappop(h)\n#\n#     # If a is greater than N, Takahashi cannot finish all of the assignments\n#     if a > N:\n#         print(-1)\n#         exit()\n#\n#     # Push a-1 into the heap\n#     heapq.heappush(h, -(a-1))\n#\n# # Pop the largest element in the heap\n# a = -heapq.heappop(h)\n#\n# # If a is greater than N, Takahashi cannot finish all of the assignments\n# if a > N:\n#     print(-1)\n#     exit()\n#\n# # Print N-(a-1)\n# print(N-(a-1))\n", "# Input\nN = int(input())\na = list(map(int, input().split()))\n", "\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\n\nprint(n - s)\n", "\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n / m:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n"]