2022-04-19 20:03:27.121716 num operations 1
2022-04-19 20:03:27.121727 size on input set 1
2022-04-19 20:03:27.121867 using api key jaanu
2022-04-19 20:03:52.461772 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    with sys.stdin as f:\n        n = int(f.readline())\n        tree = [[] for i in range(n)]\n        for i in range(n-1):\n            a, b = map(int, f.readline().split())\n            tree[a-1].append(b-1)\n            tree[b-1].append(a-1)\n        for i in range(n):\n            tree[i].sort()\n        max_paths = 0\n        for i in range(n):\n            for j in range(len(tree[i])):\n                for k in range(j+1, len(tree[i])):\n                    a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                    paths = [0]*3\n                    for l in range(3):\n                        paths[l] = len(path(tree, a, b, c, l))\n                    max_paths = max(max_paths, sum(paths))\n                    if max_paths == sum(paths):\n                        ans = [a, b, c]\n        print(max_paths)\n        print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1 # indices start at 1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])-1):\n            for k in range(j+1, len(tree[i])-1):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650398609,
  "object": "edit"
}
2022-04-19 20:03:52.462213 fix syntax errors 8 ['import sys\n\ndef main():\n    with sys.stdin as f:\n        n = int(f.readline())\n        tree = [[] for i in range(n)]\n        for i in range(n-1):\n            a, b = map(int, f.readline().split())\n            tree[a-1].append(b-1)\n            tree[b-1].append(a-1)\n        for i in range(n):\n            tree[i].sort()\n        max_paths = 0\n        for i in range(n):\n            for j in range(len(tree[i])):\n                for k in range(j+1, len(tree[i])):\n                    a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                    paths = [0]*3\n                    for l in range(3):\n                        paths[l] = len(path(tree, a, b, c, l))\n                    max_paths = max(max_paths, sum(paths))\n                    if max_paths == sum(paths):\n                        ans = [a, b, c]\n        print(max_paths)\n        print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1 # indices start at 1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])-1):\n            for k in range(j+1, len(tree[i])-1):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-19 20:03:52.462341 size on output set 5
2022-04-19 20:03:52.462353 num operations 1
2022-04-19 20:03:52.462359 size on input set 1
2022-04-19 20:03:52.462526 using api key kouti
2022-04-19 20:04:43.640312 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split()) \n    tree[v1-1].append(v2-1)\n    tree[v2-1].append(v1-1)\ndef dfs(vertex, parent):\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n + 1)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1].append(v2)\n    tree[v2].append(v1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, 0)\n    cnt2, edges2 = dfs(v2, 0)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
  ],
  "created": 1650398634,
  "object": "edit"
}
2022-04-19 20:04:43.640763 fix syntax errors 8 ['\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split()) \n    tree[v1-1].append(v2-1)\n    tree[v2-1].append(v1-1)\ndef dfs(vertex, parent):\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n + 1)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1].append(v2)\n    tree[v2].append(v1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, 0)\n    cnt2, edges2 = dfs(v2, 0)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']
2022-04-19 20:04:43.640896 size on output set 5
