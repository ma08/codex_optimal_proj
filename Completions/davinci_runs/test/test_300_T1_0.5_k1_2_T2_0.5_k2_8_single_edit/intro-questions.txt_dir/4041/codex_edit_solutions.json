["from collections import defaultdict\nfrom collections import deque\n\n\n# Read input\nn, m = map(int, input().split())\nedges = defaultdict(list)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a].append(b)\n    edges[b].append(a)\n\n# Perform a BFS to determine if there is a cycle\nvisited = [False for _ in range(n+1)]\nq = deque()\nq.append(1)\nvisited[1] = True\nwhile q:\n    cur = q.popleft()\n    for child in edges[cur]:\n        if visited[child]:\n            print('NO')\n            exit()\n        else:\n            visited[child] = True\n            q.append(child)\n\nprint('YES')\n", "\n\ns = str(input())\nt = str(input())\n\ndef get_lcs(s,t):\n    # Create a DP matrix\n    dp = [[0 for i in range(len(s)+1)] for j in range(len(t)+1)]\n    \n    # Populate the matrix\n    for i in range(1, len(t)+1):\n        for j in range(1, len(s)+1):\n            if t[i-1] == s[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[-1][-1]\n\nprint(len(s) - get_lcs(s,t))\n", "\n\ninp = input()\nsub = input()\n\n# Initialize a 2d array of size len(inp) + 1 x len(sub) + 1.\n# Each element represents the length of the longest subsequence of the sub\n# in a substring of inp.\ndp = [[0 for _ in range(len(sub)+1)] for _ in range(len(inp)+1)]\n\nfor i in range(1, len(inp)+1):\n    for j in range(1, len(sub)+1):\n        if inp[i-1] == sub[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nprint(len(inp) - dp[-1][-1])\n", "\ninp = input()\nsub = input()\n\n# Initialize a 2d array of size len(inp) + 1 x len(sub) + 1\n# Each element represents the length of the longest subsequence of the sub\n# in a substring of inp\ndp = [[0 for _ in range(len(sub)+1)] for _ in range(len(inp)+1)]\n\nfor i in range(1, len(inp)+1):\n    for j in range(1, len(sub)+1):\n        if inp[i-1] == sub[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nprint(len(inp) - dp[-1][-1])\n", "\n\ninp = input()\nsub = input()\n\ndp = [[0 for _ in range(len(inp)+1)] for _ in range(len(sub)+1)]\n\nfor i in range(1, len(sub)+1):\n    for j in range(1, len(inp)+1):\n        if sub[i-1] == inp[j-1]:\n            dp[i][j] = dp[i][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j])\n\nprint(len(inp) - dp[-1][-1])\n", "\ns = input()\nt = input()\n\n\ndef get_lcs(s, t):\n    # Create a DP matrix\n    dp = [[0 for i in range(len(s) + 1)] for j in range(len(t) + 1)]\n\n    # Populate the matrix\n    for i in range(1, len(t)+1):\n        for j in range(1, len(s)+1):\n            if t[i-1] == s[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[-1][-1]\n\nprint(len(s) - get_lcs(s,t))\n", "\ninp = input()\nsub = input()\n\n# Initialize a 2d array of size len(inp) + 1 x len(sub) + 1\n# Each element represents the length of the longest subsequence of the sub\n# in a substring of inp\ndp = [[0 for _ in range(len(sub) + 1)] for _ in range(len(inp) + 1)]\n\nfor i in range(1, len(inp)+1):\n    for j in range(1, len(sub)+1):\n        if inp[i-1] == sub[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nprint(len(inp) - dp[-1][-1])\n", "\n\ns = \"abcde\"\nt = \"ace\"\n\ndef get_lcs(s,t):\n    # Create a DP matrix\n    dp = [[0 for i in range(len(s)+1)] for j in range(len(t)+1)]\n    \n    # Populate the matrix\n    for i in range(1, len(t)+1):\n        for j in range(1, len(s)+1):\n            if t[i-1] == s[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[-1][-1]\n\nprint(len(s) - get_lcs(s,t))\n", "\ns = input()\nt = input()\n\ndef get_lcs(s,t):\n    # Create a DP matrix\n    dp = [[0 for i in range(len(s)+1)] for j in range(len(t)+1)]\n    \n    # Populate the matrix\n    for i in range(1, len(t)+1):\n        for j in range(1, len(s)+1):\n            if t[i-1] == s[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[-1][-1]\n\nprint(len(s) - get_lcs(s,t))\n", "\n\ns = \"abcdefghijklmnopqrstuvwxyz\"\nt = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef get_lcs(s,t):\n    # Create a matrix to store results of subproblems\n    dp = [[0] * (len(s) + 1) for i in range(len(t) + 1)]\n\n    # Fill d[][] in bottom up manner\n    for i in range(len(t) + 1):\n        for j in range(len(s) + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif t[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[len(t)][len(s)]\n\n\nprint(len(s) - get_lcs(s,t))\n", "\n\ns = input().strip()\nt = input().strip()\n\ndef get_lcs(s,t):\n    # Create a DP matrix\n    dp = [[0 for i in range(len(s)+1)] for j in range(len(t)+1)]\n    \n    # Populate the matrix\n    for i in range(1, len(t)+1):\n        for j in range(1, len(s)+1):\n            if t[i-1] == s[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[-1][-1]\n\nprint(len(s) - get_lcs(s,t))\n", "\n\ninp = input()\nsub = input()\n\ndp = [[0 for _ in range(len(sub)+1)] for _ in range(len(inp)+1)] # dp[i][j] = length of longest common subsequence of inp[:i] and sub[:j]\n\nfor i in range(1, len(inp)+1):\n    for j in range(1, len(sub)+1):\n        if inp[i-1] == sub[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1 # inp[i-1] and sub[j-1] are in the LCS\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # inp[i-1] and sub[j-1] are not in the LCS\n\nprint(len(inp) - dp[-1][-1]) # number of deletions to make inp a subsequence of sub\n", "\n\ninp = input().strip()\nsub = input().strip()\n\n# Initialize a 2d array of size len(inp) + 1 x len(sub) + 1\n# Each element represents the length of the longest subsequence of the sub\n# in a substring of inp\ndp = [[0 for _ in range(len(sub)+1)] for _ in range(len(inp)+1)]\n\nfor i in range(1, len(inp)+1):\n    for j in range(1, len(sub)+1):\n        if inp[i-1] == sub[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nprint(len(inp) - dp[-1][-1])\n"]