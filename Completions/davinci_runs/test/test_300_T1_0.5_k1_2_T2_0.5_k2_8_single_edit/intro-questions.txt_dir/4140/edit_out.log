2022-04-19 21:30:39.895073 num operations 1
2022-04-19 21:30:39.895086 size on input set 1
2022-04-19 21:30:39.895254 using api key sunu
2022-04-19 21:30:59.030437 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\n# the number of tiles to be repainted\n# is the number of adjacent tiles with the same color.\n# so we just need to count the number of adjacent tiles with the same color\n\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\ns = stdin.readline().strip()\n\n# the number of tiles to be repainted\n# is the number of adjacent tiles with the same color\n# so we just need to count the number of adjacent tiles with the same color\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "from sys import stdin\n\ns = stdin.readline().strip().split()\n\n# the number of tiles to be repainted\n# is the number of adjacent tiles with the same color\n# so we just need to count the number of adjacent tiles with the same color\n\ncount = 0\nprev = s[0][0]\nfor i in range(1, len(s[0])):\n    if prev != s[0][i]:\n        prev = s[0][i]\n    else:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 3,
      "text": "\nfrom sys import stdin\n\ns = stdin.readline().strip()\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 4,
      "text": "\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\n# the number of tiles to be replaced\n# is the number of adjacent tiles with the same color\n# so we just need to count the number of adjacent tiles with the same color\n\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 5,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline().strip() + '0'\n\n# we can solve this problem by dynamic programming\n# dp[i][j] is the number of ways to make a string of length i\n# that ends with the letter j\n# dp[i][j] = sum(dp[i - 1][k]) for k not equal to j\n# dp[0][0] = 1\n\ndp = [[0 for _ in range(26)] for _ in range(len(s))]\n\ndp[0][0] = 1\n\nfor i in range(1, len(s)):\n    for j in range(26):\n        for k in range(26):\n            if j != k:\n                dp[i][j] += dp[i - 1][k]\n\nans = 0\nfor i in range(26):\n    ans += dp[len(s) - 1][i]\n\nprint(ans)\n"
    },
    {
      "index": 6,
      "text": "\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\nprint(s)\n"
    },
    {
      "index": 7,
      "text": "\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\ndef longest_substring_without_repeating_characters(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    l = 0\n    max_len = 0\n    for r in range(1, len(s)):\n        for i in range(l, r):\n            if s[i] == s[r]:\n                l = i + 1\n        max_len = max(max_len, r - l + 1)\n    return max_len\n \nprint(longest_substring_without_repeating_characters(s))\n"
    }
  ],
  "created": 1650403840,
  "object": "edit"
}
2022-04-19 21:30:59.030764 fix syntax errors 8 ['\n\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\n# the number of tiles to be repainted\n# is the number of adjacent tiles with the same color.\n# so we just need to count the number of adjacent tiles with the same color\n\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\n\nprint(count)\n', '\n\nfrom sys import stdin\ns = stdin.readline().strip()\n\n# the number of tiles to be repainted\n# is the number of adjacent tiles with the same color\n# so we just need to count the number of adjacent tiles with the same color\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\nprint(count)\n', 'from sys import stdin\n\ns = stdin.readline().strip().split()\n\n# the number of tiles to be repainted\n# is the number of adjacent tiles with the same color\n# so we just need to count the number of adjacent tiles with the same color\n\ncount = 0\nprev = s[0][0]\nfor i in range(1, len(s[0])):\n    if prev != s[0][i]:\n        prev = s[0][i]\n    else:\n        count += 1\n\nprint(count)\n', '\nfrom sys import stdin\n\ns = stdin.readline().strip()\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\n\nprint(count)\n', '\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\n# the number of tiles to be replaced\n# is the number of adjacent tiles with the same color\n# so we just need to count the number of adjacent tiles with the same color\n\ncount = 0\nprev = s[0]\nfor i in range(1, len(s)):\n    if prev != s[i]:\n        prev = s[i]\n    else:\n        count += 1\n\nprint(count)\n', "\n\nfrom sys import stdin\n\ns = stdin.readline().strip() + '0'\n\n# we can solve this problem by dynamic programming\n# dp[i][j] is the number of ways to make a string of length i\n# that ends with the letter j\n# dp[i][j] = sum(dp[i - 1][k]) for k not equal to j\n# dp[0][0] = 1\n\ndp = [[0 for _ in range(26)] for _ in range(len(s))]\n\ndp[0][0] = 1\n\nfor i in range(1, len(s)):\n    for j in range(26):\n        for k in range(26):\n            if j != k:\n                dp[i][j] += dp[i - 1][k]\n\nans = 0\nfor i in range(26):\n    ans += dp[len(s) - 1][i]\n\nprint(ans)\n", '\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\nprint(s)\n', '\nfrom sys import stdin\n\ns = stdin.readline().strip()\n\ndef longest_substring_without_repeating_characters(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    l = 0\n    max_len = 0\n    for r in range(1, len(s)):\n        for i in range(l, r):\n            if s[i] == s[r]:\n                l = i + 1\n        max_len = max(max_len, r - l + 1)\n    return max_len\n \nprint(longest_substring_without_repeating_characters(s))\n']
2022-04-19 21:30:59.030819 size on output set 8
2022-04-19 21:30:59.030833 num operations 1
2022-04-19 21:30:59.030839 size on input set 1
2022-04-19 21:30:59.031018 using api key derek
2022-04-19 21:30:59.074691 in retry 6 1.5 <class 'Exception'>, Retrying in 1 seconds...
2022-04-19 21:31:00.576584 using api key sunu
2022-04-19 21:31:11.212408 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 1,
      "text": "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 2,
      "text": "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 3,
      "text": "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 4,
      "text": "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 5,
      "text": "\n\n# -----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 6,
      "text": "\n\n# -----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    },
    {
      "index": 7,
      "text": "\n\n# -----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"
    }
  ],
  "created": 1650403860,
  "object": "edit"
}
2022-04-19 21:31:11.213023 fix syntax errors 8 ["\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n#-----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n\n# -----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n\n# -----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n", "\n\n# -----main-----\n\nS = input()\n\n# black, white count\nb_cnt = 0\nw_cnt = 0\n\n# count black and white\nfor i in S:\n    if i == '0':\n        b_cnt += 1\n    else:\n        w_cnt += 1\n\n# output\nprint(min(b_cnt, w_cnt))\n"]
2022-04-19 21:31:11.213072 size on output set 3
