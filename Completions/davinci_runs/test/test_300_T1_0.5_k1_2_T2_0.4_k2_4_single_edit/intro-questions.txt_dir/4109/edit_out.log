2022-04-17 22:22:17.885696 num operations 1
2022-04-17 22:22:17.885729 size on input set 1
2022-04-17 22:22:42.922966 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0a\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 1,
      "text": "# -*- coding: utf-8 -*-\n\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0a\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n# \u5168\u63a2\u7d22\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 3,
      "text": "\n\nN, M = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor i in range(N):\n    for j in range(M):\n        if a[i] == b[j]:\n            ans = min(ans, a[i])\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    }
  ],
  "created": 1650234138,
  "object": "edit"
}
2022-04-17 22:22:42.923227 fix syntax errors 4 ['\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以上になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以上になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '# -*- coding: utf-8 -*-\n\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以上になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以上になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n\n# 全探索\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n\nN, M = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor i in range(N):\n    for j in range(M):\n        if a[i] == b[j]:\n            ans = min(ans, a[i])\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n']
2022-04-17 22:22:42.923405 size on output set 4
2022-04-17 22:22:42.923422 num operations 1
2022-04-17 22:22:42.923429 size on input set 1
2022-04-17 22:22:49.006743 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(M)]\n    for i in range(N):\n        C[i], *A[i - 1] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport heapq\n\n\ndef read_list():\n    return list(map(int, input().split()))\n\n\ndef read_tuple():\n    return tuple(map(int, input().split()))\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = read_tuple()\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = read_list()\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 3,
      "text": "\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    }
  ],
  "created": 1650234162,
  "object": "edit"
}
2022-04-17 22:22:49.006948 fix syntax errors 4 ['\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(M)]\n    for i in range(N):\n        C[i], *A[i - 1] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\n\nimport heapq\n\n\ndef read_list():\n    return list(map(int, input().split()))\n\n\ndef read_tuple():\n    return tuple(map(int, input().split()))\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = read_tuple()\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = read_list()\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n']
2022-04-17 22:22:49.007103 size on output set 3
