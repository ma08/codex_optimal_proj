["\nx,y = list(map(int,input().split()))\n\nprint((int((x * (x-1)) / 2  + (y * (y - 1))/2)))\n", "n, m = list(map(int, input().split()))\nln = []\nans = 0\nfor i in range(n):\n    ln.append(2)\nfor i in range(m):\n    ln.append(3)\nfor a in range(len(ln)):\n    for b in range(len(ln)):\n        if a != b:\n            if (ln[a]+ln[b]) % 2 == 0:\n                ans += 1\nprint((ans//2))\n", "from scipy.special import comb\n\nn, m = map(int, input().split())\nprint(int(comb(n, 2) + comb(m, 2)))", "import math\n\nn, m = list(map(int, input().split()))\n\n\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\nif n >= 2 and m >= 2:\n    ans = combinations_count(m, 2) + combinations_count(n, 2)\nelif n < 2 and m < 2:\n    ans = 0\nelif n < 2:\n    ans = combinations_count(m, 2)\nelif m < 2:\n    ans = combinations_count(n, 2)\n\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\nprint((n*(n-1)//2+(m*(m-1)//2)))\n", "n,m = list(map(int,input().split()))\n  \nprint((int(n * (n-1) / 2 + m * (m - 1) / 2)))\n", "N, M= map(int, input().split())\nans = (N+M)*(N+M-1)//2 - N*M\nprint(ans)", "N,M=map(int,input().split())\n\nc = (N+M)*(N+M-1)/2 - N*M\n\nprint(int(c))", "a,b=map(int,input().split());print(a*(a-1)//2+b*(b-1)//2)", "import math\nN,M=map(int,input().split())\nprint((M+N)*(M+N-1)//2-M*N)", "N, M = list(map(int, input().split()))\n\nprint((N * (N - 1) // 2 + M * (M - 1) // 2))\n", "import math\ndef combinations_count(n, r):\n\tif n < 2:\n\t\treturn 0\n\treturn math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nn, m = [int(i) for i in input().split()]\nprint(combinations_count(n, 2) + combinations_count(m, 2))", "n, m = map(int, input().split())\n\nans = n * (n - 1) // 2 + m * (m - 1) // 2\nprint(ans)", "n, m = list(map(int, input().split()))\nprint((n * (n - 1) // 2 + m * (m - 1) // 2))\n", "import itertools\nn, m = list(map(int, input().split()))\nln = []\nans = 0\nfor i in range(n):\n    ln.append(2)\nfor i in range(m):\n    ln.append(3)\nfor x in itertools.combinations(ln, 2):\n    if (x[0]+x[1]) % 2 == 0:\n        ans += 1\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\nans = 0\n\nif n == 0:\n    print((int(m * (m - 1) / 2)))\n    return\n\nif m == 0:\n    print((int(n * (n - 1) / 2)))\n    return\n\nans = (n * (n - 1) / 2) + (m * (m - 1) / 2)\nprint((int(ans)))\n", "n, m = map(int, input().split())\n\nans = int(n * (n - 1) / 2 + m * (m - 1) / 2)\nprint(ans)", "from operator import mul\nfrom functools import reduce\n\ndef cmb(n,r):\n    r = min(n-r,r)\n    if n <= 1: return 0\n    if r == 0: return 1\n    over = reduce(mul, range(n, n - r, -1))\n    under = reduce(mul, range(1,r + 1))\n    return over // under\n\nN, M = map(int, input().split())\n\nprint(cmb(N,2)+cmb(M,2))", "def factorial(n):\n    ans = 1\n    for i in range(1,n+1):\n        ans *= i\n    return ans\n\ndef combination(n,r):\n    return factorial(n)//(factorial(n-r)*factorial(r))\n\nN,M = map(int,input().split())\n\nprint(combination(N,2)+combination(M,2))", "a = list(map(int, input().rstrip().split()))\nout=0\nfor i in a:\n    if i > 1:\n        out += i*(i-1)//2\nprint(out)\n", "N,M = map(int,input().split())\nprint((N*(N-1)//2)+(M*(M-1)//2))", "import numpy as np\n#n = int(input())\na = list(map(int, input().rstrip().split()))\nout=0\nfor i in a:\n    if i > 1:\n        out += i*(i-1)//2\nprint(out)\n", "from scipy.special import comb\nN,M = input().split()\nN = int(N)\nM = int(M)\n\nA = 0\nB = 0\nif N >= 2 :\n  A = comb(N, 2, exact=True)\n\nif M >= 2 :\n  B = comb(M, 2, exact=True)\n \nprint(A + B)", "import math\nn,m=map(int,input().split())\n \n \ndef combinations_count(a, b):\n  if a!=0 and a!=1:\n    return math.factorial(a) // (math.factorial(a - b) * math.factorial(b))\n  else:\n    return 0\n \nprint(combinations_count(n, 2)+combinations_count(m,2))", "N, M = list(map(int, input().split()))\nprint(N*(N-1)//2 + M*(M-1)//2)", "import itertools\nN,M = map(int,input().split())\nball = list(range(2,2*N+1,2))+list(range(1,2*M,2))\ncount=0\nfor i,j in list(itertools.combinations(ball,2)):\n  \tif (i+j)%2==0:count+=1\nprint(count)", "# coding: utf-8\n# Your code here!\n[n,m] = input().split()\nn = int(n)\nm = int(m)\n\nsum_n = 0\nsum_m = 0\n\nfor i in range(n):\n    sum_n += i\n    \nfor j in range(m):\n    sum_m += j\n    \nprint(sum_n+sum_m)", "from operator import mul\nfrom functools import reduce\ndef cmb(n,r):\n    over=reduce(mul,range(n,n-r,-1))\n    under=reduce(mul,range(1,r+1))\n    return over//under\n\nN,M=map(int,input().split())\nif N<=1:\n    C=0\nelse:\n    C=cmb(N,2)\nif M<=1:\n    D=0\nelse:\n    D=cmb(M,2)\n    \nprint(C+D)", "n,m = map(int,input().split())\nimport math\n\na = (n * (n - 1)) / 2\n\nb = (m * (m - 1)) / 2\n\nprint(math.floor(a + b))", "N,M = map(int,input().split())\nprint(N*(N-1)//2+M*(M-1)//2)", "n, m = map(int, input().split())\nprint((n+m)*(n+m-1)//2-n*m)", "N,M = map(int,input().split())\ncnt = 0\nif N >= 2:\n    cnt += (N*(N-1))/2\nif M >= 2:\n    cnt += (M*(M-1))/2\n\nprint(int(cnt))", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\n#from heapq import heappush, heappop\n#import numpy as np\n#from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN, M = na()\nprint((N * (N - 1) // 2 + M * (M - 1) // 2))\n\n\n", "import  math\na=list(map(int,input().split()))\nif a[0]==1 and a[1]==1:\n    print((0))\n    \nelif a[0] == 0 or a[0]== 1:\n    b = math.factorial(a[1])/((math.factorial(2)*math.factorial(a[1]-2)) )\n    print((int(b)))  \n   \n    \nelif a[1]== 0  or a[1]== 1:\n    b = math.factorial(a[0])/((math.factorial(2)*math.factorial(a[0]-2)))\n    print((int(b)))\n    \n    \nelse:\n    b = math.factorial(a[1])/((math.factorial(2)*math.factorial(a[1]-2)) )\n    c = math.factorial(a[0])/((math.factorial(2)*math.factorial(a[0]-2)))\n    print((int(b+c)))\n", "import math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self,Nodes,is_directed=False):\n        self.nodes=Nodes\n        self.adj_list={}\n        self.is_directed=is_directed\n \n        for node in self.nodes:\n            self.adj_list[node]=[]\n            \n    def add_edge(self,u,v):\n        self.adj_list[u].append(v)\n        if self.is_directed==False:\n            self.adj_list[v].append(u)\n \n    def print_graph(self):\n        for node in self.nodes:\n            print((node,\"->\",self.adj_list[node]))\n \n    def degree_node(self,node):\n        return len(self.adj_list[node])\n \n    def dfsUTIL(self,v,visited,parents=[]):\n        #print(v,end=\" \")\n        visited[v]=True\n        for i in self.adj_list[v]:\n            if visited[i]==False:\n                self.dfsUTIL(i,visited,parents)\n                parents.append(i)        \n    \n    def dfs(self,v):\n        visited=[False]*(max(self.adj_list)+1)\n        parents=[v]\n        self.dfsUTIL(v,visited,parents)\n        return len(parents)\n        \n#####sorting a dictionary by the values#####\ndef dict_sort(ans):\n    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))\n    \n##### naive method for testing prime or not O(n^.5)#####\ndef is_prime(n):\n    if n==1:\n        return 0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\n\n#####swap function#####\ndef swap(a,b):\n    temp=a\n    a=b\n    b=temp\n    return a,b\n\n#####Primes till Nth O(n)#####\ndef seive_primes(n):\n    flag=[0]*(n+10)\n    flag[1]=flag[0]=1\n    i=2\n    while i*i<=n+1:\n        if flag[i]==0:\n            j=i*i\n            while j<=n+1:\n                flag[j]=1\n                j+=i\n        i+=1\n    return flag\n\n#####all the prime factors of a number#####\ndef factors(n):\n    d={}\n    while(n%2==0):\n        if 2 in d:\n            d[2]+=1\n        else:\n            d[2]=1\n        n/=2\n    for i in range(3,int(n**0.5)+1,2):\n        while(n%i==0):\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n            n/=i\n    n=int(n)\n    if n>1:\n        d[n]=1\n    return d\n\n#####greatest common divisor of two numbers#####\ndef gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\n#####least common multiplyer of two numbers#####\ndef lcm(a,b):\n    return (a*b)//gcd(a,b)\n\n#####function that return all the letters#####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n#####binary search O(logN)#####\ndef binary_search(ls,n,flag):\n    low=0\n    hi=n-1\n    while(low<=hi):\n        mid=(low+hi)//2\n        if ls[mid]==flag:\n            return mid\n        elif ls[mid]>flag:\n            hi=mid-1\n        else:\n            low=mid+1\n    return -1\n\n#####quadratic roots#####\ndef qdrt(a,b,c):\n    chk=b*b-4*a*c\n    if chk>=0:\n        ans1=(-b+chk**0.5)/(2*a)\n        ans2=(-b-chk**0.5)/(2*a)\n        return [int(ans1),int(ans2)]\n    return -1\n#####permutations#####\ndef permutation(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(n-r+1,n+1):\n        ans*=i\n    return ans\n\n#####combinations#####\ndef combination(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(r):\n        ans*=(n-i)\n    div=1\n    for i in range(2,r+1):\n        div*=i\n    return ans//div\n        \n#####taking an array/list as input#####\ndef arinp():\n    ls=list(map(int,input().split()))\n    return ls\n\n#####taking multiple inputs#####\ndef mult_inp():\n    return list(map(int,input().split()))\n\n#####Main function starts from here#####\ndef main():\n    n,m=mult_inp()\n    print((combination(n,2)+combination(m,2)))\ndef __starting_point():\n    main()\n    \n\n    \n    \n    \n            \n    \n    \n\n__starting_point()", "n, m = map(int, input().split())\nprint(n * (n - 1) // 2 + m * (m - 1) // 2)", "a, b = map(int, input().split())\n \nprint(int(a*(a-1)/2+b*(b-1)/2))", "n,m= map(int, input().split())\n \nprint(int(((n*(n-1))+m*(m-1))/2))", "n, m = map(int, input().split())\nprint(int(n*(n-1)/2 + m*(m-1)/2))", "def main():\n    n, m = map(int, input().split())\n    # n\u306f\u5076\u6570\u3001m\u306f\u5947\u6570\n    # n+m\u304b\u30892\u3064\u9078\u3076\u9078\u3073\u65b9\u306f\n    # n:m = 0:2 \u548c\u306f \u5076\u6570\u3001\u9078\u3073\u65b9\u306fmC2\n    # n:m = 1:1 \u548c\u306f \u5947\u6570 \uff08\u4eca\u56de\u306f\u3053\u308c\u306f\u542b\u3081\u306a\u3044\uff09\n    # n:m = 2:0 \u548c\u306f \u5076\u6570\u3001\u9078\u3073\u65b9\u306fnC2\n    cnt = 0\n    if m >= 2:\n        cnt += m * (m -1) // 2\n    if n >=2:\n        cnt += n * (n -1) // 2\n    print(cnt)\n\ndef __starting_point():\n    main()\n__starting_point()", "from scipy.special import comb\nn,m=map(int, input().split())\nprint(comb(n,2,exact=True)+comb(m,2,exact=True))", "N, M = map(int, input().split())\n\n# Think about sets\nall = (N+M) * (N+M-1) // 2\nodd = N * M\nprint(all - odd)", "n, m = map(int, input().split())\nans = 0\nif n >= 2:\n    ans += n*(n-1)//2\nelse:\n    ans += 0\n\nif m >= 2:\n    ans += m*(m-1)//2\nelse:\n    ans += 0\n\nprint(ans)", "n, m = list(map(int,input().split()))\n\nsum = n * (n - 1) / 2 + m * (m - 1) / 2 \n\nprint((int(sum)))\n", "n, m = map (int, input().split())\nex1 = n*(n-1)//2\nex2 = m*(m-1)//2\nans = ex1 + ex2\nprint(ans)", "print(sum(i*~-i//2for i in map(int,input().split())))", "n, m = map(int, input().split())\nprint((n*max(n-1, 0)//2 + m*max(m-1, 0) // 2))", "N,M = map(int,input().split())\nprint(N*(N-1)//2+M*(M-1)//2)", "import math\n\ndef comb(n, r):\n  if n <= 1:\n    return 0\n  return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nN, M = list(map(int, input().split()))\nprint(comb(N+M, 2) - N*M )", "import math\nN,M=list(map(int, input().split()))\n\nx=(N*(N-1)/2)+(M*(M-1)/2)\n\nprint((math.floor(x)))\n", "N,M = map(int,input().split())\nprint(N*(N-1)//2+M*(M-1)//2)", "n, m = list(map(int, input().split()))\nprint((m * (m - 1) // 2 + n * (n - 1) // 2))\n", "n,m = map(int,input().split())\nif n > 1:\n    an = n*(n-1)/2\nelse:\n    an = 0\nif m>1:\n    am = m*(m-1)/2\nelse:\n    am = 0\nprint(int(an+am))", "n,m=map(int,input().split())\nprint(int((n*(n-1)/2)+(m*(m-1)/2)))", "n, m = map(int, input().split())\nres = ((n*n)-n)//2+((m*m)-m)//2\nprint(res)", "n,m = map(int,input().split())\nprint(n*(n-1)//2+m*(m-1)//2)", "import math\nN,M=map(int,input().split())\ndef C(x):\n    if x>=2:\n        return math.factorial(x)//(math.factorial(x-2)*2)\n    else:\n        return 0\nprint(C(N)+C(M))", "n, m = map(int, input().split())\nans = n*(n - 1)/2 + m*(m - 1)/2\nprint(int(ans))", "import math\ndef comb(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nn,m=list(map(int,input().split()))\nif (n<=1) and (m<=1):\n  ans=0\nelse:\n  if n<=1:\n    ans=comb(m,2)\n  elif m<=1:\n    ans=comb(n,2)\n  else:\n    ans=comb(n,2)+comb(m,2)\n  \nprint(ans)\n", "def resolve():\n    n,m = map(int,input().split())\n    print(int(n*(n-1)/2+m*(m-1)/2))\n\nresolve()", "n,m=map(int,input().split())\nprint(n*(n-1)//2 + m*(m-1)//2)", "n, m = map(int, input().split())\n\nans = (n * (n-1) //2) + (m * (m-1) //2)\nprint(ans)", "n, m = list(map(int, input().split()))\n\nif n >= 2:\n    even = n * (n-1) / 2\nelse:\n    even = 0\n\nif m >= 2:\n    odd = m * (m-1) / 2\nelse:\n    odd = 0\n\nprint((int(even+odd)))\n\n", "inp=input().split()\nn=int(inp[0])\nm=int(inp[1])\narr=[]\npares=0\nimpares=0\ncount=1\nnums=0\n\ndef binary(arr, menor, mayor, x): \n    if mayor >= menor: \n        med = (mayor + menor) // 2\n        if arr[med] == x: \n            return med \n\n        elif arr[med] > x: \n            return binary(arr, menor, med - 1, x) \n  \n        else: \n            return binary(arr, med + 1, mayor, x) \n    else: \n        return -1\n\nwhile len(arr)<(m+n):\n    if count%2==0 and pares<n:\n        arr.append(count)\n        pares+=1\n    elif count%2!=0 and impares<m:\n        arr.append(count)\n        impares+=1\n    count+=1\nsums=[]\n\n\nfor x in arr:\n   for y in arr:\n        if(x+y)%2==0 and binary(sums, 0, len(sums)-1, [y,x])==-1 and x!=y:\n            sums.append([x,y])\n            nums+=1\nprint(nums)\n", "from scipy.special import comb\n\nn, m = list(map(int, input().split()))\nif n <= 1:\n  a = 0\nelse:\n  a = comb(n, 2, exact = \"true\")\nif m <= 1:\n  b = 0\nelse:\n  b = comb(m, 2, exact = \"true\")\nprint(a+b)", "n, m = map(int, input().split())\nprint(n*(n-1)//2+m*(m-1)//2)", "n,m = map(int,input().split())\n\nans = int(n*(n-1)/2 + m*(m-1)/2)\nprint(ans)", "import math\n\nn, m = list(map(int, input().split()))\n\ndef c(a, b):\n    if a >= 2:\n        return math.factorial(a) // (math.factorial(b) * math.factorial(a - b))\n    else:\n        return 0\n        \n\nprint((c(n, 2) + c(m, 2)))\n", "n, m = map(int ,input().split())\n\nx= n*(n-1)/2\nz= m*(m-1)/2\nprint(int(x+z))", "# 159 A\nN,M = list(map(int, input().split()))\nprint((N*(N-1) + M*(M-1))//2)", "N, M = list(map(int, input().split()))\n\nans = N*(N-1)//2 + M*(M-1)//2\nprint(ans)\n", "def main():\n    N, M = tuple([int(_x) for _x in input().split()])\n    print((N*(N-1)//2 + M*(M-1)//2))\n\n\nmain()\n", "N,M=map(int,input().split())\nprint(N*(N-1)//2+M*(M-1)//2)", "def main():\n    n,m = map(int, input().split())\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            cnt +=1\n    \n    for i in range(m):\n        for j in range(i+1, m):\n            cnt +=1\n    return cnt\n\ndef __starting_point():\n    print(main())\n__starting_point()", "from math import floor\nn,m = list(map(int,input().split()))\na =(n*(n-1))/2\nb =(m*(m-1))/2\nprint((floor(a+b)))\n", "n, m = list(map(int, input().split()))\nprint((n * (n - 1) // 2 + m * (m - 1) // 2))\n", "N, M = map(int, input().split())\nx = N + M\nprint(x * (x - 1) // 2 - N * M)", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int):\n    T=N+M\n    T=((T*(T-1))/2)\n    return print(int(T-M*N))\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    solve(N, M)\n\ndef __starting_point():\n    main()\n__starting_point()", "[N, M] = [int(i) for i in input().split()]\nprint(int(N*max(N-1, 0)/2) + int(M*max(M-1, 0)/2))", "import sys\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\ndef solve():\n    n, m = inl()\n    return n * (n - 1) // 2 + m * (m - 1) // 2\n\n\nprint(solve())\n", "n, m = map(int, input().split())\n\nans = int((n*(n-1)/2) + (m*(m-1)/2))\nprint(ans)", "n,m = map(int,input().split())\nprint((n*(n-1))//2 + (m*(m-1))//2)", "n, m = list(map(int, input().split()))\nprint((n*(n-1)//2 + m*(m-1)//2))\n", "N, M = list(map(int, input().split()))\n\nif N < 2:\n    guusuu = 0\nelse:\n    guusuu = N * (N - 1) / 2\n\nif M < 2:\n    kisuu = 0\nelse:\n    kisuu = M * (M - 1) / 2\n\nprint(int(guusuu + kisuu))", "m,n=map(int,input().split())\nprint(m*(m-1)//2+n*(n-1)//2)", "N,M=list(map(int,input().split()))\nprint((N*(N-1)//2+M*(M-1)//2))\n", "n,m=map(int,input().split())\nprint(n*(n-1)//2+m*(m-1)//2)", "N,M = list(map(int,input().split()))\n\nki = (N*(N-1))//2\ngu = (M*(M-1))//2\n\nprint((ki+gu))\n", "N, M = list(map(int, input().split()))\nprint(N*(N-1)//2 + M*(M-1)//2)", "N, M = map(int, input().split())\nans = N*(N-1)//2 + M*(M-1)//2\nprint(ans)", "a=input(\"\")\nlista=a.split()\nlista2=[]\npar=0\nimpar=-1\ncontador=0\nfor i in range (int(lista[0])):\n  par+=2\n  lista2.append(par)\nfor i in range (int(lista[1])):\n  impar+=2\n  lista2.append(impar)\nlongitud=len(lista2)-1\n\nfor i in range (0,len(lista2)):\n  b=i\n  while True:\n    if b+1>longitud:\n      break \n    else: \n      suma=lista2[i]+lista2[b+1]\n      b=b+1\n      if suma%2==0:\n        contador+=1\n      \nprint(contador)\n", "import itertools\nn,m=map(int,input().split())\ni = [2]*n\nj = [2]*m\np = list(itertools.combinations(i, 2))\nq = list(itertools.combinations(j, 2))\nprint(len(p)+len(q))", "N,M=map(int,input().split())\n#----------\u4ee5\u4e0a\u5165\u529b----------\nprint (int(N*(N-1)/2+M*(M-1)/2))", "import os, sys, re, math\n\n(N, M) = [int(n) for n in input().split()]\n\ncn = (N * (N - 1)) // 2\ncm = (M * (M - 1)) // 2\nprint((cn + cm))\n", "N, M = [int(s) for s in input().split(' ')]\nprint(((N * (N - 1) + M * (M - 1)) // 2))\n", "n,m = map(int,input().split())\nans = 0\ndef com2(x):\n  return x*(x-1)//2\nif n >= 2:\n  ans += com2(n)\nif m >= 2:\n  ans += com2(m)\nprint(ans)", "n,m = map(int,input().split())\nprint(n*(n-1)//2 + m*(m-1)//2)", "N, M = map(int, input().split())\nans = (N+M)*(N+M-1)//2 - (N*M)\nprint(ans)", "n,m = list(map(int,input().split()))\nans = 0\nif(n >= 2):\n    ans += n*(n-1)//2\n    \nif(m >= 2):\n    ans += m*(m-1)//2\nprint(ans)\n", "a,b=map(int,input().split())\nprint(a*(a-1)//2+b*(b-1)//2)"]