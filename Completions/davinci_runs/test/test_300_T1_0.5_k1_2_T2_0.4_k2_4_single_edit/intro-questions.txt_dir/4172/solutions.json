["#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,k = LI()\n    a = LI()\n    a.sort()\n    d = defaultdict(lambda : 0)\n    c = defaultdict(lambda : 0)\n    s = [0]\n    for i in a:\n        d[i] += i\n        c[i] += 1\n        s.append(s[-1]+i)\n    ans = float(\"inf\")\n    p = -1\n    for i in a:\n        if i == p:\n            continue\n        if k <= c[i]:\n            ans = 0\n            break\n        l,r = bisect.bisect_left(a,i),bisect.bisect_right(a,i)\n        m = r\n        if m >= k:\n            ns = l*(i-1)-s[l]\n            su = ns+k-c[i]\n            if su < ans:\n                ans = su\n        m = n-l\n        if m >= k:\n            ns = s[n]-s[r]-(n-r)*(i+1)\n            su = ns+k-c[i]\n            if su < ans:\n                ans = su\n        ns = s[n]-s[r]-(n-r)*(i+1)+l*(i-1)-s[l]\n        su = ns+k-c[i]\n        if su < ans:\n            ans = su\n        p = i\n    print(ans)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "from collections import Counter\n\nimport sys\nfrom itertools import accumulate\n\n\n#\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n\ndef go():\n    n, k = list(map(int, input().split()))\n    a = sorted(map(int, input().split()))\n    c = Counter(a)\n    if max(c.values()) >= k:\n        return 0\n\n    upsum = {}\n    upcnt = {}\n    prev = -1\n    cursum = 0\n    for cnt, aa in enumerate(a):\n        if aa != prev:\n            upsum[aa] = cursum\n            upcnt[aa] = cnt\n        cursum += aa\n        prev = aa\n\n    downsum = {}\n    downcnt = {}\n    prev = -1\n    cursum = 0\n    for cnt, aa in enumerate(reversed(a)):\n        if aa != prev:\n            downsum[aa] = cursum\n            downcnt[aa] = cnt\n        cursum += aa\n        prev = aa\n\n    best = cursum\n    for target, cnt in list(c.items()):\n        need = k - cnt\n        if upcnt[target] >= need:\n            best = min(best, (target - 1) * upcnt[target] - upsum[target] + need)\n        if downcnt[target] >= need:\n            best = min(best, downsum[target] - (target + 1) * downcnt[target] + need)\n        best = min(best, (target - 1) * upcnt[target] - upsum[target]\n                   + downsum[target] - (target + 1) * downcnt[target] +need\n                   )\n\n    return best\n\n\n# x,s = map(int,input().split())\n# t = int(input())\nt = 1\n# ans = []\nfor _ in range(t):\n    print(go())\n    # ans.append(str(go()))\n#\n# print('\\n'.join(ans))\n", "def main():\n    import sys\n    input=sys.stdin.readline\n    n,k=map(int,input().split())\n    A=list(map(int,input().split()))\n    A.sort()\n    A.append(0)\n    l1=[0]*n\n    for i in range(1,n):\n        l1[i]=l1[i-1]+(A[i]-A[i-1])*i \n    l2=[0]*n\n    for i in range(1,n):\n        l2[n-i-1]=l2[n-i]+(A[n-i]-A[n-i-1])*i \n    ans=float(\"INF\")\n    c=1\n    for i in range(n):\n        if A[i+1]==A[i]:\n            c+=1\n        else:\n            c1=i-c+1\n            c2=n-i-1\n            if c>=k:\n                ans=0\n            elif c+c1>=k or c+c2>=k:\n                if c+c1>=k:\n                \tans=min(ans,l1[i]-c-c1+k)\n                if c+c2>=k:\n                \tans=min(ans,l2[i]-c-c2+k)\n            else:\n                ans=min(ans,l1[i]+l2[i]-n+k)\n            c=1\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\nfrom bisect import bisect, bisect_left\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na = Counter(a)\nc = sorted(Counter(a).items())\nkeys = sorted(Counter(a).keys())\n\nm = len(c)\nl_cum = [c[0][0] * c[0][1]]\nl_cnt = [c[0][1]]\nfor i in range(1, m):\n\tl_cum.append(l_cum[-1] + c[i][0] * c[i][1])\n\tl_cnt.append(l_cnt[-1] + c[i][1])\n\n\nr_cum = [0 for _ in range(m)]\nr_cum[-1] = c[-1][0] * c[-1][1]\nr_cnt = [0 for _ in range(m)]\nr_cnt[-1] = c[-1][1]\nfor i in range(m-2, -1, -1):\n\tr_cum[i] = r_cum[i+1] + c[i][0] * c[i][1]\n\tr_cnt[i] = r_cnt[i+1] + c[i][1]\n\n#print(l_cum)\n#print(r_cum)\n\nans = 10**20\nfor i in range(m):\n\tc_num = a[keys[i]]\n\tif c_num >= k:\n\t\tans = 0\n\t\tbreak\n\n\tif i > 0:\n\t\tl_res = (keys[i]-1) * l_cnt[i-1] - l_cum[i-1]\n\t\tl_num = l_cnt[i-1]\n\telse:\n\t\tl_res = 10**30\n\t\tl_num = 0\n\tif i < m-1:\n\t\tr_res = r_cum[i+1] - (keys[i]+1) * r_cnt[i+1]\n\t\tr_num = r_cnt[i+1]\n\telse:\n\t\tr_res = 10**30\n\t\tr_num = 0\n\n\tif c_num + l_num < k and c_num + r_num < k:\n\t\tans = min(ans, l_res + r_res + k - c_num)\n\telif c_num + l_num < k:\n\t\tans = min(ans, r_res + k - c_num)\n\telif c_num + r_num < k:\n\t\tans = min(ans, l_res + k - c_num)\n\telse:\n\t\tans = min(ans, min(r_res, l_res) + k - c_num)\n\t#print(ans)\n\nprint(ans)", "n, k = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nsums, suf, q1 = [0]*n, [n]*n, n\nfor q in range(n-2, -1, -1):\n    sums[q] = sums[q + 1]\n    if a[q] != a[q1-1]:\n        sums[q] += (n-q1)*(a[q1-1]-a[q])+(q1-q-1)*(a[q1-1]-a[q]-1)\n        q1 = q + 1\n    suf[q] = q1\nans, sum1, q1 = sums[0]+k-suf[0] if suf[0] < k else 0, 0, -1\nfor q in range(1, n):\n    if a[q] != a[q1 + 1]:\n        sum1 += (q1+1)*(a[q]-a[q1+1])+(q-q1-1)*(a[q]-a[q1+1]-1)\n        q1 = q - 1\n    if suf[q]-q1-1 >= k:\n        ans = 0\n        break\n    if k <= suf[q]:\n        ans = min(ans, sum1+k-suf[q]+q1+1)\n    if k < n-q1:\n        ans = min(ans, sums[q]+k-suf[q]+q1+1)\n    ans = min(ans, sum1+sums[q]+k-suf[q]+q1+1)\nprint(ans)\n"]