["\n\nn, k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]  # list of integers\n\nd.sort()\n\n# build a lookup table for each mod value,\n# i.e. mods[i] is the number of integers that have remainder i when divided by k\nmods = [0] * k\nfor i in d:\n    mods[i % k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val] / 2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k % 2 == 0:\n    if max_mod_val == int(k / 2):\n        num_pairs += int(mods[0] / 2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k - max_mod_val]) / 2)\n\nprint(2 * num_pairs)\n", "\n\nn,k = map(int,input().split())\nd = list(map(int,input().split()))\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\n\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nif l < r:\n    if possible(d[l], d[r]):\n        ans += 2\n        l += 1\n        r -= 1\n    else:\n        ans += 1\n        r -= 1\n\nif l == r:\n    ans += 1\n\nprint(ans)\n", "\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\n\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"]