2022-04-16 00:33:43.888889 num operations 1
2022-04-16 00:33:43.888907 size on input set 1
2022-04-16 00:33:45.645621 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/python3\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    }
  ],
  "created": 1650069224,
  "object": "edit"
}
2022-04-16 00:33:45.645860 fix syntax errors 3 ['import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '#!/usr/bin/python3\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n']
2022-04-16 00:33:45.645914 size on output set 3
2022-04-16 00:33:45.645926 num operations 1
2022-04-16 00:33:45.645931 size on input set 1
2022-04-16 00:33:50.614533 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split()) \n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import deque\n\nfrom sys import stdin\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninputLines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(inputLines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, inputLines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, inputLines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    }
  ],
  "created": 1650069225,
  "object": "edit"
}
2022-04-16 00:33:50.614840 fix syntax errors 3 ["\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split()) \n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\nfrom collections import deque\n\nfrom sys import stdin\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninputLines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(inputLines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, inputLines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, inputLines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]
2022-04-16 00:33:50.614937 size on output set 3
