2022-04-09 20:47:09.692229 """
You are given a tree consisting exactly of $n$ vertices. Tree is a connected undirected graph with $n-1$ edges. Each vertex $v$ of this tree has a value $a_v$ assigned to it.

Let $dist(x, y)$ be the distance between the vertices $x$ and $y$. The distance between the vertices is the number of edges on the simple path between them.

Let's define the cost of the tree as the following value: firstly, let's fix some vertex of the tree. Let it be $v$. Then the cost of the tree is $\sum\limits_{i = 1}^{n} dist(i, v) \cdot a_i$.

Your task is to calculate the maximum possible cost of the tree if you can choose $v$ arbitrarily.


-----Input-----

The first line contains one integer $n$, the number of vertices in the tree ($1 \le n \le 2 \cdot 10^5$).

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 2 \cdot 10^5$), where $a_i$ is the value of the vertex $i$.

Each of the next $n - 1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects ($1 \le u_i, v_i \le n$, $u_i \ne v_i$).

It is guaranteed that the given edges form a tree.


-----Output-----

Print one integer â€” the maximum possible cost of the tree if you can choose any vertex as $v$.


-----Examples-----
Input
8
9 4 1 7 10 1 6 5
1 2
2 3
1 4
1 5
5 6
5 7
5 8

Output
121

Input
1
1337

Output
0



-----Note-----

Picture corresponding to the first example: [Image]

You can choose the vertex $3$ as a root, then the answer will be $2 \cdot 9 + 1 \cdot 4 + 0 \cdot 1 + 3 \cdot 7 + 3 \cdot 10 + 4 \cdot 1 + 4 \cdot 6 + 4 \cdot 5 = 18 + 4 + 0 + 21 + 30 + 4 + 24 + 20 = 121$.

In the second example tree consists only of one vertex so the answer is always $0$.
"""
2022-04-09 20:47:09.692255 --------------------------
2022-04-09 20:47:33.594032 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))"
    }
  ],
  "created": 1649551630,
  "id": "cmpl-4vG1OupIVyEjNs8bXG2yQ3xAsprT2",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 20:47:33.594257 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 20:47:33.594318 REASON stop
2022-04-09 20:47:33.606330 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))"
}
2022-04-09 20:47:33.606424 REASON stop
