["\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])  # O(nlogn)\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:  # O(n)\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)  # O(n)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\n\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound \n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef solve(input_):\n    return\n", "\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n", "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    print(minions)\n    minions.sort(key=lambda x: x[1])\n    print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n", "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(tuple(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    rooms = []\n    rooms.append(intervals[0][1])\n    for i in range(n):\n        for j in range(len(rooms)):\n            if intervals[i][0] >= rooms[j]:\n                rooms[j] = intervals[i][1]\n                break\n        if j == len(rooms) - 1:\n            rooms.append(intervals[i][1])\n    print(len(rooms))\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n", "\nimport sys\n\ndef main(pname):\n    # sys.stdin = open(pname + '.in', 'r')\n    # sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n", "\n\n# Use a greedy algorithm. For each minion, find the lowest temperature that is available. If none is available, create a new room with that temperature.\n\nn = int(input()) # number of minions\nminions = []\nrooms = []\n\n    # tuple of lower and upper temperature bounds for each minion\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n# for each minion, check if there is a room that meets the temperature requirements\n\nfor i in range(n):\n    # set default to false\n    m = minions[i]\n    available = False\n        # if temperature is between the bounds, the minion is satisfied\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        # if no room meets the requirements, create a new room with the lower bound temperature\n        rooms.append(m[0])\n\nprint(len(rooms))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\n\n# this is a file\n", "\n\n# n = int(input())\n# for i in range(n):\n#     print(i)\n#\n# for i in range(n):\n#     for j in range(n):\n#         print(i, j)\n#\n# for i in range(n):\n#     for j in range(n):\n#         for k in range(n):\n#             print(i, j, k)\n#\n# for i in range(n):\n#     for j in range(n):\n#         for k in range(n):\n#             for l in range(n):\n#                 print(i, j, k, l)\n#\n# for i in range(n):\n#     for j in range(n):\n#         for k in range(n):\n#             for l in range(n):\n#                 for m in range(n):\n#                     print(i, j, k, l, m)\n", "\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\nimport sys\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n): \n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n): \n    m = minions[i]\n    available = False\n    for r in rooms: \n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0]) \n\nprint(len(rooms))\n", "\n\ndef solve(input):\n    n = int(input[0]) # number of elements in array\n    a = [int(x) for x in input[1].split()]\n    print(n)\n    print(a)\n\n    return 0\n\n\nif __name__ == '__main__':\n    input = [\n        '5',\n        '1 2 3 4 5'\n    ]\n    print(solve(input))\n", "# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\nn = int(input())\nminions = []\nrooms = []\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\nprint(len(rooms))\n", "import math\n\n\n\ndef main():\n    N, K = map(int, input().split())\n    A = [int(x) for x in input().split()]\n    A.sort()\n    # print(A)\n    ans = float('inf')\n    for i in range(N - K + 1):\n        ans = min(ans, A[i + K - 1] - A[i])\n    print(ans)\n\n\nmain()\n", "n = int(input())\nprint(n)\n", "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n", "\n\ndef main():\n    N = int(input())\n    minions = [\n        [int(x) for x in input().split()]\n        for i in range(N)\n    ]\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n, m = [int(i) for i in input().split()]\n    cows = []\n    for i in range(n):\n        cows.append(int(input()))\n    cows.sort()\n    cows.reverse()\n    intervals = []\n    for i in range(n):\n        intervals.append(cows[i] - cows[i+1])\n    intervals.sort()\n    intervals.reverse()\n    print(sum(intervals[m-1:]))\n\nif __name__ == \"__main__\":\n    main('socdist')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"]