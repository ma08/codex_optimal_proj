["---\ntitle: \"file\"\ndate: 2019-03-05T15:27:49+08:00\ndraft: false\n---\n\n\n# file\n\n## \u6982\u8ff0\n\nfile \u547d\u4ee4\u662f\u7528\u6765\u68c0\u67e5\u6587\u4ef6\u7c7b\u578b\u7684\uff0c\u5b83\u662f\u901a\u8fc7\u68c0\u67e5\u6587\u4ef6\u7684\u524d\u51e0\u4e2a\u5b57\u8282\u6765\u5224\u65ad\u6587\u4ef6\u7c7b\u578b\u7684\u3002\n\n\n\n## \u5e38\u7528\u53c2\u6570\n\n```\n-b  \u53bb\u9664\u6587\u4ef6\u540d\u524d\u9762\u7684\u8def\u5f84\uff0c\u53ea\u8f93\u51fa\u6587\u4ef6\u540d\n-c  \u6839\u636emagic\u6587\u4ef6\u751f\u6210\u4e00\u4e2acache\u6587\u4ef6\n-f  \u6307\u5b9a\u4e00\u4e2a\u6587\u4ef6\u5217\u8868\uff0cfile\u5c06\u4f1a\u68c0\u67e5\u8fd9\u4e2a\u6587\u4ef6\u5217\u8868\u91cc\u9762\u5217\u51fa\u7684\u6587\u4ef6\n-F  \u5206\u9694\u7b26\uff0c\u7f3a\u7701\u7684\u5206\u9694\u7b26\u662f\u201c:\u201d\uff0c-F\u6307\u5b9a\u5206\u9694\u7b26\n-h  \u5982\u679c\u6587\u4ef6\u662f\u4e00\u4e2a\u8f6f\u8fde\u63a5\uff0c\u90a3\u4e48\u663e\u793a\u8fde\u63a5\u6587\u4ef6\u7684\u6587\u4ef6\u540d\uff0c\u800c\u4e0d\u662f\u8fde\u63a5\u76ee\u6807\u7684\u6587\u4ef6\u540d\n-i  \u663e\u793amime\u7c7b\u578b\n-m  \u6307\u5b9amagic\u6587\u4ef6\n-z  \u5982\u679c\u6587\u4ef6\u662f\u538b\u7f29\u6587\u4ef6\uff0c\u5219\u663e\u793a\u5176\u4e2d\u7684\u6587\u4ef6\u7c7b\u578b\n```\n\n\n\n## \u5e38\u7528\u7528\u6cd5\n\n```\nfile -i filename  \u663e\u793a\u6587\u4ef6mime\u7c7b\u578b\nfile -b filename  \u53bb\u9664\u6587\u4ef6\u540d\u524d\u9762\u7684\u8def\u5f84\uff0c\u53ea\u8f93\u51fa\u6587\u4ef6\u540d\nfile -z filename  \u5982\u679c\u6587\u4ef6\u662f\u538b\u7f29\u6587\u4ef6\uff0c\u5219\u663e\u793a\u5176\u4e2d\u7684\u6587\u4ef6\u7c7b\u578b\n```\n\n\n\n## \u53c2\u8003\u8d44\u6599\n\n[Linux file\u547d\u4ee4\u7528\u6cd5\u8be6\u89e3](https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)\n\n[Linux file\u547d\u4ee4\u8be6\u89e3](https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)\n", "\n\ndef main():\n    # read data for n sequences\n    n = int(input())\n    s = []\n    t = []\n    for i in range(n):\n        s_i = input()\n        s.append(s_i)\n        t_i = input()\n        t.append(t_i)\n\n    # solve\n    for i in range(n):\n        if s[i] == t[i]:\n            print(0)\n        else:\n            # create a dictionary to store the number of occurences of each character\n            d = {}\n            for j in range(n):\n                if s[i][j] in d:\n                    d[s[i][j]] += 1\n                else:\n                    d[s[i][j]] = 1\n                if t[i][j] in d:\n                    d[t[i][j]] -= 1\n                else:\n                    d[t[i][j]] = -1\n            flag = True\n            for key in d:\n                if d[key] != 0:\n                    flag = False\n                    break\n            if flag:\n                j = 0\n                k = 0\n                count = 0\n                while j < n and k < n:\n                    if s[i][j] == t[i][k]:\n                        j += 1\n                        k += 1\n                    else:\n                        j += 1\n                        count += 1\n                if count > 10000:\n                    print(-1)\n                else:\n                    print(count)\n                    j = 0\n                    k = 0\n                    while j < n and k < n:\n                        if s[i][j] == t[i][k]:\n                            j += 1\n                            k += 1\n                        else:\n                            print(j, end=' ')\n                            j += 1\n                            count += 1\n            else:\n                print(-1)\n\nmain()\n", "\n\ndef main():\n    # read data for n characters\n    n = int(input())\n    s = input()\n    t = input()\n\n    # solve\n    if s == t:\n        print(0)\n    else:\n        # create a dictionary to store the number of occurrences of each character\n        d = {}\n        for i in range(n):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n            if t[i] in d:\n                d[t[i]] -= 1\n            else:\n                d[t[i]] = -1\n        flag = True\n        for key in d:\n            if d[key] != 0:\n                flag = False\n                break\n        if flag:\n            i = 0\n            j = 0\n            count = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n                    count += 1\n            if count > 10000:\n                print(-1)\n            else:\n                print(count)\n                i = 0\n                j = 0\n                while i < n and j < n:\n                    if s[i] == t[j]:\n                        i += 1\n                        j += 1\n                    else:\n                        print(i, end=' ')\n                        i += 1\n                        count += 1\n        else:\n            print(-1)\n\nmain()\n", "\n\ndef main():\n    # read data for n sequences\n    n = int(input())\n    s = input()\n    t = input()\n\n    # solve\n    if s == t:\n        print(0)\n    else:\n        # create a dictionary to store the number of occurences of each character\n        d = {}\n        for i in range(n):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n            if t[i] in d:\n                d[t[i]] -= 1\n            else:\n                d[t[i]] = -1\n        flag = True\n        for key in d:\n            if d[key] != 0:\n                flag = False\n                break\n        if flag:\n            i = 0\n            j = 0\n            count = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n                    count += 1\n            if count > 10000:\n                print(-1)\n            else:\n                print(count)\n            i = 0\n            j = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    print(i, end=' ')\n                    i += 1\n                    count += 1\n        else:\n            print(-1)\n\nmain()\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#define BUFFER_SIZE 25\n#define READ_END 0\n#define WRITE_END 1\n#define SHM_SIZE 1024\n\nint main()\n{\n    int fd[2];\n    pid_t pid;\n    char write_msg[BUFFER_SIZE] = \"Greetings\";\n    char read_msg[BUFFER_SIZE];\n    int shm_id;\n    int *shm_ptr;\n    key_t key;\n\n    key = ftok(\"/tmp\", 'a');\n    shm_id = shmget(key, SHM_SIZE, IPC_CREAT | 0666);\n    shm_ptr = shmat(shm_id, NULL, 0);\n\n    if (pipe(fd) == -1)\n    {\n        fprintf(stderr, \"Pipe failed\");\n        return 1;\n    }\n\n    pid = fork();\n\n    if (pid < 0)\n    {\n        fprintf(stderr, \"Fork failed\");\n        return 1;\n    }\n\n    if (pid > 0)\n    {\n        close(fd[READ_END]);\n        write(fd[WRITE_END], write_msg, strlen(write_msg) + 1);\n        close(fd[WRITE_END]);\n        wait(NULL);\n        printf(\"Child wrote: [%s]\\n\", shm_ptr);\n    }\n    else\n    {\n        close(fd[WRITE_END]);\n        read(fd[READ_END], read_msg, BUFFER_SIZE);\n        close(fd[READ_END]);\n        sprintf(shm_ptr, \"Child read: [%s]\\n\", read_msg);\n    }\n\n    shmdt(shm_ptr);\n    shmctl(shm_id, IPC_RMID, NULL);\n\n    return 0;\n}\n", "import os\n\n#os.getcwd()\n#os.chdir(path)\n#os.listdir(path)\n#os.mkdir(path)\n#os.path.join(path, dirname)\n#os.path.basename(path)\n#os.path.dirname(path)\n#os.path.split(path)\n#os.path.getsize(path)\n#os.path.exists(path)\n#os.path.isdir(path)\n#os.path.isfile(path)\n#os.path.splitext(path)\n\n#open(path, mode)\n#file.read()\n#file.readline()\n#file.write(str)\n#file.close()\n\n#shutil.copy(path, newpath)\n#shutil.copytree(path, newpath)\n#shutil.move(path, newpath)\n#shutil.rmtree(path)\n\n#zipfile.ZipFile(path)\n#zipfile.extractall(path)\n\n#open(path).read()\n\n"]