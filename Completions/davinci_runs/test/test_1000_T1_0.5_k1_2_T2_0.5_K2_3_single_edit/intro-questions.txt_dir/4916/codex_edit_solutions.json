["\n\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n ** 2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0] * (k + 1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k + 1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k + 1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(\n                    next_tile[1] - start_tile[1]\n                )\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:  # noqa: E712\n            best_path = path_length\n    print(best_path)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return (abs(start[0]-end[0]) + abs(start[1]-end[1]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile, and\n    # create a list to store the tiles to visit in order\n    min_distance = {}\n    tiles_to_visit = []\n\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0,\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles to visit in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles on the board\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles on the board\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile if necessary\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2),\n                                                         min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles on the board\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles on the board\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles on the board\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles on the board\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i, row in enumerate(tiles):\n        for j, col in enumerate(row):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i, row in enumerate(tiles):\n            for j, col in enumerate(row):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2, row in enumerate(tiles):\n                        for j2, col in enumerate(row):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i, row in enumerate(tiles):\n        for j, col in enumerate(row):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2, row in enumerate(tiles):\n                    for j2, col in enumerate(row):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3, row in enumerate(tiles):\n                                for j3, col in enumerate(row):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4, row in enumerate(tiles):\n                                            for j4, col in enumerate(row):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\n \nn = int(input())\n \nfor i in range(n):\n    a, b = map(int, input().split())\n    print(math.factorial(a) + math.factorial(b))\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k, n):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {1: 0}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k, n):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < (n * n)\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = []\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile.append((i, j))\n                            break\n                    if next_tile:\n                        break\n                if len(next_tile) > 1:\n                    # Find the closest next tile\n                    min_dist = n**2\n                    closest_tile = None\n                    for tile in next_tile:\n                        dist = abs(tile[0] - start_tile[0]) + abs(tile[1] - start_tile[1])\n                        if dist < min_dist:\n                            min_dist = dist\n                            closest_tile = tile\n                    next_tile = closest_tile\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                start_tile = next_tile\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0] - tile[0]) + abs(start[1] - tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n", "\n\ndef get_min_dist(n, k, matrix, dp):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    dp = [[-1 for i in range(n)] for j in range(n)]\n    print(get_min_dist(n, k, matrix, dp))\n", "\n\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n        \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k and tiles[i][j] != 1:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k-1, i+1, j), min_hopscotch_helper(tiles, n, k-1, i-1, j), min_hopscotch_helper(tiles, n, k-1, i, j+1), min_hopscotch_helper(tiles, n, k-1, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n", "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n# print(tiles)\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k-1, i+1, j), min_hopscotch_helper(tiles, n, k-1, i-1, j), min_hopscotch_helper(tiles, n, k-1, i, j+1), min_hopscotch_helper(tiles, n, k-1, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n", "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n", "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1)\n\nif __name__ == \"__main__\":\n    main()\n"]