["\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        yield int(input())\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) ** 2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm. The idea is to start from the center\n# and move the figures to the closest cells. If the center is not empty, we can move the figures\n# in the center to the closest cells and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center. Because we move the figures\n# to the closest cells, the number of moves is minimized. The time complexity is O(n^2), which is\n# the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) ** 2\n\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\ndef get_input(input_func=input):\n    t = int(input())\n    for i in range(t):\n        n = int(input_func())\n        yield n\n\ndef solve(n):\n    pass\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"]