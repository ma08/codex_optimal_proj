["\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove()))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove())))\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\nimport sys\n\n\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k).remove()))\n    print(\" \".join(map(str, sorted(SegmentTree(segments, k).remove()))))\n\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"]