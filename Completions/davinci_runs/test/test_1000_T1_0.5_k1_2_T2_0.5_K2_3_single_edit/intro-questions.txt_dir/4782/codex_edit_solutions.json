["import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for sample inputs, but not for all test cases\n# n, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n", "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n", "\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n - 1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\nmain()\n", "\n", "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m) # n-1 * n-2 // 2 + m\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Worked for sample inputs, but not for all test cases.\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n", "\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n", "\nfrom sys import stdin\n\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m+1)))\n    else:\n        heap = []\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n", "\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST of the graph\n# the cost of plowing the roads is the sum of the weights of the MST of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1, the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n - 1:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n - 1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\nmain()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m \n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n, m = [int(x) for x in input().split()]\n    print((n-1)*(n-2)//2 + m)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)+1) + m)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + min(m, n-m))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n) // 2)\n", "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n + 1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"]