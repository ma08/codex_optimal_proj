2022-04-16 01:13:02.489271 num operations 1
2022-04-16 01:13:02.489290 size on input set 1
2022-04-16 01:13:04.813157 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    }
  ],
  "created": 1650071582,
  "object": "edit"
}
2022-04-16 01:13:04.813390 fix syntax errors 3 ['\n\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '#!/usr/bin/python3\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n']
2022-04-16 01:13:04.813523 size on output set 3
2022-04-16 01:13:04.813535 num operations 1
2022-04-16 01:13:04.813540 size on input set 1
2022-04-16 01:13:07.502272 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n# problem : https://www.codechef.com/problems/DNASTR\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input().strip() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650071584,
  "object": "edit"
}
2022-04-16 01:13:07.502469 fix syntax errors 3 ["\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\n# problem : https://www.codechef.com/problems/DNASTR\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input().strip() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 01:13:07.502511 size on output set 3
2022-04-16 01:13:07.502522 num operations 1
2022-04-16 01:13:07.502528 size on input set 1
2022-04-16 01:13:13.114969 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna)[-1].weight)\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(edge.weight for edge in mst))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(graph.size)\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna, k))\n\ndef kruskal(dna, k):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight)[:k]:\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append((edge.vertex1, edge.vertex2))\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst, ds\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650071587,
  "object": "edit"
}
2022-04-16 01:13:13.115259 fix syntax errors 3 ['\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna)[-1].weight)\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(edge.weight for edge in mst))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(graph.size)\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna, k))\n\ndef kruskal(dna, k):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight)[:k]:\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append((edge.vertex1, edge.vertex2))\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst, ds\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 01:13:13.115419 size on output set 3
2022-04-16 01:13:13.115435 num operations 1
2022-04-16 01:13:13.115440 size on input set 1
2022-04-16 01:13:37.151757 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [float(\"inf\") for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == float(\"inf\"):\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n"
    },
    {
      "index": 2,
      "text": "\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[0 for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\n# print(sum(e for e, v in edges))\nfor e, v in edges:\n    print(e)\n"
    }
  ],
  "created": 1650071593,
  "object": "edit"
}
2022-04-16 01:13:37.151973 fix syntax errors 3 ['\n\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [float("inf") for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == float("inf"):\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n', '\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[0 for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\n# print(sum(e for e, v in edges))\nfor e, v in edges:\n    print(e)\n']
2022-04-16 01:13:37.152099 size on output set 3
2022-04-16 01:13:37.152111 num operations 1
2022-04-16 01:13:37.152116 size on input set 1
2022-04-16 01:13:41.971199 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split()) # n is the number of strings and k is the length of each string\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings (i,j)\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child, parent_list):\n        while parent[child] != child:\n            child = parent[child]\n        return parent_list[child]\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i, parent), find(parent, j, parent)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650071617,
  "object": "edit"
}
2022-04-16 01:13:41.971498 fix syntax errors 3 ["\n\ndef main():\n    n, k = map(int, input().split()) # n is the number of strings and k is the length of each string\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings (i,j)\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child, parent_list):\n        while parent[child] != child:\n            child = parent[child]\n        return parent_list[child]\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i, parent), find(parent, j, parent)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 01:13:41.971643 size on output set 3
2022-04-16 01:13:41.971665 num operations 1
2022-04-16 01:13:41.971671 size on input set 1
2022-04-16 01:13:53.241645 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a][b] = True\n        graph[b][a] = True\n\n    def dfs(v, path):\n        path.append(v)\n        if len(path) == n:\n            print(*path)\n            sys.exit()\n        for i in range(n):\n            if graph[v][i] and i not in path:\n                dfs(i, path)\n        path.pop()\n\n    for i in range(n):\n        dfs(i, [])\n    print(-1)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)} # components[i] = component id of node i\n    total_distance = 0\n    for i, j, d in edges: # kruskal\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges: # print spanning tree\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650071622,
  "object": "edit"
}
2022-04-16 01:13:53.241856 fix syntax errors 3 ['\n\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a][b] = True\n        graph[b][a] = True\n\n    def dfs(v, path):\n        path.append(v)\n        if len(path) == n:\n            print(*path)\n            sys.exit()\n        for i in range(n):\n            if graph[v][i] and i not in path:\n                dfs(i, path)\n        path.pop()\n\n    for i in range(n):\n        dfs(i, [])\n    print(-1)\n\nmain()\n', 'import sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\nmain()\n', '\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)} # components[i] = component id of node i\n    total_distance = 0\n    for i, j, d in edges: # kruskal\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges: # print spanning tree\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 01:13:53.241902 size on output set 3
2022-04-16 01:13:53.241913 num operations 1
2022-04-16 01:13:53.241918 size on input set 1
2022-04-16 01:13:56.842856 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[float(\"inf\") for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float(\"inf\"):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[sys.maxsize for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != sys.maxsize:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[i][j] < mst[i][v]):\n                v = j\n        used[v] = True\n        ans += mst[i][v]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650071633,
  "object": "edit"
}
2022-04-16 01:13:56.843164 fix syntax errors 3 ['\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[float("inf") for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float("inf"):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[sys.maxsize for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != sys.maxsize:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[i][j] < mst[i][v]):\n                v = j\n        used[v] = True\n        ans += mst[i][v]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 01:13:56.843223 size on output set 3
2022-04-16 01:13:56.843235 num operations 1
2022-04-16 01:13:56.843241 size on input set 1
2022-04-16 01:14:13.454269 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nimport heapq\n\ndef read_input():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        dna = sys.stdin.readline().strip()\n        for j in range(i):\n            u, v = i, j\n            graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n            graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n    return n, k, graph\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    },
    {
      "index": 1,
      "text": "\nimport heapq\nimport sys\n\ndef main():\n    # Read input and build graph\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        dna = sys.stdin.readline().strip()\n        for j in range(i):\n            u, v = i, j\n            graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n            graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n    # Prim's algorithm\n    min_tree = []\n    min_weight = 0\n    visited = [False] * n\n    pq = [(0, 0, dna)]\n    while pq:\n        weight, u, dna = heapq.heappop(pq)\n        if not visited[u]:\n            visited[u] = True\n            min_tree.append((u, dna))\n            min_weight += weight\n            for v, w in graph[u]:\n                if not visited[v]:\n                    heapq.heappush(pq, (w, v, dna))\n\n    # Print results\n    print(min_weight)\n    for u, dna in min_tree[1:]:\n        print(min_tree.index((u, dna)), u)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    }
  ],
  "created": 1650071636,
  "object": "edit"
}
2022-04-16 01:14:13.454488 fix syntax errors 3 ["import sys\n\nimport heapq\n\ndef read_input():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        dna = sys.stdin.readline().strip()\n        for j in range(i):\n            u, v = i, j\n            graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n            graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n    return n, k, graph\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", '\nimport heapq\nimport sys\n\ndef main():\n    # Read input and build graph\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        dna = sys.stdin.readline().strip()\n        for j in range(i):\n            u, v = i, j\n            graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n            graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n    # Prim\'s algorithm\n    min_tree = []\n    min_weight = 0\n    visited = [False] * n\n    pq = [(0, 0, dna)]\n    while pq:\n        weight, u, dna = heapq.heappop(pq)\n        if not visited[u]:\n            visited[u] = True\n            min_tree.append((u, dna))\n            min_weight += weight\n            for v, w in graph[u]:\n                if not visited[v]:\n                    heapq.heappush(pq, (w, v, dna))\n\n    # Print results\n    print(min_weight)\n    for u, dna in min_tree[1:]:\n        print(min_tree.index((u, dna)), u)\n\nif __name__ == "__main__":\n    main()\n', "#!/usr/bin/env python3\n\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"]
2022-04-16 01:14:13.454594 size on output set 3
