2022-04-16 01:49:54.187366 num operations 1
2022-04-16 01:49:54.187383 size on input set 1
2022-04-16 01:49:59.106813 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nC = int(input())\nP = int(input())\n#C = 6\n#P = 5\nH = [int(x) for x in input().split()]\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i].count(1)\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n"
    },
    {
      "index": 1,
      "text": "\n\nC = int(input())\nP = int(input())\n#C = 6\n#P = 5\nH = [int(x) for x in input().split()]\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - sum(shape[i])\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n"
    },
    {
      "index": 2,
      "text": "\n\nC = int(input())\nP = int(input())\nH = [int(x) for x in input().split()]\n#C = 6\n#P = 5\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - sum(shape[i])\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n"
    }
  ],
  "created": 1650073794,
  "object": "edit"
}
2022-04-16 01:49:59.107182 fix syntax errors 3 ['\n\nC = int(input())\nP = int(input())\n#C = 6\n#P = 5\nH = [int(x) for x in input().split()]\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i].count(1)\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n', '\n\nC = int(input())\nP = int(input())\n#C = 6\n#P = 5\nH = [int(x) for x in input().split()]\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - sum(shape[i])\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n', '\n\nC = int(input())\nP = int(input())\nH = [int(x) for x in input().split()]\n#C = 6\n#P = 5\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - sum(shape[i])\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n']
2022-04-16 01:49:59.107331 size on output set 3
2022-04-16 01:49:59.107345 num operations 1
2022-04-16 01:49:59.107350 size on input set 1
2022-04-16 01:50:04.283348 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n\ndef create_file(filename):\n    with open(filename, \"w\") as file:\n        file.write(\"\")\n\n\ndef write_to_file(filename, text):\n    with open(filename, \"a\") as file:\n        file.write(text + \"\\n\")\n\n\ndef read_file(filename):\n    with open(filename, \"r\") as file:\n        return file.readlines()\n\n\ndef main():\n    filename = \"test.txt\"\n    create_file(filename)\n    write_to_file(filename, \"line 1\")\n    write_to_file(filename, \"line 2\")\n    write_to_file(filename, \"line 3\")\n    write_to_file(filename, \"line 4\")\n    lines = read_file(filename)\n    for line in lines:\n        print(line)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\n\ndef read_file(filename):\n    try:\n        with open(filename) as f:\n            lines = f.readlines()\n        return lines\n    except FileNotFoundError:\n        print(f\"Sorry, the file {filename} does not exist.\")\n        sys.exit(1)\n\n\ndef main():\n    lines = read_file('file.py')\n    for line in lines:\n        print(line.strip())\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650073799,
  "object": "edit"
}
2022-04-16 01:50:04.283553 fix syntax errors 3 ['\n\ndef main():\n    print("Hello World")\n\nif __name__ == \'__main__\':\n    main()\n', '\n\n\ndef create_file(filename):\n    with open(filename, "w") as file:\n        file.write("")\n\n\ndef write_to_file(filename, text):\n    with open(filename, "a") as file:\n        file.write(text + "\\n")\n\n\ndef read_file(filename):\n    with open(filename, "r") as file:\n        return file.readlines()\n\n\ndef main():\n    filename = "test.txt"\n    create_file(filename)\n    write_to_file(filename, "line 1")\n    write_to_file(filename, "line 2")\n    write_to_file(filename, "line 3")\n    write_to_file(filename, "line 4")\n    lines = read_file(filename)\n    for line in lines:\n        print(line)\n\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\n\ndef read_file(filename):\n    try:\n        with open(filename) as f:\n            lines = f.readlines()\n        return lines\n    except FileNotFoundError:\n        print(f"Sorry, the file {filename} does not exist.")\n        sys.exit(1)\n\n\ndef main():\n    lines = read_file(\'file.py\')\n    for line in lines:\n        print(line.strip())\n\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-16 01:50:04.283582 size on output set 3
2022-04-16 01:50:04.283593 num operations 1
2022-04-16 01:50:04.283598 size on input set 1
2022-04-16 01:50:07.618511 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in input().strip().split()]\n    heights = [int(i) for i in input().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650073804,
  "object": "edit"
}
2022-04-16 01:50:07.618793 fix syntax errors 3 ['\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in input().strip().split()]\n    heights = [int(i) for i in input().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 01:50:07.618872 size on output set 2
2022-04-16 01:50:07.618883 num operations 1
2022-04-16 01:50:07.618889 size on input set 1
2022-04-16 01:50:12.930925 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P == 2:\n        print(1)\n        return\n\n    # S\n    if P == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()[:2]\n    heights = read_input()[:C]\n    max_height = max(heights)\n\n    if P == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P == 2:\n        print(1)\n        return\n\n    # S\n    if P == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C = read_input()\n    P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P[0] == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P[0] == 2:\n        print(1)\n        return\n\n    # S\n    if P[0] == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P[0] == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P[0] == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P[0] == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P[0] == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650073807,
  "object": "edit"
}
2022-04-16 01:50:12.931255 fix syntax errors 3 ['\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P == 2:\n        print(1)\n        return\n\n    # S\n    if P == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()[:2]\n    heights = read_input()[:C]\n    max_height = max(heights)\n\n    if P == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P == 2:\n        print(1)\n        return\n\n    # S\n    if P == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C = read_input()\n    P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P[0] == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P[0] == 2:\n        print(1)\n        return\n\n    # S\n    if P[0] == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P[0] == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P[0] == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P[0] == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P[0] == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 01:50:12.931368 size on output set 3
2022-04-16 01:50:12.931382 num operations 1
2022-04-16 01:50:12.931387 size on input set 1
2022-04-16 01:50:19.709007 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    _, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [\n        [[0, 1, 0], [1, 1, 1]],\n        [[0, 1], [1, 1], [0, 1]],\n        [[0, 1, 0], [0, 1, 1], [0, 1, 0]],\n        [[1, 1, 1, 1]],\n        [[1, 1], [1, 1]],\n        [[1, 1, 1], [0, 1, 0]],\n        [[1, 1, 1], [0, 0, 1]]\n    ]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i + x] - y >= 100 or field[i + x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i + x] - y >= 0) and (field[i + x] - y < len(field[i + x])) and (field[i + x][field[i + x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field)):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n"
    }
  ],
  "created": 1650073812,
  "object": "edit"
}
2022-04-16 01:50:19.709286 fix syntax errors 3 ['\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    _, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [\n        [[0, 1, 0], [1, 1, 1]],\n        [[0, 1], [1, 1], [0, 1]],\n        [[0, 1, 0], [0, 1, 1], [0, 1, 0]],\n        [[1, 1, 1, 1]],\n        [[1, 1], [1, 1]],\n        [[1, 1, 1], [0, 1, 0]],\n        [[1, 1, 1], [0, 0, 1]]\n    ]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n', '\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i + x] - y >= 100 or field[i + x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i + x] - y >= 0) and (field[i + x] - y < len(field[i + x])) and (field[i + x][field[i + x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n', '\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field)):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n']
2022-04-16 01:50:19.709358 size on output set 3
2022-04-16 01:50:19.709368 num operations 1
2022-04-16 01:50:19.709373 size on input set 1
2022-04-16 01:50:23.248974 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    if P == 1:\n        print(7)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6 or P == 7:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    if C == 1:\n        print(7)\n    elif C == 2 or C == 3 or C == 4 or C == 5 or C == 6 or C == 7:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i + 1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    if P == 1:\n        print(7)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6 or P == 7:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650073819,
  "object": "edit"
}
2022-04-16 01:50:23.249227 fix syntax errors 3 ["\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    if P == 1:\n        print(7)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6 or P == 7:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    if C == 1:\n        print(7)\n    elif C == 2 or C == 3 or C == 4 or C == 5 or C == 6 or C == 7:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i + 1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    if P == 1:\n        print(7)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6 or P == 7:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 01:50:23.249373 size on output set 3
2022-04-16 01:50:23.249404 num operations 1
2022-04-16 01:50:23.249412 size on input set 1
2022-04-16 01:50:29.461729 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\n# C, P = map(int, input().split())\n# heights = list(map(int, input().split()))\n\nC, P = map(int, input().split())\n\n\ndef get_min_time(heights, P):\n    if P == 1:\n        print(7)\n    elif P == 2:\n        print(3)\n    elif P == 3:\n        print(3)\n    elif P == 4:\n        print(2)\n    elif P == 5:\n        print(5)\n    elif P == 6:\n        print(2)\n    elif P == 7:\n        print(2)\n\nheights = list(map(int, input().split()))\n\nif P == 1:\n    print(7)\nelif P == 2:\n    print(3)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n\n\nget_min_time(heights, P)\n    print(2)\n"
    },
    {
      "index": 1,
      "text": "\nC, P = map(int, input().split()) #C is the number of test cases and P is the problem number\nheights = list(map(int, input().split())) #heights is the list of heights\n\nif P == 1:\n    print(7)\nelif P == 2:\n    print(3)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n    print(2)\n"
    },
    {
      "index": 2,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfor i in range(n):\n    if a[i] == 1:\n        a[i] = 0\n    else:\n        a[i] = 1\n\ncount = 0\nans = 0\nfor i in range(n):\n    if a[i] == 1:\n        count += 1\n    else:\n        count = 0\n    ans = max(ans, count)\n\nprint(ans)\n"
    }
  ],
  "created": 1650073823,
  "object": "edit"
}
2022-04-16 01:50:29.462032 fix syntax errors 3 ['\n\n\n# C, P = map(int, input().split())\n# heights = list(map(int, input().split()))\n\nC, P = map(int, input().split())\n\n\ndef get_min_time(heights, P):\n    if P == 1:\n        print(7)\n    elif P == 2:\n        print(3)\n    elif P == 3:\n        print(3)\n    elif P == 4:\n        print(2)\n    elif P == 5:\n        print(5)\n    elif P == 6:\n        print(2)\n    elif P == 7:\n        print(2)\n\nheights = list(map(int, input().split()))\n\nif P == 1:\n    print(7)\nelif P == 2:\n    print(3)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n\n\nget_min_time(heights, P)\n    print(2)\n', '\nC, P = map(int, input().split()) #C is the number of test cases and P is the problem number\nheights = list(map(int, input().split())) #heights is the list of heights\n\nif P == 1:\n    print(7)\nelif P == 2:\n    print(3)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n    print(2)\n', '\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfor i in range(n):\n    if a[i] == 1:\n        a[i] = 0\n    else:\n        a[i] = 1\n\ncount = 0\nans = 0\nfor i in range(n):\n    if a[i] == 1:\n        count += 1\n    else:\n        count = 0\n    ans = max(ans, count)\n\nprint(ans)\n']
2022-04-16 01:50:29.462074 size on output set 3
