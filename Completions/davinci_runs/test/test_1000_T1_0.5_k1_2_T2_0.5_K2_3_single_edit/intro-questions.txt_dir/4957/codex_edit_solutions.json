["\n\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#' \n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print ''.join(row)\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:]\n    for i in range(n):\n        print(grid[i])\n\nmain()\n", "\nfor i in range(10):\n    print(i)\n", "\n\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print(''.join(row))\n", "#!/usr/bin/python\n\nimport sys\n\ndef main():\n    # n, m = [int(x) for x in sys.stdin.readline().split()]\n    # grid = [sys.stdin.readline() for _ in range(n)]\n    # output = [['.' for _ in range(m)] for _ in range(n)]\n    # for i in range(n):\n    #     for j in range(m):\n    #         if grid[i][j] == '#':\n    #             continue\n    #         # place shop if no shop in adjacent cells\n    #         if (i > 0 and output[i-1][j] != 'E') and \\\n    #            (i < n-1 and output[i+1][j] != 'E') and \\\n    #            (j > 0 and output[i][j-1] != 'E') and \\\n    #            (j < m-1 and output[i][j+1] != 'E'):\n    #             output[i][j] = 'E'\n    # for row in output:\n    #     sys.stdout.write(''.join(row))\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split() # split line into list of strings\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = [] # list of lists\n    for _ in range(n):\n        line = input() # read line\n        grid.append(list(line)) # convert line to list of characters\n\n    # Go through each cell and determine whether or not it should be a coffee shop.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n-1:\n                    if grid[row-1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row-1][col] == '.' or grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m-1:\n                    if grid[row][col-1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col-1] == '.' or grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n): # print grid\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "#!/usr/bin/env python\n\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "from sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there.\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j + 1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i - 1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j - 1))\n        if i < n - 1 and grid[i + 1][j] == '.':\n            q.append((i + 1, j))\n        if j < m - 1 and grid[i][j + 1] == '.':\n            q.append((i, j + 1))\n\nprint(*grid, sep='\\n')\n", "\nfrom collections import deque\n\ndef main():\n    n,m = [int(x) for x in input().split()]\n    grid = [input() for _ in range(n)]\n    d=deque()\n    for i in range(n): \n        for j in range(m): \n            if grid[i][j]=='.':\n                d.append((i,j))\n                break \n        if len(d)>0: \n            break \n    while len(d)>0: \n        x,y=d.popleft()\n        for i,j in ((x-1,y),(x,y-1),(x,y+1),(x+1,y)): \n            if 0<=i<n and 0<=j<m and grid[i][j]=='.':\n                d.append((i,j))\n                grid[i][j]='E'\n    for i in grid: \n        print(i)\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j + 1:]\n                if i > 0 and grid[i - 1][j] == '.':\n                    grid[i - 1] = grid[i - 1][:j] + 'E' + grid[i - 1][j + 1:]\n                if j > 0 and grid[i][j - 1] == '.':\n                    grid[i] = grid[i][:j - 1] + 'E' + grid[i][j:]\n                if i < n - 1 and grid[i + 1][j] == '.':\n                    grid[i + 1] = grid[i + 1][:j] + 'E' + grid[i + 1][j + 1:]\n                if j < m - 1 and grid[i][j + 1] == '.':\n                    grid[i] = grid[i][:j + 1] + 'E' + grid[i][j + 2:]\n    for i in range(n):\n        print(grid[i])\n\n\nmain()\n", "\n#!/usr/bin/env python\nimport sys\nfrom collections import defaultdict\nimport re\n \ndef make_graph(edges):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return graph\n \ndef bfs(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)\n    return visited\n \ndef is_connected(graph):\n    return len(bfs(graph, graph.keys()[0])) == len(graph)\n \ndef is_eulerian(graph):\n    return all(len(graph[v]) % 2 == 0 for v in graph)\n \ndef find_eulerian_tour(graph):\n    tour = []\n    if is_eulerian(graph):\n        tour.append(graph.keys()[0])\n        return find_tour(graph, tour[-1], tour)\n    else:\n        return []\n \ndef find_tour(graph, v, tour):\n    for w in graph[v]:\n        if len(graph[w]) == 1:\n            tour.append(w)\n            del graph[v][graph[v].index(w)]\n            del graph[w]\n            return find_tour(graph, w, tour)\n        elif len(graph[w]) > 1:\n            tour.append(w)\n            del graph[v][graph[v].index(w)]\n            return find_tour(graph, w, tour)\n    return tour\n \ndef main():\n    lines = sys.stdin.read().splitlines()\n    edges = []\n    for line in lines:\n        edges.append(re.findall(r'\\d+', line))\n    graph = make_graph(edges)\n    if not is_connected(graph):\n        print \"Graph is not connected.\"\n    else:\n        tour = find_eulerian_tour(graph)\n        if len(tour) == 0:\n            print \"Graph is not Eulerian.\"\n        else:\n            print \"Tour:\", tour\n \nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import deque\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there.\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i-1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j-1))\n        if i < n-1 and grid[i+1][j] == '.':\n            q.append((i+1, j))\n        if j < m-1 and grid[i][j+1] == '.':\n            q.append((i, j+1))\n\nprint(*grid, sep='\\n')\n", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j + 1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j + 1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j + 1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j + 2:]\n    for i in range(n):\n        print(grid[i])\n\nmain()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row + 1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n - 1:\n                    if grid[row - 1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row - 1][col] == '.' or grid[row + 1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col + 1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m - 1:\n                    if grid[row][col - 1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col - 1] == '.' or grid[row][col + 1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n\n        print()\n\nmain()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines. \n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n-1:\n                    if grid[row-1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row-1][col] == '.' or grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m-1:\n                    if grid[row][col-1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col-1] == '.' or grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place shop if no shop in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and \\\n               (i < n-1 and output[i+1][j] != 'E') and \\\n               (j > 0 and output[i][j-1] != 'E') and \\\n               (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\nfrom __future__ import print_function\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there.\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j + 1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i - 1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j - 1))\n        if i < n - 1 and grid[i + 1][j] == '.':\n            q.append((i + 1, j))\n        if j < m - 1 and grid[i][j + 1] == '.':\n            q.append((i, j + 1))\n\nprint(*grid, sep='\\n')\n", "\nimport sys\nimport math\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "from collections import deque\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        s = input()\n        print(s)\n\nif __name__ == '__main__':\n    main()\n"]