["\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))", "\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])"]