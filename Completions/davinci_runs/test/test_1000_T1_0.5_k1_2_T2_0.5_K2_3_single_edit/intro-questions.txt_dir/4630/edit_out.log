2022-04-16 00:30:32.149251 num operations 1
2022-04-16 00:30:32.149269 size on input set 1
2022-04-16 00:30:39.932684 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p) == 1\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 0\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_cycle(i, p, visited):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if visited[i] > 0:\n        return 0\n    visited[i] = -2\n    return check_cycle(p[i] - 1, p, visited)\n\ndef find_cycle_length(i, p, visited):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p, visited)\n\ndef solve_cycle(i, p, visited):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p, visited)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    visited = [0 for _ in range(n)]\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p, visited))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] < 0:\n        return 0\n    p[i] *= -1\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650069032,
  "object": "edit"
}
2022-04-16 00:30:39.932936 fix syntax errors 3 ['\n\ndef check_cycle(i, p):\n    """\n    Checks if there is a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p) == 1\n\ndef find_cycle_length(i, p):\n    """\n    Finds the length of a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    """\n    Solves a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 0\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    """\n    Solves a query.\n    """\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    """\n    Main function.\n    """\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef check_cycle(i, p, visited):\n    """\n    Checks if there is a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    if visited[i] > 0:\n        return 0\n    visited[i] = -2\n    return check_cycle(p[i] - 1, p, visited)\n\ndef find_cycle_length(i, p, visited):\n    """\n    Finds the length of a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p, visited)\n\ndef solve_cycle(i, p, visited):\n    """\n    Solves a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p, visited)\n\ndef solve_query(n, p):\n    """\n    Solves a query.\n    """\n    visited = [0 for _ in range(n)]\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p, visited))\n    return res\n\ndef main():\n    """\n    Main function.\n    """\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef check_cycle(i, p):\n    """\n    Checks if there is a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    if p[i] < 0:\n        return 0\n    p[i] *= -1\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    """\n    Finds the length of a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    """\n    Solves a cycle starting from index i.\n    """\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    """\n    Solves a query.\n    """\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    """\n    Main function.\n    """\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 00:30:39.932987 size on output set 3
2022-04-16 00:30:39.933000 num operations 1
2022-04-16 00:30:39.933005 size on input set 1
2022-04-16 00:30:46.602396 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 2,
      "text": "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n        self.cycle = [1] * n\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(n)\n        for i in range(n):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650069039,
  "object": "edit"
}
2022-04-16 00:30:46.602728 fix syntax errors 3 ['\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=" ")\n        print()\n\n# I/O\n\nif __name__ == "__main__":\n    solve()\n', '\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=" ")\n        print()\n\n# I/O\n\nif __name__ == "__main__":\n    solve()\n', '\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n        self.cycle = [1] * n\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(n)\n        for i in range(n):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=" ")\n        print()\n\n# I/O\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-16 00:30:46.602796 size on output set 3
