["\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x - 1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x + 1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + (y - 1)])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + (y + 1)])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x - 1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x + 1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x - 1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x + 1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y - 1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y + 1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x - 1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x + 1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y - 1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y + 1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    print(t, N, M)\n    print(grid)\n    print()\n    print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n    print(result)\n\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n# TODO: implement the solution\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    print(sx, sy)\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '#':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] != '1':\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] != '1':\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] != '1':\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] != '1':\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R'] else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R'] else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R'] else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R'] else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m - m - n + 1:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n# TODO: implement the solution\n\ndef main():\n    pass \n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        print(queue)\n        print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\n\ndef write_output(msg):\n\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row - 1][col] == '0' or grid[row - 1][col] == 'S' or grid[row - 1][col] == 'U'):\n            paths.append((row - 1, col, t + 1))\n        if row < N - 1 and (grid[row + 1][col] == '0' or grid[row + 1][col] == 'S' or grid[row + 1][col] == 'D'):\n            paths.append((row + 1, col, t + 1))\n        if col >= 1 and (grid[row][col - 1] == '0' or grid[row][col - 1] == 'S' or grid[row][col - 1] == 'L'):\n            paths.append((row, col - 1, t + 1))\n        if col < M - 1 and (grid[row][col + 1] == '0' or grid[row][col + 1] == 'S' or grid[row][col + 1] == 'R'):\n            paths.append((row, col + 1, t + 1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        else:\n        if grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        else:\n        if grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n", "\n# TODO: implement the solution\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\": # start node\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\": # normal node\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\": # up node\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\": # down node\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\": # left node\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\": # right node\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\treturn 1\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U' or grid[row-1][col] == 'D'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'U' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L' or grid[row][col-1] == 'R'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'L' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col, t))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if (row, col, t) not in visited:\n                    q.append((row, col, t))\n                    visited.add((row, col, t))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"]