["\n\n# Python3 program to find the smallest good number\n# greater than or equal to n.\n\ndef good(n):\n\n    # If n is already a good number\n    if (n == 1):\n        return n\n\n    # Find all powers of 3 and store in a list\n    powers = []\n    i = 1\n    while (3 ** i <= n):\n        powers.append(3 ** i)\n        i += 1\n\n    # dp[i] stores the smallest good number\n    # greater than or equal to i.\n    dp = [0 for i in range(n + 1)]\n\n    # Initialize all dp values as n+1\n    for i in range(1, n + 1):\n        dp[i] = n + 1\n\n    # Fill dp values starting from 2\n    for i in range(2, n + 1):\n\n        # For every power of 3, check if we can\n        # get a smaller good number by adding it\n        for x in powers:\n\n            # If i>x and dp[i-x] is a good number\n            # then we can make dp[i] a good number\n            # by adding x to it.\n            if (i > x and dp[i - x] != n + 1):\n                dp[i] = min(dp[i], dp[i - x] + x)\n\n    # Return dp[n] if it is a good number else\n    # return -1\n    return dp[n] if (dp[n] != n + 1) else -1\n\n\n# Driver code\nif __name__ == \"__main__\":\n\n    n = int(input())\n    print(good(n))\n", "\nimport sys\nfrom math import log\nfrom bisect import bisect_left\n \ndef is_power_of_3(x):\n    return x > 0 and 3 ** round(log(x, 3)) == x\n \n# If a number is a power of 3, then the next power of 3 is the next good number\ngood_numbers = [3 ** i for i in range(1, int(log(10 ** 18, 3)))]\n \nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(good_numbers[bisect_left(good_numbers, n)])\n", "\n\ndef find_smallest_good_number(n):\n    if n == 1:\n        return n\n    powers = []\n    i = 1\n    while 3 ** i <= n:\n        powers.append(3 ** i)\n        i += 1\n    dp = [0 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i] = n + 1\n    for i in range(2, n + 1):\n        for x in powers:\n            if i > x and dp[i - x] != n + 1:\n                dp[i] = min(dp[i], dp[i - x] + x)\n    return dp[n] if dp[n] != n + 1 else -1\nif __name__ == \"__main__\":\n    n = int(input())\n    print(find_smallest_good_number(n))\n", "\nimport sys\nfrom math import log\nfrom bisect import bisect_left\n\ndef is_power_of_3(x):\n    return x > 0 and 3 ** round(log(x, 3)) == x\n\n# If a number is a power of 3, then the next power of 3 is the next good number\ngood_numbers = [3 ** i for i in range(1, int(log(10 ** 18, 3)))]\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(good_numbers[bisect_left(good_numbers, n)])\n", "#!/usr/bin/env python3\n\nimport sys\nfrom math import log\nfrom bisect import bisect_left\n\ndef is_power_of_3(x):\n    return x > 0 and 3 ** round(log(x, 3)) == x\n\n# If a number is a power of 3, then the next power of 3 is the next good number\ngood_numbers = [3 ** i for i in range(1, int(log(10 ** 18, 3)))]\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(good_numbers[bisect_left(good_numbers, n)])\n", "\ndef good(n):\n    if n == 1:\n        return n\n    powers = []\n    i = 1\n    while 3 ** i <= n:\n        powers.append(3 ** i)\n        i += 1\n    dp = [0 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i] = n + 1\n    for i in range(2, n + 1):\n        for x in powers:\n            if i > x and dp[i - x] != n + 1:\n                dp[i] = min(dp[i], dp[i - x] + x)\n    return dp[n] if dp[n] != n + 1 else -1\nif __name__ == '__main__':\n    n = int(input())\n    print(good(n))\n"]