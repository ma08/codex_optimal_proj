["\n\n# Python3 program to find the smallest good number \n# greater than or equal to n. \n\ndef good(n) : \n\t\n\t# If n is already a good number \n\tif (n == 1) : \n\t\treturn n \n\t\n\t# Find all powers of 3 and store in a list \n\tpowers = [] \n\ti = 1\n\twhile (3 ** i <= n) : \n\t\tpowers.append(3 ** i) \n\t\ti += 1\n\t\n\t# dp[i] stores the smallest good number \n\t# greater than or equal to i. \n\tdp = [0 for i in range(n + 1)] \n\t\n\t# Initialize all dp values as n+1 \n\tfor i in range(1, n + 1) : \n\t\tdp[i] = n + 1\n\t\n\t# Fill dp values starting from 2 \n\tfor i in range(2, n + 1) : \n\t\t\n\t\t# For every power of 3, check if we can \n\t\t# get a smaller good number by adding it \n\t\tfor x in powers : \n\t\t\t\n\t\t\t# If i>x and dp[i-x] is a good number \n\t\t\t# then we can make dp[i] a good number \n\t\t\t# by adding x to it. \n\t\t\tif (i > x and dp[i - x] != n + 1) : \n\t\t\t\tdp[i] = min(dp[i], dp[i - x] + x) \n\t\t\n\t# Return dp[n] if it is a good number else \n\t# return -1 \n\treturn dp[n] if (dp[n] != n + 1) else -1\n\n# Driver code \nif __name__ == \"__main__\" : \n\t\n\tn = int(input())\n\tprint(good(n))", "\n\nimport sys\nfrom math import log\nfrom bisect import bisect_left\n\ndef is_power_of_3(x):\n    return x > 0 and 3 ** round(log(x, 3)) == x\n\n# If a number is a power of 3, then the next power of 3 is the next good number\ngood_numbers = [3 ** i for i in range(1, int(log(10 ** 18, 3)))]\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(good_numbers[bisect_left(good_numbers, n)])"]