["\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(int, stdin.readline().split())))\n\narea = int(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0],\n                 points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(\"%.6f %.6f\" % (x, y))\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_resized_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    resized_points = []\n    for x, y in points:\n        resized_points.append(((x-cx)*ratio+cx, (y-cy)*ratio+cy))\n    return resized_points\n\ndef main():\n    N, points, A = read_input()\n    resized_points = get_resized_points(points, A)\n    print_output(resized_points)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(list(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i][0] += scale * (points[i][0] - centroid[0]) - points[i][0]\n    points[i][1] += scale * (points[i][1] - centroid[1]) - points[i][1]\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i][0] -= min_x\n    points[i][1] -= min_y\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\nimport sys\nimport math\n\n# the number of corners of the polygon\nn = int(input())\n\n# list of corners of the polygon\ncorners = []\n\n# the area of the desired polygon\narea = int(input())\n\n# the current area of the polygon\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new corners\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y is 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new corners\nfor point in new_corners:\n    print(point[0], point[1])\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A_0 = float(input())\n    A = float(input()) \n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_1 = 0\n    for i in range(N):\n        A_1 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_1 = abs(A_1)\n\n    # find scale factor\n    s = A / A_1\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the new area of the polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        points.append(tuple(map(float, sys.stdin.readline().split())))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p[0] * p_next[1] - p[1] * p_next[0] for p, p_next in zip(points, points[1:] + [points[0]]))\n    # Find the new area of the polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(raw_input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = raw_input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(raw_input().strip())\n    print(corners, area)\n    for corner in corners:\n        print(corner[0])\n        print(corner[1])\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # find the new area of the polygon\n    new_area = A\n    # find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]),\n                 points[i][1] + scale * (points[i][1] - centroid[1]))\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(x, y)\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_resized_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    resized_points = []\n    for x, y in points:\n        resized_points.append(((x-cx)*ratio, (y-cy)*ratio))\n    return resized_points\n\ndef main():\n    N, points, A = read_input()\n    resized_points = get_resized_points(points, A)\n    print_output(resized_points)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    # the number of corners of the polygon\n    n = int(input())\n\n    # list of corners of the polygon\n    corners = []\n\n    # the area of the desired polygon\n    area = int(input())\n\n    # the current area of the polygon\n    current_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new corners\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y is 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new corners\nfor point in new_corners:\n    print(point[0], point[1])\n", "\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import chain\nfrom fractions import Fraction\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor), y*scaling_factor + c.y*(1-scaling_factor))\n            for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return abs(sum(x0*y1 - x1*y0\n                   for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1])))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor), y*scaling_factor + c.y*(1-scaling_factor)) for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0] - xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0] - ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d = sum(ds)\n    r = a/d\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(x, y)\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_resized_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    resized_points = []\n    for x, y in points:\n        resized_points.append(((x-cx)*ratio+cx, (y-cy)*ratio+cy))\n    return resized_points\n\ndef main():\n    N, points, A = read_input()\n    resized_points = get_resized_points(points, A)\n    print_output(resized_points)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().strip().split(\" \")\n        corners.append((float(x), float(y)))\n    area = int(input().strip())\n    print(corners)\n    print(area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().strip().split()\n        corners.append((float(x), float(y)))\n    area = float(input().strip())\n    print(corners)\n    print(area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / Decimal(len(points)),\n                 sum(y for x, y in points) / Decimal(len(points)))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(Decimal(1)-scaling_factor), y*scaling_factor + c.y*(Decimal(1)-scaling_factor)) for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, raw_input().split())\n        points.append((x, y))\n    A = float(raw_input())\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d = sum(ds)\n    r = a/d\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n"]