["\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = a[root - 1]\n    dp[root][1] = 0 # not used\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)] # dp[i][0] is the max value if we choose the subtree of i, dp[i][1] is the max value if we don't choose the subtree of i\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree. So we add the max of the sum of the subtree's children.\n2. If we don't choose the root, then we can choose the root and the subtree of the root. So we add the sum of the subtree's children.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # choose root\ndp[root][1] = max(dp[child][0] for child in children)  # don't choose root\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"]