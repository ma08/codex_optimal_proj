2022-04-15 23:47:42.833064 num operations 1
2022-04-15 23:47:42.833073 size on input set 1
2022-04-15 23:47:49.035046 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree. So we add the max of the sum of the subtree's children.\n2. If we don't choose the root, then we can choose the root and the subtree of the root. So we add the sum of the subtree's children.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # choose root\ndp[root][1] = max(dp[child][0] for child in children)  # don't choose root\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = a[root - 1]\n    dp[root][1] = 0 # not used\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)] # dp[i][0] is the max value if we choose the subtree of i, dp[i][1] is the max value if we don't choose the subtree of i\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1650066463,
  "object": "edit"
}
2022-04-15 23:47:49.035271 fix syntax errors 3 ['\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree. So we add the max of the sum of the subtree\'s children.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root. So we add the sum of the subtree\'s children.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # choose root\ndp[root][1] = max(dp[child][0] for child in children)  # don\'t choose root\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = a[root - 1]\n    dp[root][1] = 0 # not used\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)] # dp[i][0] is the max value if we choose the subtree of i, dp[i][1] is the max value if we don\'t choose the subtree of i\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-15 23:47:49.035341 size on output set 3
2022-04-15 23:47:49.035352 num operations 1
2022-04-15 23:47:49.035357 size on input set 1
2022-04-15 23:47:51.621898 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650066469,
  "object": "edit"
}
2022-04-15 23:47:51.622087 fix syntax errors 3 ["\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-15 23:47:51.622109 size on output set 3
