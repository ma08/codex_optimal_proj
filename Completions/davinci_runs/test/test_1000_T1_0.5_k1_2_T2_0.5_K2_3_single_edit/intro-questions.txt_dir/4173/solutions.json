["q = int(input())\nfor i in range(q):\n\tn, a, b = list(map(int, input().split()))\n\tif n % 2 == 0:\n\t\tprint(min(n * a, n // 2 * b))\n\telse:\n\t\tprint(min(n * a, (n // 2) * b + a))\n", "q=int(input())\nfor l in range(q):\n\tn,a,b=list(map(int,input().split()))\n\tif(2*a<=b):\n\t\tprint(n*a)\n\telse:\n\t\tprint((n//2)*b+(n%2)*a)\n", "q = int(input())\nfor j in range(q):\n    n, a, b = map(int, input().split())\n    if(b / 2 > a):\n        print(n * a)\n    else:\n        print(n // 2 * b + (n % 2) * a)", "n = int(input())\nfor i in range(n):\n    lit, one, two = map(int, input().split())\n    if two > one * 2:\n        print(one * lit)\n    else:\n        print(two * (lit // 2) + one * (lit % 2))", "q = int(input())\nfor i in range(q):\n    n, a, b = map(int, input().split())\n    print(min((n // 2) * b + (n % 2) * a, n * a))", "q = int(input())\nfor _ in range(q):\n    n, a, b = list(map(int, input().split()))\n    if 2 * a <= b:\n        print(n * a)\n    else:\n        if n % 2:\n            print(a + n // 2 * b)\n        else:\n            print(n // 2 * b)\n", "def main():\n\tq = int(input())\n\tfor case in range(q):\n\t\tn,a,b = map(int, input().split())\n\t\tif n%2==0:\n\t\t\tprint(min(n*a,n*b//2))\n\t\telse:\n\t\t\tprint(min(n*a,(n-1)*b//2+a))\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "#JMD\n#Nagendra Jha-4096\n\n \nimport sys\nimport math\n\n#import fractions\n#import numpy\n \n###File Operations###\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\n###Defines...###\nmod=1000000007\n \n###FUF's...###\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n \n \n \n##### Main ####\nt=int(input())\nfor tt in range(t):\n    #n=int(input())\n    n,a,b= map(int, sys.stdin.readline().split(' '))\n    a1=n*a\n    a2=(n//2)*b\n    if(n%2):\n        a2+=a\n    print(min(a1,a2))\n    #a=list(map(int,sys.stdin.readline().split(' ')))\n    \n    \n#####File Operations#####\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()", "q = int(input())\n\n\nfor x in range(q):\n    # buy n\n    n,a,b = list(map(int,input().split()))\n    if a<=(b//2):\n        print(n*a)\n    else:\n        print(b*(n//2) + a*(n%2))\n", "q = int(input())\nfor _ in range(q):\n    n,a,b = list(map(int,input().split()))\n    res = 0\n    if n % 2 == 1:\n        res += a\n    res += (n // 2) * min(2 * a, b)\n    print(res)\n", "q = int(input())\nfor _ in range(q):\n    n, a, b = (int(t) for t in input().split(' '))\n    print(min(n * a, (n // 2) * b + (n % 2) * a))\n", "for i in range(int(input())):\n    n,a,b=map(int,input().split())\n    best=min(a*2,b)\n    print(n//2*best+n%2*a)", "for _ in range(int(input())):\n    n,a,b=map(int,input().split())\n    if b>2*a:\n        print(n*a)\n    else:\n        print((n//2)*b+(n%2)*a)", "for _ in range(int(input())):\n    n,a,b=map(int,input().split())\n    if 2*a<=b:\n        print(a*n)\n    else:print((n//2)*b+(n%2)*a)", "import io, sys, atexit, os\n\n\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li ():\n\treturn list (map (int, input ().split ()))\n\n\ndef num ():\n\treturn map (int, input ().split ())\n\n\ndef nu ():\n\treturn int (input ())\n\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\n\ndef solve ():\n\tt = nu()\n\tfor it in range (t):\n\t\tn,a,b=num()\n\t\tx=0\n\t\tif(n%2==0):\n\t\t\tx=n//2*b\n\t\telse:\n\t\t\tx=n//2*b+a\n\t\ty=n*a\n\t\tprint(min(x,y))\n\n\n\ndef __starting_point():\n\tsolve ()\n__starting_point()", "import math\nimport bisect\nimport itertools\nimport sys\nI=lambda : sys.stdin.readline()\nmod=10**9 +7\n'''fact=[1]*100001\nifact=[1]*100001\nfor i in range(1,100001):\n    fact[i]=((fact[i-1])*i)%mod\n    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod\ndef ncr(n,r):\n    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod\ndef npr(n,r):\n    return (((fact[n]*ifact[n-r])%mod))\n    '''\n\ndef modu(a,m):\n    if a%m:\n        return a%m\n    return m\n\ndef mindiff(a):\n    b=a[:]\n    b.sort()\n    m=10000000000\n    for i in range(len(b)-1):\n        if b[i+1]-b[i]<m:\n            m=b[i+1]-b[i]\n    return m\n    \ndef lcm(a,b):\n    return a*b//math.gcd(a,b)\n\n    \ndef merge(a,b):\n    i=0;j=0\n    c=0\n    ans=[]\n    while i<len(a) and j<len(b):\n        if a[i]<b[j]:\n            ans.append(a[i])\n            i+=1\n        else:\n            ans.append(b[j])\n            c+=len(a)-i\n            j+=1\n    ans+=a[i:]\n    ans+=b[j:]\n    return ans,c\ndef mergesort(a):\n    if len(a)==1:\n        return a,0\n    mid=len(a)//2   \n    left,left_inversion=mergesort(a[:mid])\n    right,right_inversion=mergesort(a[mid:])\n    m,c=merge(left,right)\n    c+=(left_inversion+right_inversion)\n    return m,c\n    \ndef is_prime(num):\n    if num == 1: return False\n    if num == 2: return True\n    if num == 3: return True\n    if num%2 == 0: return False\n    if num%3 == 0: return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num%t == 0: return False\n        t += a\n        a = 6 - a\n    return True\n    \n  \ndef ceil(a,b):\n    if a%b==0:\n        return a//b\n    else:\n        return (a//b + 1)\n\ndef binsearch(arr,b,low,high):\n    if low==high:\n        return low\n    if arr[math.ceil((low+high)/2)]<b:\n        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )\n    else:\n        return binsearch(arr,b,math.ceil((low+high)/2),high)\ndef ncr1(n,r):\n    s=1\n    for i in range(min(n-r,r)):\n        s*=(n-i)\n        s%=mod\n        s*=pow(i+1,mod-2,mod)\n        s%=mod\n    return s\n    \ndef calc(n,m,r):\n    s=0\n    for i in range(0,r+1,2):\n        s+=ncr1(n,i)*ncr1(m,i)\n        s%=mod\n    return s    \n        \n        \n\n#/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfor _ in range(int(input())):\n    n,a,b=list(map(int,input().split()))\n    if b>=2*a:\n        print(n*a)\n    elif b<2*a:\n        print((n//2 * b) + (n%2)*a)\n        \n\n\n\n", "q = int(input())\nfor i in range(q):\n    n,a,b = list(map(int,input().split()))\n    num = 2 * a\n    print(n // 2 * min(num,b) + n % 2 * a)\n", "from sys import stdin,stdout\n#from collections import defaultdict as dd\ninp=lambda :(int(o) for o in  stdin.readline().split())\nsinp=lambda:(o for o in  stdin.readline().split())\nout=lambda: stdout.write(str())\nI=lambda:map(int,input().split())\nY=lambda:int(input())\n#print(inp())    #generator object\n\nfor _ in range(int(input())):\n    n,a,b=I()\n    if 2*a<b:\n        print(n*a)\n    else:\n        print((n//2)*b+(n%2)*a)", "q=int(input())\nQuery=[list(map(int,input().split())) for i in range(q)]\n\nfor n,a,b in Query:\n    ANS=n*a\n    ANS2=n//2*b+n%2*a\n\n    print(min(ANS,ANS2))\n", "#\t!/usr/bin/env python3\n#\tcoding: UTF-8\n#\tModified: <19/Feb/2019 08:08:00 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n#\tQuestion Link\n#\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    for tc in range(int(input())):\n        n, a, b = get_ints()\n        if 2 * a < b:\n            print(n * a)\n        else:\n            print(n // 2 * b + (n % 2) * a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\ndef main():\n    n,a,b = get_tuple()\n    print(a*n) if a<=b/2 else print((n//2)*b+(n%2)*a)\n    \n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "q=int(input())\nfor item in range(q):\n    n,a,b=[int(x) for x in input().split()]\n    counter=n//2*min(2*a,b)\n    if n%2==1:\n        counter+=a\n    print(counter)\n", "t = int(input())\nfor i in range(t):\n    s = input().split()\n    n, a, b = int(s[0]), int(s[1]), int(s[2])\n    x = min(a*2, b)\n    d = n//2\n    res = d*x\n    n-=2*d\n    if n!=0:\n        res+=a\n    print(res)", "\n\nfor _ in range(int(input())):\n\tn,a,b=list(map(int,input().rstrip().split(\" \")))\n\tif(a+a>b):\n\t\tif(n%2!=0):\n\t\t\tprint(((n//2)*b)+a)\n\t\telse:\n\t\t\tprint((n//2)*b)\n\telse:\n\t\tprint(n*a)\n"]