["\n# coding=utf-8\nimport sys\nimport os\nimport heapq\nimport math\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n#\n\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the array of books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input()\n\n        # Add it to the array of books\n        books.append(book)\n\n    # Print the array of books\n    print(books)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\"\"\"\nProblem\nYou are given a sequence of queries of the form \"L x\" or \"R x\", where x is an integer.\nFor each query of the form \"L x\", you add x to the bookshelf on the left side.\nFor each query of the form \"R x\", you add x to the bookshelf on the right side.\nAfter each query, you want to know the minimum number of books to remove from the bookshelf such that all the remaining books are sorted in non-decreasing order.\nFor example, suppose you are given the following queries:\nL 1\nL 3\nL 2\nR 4\nL 5\nR 2\nThe bookshelf would look like this:\n1 3 2 _ _ 5 2\nThe minimum number of books to remove is 2. One possibility is to remove the first two books and the last book:\n_ _ 2 _ _ 5 _\nThe books could then be sorted by re-inserting the 3, 4, and 5:\n_ _ 2 3 4 5 _\nFunction Description\nComplete the function minimum_number_of_removals in the editor below.\nminimum_number_of_removals has the following parameter(s):\nstring queries[q]: an array of queries\nReturns:\nint: the minimum number of books to remove\nConstraints\n1 \u2264 q \u2264 2 \u00d7 105\n1 \u2264 x \u2264 109\nSubtasks\n20 points: 1 \u2264 q \u2264 2 \u00d7 104\n80 points: Original constraints\nSample Input 0\n5\nL 1\nL 3\nL 2\nR 4\nL 5\nSample Output 0\n2\nExplanation 0\nThe bookshelf looks like this after the first query:\n1 _ _ _ _ _ _\nAfter the second query:\n1 3 _ _ _ _ _\nAfter the third query:\n1 3 2 _ _ _ _\nAfter the fourth query:\n1 3 2 _ 4 _ _\nAfter the fifth query:\n1 3 2 _ 4 5 _\nThe minimum number of books to remove is 2. One possibility is to remove the first two books and the last book:\n_ _ 2 _ 4 5 _\nThe books could then be sorted by re-inserting the 3, 4, and 5:\n_ _ 2 3 4 5 _\nSample Input 1\n5\nR 1\nR 3\nL 2\nL 4\nL 5\nSample Output 1\n0\nExplanation 1\nThe bookshelf is already sorted, so no books need to be removed.\nSample Input 2\n6\nL 3\nL 4\nL 2\nR 1\nR 5\nL 7\nSample Output 2\n1\nExplanation 2\nThe bookshelf looks like this after the first query:\n3 _ _ _ _ _ _\nAfter the second query:\n3 4 _ _ _ _ _\nAfter the third query:\n3 4 2 _ _ _ _\nAfter the fourth query:\n3 4 2 1 _ _ _\nAfter the fifth query:\n3 4 2 1 _ 5 _\nAfter the sixth query:\n3 4 2 1 _ 5 7\nThe minimum number of books to remove is 1. One possibility is to remove the first book:\n_ 4 2 1 _ 5 7\nThe books could then be sorted by re-inserting the 3:\n_ 3 4 2 1 _ 5 7\n\"\"\"\n\n\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n"]