["import sys\nfrom collections import defaultdict\n\ndef main():\n    frosh = int(sys.stdin.readline().strip())\n    classes = defaultdict(lambda: 0)\n    for _ in range(frosh):\n        courses = tuple(sorted(map(int, sys.stdin.readline().strip().split())))\n        classes[courses] += 1\n    print(max(classes.values()))\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport math\n\nimport sys\n\nif __name__ == '__main__':\n    x = int(sys.stdin.readline().strip())\n    print(math.ceil(math.log(x, 2)))\n", "\n\n# from collections import Counter\n\n# n = int(input())\n\n# course_combinations = []\n\n# for i in range(n):\n#     courses = list(map(int, input().split(\" \")))\n#     course_combinations.append(tuple(sorted(courses)))\n\n# # print(course_combinations)\n\n# c = Counter(course_combinations)\n# most_common = c.most_common(1)\n\n# # print(most_common)\n\n# print(most_common[0][1])\n\nn = int(input())\n\nfor i in range(n):\n    s = input()\n    if len(s) > 10:\n        print(s[0] + str(len(s) - 2) + s[-1])\n    else:\n        print(s)\n", "\nimport sys\n\nfroshes = int(sys.stdin.readline().strip())\ncombos = []\nfor i in range(froshes):\n    combo = sorted(list(map(int, sys.stdin.readline().strip().split())))\n    combos.append(combo)\n\ncombos = sorted(combos)\n\nmax_popularity = 1\npopularity = 1\nfor i in range(1, froshes):\n    if combos[i] == combos[i-1]:\n        popularity += 1\n    else:\n        popularity = 1\n    if popularity > max_popularity:\n        max_popularity = popularity\n\nprint(max_popularity)\n", "\nimport sys\n\nfrom collections import defaultdict\n\ndef main():\n    frosh = int(sys.stdin.readline().strip())\n    classes = defaultdict(lambda: 0)\n    for _ in range(frosh):\n        courses = tuple(\n            sorted(map(int, sys.stdin.readline().strip().split()))\n        )\n        classes[courses] += 1\n    print(max(classes.values()))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\n\nfroshes = int(sys.stdin.readline().strip())\ncombos = []\nfor i in range(froshes):\n    combo = sorted(list(map(int, sys.stdin.readline().strip().split())))\n    combos.append(combo)\n\ncombos = sorted(combos)\n\nmax_popularity = 1\npopularity = 1\nfor i in range(1, froshes):\n    if combos[i] == combos[i-1]:\n        popularity += 1\n    else:\n        popularity = 1\n    if popularity > max_popularity:\n        max_popularity = popularity\n\nprint(max_popularity)\n", "import sys\n\ndef find_popular_combinations(frosh):\n    combinations = {}\n    for combination in frosh:\n        if combination in combinations:\n            combinations[combination] += 1\n        else:\n            combinations[combination] = 1\n\n    most_popular = max(combinations.values())\n    return most_popular\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline().strip())\n    frosh = set()\n    for i in range(n):\n        frosh.add(tuple(sorted([int(x) for x in sys.stdin.readline().strip().split()])))\n    print(find_popular_combinations(frosh))\n", "#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    courses = {}\n    for i in range(n):\n        course_list = [int(x) for x in sys.stdin.readline().strip().split()]\n        course_list.sort()\n        course_list = tuple(course_list)\n        if course_list in courses:\n            courses[course_list] += 1\n        else:\n            courses[course_list] = 1\n    max_count = max(courses.values())\n    print(sum([courses[x] for x in courses if courses[x] == max_count]))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    frosh = int(sys.stdin.readline().strip())\n    classes = defaultdict(lambda: 0)\n    for _ in range(frosh):\n        courses = tuple(sorted(map(int, sys.stdin.readline().strip().split()))\n        classes[courses] += 1\n    print(max(classes.values())\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef get_frosh_courses(n):\n    frosh_courses = []\n    for i in range(n):\n        frosh_courses.append(sys.stdin.readline().strip().split())\n    return frosh_courses\n\ndef get_popularities(frosh_courses):\n    popularities = {}\n    for frosh_course in frosh_courses:\n        frosh_course_tuple = tuple(sorted(frosh_course))\n        if frosh_course_tuple in popularities:\n            popularities[frosh_course_tuple] += 1\n        else:\n            popularities[frosh_course_tuple] = 1\n    return popularities\n\ndef get_most_popularities(popularities):\n    most_popularities = []\n    max_popularity = max(popularities.values())\n    for frosh_course_tuple, popularity in popularities.iteritems():\n        if popularity == max_popularity:\n            most_popularities.append(frosh_course_tuple)\n    return most_popularities\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    frosh_courses = get_frosh_courses(n)\n    popularities = get_popularities(frosh_courses)\n    most_popularities = get_most_popularities(popularities)\n    print(len(most_popularities))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# MAIN \n\n# Read in the input and store it in a dictionary\n# The key is the frosh and the value is the courses\nfrosh = {}\n\nfor line in sys.stdin:\n    frosh[line] = frosh.get(line, 0) + 1\n\n# Find the most popular combination of courses\n# i.e. the highest value in the dictionary\nmost_popular = max(frosh.values())\n\n# Print the number of frosh who have the most popular combination\nprint(most_popular)\n", "import sys\n\ndef get_frosh_courses(n):\n    frosh_courses = []\n    for i in range(n):\n        frosh_courses.append(sys.stdin.readline().strip().split())\n    return frosh_courses\n\ndef get_popularities(frosh_courses):\n    popularities = {}\n    for frosh_course in frosh_courses:\n        frosh_course_tuple = tuple(sorted(frosh_course))\n        if frosh_course_tuple in popularities:\n            popularities[frosh_course_tuple] += 1\n        else:\n            popularities[frosh_course_tuple] = 1\n    return popularities\n\ndef get_most_popularities(popularities):\n    most_popularities = []\n    max_popularity = max(popularities.values())\n    for frosh_course_tuple, popularity in popularities.items():\n        if popularity == max_popularity:\n            most_popularities.append(frosh_course_tuple)\n    return most_popularities\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    frosh_courses = get_frosh_courses(n)\n    popularities = get_popularities(frosh_courses)\n    most_popularities = get_most_popularities(popularities)\n    print(len(most_popularities))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\ndef main(args):\n    n = int(input())\n    course_combinations = []\n\n    for i in range(n):\n        courses = list(map(int, input().split(\" \")))\n        course_combinations.append(tuple(sorted(courses)))\n\n    c = Counter(course_combinations)\n    most_common = c.most_common(1)\n    print(most_common[0][1])\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n", "\n\nimport sys\n\ndef main():\n    frosh = int(sys.stdin.readline().strip())\n    course_counts = {}\n    for i in range(frosh):\n        course_combination = tuple(sorted(map(int, sys.stdin.readline().strip().split())))\n        course_counts[course_combination] = course_counts.get(course_combination, 0) + 1\n    print(max(course_counts.values()))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n# MAIN\n\n# Read in the input and store it in a dictionary\n# The key is the frosh and the value is the courses\nfrosh = {}\n\nfor line in sys.stdin:\n    frosh[line.strip()] = frosh.get(line.strip(), 0) + 1\n\n# Find the most popular combination of courses\n# i.e. the highest value in the dictionary\nmost_popular = max(frosh.values())\n\n# Print the number of frosh who have the most popular combination\nprint(most_popular)\n", "\nfrom collections import Counter, defaultdict\n\nn = int(input())\ncourse_combinations = defaultdict(int)\n\nfor i in range(n):\n    courses = list(map(int, input().split(\" \")))\n    course_combinations[tuple(sorted(courses))] += 1\n\n\n# print(course_combinations)\n\nmost_common = Counter(course_combinations).most_common(1)\n# c = Counter(course_combinations)\n# most_common = c.most_common(1)\n\n# print(most_common)\n\nprint(most_common[0][0])\n", "\n\nimport sys\n\ndef main():\n    print(\"hello world\")\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    frosh = int(sys.stdin.readline().strip())\n    course_counts = {}\n    for i in range(frosh):\n        course_combination = tuple(sorted(map(int, sys.stdin.readline().strip().split())))\n        course_counts[course_combination] = course_counts.get(course_combination, 0) + 1\n    print max(course_counts.values())\n\nif __name__ == '__main__':\n    main()\n", " \nimport sys\n\ndef get_frosh_courses(n):\n    frosh_courses = []\n    for i in range(n):\n        frosh_courses.append(sys.stdin.readline().strip().split())\n    return frosh_courses\n\ndef get_popularities(frosh_courses):\n    popularities = {}\n    for frosh_course in frosh_courses:\n        frosh_course_tuple = tuple(sorted(frosh_course))\n        if frosh_course_tuple in popularities:\n            popularities[frosh_course_tuple] += 1\n        else:\n            popularities[frosh_course_tuple] = 1\n    return popularities\n\ndef get_most_popularities(popularities):\n    most_popularities = []\n    max_popularity = max(popularities.values())\n    for frosh_course_tuple, popularity in popularities.items():\n        if popularity == max_popularity:\n            most_popularities.append(frosh_course_tuple)\n    return most_popularities\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    frosh_courses = get_frosh_courses(n)\n    popularities = get_popularities(frosh_courses)\n    most_popularities = get_most_popularities(popularities)\n    print(len(most_popularities))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n# MAIN\n\n# Read in the input and store it in a dictionary\n# The key is the frosh and the value is the courses\nfrosh = {}\n\nfor line in sys.stdin:\n    frosh[line] = frosh.get(line, 0) + 1\n\n# Find the most popular combination of courses\n# i.e. the highest value in the dictionary\nmost_popular = max(frosh.values())\n\n# Print the number of frosh who have the most popular combination\nprint(most_popular)\n", "import sys\n\ndef find_popular_combinations(n):\n    combinations = {}\n    for i in range(n):\n        combination = frosh[i] # frosh[i] is a list\n        combination.sort()\n        combination = tuple(combination)\n        if combination in combinations:\n            combinations[combination] += 1\n        else:\n            combinations[combination] = 1\n    most_popular = max(combinations.values())\n    return [combination for combination in combinations if combinations[combination] == most_popular]\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline().strip())\n    frosh = []\n    for i in range(n):\n        frosh.append([int(x) for x in sys.stdin.readline().strip().split()])\n    print(len(find_popular_combinations(n)))\n", "\n\nimport sys\n\ndef main():\n    num_cases = int(sys.stdin.readline().strip())\n    for i in range(num_cases):\n        num_frosh = int(sys.stdin.readline().strip())\n        course_counts = {}\n        for j in range(num_frosh):\n            course_combination = tuple(sorted(map(int, sys.stdin.readline().strip().split())))\n            course_counts[course_combination] = course_counts.get(course_combination, 0) + 1\n        print max(course_counts.values())\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    courses = {}\n    for i in range(n):\n        course_list = [int(x) for x in sys.stdin.readline().strip().split()]\n        course_list.sort()\n        course_list = tuple(course_list)\n        if course_list in courses:\n            courses[course_list] += 1\n        else:\n            courses[course_list] = 1\n    max_count = max(courses.values())\n    print(sum([courses[x] for x in courses if courses[x] == max_count]))\n\nif __name__ == '__main__':\n    main()\n"]