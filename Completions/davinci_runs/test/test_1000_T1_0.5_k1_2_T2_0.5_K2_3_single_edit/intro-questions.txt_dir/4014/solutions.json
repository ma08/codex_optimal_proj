["def ke(i):\n    return b[i]\nn,m=map(int,input().split())\na=[0]*m\nb=[0]*m\nc=[0]*m\ne=[]\nans=[0]*n\nfor i in range(m):\n    a[i],b[i],c[i]=map(int,input().split())\n    ans[b[i]-1]=m+1\n    e.append(i)\ne.sort(key=ke)\nfor i in range(m):\n    k=0\n    for j in range(a[e[i]]-1,b[e[i]]-1):\n        if ans[j]==0:\n            ans[j]=e[i]+1\n            k+=1\n        if k==c[e[i]]:\n            break\n    if k!=c[e[i]]:\n        print(-1)\n        return\nfor i in ans:\n    print(i,end=' ')", "n, m = list(map(int, input().split()))\nL = []\nfor i in range(m):\n    a, b, c = list(map(int, input().split()))\n    L.append([b, a, c, i])\nL.sort()\n\nM = [-1 for i in range(n + 1)]\nfor i in range(m):\n    M[L[i][0]] = m + 1\nfor i in range(1, n + 1):\n    if M[i] == -1:\n        f = False\n        for j in range(m):\n            if L[j][1] <= i and L[j][2] > 0 and i < L[j][0]:\n                M[i] = L[j][3] + 1\n                L[j][2] -= 1\n                f = True\n                break\n        if not(f):\n            M[i] = 0\nf = True\nfor j in range(m):\n    if L[j][2] > 0:\n        f = False\nif f:\n    print(*M[1:])\nelse:\n    print(-1)\n", "T = input().split(' ')\nn = int(T[0])\nm = int(T[1])\nL = [0] * n\nM = []\nD = [0] * m\nF = [0] * m\nfor i in range(m):\n    S = input().split(' ')\n    a = int(S[0])\n    b = int(S[1])\n    c = int(S[2])\n    L[b-1] = m+1\n    F[i] = b-1\n    M.append((a-1, b-2, i+1))\n    D[i] = c\nM.sort()\nfor i in range(n):\n    if L[i] == 0:\n        G = []\n        for j in range(len(M)):\n            if M[j][0]<=i:\n                G.append((M[j][1], M[j][2]))\n        G.sort()\n        for k in range(len(G)):\n            if D[G[k][1]-1] > 0 and F[G[k][1]-1]>i:\n                D[G[k][1]-1]-=1\n                L[i] = G[k][1]\n                break\nb = True\nfor j in range(len(D)):\n    if D[j] > 0:\n        b = False\nif b:\n    for i in range(n-1):\n        print(L[i], end=' ')\n    print(L[n-1])\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\nprep = []\n\ndays = [-1] * n\nrelease = []\n\nfor i in range(m):\n    s_, d_, c_ = list(map(int, input().split()))\n    release.append(s_)\n    days[d_ - 1] = i\n    prep.append(c_)\n\nrel_on_day = {}\nfor i, r in enumerate(release):\n    if r - 1 in rel_on_day:\n        rel_on_day[r - 1].append(i)\n    else:\n        rel_on_day[r - 1] = [i]\n\nans = []\n\nwaiting = set()\n\nexam_q = []\nfor d in days:\n    if d != -1:\n        exam_q.append(d)\n\n#print(rel_on_day)\n\nfor i in range(n):\n    if i in rel_on_day:\n        waiting = waiting | set(rel_on_day[i])\n\n #   print(waiting)\n\n\n    if days[i] != -1: #exam\n        if prep[days[i]] == 0:\n            ans.append(m + 1)\n            waiting.remove(days[i])\n        else:\n            print(-1)\n            return\n    else: #choose closest unstudied exam\n        chosen = None\n        for ex in exam_q:\n            if prep[ex] > 0 and ex in waiting:\n                chosen = ex\n                break\n        if not chosen is None:\n            prep[ex] -= 1\n            ans.append(ex + 1)\n        else:\n            ans.append(0)\n\nprint(\" \".join(list(map(str, ans))))\n", "import sys\n\n\n\n\n\n\n\n\n\n\ndef __starting_point():\n    n, m = [int(c) for c in input().split()]\n    s = []\n    d = []\n    c = []\n    studying = []\n    for _ in range(m):\n        x,y,z = [int(w) for w in input().split()]\n        s.append(x)\n        d.append(y)\n        c.append(z)\n        \n    plan = []\n\n    for i in range(1, n+1):\n        \n        if i in s:\n            indices = [k for k, x in enumerate(s) if x == i]\n            for idx in indices:\n                studying.append( (d[idx], idx) )\n            studying.sort()\n        \n        #print(studying)\n        if i in d:\n            idx = d.index(i)\n            if (i, idx) in studying:\n                print (-1)\n                return\n            else:\n                plan.append(m+1)\n        else:\n            if not studying:\n                plan.append(0)\n                continue\n            idx = studying[0][1]\n            plan.append(idx+1)\n            c[idx] -= 1\n            if c[idx] == 0:\n                studying = studying[1:]\n\n    for i in plan:\n        print (i, end=' ')\n    print()\n\n\n\n\n\n\n__starting_point()", "# Hello World program in Python\nclass exam:\n    def __init__(self, tickets, ex_day, prep_days, index):\n        self.tick = tickets-1\n        self.ex_day = ex_day-1\n        self.prep_days = prep_days\n        self.index = index\n\n\ndef task():\n    n, m = [int(x) for x in input().split(' ')]\n    exs = list()\n    for i in range(m):\n        a, b, c = [int(x) for x in input().split(' ')]\n        exs.append(exam(a, b, c, i + 1))\n    s = sum((x.prep_days for x in exs))\n    if s > n - m:\n        print(-1)\n        return -1\n    exs = sorted(exs, key=lambda x: -x.tick)\n    exdays = [x.ex_day for x in exs]\n    days = [m+1 if i in exdays else 0 for i in range(0, n)]\n    for ex in exs:\n        d = ex.ex_day\n        offs = 1\n        for i in range(ex.prep_days):\n            cont = True\n            while (cont):\n                if d - offs < ex.tick:\n                    print(-1)\n                    return\n                if days[d - offs] == 0:\n                    days[d - offs] = ex.index\n                    cont = False\n                else:\n                    offs += 1\n\n    print(' '.join((str(x) for x in days)))\n\n\ntask()", "n, m = map(int, input().split())\nexams = []\nfor i in range(m):\n    e = list(map(int, input().split()))\n    e.append(0)\n    e.append(i + 1)\n    exams.append(e)\nexams.sort()\nnow, have, f, ans, c = 0, [], True, [], 0\nfor i in range(1, n + 1):\n    while now < m and exams[now][0] == i:\n        have.append(exams[now][1:])\n        now += 1\n        have.sort()\n    if c < len(have) and have[c][0] == i:\n        if have[c][1] == have[c][2]:\n            ans.append(m + 1)\n            c += 1\n        else:\n            f = False\n            break\n    else:\n        j = 0\n        while j < len(have) and have[j][1] == have[j][2]:\n            j += 1\n        if j == len(have):\n            ans.append(0)\n        else:\n            ans.append(have[j][3])\n            have[j][2] += 1\nif f:\n    for i in range(n):\n        print(ans[i], end=' ')\nelse:\n    print(-1)", "n, m =[int(i) for i in input().split()]\ns = [0] * m\nd = [0] * m\nc = [0] * m\nfor i in range(m):\n\ts[i], d[i], c[i] = [int(j) - 1 for j in input().split()]\n\tc[i] += 1\n\tif d[i] - s[i] < c[i]:\n\t\tprint(-1)\n\t\tquit()\n\nans = [0] * n\nfor i in d:\n\tans[i] = m + 1\n\nexam = []\nfor i in range(n):\n\texam.append([])\n\tfor j in range(m):\n\t\tif s[j] <= i < d[j]:\n\t\t\texam[i].append(j)\n\nfor i in range(n):\n\tif ans[i] == 0:\n\t\tday_min = n + 1\n\t\tfor j in exam[i]:\n\t\t\tif (d[j] < day_min) and (c[j] > 0):\n\t\t\t\tday_min = d[j]\n\t\t\t\texam_min = j\n\t\tif day_min != n + 1:\n\t\t\tans[i] = exam_min + 1\n\t\t\tc[exam_min] -= 1\n\telse:\n\t\tif c[d.index(i)] != 0:\n\t\t\tprint(-1)\n\t\t\tquit()\n\nfor i in range(n):\n\tif i != n - 1:\n\t\tprint(ans[i], end = \" \")\n\telse:\n\t\tprint(ans[i])\n\n\n", "(n, m) = list(map(int, input().split()))\n\narray = [0] * (n + 1)\nlst = []\nfor x in range(m):\n    (s, d, c) = list(map(int, input().split()))\n    lst.append((d, s, c, x + 1))\n\nlst.sort()\ni = 0\nflag = True\nfor (d, s, c, p) in lst:\n    x = s\n    while c > 0 and x < d:\n        if array[x] == 0:\n            array[x] = p\n            c -= 1\n        x += 1\n    if c != 0:\n        flag = False\n        break\n    else:\n        array[d] = m + 1\n\nif flag:\n    print(*array[1:])\nelse:\n    print(-1)\n", "import bisect\nn,m=list(map(int,input().split()))\na=[]\nb=[]\nfor i in range(m):\n    s,d,c=list(map(int,input().split()))\n    if c>d-s+1:\n        print(-1)\n        quit()\n    l=bisect.bisect_left(b,d)\n    a.insert(l,[s,d,c,i+1])\n    b.insert(l,d)\nds=list('0' for i in range(n))\nfor i in range(m):\n    s,d,c,mi=a[i]\n    c0=0\n    for j in range(s,d):\n        if ds[j-1]=='0':\n            ds[j-1]=str(mi)\n            c0+=1\n        if c0>=c:\n            break\n    if c0<c:\n        print(-1)\n        quit()\n    ds[d-1]=str(m+1)\nprint(' '.join(ds))\n", "[n, m] = [int(x) for x in input().split()]\nI = 0\nS = 1\nD = 2\nC = 3\nexses = [[0, 0, 0, 0]]\npops = [0] * (n+1)\ni = 1\nwhile i <= m:\n  [s, d, c] = [int(x) for x in input().split()]\n  exses.append([i, s, d, c])\n  pops[d] = i\n  i += 1\n\ni = 1\nresult = [0] * (n+1)\nfail = False\nwhile i <=n:\n  if pops[i] != 0 and exses[pops[i]][C] == 0:\n    result[i] = m+1\n  elif pops[i] != 0 and exses[pops[i]][C] > 0:\n    fail = True\n    break\n  else:\n    ex = None\n    min = n+1\n    for e in exses:\n      if e[D] > i and e[S] <= i and e[D] < min and e[C] > 0:\n        min = e[D]\n        ex = e\n    if ex == None:\n      result[i] = 0\n    else:\n      result[i] = ex[I]\n      ex[C] -= 1\n  i += 1\n\nif fail:\n  print(-1)\nelse:\n  for x in result[1:]:\n    print(x, end=' ')\n", "def solve(n, m, ss, dd, cc):\n\t# day: i ( 1 -> n)\n\t# exam: j (0 -> m - 1)\n\t# date : d (1 -> n)\n\t# start: s (1 -> n)\n\t#\n\n\tdate = [-1] * (n + 1)\n\tfor j, d in enumerate(dd):\n\t\tdate[d] = j\t\t# mark exam date for i-th exam\n\t# print(date)\n\tstart = [[] for _ in range(n + 1)]\n\tfor j, d in enumerate(ss):\n\t\tstart[d].append(j)\n\t# print(start)\n\tpreps = []\n\tfor i in range(1, n + 1): # for each day in n days\n\t\tif start[i]: # a start date\n\t\t\tpreps += start[i] # add to the list of preparation\n\t\t# print(date)\n\t\tu = date[i]\n\n\t\t# print(i, u, start[i], end=' ')\n\t\tif u >= 0: # an exam date 0 -> m - 1\n\t\t\tj = u # j-th exam\n\t\t\tif cc[j] > 0: # failed to prepare\n\t\t\t\t# print('failed ', j + 1)\n\t\t\t\treturn -1\n\t\t\tdate[i] = m + 1 # take the exam\n\t\telse:\n\t\t\t# print(preps, end=' ')\n\t\t\tif not preps: # no subject to prepare\n\t\t\t\tdate[i] = 0\n\t\t\telse: # prepare for subject closest to the exam date\n\t\t\t\tmin_d = min(dd[j] for j in preps)\n\t\t\t\tfor j in preps:\n\t\t\t\t\tif dd[j] == min_d: break\n\t\t\t\tdate[i] = j + 1 # prepare for j-th exam\n\t\t\t\tcc[j] -= 1\n\t\t\t\tif cc[j] == 0:\n\t\t\t\t\tpreps.remove(j)\n\t\t# print(date[i])\n\n\treturn date[1:]\n\n\n\n\n\ndef main():\n\tn, m = [int(_) for _ in input().split()]\n\n\ts = []\n\td = []\n\tc = []\n\tfor i in range(m):\n\t\ts_, d_, c_ = [int(_) for _ in input().split()]\n\n\t\ts.append(s_)\n\t\td.append(d_)\n\t\tc.append(c_)\n\n\n\n\n\tplan = solve(n, m, s, d, c)\n\tif isinstance(plan, list):\n\t\tprint(' '.join(map(str, plan)))\n\telse:\n\t\tprint(-1)\n\n\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "import heapq\nn,m = [int(s) for s in input().split()]\nq0,q1 = [],[]\nans = [0]*n\nfor i in range(m):\n    si, di, ci = [int(s) for s in input().split()]\n    si -= 1\n    di -= 1\n    ans[di] = m+1\n    heapq.heappush(q0, (si, di, ci, i))\n\nfor currday in range(n):\n    while len(q0) and q0[0][0] <= currday:\n        si,di,ci,i = heapq.heappop(q0)\n        heapq.heappush(q1, (di,si,ci,i))\n    if len(q1) and ans[currday] == 0:\n        if currday > q1[0][0]:\n            break\n        ans[currday] = q1[0][3]+1\n        if q1[0][2] == 1:\n            heapq.heappop(q1)\n        else:\n            q1[0] = (q1[0][0], q1[0][1], q1[0][2]-1, q1[0][3])\n\nif len(q1) == 0 and len(q0) == 0:\n    print(*ans)\nelse:\n    print(-1)", "#!/usr/bin/env python3\nfrom sys import stdin, stdout\n\ndef rint():\n    return list(map(int, stdin.readline().split()))\n#lines = stdin.readlines()\n\nn, m = rint()\n\ns = [0 for i in range(m)]\nd = [0 for i in range(m)]\nc = [0 for i in range(m)]\n\n\nfor i in range(m):\n    s[i], d[i], c[i] = rint()\n\ns_in_day = [set() for i in range(n+1)]\nfor i in range(m):\n    day = s[i]\n    s_in_day[day].add(i)\n\nd_in_day = [-1 for i in range(n+1)]\nfor i in range(m):\n    day = d[i]\n    d_in_day[day] = i\n\n\ndi_sorted = [0 for i in range(m)]\ndi_sorted.sort(key=lambda x: d[i])\n\nans = [0 for i in range(n+1)]\n\ncandi_exam = set()\nfor day in range(1, n+1):\n    for exam in s_in_day[day]:\n        candi_exam.add(exam)\n    if d_in_day[day] != -1:\n        exam = d_in_day[day]\n        if c[exam] != 0:\n            print(-1)\n            return\n        ans[day] = m+1\n        if exam in candi_exam:\n            candi_exam.remove(exam)\n        continue\n    \n    if len(candi_exam) == 0:\n        ans[day] = 0\n        continue\n    min_d_day = 101\n    busy_exam = 0\n    for exam in candi_exam:\n        if d[exam] < min_d_day:\n            busy_exam = exam\n            min_d_day = d[exam]\n    \n    ans[day] = busy_exam + 1\n    c[busy_exam] -= 1\n    if c[busy_exam] == 0:\n        candi_exam.remove(busy_exam)\nfor i in range(m):\n    if c[i] != 0:\n        print(-1)\n        return\nprint(*ans[1:])\n    \n\n        \n\n", "aa = input()\nn, m = [int(s) for s in aa.split(' ')]\n\nexams = []\nres = [0] * n\n\nfor i in range(m):\n    aa = input()\n    s,d,c = [int(s) for s in aa.split(' ')]\n    el = {'s':s-1, 'd':d-1, 'c':c}\n    exams.append(el)\n    res[d - 1] = m + 1\n\nfor i in range(n-1, -1,-1):\n    if res[i] > 0: #exam\n        continue\n    exam_num = -1\n    min_zapas = n + 1\n    for j in range(m):\n        if (exams[j]['s'] <= i) and (i < exams[j]['d']) and (exams[j]['c'] > 0):\n            zapas = i - exams[j]['s'] - exams[j]['c']\n            if zapas < min_zapas:\n                min_zapas = zapas\n                exam_num = j\n            if zapas < 0:\n                break\n    if exam_num == -1:\n        continue\n    \n    res[i] = exam_num + 1\n    exams[exam_num]['c'] = exams[exam_num]['c'] - 1\n    \npossible = True\n\nfor i in range(m):\n    if exams[i]['c'] > 0:\n        possible = False\n        break\n\nif possible:\n    print(\" \".join([str(x) for x in res]))\nelse:\n    print(-1)", "R = lambda: list(map(int, input().split()))\n\nn, m= R()\na = []\nfor i in range(m):\n    s, d, c = R()\n    a.append([d, s, c, i+1])\na.sort()\nr = [0] * (n+1)\nfor i in range(m): r[a[i][0]] = m + 1\nfor i in range(m):\n    for j in range(a[i][1], a[i][0]):\n        if a[i][2]==0: break\n        elif r[j]==0:\n            r[j] = a[i][3]\n            a[i][2] -= 1\n    if a[i][2]: print((-1)); return\nprint(*r[1:])\n", "from collections import namedtuple\n\nExam = namedtuple(\"Exam\", \"id s d c\")\n\n\ndef get_exam(day, exams, prepared):\n    result = None\n\n    for exam in exams:\n        if exam.s <= day and prepared[exam.id] < exam.c and (result is None or exam.d < result.d):\n            result = exam\n\n    return result\n\n\nn, m = list(map(int, input().split()))\nexams = []\nprepared = [0] * (m + 1)\nschedule = [0] * (n + 1)\n\nfor i in range(m):\n    s, d, c = list(map(int, input().split()))\n    exams.append(Exam(i + 1, s, d, c))\n    schedule[d] = -1\n\nfor day in range(1, n + 1):\n    if schedule[day] == -1:\n        print(-1)\n        return\n\n    if schedule[day] == m + 1:\n        continue\n\n    exam = get_exam(day, exams, prepared)\n\n    if exam is None:\n        continue\n\n    prepared[exam.id] += 1\n    schedule[day] = exam.id\n\n    if prepared[exam.id] == exam.c:\n        schedule[exam.d] = m + 1\n\nprint(' '.join(map(str, schedule[1:])))\n", "a = input().split(\" \")\na = [int(e) for e in a]\n\nisdc = []\nfor i in range(a[1]):\n    l = input().split(\" \")\n    l = [int(e) for e in l]\n    isdc.append([i+1, l[0]-1, l[1]-1, l[2]])\n\nl = [0] * a[0]\nfor e in isdc:\n    l[e[2]] = len(isdc) + 1\n\nisdc = sorted(isdc, key=lambda one: one[2])\n\nfor exam in isdc:\n    day = exam[1]\n    while day < exam[2]:\n        if exam[3] == 0:\n            break\n        if l[day] == 0:\n            l[day] = exam[0]\n            exam[3] -= 1\n\n        day += 1\n\n    if exam[3] != 0:\n        print(-1)\n        return\n\nfor e in l:\n    print(e, end=\" \")\n", "import heapq\n\n\n\n\nn, m = map(int, input().split())\nans = [0]*n\nary = []\ndp = [[0]*n for i in range(n)]\n# print(dp)\ntmp =0\n\nwhile tmp < m:\n    s, d, c = map(int, input().split())\n    s -= 1; d -= 1\n    ans[d] = m + 1\n    ary.append((s, d, c + 1, tmp))\n    # print('sdc', s,d,c)\n    dp[s][d] = c + 1\n    # print('dp', dp[s][d])\n    tmp += 1\n\n\n# print(dp)\n\n\nd = 2\nwhile d< n:\n    l = 0\n    while l+d < n:\n        r = l+d\n\n        dp[l][r] += dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n        # print('lr', l, r ,dp[l][r], dp[l + 1][r], dp[l][r - 1], dp[l + 1][r - 1])\n        # if dp[l][r] > d:\n        #     print(-1)\n        #     quit(0)\n        l += 1\n    d+=1\n\nl = 0\npos = 0\nsary = sorted(ary)\n# print(sary)\nque = []\n\nwhile l<n:\n    while pos<m and sary[pos][0] == l:\n        heapq.heappush(que, [sary[pos][1], sary[pos][2] , sary[pos][3]])\n        pos += 1\n    if ans[l] > 0:\n        l += 1\n        continue\n    if que.__len__() == 0:\n        # ans[l] = 0\n        l += 1\n        continue\n    head = heapq.heappop(que)\n    # print('head',l, head)\n    if head[1] + l - 1 > head[0]:\n        print(-1)\n        quit(0)\n\n\n    head[1] -= 1\n    ans[l] = head[2] + 1\n    if head[1] > 1:\n        heapq.heappush(que, head)\n    l += 1\n\nif que.__len__() >0 or pos < m:\n    print(-1)\nelse:\n    print(*ans)", "import heapq\n\n\n\n\nn, m = map(int, input().split())\nans = [0]*n\nary = []\ndp = [[0]*n for i in range(n)]\n# print(dp)\ntmp =0\n\nwhile tmp < m:\n    s, d, c = map(int, input().split())\n    s -= 1; d -= 1\n    ans[d] = m + 1\n    ary.append((s, d, c + 1, tmp))\n    # print('sdc', s,d,c)\n    dp[s][d] = c\n    # print('dp', dp[s][d])\n    tmp += 1\n\n\n# print(dp)\n\n\nd = 2\nwhile d< n:\n    l = 0\n    while l+d < n:\n        r = l+d\n\n        dp[l][r] += dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n        # print('lr', l, r ,dp[l][r], dp[l + 1][r], dp[l][r - 1], dp[l + 1][r - 1])\n        if dp[l][r] > d:\n            print(-1)\n            quit(0)\n        l += 1\n    d+=1\n\nl = 0\npos = 0\nsary = sorted(ary)\n# print(sary)\nque = []\n\nwhile l<n:\n    while pos<m and sary[pos][0] == l:\n        heapq.heappush(que, [sary[pos][1], sary[pos][2] , sary[pos][3]])\n        pos += 1\n    if ans[l] > 0:\n        l += 1\n        continue\n    if que.__len__() == 0:\n        # ans[l] = 0\n        l += 1\n        continue\n    head = heapq.heappop(que)\n    # print('head',l, head)\n    if head[1] + l - 1 > head[0]:\n        print(-1)\n        quit(0)\n\n\n    head[1] -= 1\n    ans[l] = head[2] + 1\n    if head[1] > 1:\n        heapq.heappush(que, head)\n    l += 1\n\nif que.__len__() >0 or pos < m:\n    print(-1)\nelse:\n    print(*ans)", "n,m =map(int,input().split())\nl = list()\nout = [0] * n\nfor i in range(m):\n    s1,d1,c1 = map(int,input().split())\n    l.append((s1,d1,c1,i))\nl.sort(key=lambda x:x[1])\ncan = True\nfor j in l:\n    out[j[1] - 1] = m + 1\nfor i in l:\n    c = i[2]\n    for t in range(i[0],i[1]):\n        if out[t - 1] == 0 and c > 0:\n            out[t - 1] = i[3] + 1\n            c -= 1\n        if c == 0:\n            break\n    if c != 0:\n        print(-1)\n        can = False\n        break\n\nif can is True:\n    print(\" \".join(map(str,out)))", "rd = lambda: list(map(int, input().split()))\nn, m = rd()\na = sorted(([*rd()] + [i + 1] for i in range(m)), key=lambda x: x[1])\nr = [0] * n\nfor x in a:\n    r[x[1] - 1] = m + 1\n    for i in range(x[0] - 1, x[1] - 1):\n        if not r[i]:\n            r[i] = x[3]\n            x[2] -= 1\n            if not x[2]:\n                break\n    if x[2]:\n        print(-1)\n        return\nprint(*r)\n", "# from itertools import accumulate\n# from bisect import bisect_left\n# from collections import OrderedDict\n\nI = lambda: list(map(int, input().split()))\n\nn, m = I()\ndates = [0 for i in range(n + 1)]\ndata = []\nfor i in range(m):\n    d = I() + [i + 1]\n    if dates[d[1]]:\n        print(-1)\n        return\n    dates[d[1]] = m + 1\n    data.append(d)\ndata.sort(key = lambda x: x[1])\nfor s, d, c, idx in data:\n    x = 0\n    for i in range(s, d):\n        if x == c:\n            break\n        if not dates[i]:\n            dates[i] = idx\n            x += 1\n    if x != c:\n        print(-1)\n        return\nprint(*dates[1:])"]