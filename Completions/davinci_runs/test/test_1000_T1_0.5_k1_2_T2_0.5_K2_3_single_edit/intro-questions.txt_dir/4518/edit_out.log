2022-04-16 00:15:05.035460 num operations 1
2022-04-16 00:15:05.035480 size on input set 1
2022-04-16 00:15:19.775936 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(b==[1,3]):\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif(b==[1,2]):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif(b==[1,2,3]):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\n        else:\n            print(\"NO\")\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        if len(b)==2:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print(\"YES\")\n                        print(\"1 3\")\n                        print(\"3 5\")\n                        print(\"5 4\")\n                        print(\"1 2\")\n                        print(\"NO\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"2 3\")\n                        print(\"3 4\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"1 3\")\n                        print(\"1 4\")\n        if len(b)==3:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print(\"YES\")\n                        print(\"1 3\")\n                        print(\"3 5\")\n                        print(\"5 4\")\n                        print(\"1 2\")\n                        print(\"NO\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"2 3\")\n                        print(\"3 4\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"1 3\")\n                        print(\"1 4\")\n        if len(b)==4:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print(\"YES\")\n                        print(\"1 3\")\n                        print(\"3 5\")\n                        print(\"5 4\")\n                        print(\"1 2\")\n                        print(\"NO\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"2 3\")\n                        print(\"3 4\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"1 3\")\n                        print(\"1 4\")\n        h=[int(x) for x in h]\n        print(\"YES\")\n        print(\"1 3\")\n        print(\"3 5\")\n        print(\"5 4\")\n        print(\"1 2\")\n        print(\"NO\")\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"2 3\")\n        print(\"3 4\")\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"1 3\")\n        print(\"1 4\")\n        if len(b)==3:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print(\"YES\")\n                        print(\"1 3\")\n                        print(\"3 5\")\n                        print(\"5 4\")\n                        print(\"1 2\")\n                        print(\"NO\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"2 3\")\n                        print(\"3 4\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"1 3\")\n                        print(\"1 4\")\n        if len(b)==4:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print(\"YES\")\n                        print(\"1 3\")\n                        print(\"3 5\")\n                        print(\"5 4\")\n                        print(\"1 2\")\n                        print(\"NO\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"2 3\")\n                        print(\"3 4\")\n                        print(\"YES\")\n                        print(\"1 2\")\n                        print(\"1 3\")\n                        print(\"1 4\")\nmain()\n"
    }
  ],
  "created": 1650068105,
  "object": "edit"
}
2022-04-16 00:15:19.776198 fix syntax errors 3 ['\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(b==[1,3]):\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif(b==[1,2]):\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif(b==[1,2,3]):\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\n        else:\n            print("NO")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        if len(b)==2:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print("YES")\n                        print("1 3")\n                        print("3 5")\n                        print("5 4")\n                        print("1 2")\n                        print("NO")\n                        print("YES")\n                        print("1 2")\n                        print("2 3")\n                        print("3 4")\n                        print("YES")\n                        print("1 2")\n                        print("1 3")\n                        print("1 4")\n        if len(b)==3:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print("YES")\n                        print("1 3")\n                        print("3 5")\n                        print("5 4")\n                        print("1 2")\n                        print("NO")\n                        print("YES")\n                        print("1 2")\n                        print("2 3")\n                        print("3 4")\n                        print("YES")\n                        print("1 2")\n                        print("1 3")\n                        print("1 4")\n        if len(b)==4:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print("YES")\n                        print("1 3")\n                        print("3 5")\n                        print("5 4")\n                        print("1 2")\n                        print("NO")\n                        print("YES")\n                        print("1 2")\n                        print("2 3")\n                        print("3 4")\n                        print("YES")\n                        print("1 2")\n                        print("1 3")\n                        print("1 4")\n        h=[int(x) for x in h]\n        print("YES")\n        print("1 3")\n        print("3 5")\n        print("5 4")\n        print("1 2")\n        print("NO")\n        print("YES")\n        print("1 2")\n        print("2 3")\n        print("3 4")\n        print("YES")\n        print("1 2")\n        print("1 3")\n        print("1 4")\n        if len(b)==3:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print("YES")\n                        print("1 3")\n                        print("3 5")\n                        print("5 4")\n                        print("1 2")\n                        print("NO")\n                        print("YES")\n                        print("1 2")\n                        print("2 3")\n                        print("3 4")\n                        print("YES")\n                        print("1 2")\n                        print("1 3")\n                        print("1 4")\n        if len(b)==4:\n            if len(d)==2:\n                if len(f)==2:\n                    if len(h)==2:\n                        print("YES")\n                        print("1 3")\n                        print("3 5")\n                        print("5 4")\n                        print("1 2")\n                        print("NO")\n                        print("YES")\n                        print("1 2")\n                        print("2 3")\n                        print("3 4")\n                        print("YES")\n                        print("1 2")\n                        print("1 3")\n                        print("1 4")\nmain()\n']
2022-04-16 00:15:19.776337 size on output set 3
2022-04-16 00:15:19.776348 num operations 1
2022-04-16 00:15:19.776354 size on input set 1
2022-04-16 00:15:25.630899 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tfor i in range(2):\n\t\t\t\t\tif road[i] not in connected:\n\t\t\t\t\t\tconnected.add(road[i])\n\t\t\t\t\t\tqueue.append(road[i])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1-1\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1-2\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2-1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2-2\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    }
  ],
  "created": 1650068119,
  "object": "edit"
}
2022-04-16 00:15:25.631125 fix syntax errors 3 ['\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tfor i in range(2):\n\t\t\t\t\tif road[i] not in connected:\n\t\t\t\t\t\tconnected.add(road[i])\n\t\t\t\t\t\tqueue.append(road[i])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', 'import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', 'import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1-1\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1-2\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2-1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2-2\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n']
2022-04-16 00:15:25.631250 size on output set 3
