2022-04-16 00:15:41.907444 num operations 1
2022-04-16 00:15:41.907463 size on input set 1
2022-04-16 00:15:54.399711 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += abs(x_sorted[1][0] - x_sorted[0][0]) - abs(x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += abs(x_sorted[-1][0] - x_sorted[-2][0]) - abs(x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += abs(x_sorted[i+1][0] - x_sorted[i][0]) - abs(x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += abs(x_sorted[-i-1][0] - x_sorted[-i-2][0]) - abs(x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += abs(x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - abs(x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 2,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point, or vice versa\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    }
  ],
  "created": 1650068142,
  "object": "edit"
}
2022-04-16 00:15:54.400094 fix syntax errors 3 ['\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += abs(x_sorted[1][0] - x_sorted[0][0]) - abs(x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += abs(x_sorted[-1][0] - x_sorted[-2][0]) - abs(x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += abs(x_sorted[i+1][0] - x_sorted[i][0]) - abs(x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += abs(x_sorted[-i-1][0] - x_sorted[-i-2][0]) - abs(x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += abs(x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - abs(x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point, or vice versa\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n']
2022-04-16 00:15:54.400216 size on output set 3
2022-04-16 00:15:54.400226 num operations 1
2022-04-16 00:15:54.400232 size on input set 1
2022-04-16 00:15:58.780611 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\nfor(int i = 0; i < n; i++)\n    x[i] += v[i];\nx.sort()\nd = 0\nfor(int i = 0; i < n - 1; i++)\n    d += x[i + 1] - x[i];\nprint(d)\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n\nprint(d)\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]  # get the new positions\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    }
  ],
  "created": 1650068154,
  "object": "edit"
}
2022-04-16 00:15:58.780811 fix syntax errors 3 ['\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\nfor(int i = 0; i < n; i++)\n    x[i] += v[i];\nx.sort()\nd = 0\nfor(int i = 0; i < n - 1; i++)\n    d += x[i + 1] - x[i];\nprint(d)\n', '\n\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n\nprint(d)\n', '\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]  # get the new positions\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n']
2022-04-16 00:15:58.780838 size on output set 3
