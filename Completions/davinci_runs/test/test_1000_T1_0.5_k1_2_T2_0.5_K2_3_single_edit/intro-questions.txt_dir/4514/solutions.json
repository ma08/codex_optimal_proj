["n, q = map(int, input().split())\npar = [int(v)-1 for v in input().split()]\nchs = [[] for i in range(n)]\nfor i, p in enumerate(par):\n    chs[p].append(i+1)\nvis = [0 for _ in range(n)]\nbel = [1 for _ in range(n)]\nstack = [0]\norder = [0]\nwhile stack:\n    v = stack[-1]\n    if len(chs[v]) == vis[v]:\n        if v != 0:\n            bel[par[v-1]] += bel[v]\n        stack.pop()\n        continue\n    ch = chs[v][vis[v]]\n    vis[v] += 1\n    order.append(ch)\n    stack.append(ch)\nFST = {}\nfor i, c in enumerate(order):\n    FST[c] = i\nout = []\nfor _ in range(q):\n    u, k = map(lambda x: int(x) - 1, input().split())\n    if k >= bel[u]:\n        out.append(-1)\n    else:\n        out.append(order[FST[u] + k] + 1)\nprint('\\n'.join(map(str, out)))", "n,q=map(int,input().split())\np=[-1]+[int(s)-1 for s in input().split()]\no=[0]*n\nl=[0]*n\ns=[1]*n\nv=[1]*n\nfor i in range(n-1,0,-1):\n  s[p[i]] += s[i]\nfor i in range(1,n):\n  l[i]=v[p[i]]\n  v[p[i]] += s[i]\n  o[l[i]]=i\n  v[i]=l[i]+1\nres=[0]*q\nfor i in range(q):\n  u,k=map(int,input().split())\n  u-=1\n  k-=1\n  res[i]=str(o[l[u]+k]+1 if k < s[u] else -1)\nprint('\\n'.join(res))", "n, q = map(int, input().split())\nv = list(map(int, input().split()))\nd = [list() for i in range(n)]\nr = [1] * n\nl = [0] * n\nfor j in range(n-1):\n    d[v[j]-1].append(j+1)\ndef push():\n    stack = list()\n    re_stack = list()\n    stack.append(0)\n    while True:\n        if len(stack) == 0:\n            return re_stack\n        tmp = stack.pop(0)\n        re_stack.append(tmp)\n        tmp_ = d[tmp]\n        stack = tmp_ + stack\ns = push()\nfor i in range(n):\n    l[s[i]] = i\nfor i in range(n-1, -1, -1):\n    for j in d[s[i]]:\n        r[s[i]] += r[j]\nss=[]\nfor x in range(q):\n    u, k = map(int, input().split())\n    if k > r[u-1]:\n        ss.append(-1)\n    else:\n        ss.append(s[l[u-1]+k-1]+1)\nprint('\\n'.join(map(str, ss)))", "n, q = map(int, input().split())\nsups = list(map(int, input().split()))\n\ndir_subs = [[] for i in range(n+1)]\nnum_subs = [0]*(n+1)\n\nsups = [0,0]+sups\nfor i in range(2, n+1):\n\tdir_subs[sups[i]].append(i)\n\n#ordered = [1]\nprev_parent = 0\n#qe = [-1]+dir_subs[1]\nqe = [1]\nordered = []\n\nwhile len(qe)>0:\n\tnew = qe.pop()\n\n\tif new > 0:\n\t\t#new_parent = sups[new]\n\t\tordered.append(new)\n\t\t#num_subs[new_parent] += 1\n\t\t\n\t\t#qe = dir_subs[new] + [-new] + qe\n\t\tqe.append(-new)\n\t\tnum = len(dir_subs[new])\n\t\tfor i in range(num):\n\t\t\tqe.append(dir_subs[new][num-1-i])\n\n\t\t#if new_parent == prev_parent:\n\t\t#\tnum_subs[new_parent] += num_subs[curr_parent]\n\t\t#\tprev_parent = new_parent\n\telse:\n\t\tparent = -new\n\t\tfor child in dir_subs[parent]:\n\t\t\tnum_subs[parent] += 1\n\t\t\tnum_subs[parent] += num_subs[child]\n\n#print(num_subs)\n#print(ordered)\n# [0, 8, 0, 5, 0, 2, 0, 1, 0, 0]\n\n\nindices = [0]*(n+1)\n\nfor i in range(n):\n\tindices[ordered[i]] = i\n\ndef ans_query(u, k):\n\tif k-1 > num_subs[u]:\n\t\treturn -1\n\t\n\tstart = indices[u]\n\tend = ordered[start+k-1]\n\treturn end\n\ns = ''\nfor i in range(q):\n\tu, k = map(int, input().split())\n\ts += (str(ans_query(u,k))+'\\n')\n\tif i%20 == 0:\n\t\tprint(s[:-1])\n\t\ts = ''\n\nif len(s) > 0:\n\tprint(s[:-1])", "from sys import *\nfrom math import *\n\n#setrecursionlimit(20000)\ngenerals = []\n\nclass Node:\n\n    def __init__ (self, value):\n        self.value = value\n        self.children = []\n        self.start = -1\n        self.end = -1\n\n    def add(self, fnode):\n        self.children.append(fnode)\n\n\ndef explore(node, index):\n    stack = []\n    stack.append(node)\n    while len(stack) > 0:\n        n = stack.pop()\n        generals.append(n.value)\n        n.start = index\n        index+=1\n        for child in n.children[::-1]:\n            stack.append(child)\n\n\n    stack = []\n    stack.append(node)\n    while len(stack) > 0:\n        n = stack.pop()\n        for i in range(len(n.children)):\n            child = n.children[i]\n            if i == len(n.children)-1:\n                child.end = n.end\n            else:\n                child.end = n.children[i+1].start\n        for child in n.children[::-1]:\n            stack.append(child)\n\n\ndef printN(node):\n    print(node.value, end=\" \")\n    print(node.start, end=\" \")\n    print(node.end)\n    for n in node.children:\n        printN(n)\n\nnodes = []\n\n\nline = stdin.readline().rstrip().split()\nn = int(line[0])\nq = int(line[1])\n\n#n = 100000\n#q = 5\n\n\nfor i in range(n):\n    nodes.append(Node(i+1))\n\ndependencies = list(map(int, stdin.readline().rstrip().split()))\n#dependencies = range(1, 100000)\nfor i in range(len(dependencies)):\n    nodes[dependencies[i]-1].add(nodes[i+1])\n\nnodes[0].start = 0\nnodes[0].end = n\nexplore(nodes[0], 0)\n\n#printN(nodes[0])\n\n\n\n\nfor i in range(q):\n    line = stdin.readline().rstrip().split()\n    u = int(line[0])\n    k = int(line[1])-1\n\n    node = nodes[u-1]\n    if k < node.end - node.start:\n        print(generals[node.start + k])\n    else:\n        print(-1)\n\n", "\n\n#input = open('e1.in').readline\n\nn, q = map(int, input().split())\nchildren = [[] for i in range(n)]\nsize = [0]*n\nfor i, p in enumerate(map(int, input().split()), 1):\n\tchildren[p-1].append(i)\n\nsize = [1]*n\n\n\ndfs = []\nindex_to_rank = [0]*n\n\n\n\ndef traverse():\n\tvisited = [False] * n\n\tstack = [(0, None)]\n\twhile stack:\n\t\ti, parent = stack[-1]\n\t\tif visited[i]:\n\t\t\tstack.pop()\n\t\t\tif parent is not None:\n\t\t\t\tsize[parent] += size[i]\n\n\t\telse:\n\t\t\tvisited[i] = True\n\t\t\tindex_to_rank[i] = len(dfs)\n\t\t\tdfs.append(i)\n\t\t\tfor j in reversed(children[i]):\n\t\t\t\tstack.append((j, i))\n\nanswer = []\ndef answer_queries():\n\tprint = answer.append\n\tfor i in range(q):\n\t\tu, k = map(int, input().split())\n\t\tindex = u-1\n\t\tif size[index] < k:\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(dfs[index_to_rank[index]+k-1]+1)\n\ntraverse()\nanswer_queries()\nprint('\\n'.join(map(str, answer)))", "n, q = list(map(int,input().split()))\nofficers = list(map(int,input().split()))\n\ns = [[] for _ in range(n)]\nc = [1] * n\nb = [0] * n\n\nfor i,v in enumerate(officers):\n\ts[v-1].append(i+1)\n\ntraversal = []\ndef dfs():\n\tstack = [0]\n\twhile stack:\n\t\tn = stack.pop()\n\t\ttraversal.append(n)\n\t\tfor child in reversed(s[n]):\n\t\t\tstack.append(child)\ndfs()\n\nfor i in range(n):\n\tb[traversal[i]] = i\n\nfor i in range(n-1,-1,-1):\n\tfor child in s[i]:\n\t\tc[i] += c[child]\n# print(c)\nanswer = []\nfor _ in range(q):\n\tu, k = list(map(int,input().split()))\n\tstart = b[u-1]\n\tif k <= c[u-1]:\n\t\tanswer.append((str(traversal[start+k-1]+1)))\n\t\t# print(traversal[start+k-1]+1)\n\telse:\n\t\tanswer.append(\"-1\")\nprint('\\n'.join(answer))\n", "# import sys \n# sys.stdin = open('in.txt','r')\n\nn, q = list(map(int, input().split()))\ng = [[] for i in range(n+1)]\n\np = list(map(int, input().split()))\nfor i in range(n-1):\n\tg[p[i]].append(i+2)\n\ntimer = 0\nchildren = [0] * (n + 1)\nwhen = [0] * (n + 1)\na = []\ninstack = [0] * (n + 1)\nstack = [1]\n\nwhile stack:\n\tu = stack[-1]\n\tif instack[u] == 1:\n\t\tchildren[u] = len(a) - when[u]\n\t\tstack.pop()\n\t\tcontinue\n\ta.append(u)\n\twhen[u] = len(a) - 1\n\tinstack[u] = 1\n\tfor i in reversed(g[u]):\n\t\tstack.append(i)\nans = [0] * q\nfor i in range(q):\n\tx, y = list(map(int, input().split()))\n\ty -= 1\n\tans[i] = '-1' if y >= children[x] else str(a[when[x] + y])\n\nprint('\\n'.join(ans))\n\n\n\t\n\n\n\n", "from collections import deque as dq\nfrom collections import defaultdict as dc\ndef dfs(stack,vis,child,when,ab):\n        while(len(stack)>0):\n                a=stack[-1]\n                if vis[a]==1:\n                        child[a]=len(ab)-when[a]\n                        c=stack.pop()\n                        continue\n                ab.append(a)\n                when[a]=len(ab)-1\n                #print(a)\n                vis[a]=1\n                for i in reversed(adj[a]):\n                        stack.append(i)\n                        #print(stack)\nadj=dc(list)\nn,q=list(map(int,input().split()))\nchild=[0]*(n+1)#store the max no. of sub tree element\nwhen=[0]*(n+1)#store i element is at when[i] place in ab\nab=[]#the dfs element\nvis=[0]*(n+1)\nstack=dq([1])\na=list(map(int,input().split()))\nfor i in range(2,n+1):\n        adj[a[i-2]].append(i)\ndfs(stack,vis,child,when,ab)\n#print(child)\nz=[]\nfor i in range(q):\n        x,y=list(map(int ,input().split()))\n        y=y-1\n        if y>=child[x]:\n                z.append(str(-1))\n        else:\n                z.append(str(ab[when[x]+y]))\nprint('\\n'.join(z))\n", "\nn,q = [int(x) for x in input().split()]\nL = [int(x)-1 for x in input().split()]\n\nG = []\nfor i in range(n):\n    G.append([])\nfor i in range(n-1):\n    G[L[i]].append((i+1,L[i]))\n    G[i+1].append((L[i],i+1))\n    \nL = [-1]+L\nG[0].reverse()\n\nfor t in range(1,n):\n    G[t] = [G[t][0]]+list(reversed(G[t][1:]))\n\noptions = [(0,0)]\nvisited = [0]*n\nsub = [1]*n\npath = []\nwhile options:\n    t = options.pop()\n    if visited[t[0]] == 0:\n        visited[t[0]] = 1\n        path.append(t[0])\n        options.extend(G[t[0]])\n    elif visited[t[0]] == 1:\n        sub[t[0]] += sub[t[1]]\n\nPosition = {}\nfor i in range(n):\n    Position[path[i]] = i\n\n\nfor i in range(q):\n    u,k = [int(x) for x in input().split()]\n    if sub[u-1] < k:\n        print(-1)\n    else:\n        print(path[Position[u-1]+k-1]+1)", "import math\nfrom collections import defaultdict\nimport sys\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n    children = [[] for _ in range(n)]\n    parent = list(map(int, input().split()))\n    for i in range(n-1):\n        children[parent[i]-1].append(i+1)\n    d = []\n    cnt = [1] * n\n    stack = [0]\n\n    def dfs():\n        while stack:\n            node = stack.pop()\n            d.append(node)\n            for i in range(len(children[node])-1, -1, -1):\n                stack.append(children[node][i])\n\n    dfs()\n    for i in range(n-1, -1, -1):\n        total = 0\n        for child in children[i]:\n            total += cnt[child]\n        cnt[i] += total\n\n    indexof = [-1] * n\n    for i, val in enumerate(d):\n        indexof[val] = i\n\n    for _ in range(q):\n        u, k = list(map(int, input().split()))\n        index = indexof[u-1]\n        pos = index + k - 1\n        if k > cnt[u-1]:\n            print(-1)\n        else:\n            print(d[pos]+1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n\nclass CodeforcesTask1006ESolution:\n    def __init__(self):\n        self.result = ''\n        self.n_q = []\n        self.command = []\n        self.queries = []\n\n    def read_input(self):\n        self.n_q = [int(x) for x in input().split(\" \")]\n        self.command = [int(x) for x in input().split(\" \")]\n        for _ in range(self.n_q[1]):\n            self.queries.append([int(x) for x in input().split(\" \")])\n\n    def process_task(self):\n        tree = [[] for _ in range(self.n_q[0])]\n        for x in range(1, self.n_q[0]):\n            tree[self.command[x - 1] - 1].append(x + 1)\n        starts = {}\n        stops = {}\n        called = []\n        to_visit = deque([1, -1])\n        while to_visit:\n            visiting = to_visit.popleft()\n            if visiting < 0:\n                stops[abs(visiting)] = len(called)\n            else:\n                called.append(visiting)\n                starts[visiting] = len(called)\n                n = sorted(tree[visiting - 1], reverse=True)\n                to_visit.appendleft(-visiting)\n                for a in n:\n                   to_visit.appendleft(a)\n        ranges = [stops[x] - starts[x] + 1 for x in range(1, self.n_q[0] + 1)]\n        for query in self.queries:\n            if ranges[query[0] - 1] >= query[1]:\n                print(called[starts[query[0]] + query[1] - 2])\n            else:\n                print('-1')\n\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask1006ESolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()", "n,q=map(int,input().split())\np=[-1]+[int(s)-1 for s in input().split()]\no=[0]*n\nl=[0]*n\ns=[1]*n\nv=[1]*n\nfor i in range(n-1,0,-1):\n  s[p[i]] += s[i]\nfor i in range(1,n):\n  l[i]=v[p[i]]\n  v[p[i]] += s[i]\n  o[l[i]]=i\n  v[i]=l[i]+1\nres=[0]*q\nfor i in range(q):\n  u,k=map(int,input().split())\n  u-=1\n  k-=1\n  res[i]=str(o[l[u]+k]+1 if k < s[u] else -1)\nprint('\\n'.join(res))", "n, q=[int(x) for x in input().split()]\nparent=[-1]+[int(x) -1 for x in input().split()]\nstart=[0]*n\nend=[1]*n\nsize=[1]*n\npath=[0]*n\nfor i in range(n-1, 0, -1):\n    size[parent[i]]+=size[i]\nfor v in range(1, n):\n    start[v]=end[parent[v]]\n    end[v]=start[v]+1\n    end[parent[v]]+=size[v]\n    path[start[v]]=v\nfor j in range(q):\n    u, k=[int(x) -1 for x in input().split()]\n    if k >= size[u]:\n        print (\"-1\")\n        \n    else:\n        print(path[start[u]+k]+1)\n", "n, q = [int(x) for x in input().split(\" \")]\nparent = [-1] + [int(x) - 1 for x in input().split(\" \")]\nstart = [0] * n\npath = [0] * n\nend = [1] * n\nsize = [1] * n\n\nfor i in range(n - 1, 0, -1):\n    size[parent[i]] += size[i]\n\nfor v in range(1, n):\n    start[v] = end[parent[v]]\n    end[v] = start[v] + 1\n    end[parent[v]] += size[v]\n    path[start[v]] = v\n\nfor j in range(q):\n    u, k = [int(x) - 1 for x in input().split(\" \")]\n    print(-1 if k >= size[u] else path[start[u] + k] + 1)\n", "from collections import *\nfrom sys import stdin\nfrom bisect import *\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return [str(x) for x in stdin.readline().split()]\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict = gdict\n\n    # add edge\n    def add_edge(self, node1, node2):\n        self.gdict[node1].append(node2)\n\n    def dfsUtil(self, v):\n        stack, self.visit, out = [v], [0] * (n + 1), []\n\n        while (stack):\n            s = stack.pop()\n\n            if not self.visit[s]:\n                out.append(s)\n                self.visit[s] = 1\n\n            for i in sorted(self.gdict[s], reverse=True):\n                if not self.visit[i]:\n                    stack.append(i)\n\n        return out\n\n\nn, q = arr_inp(1)\np, g, mem, quary = arr_inp(1), graph(), [1 for i in range(n + 1)], defaultdict(lambda: -1)\n\nfor i in range(2, n + 1):\n    g.add_edge(p[i - 2], i)\n\nall, ans = g.dfsUtil(1), []\nmem2 = {all[i]: i for i in range(n)}\n\nfor i in all[::-1]:\n    for j in g.gdict[i]:\n        mem[i] += mem[j]\n\n\nfor i in range(q):\n    u, v = arr_inp(1)\n    ans.append(str(-1 if mem[u] < v else all[mem2[u] + v - 1]))\n\nprint('\\n'.join(ans))\n", "def dfs(dp,node,edges,order):\n    visited = set()\n    stack = [node]\n    while stack:\n        curr = stack[-1]\n        if curr not in visited:\n            visited.add(curr)\n            order.append(curr)\n            \n        count = 0\n        for kid in edges[curr]:\n            if kid in visited:\n                count += 1\n            else:\n                stack.append(kid)\n\n        if count == len(edges[curr]):\n            stack.pop()\n            for kid in edges[curr]:\n                dp[curr] += dp[kid]\n\n            dp[curr] += 1\n\n        #print(stack)\n            \n\ndef solve(u,k,dp,order,indices,ans):\n    if k > dp[u]:\n        ans.append(-1)\n        return\n\n    index = indices[u]\n    ans.append(order[index+k-1])\n\ndef main():\n    n,q = list(map(int,input().split()))\n    parents = list(map(int,input().split()))\n    edges = {}\n    for i in range(1,n+1):\n        edges[i] = []\n\n    for i in range(2,n+1):\n        parent = parents[i-2]\n        edges[parent].append(i)\n\n    for i in list(edges.keys()):\n        edges[i].sort(reverse = True)\n\n    indices = [-1]*(n+1)\n    order = []\n    dp = [0]*(n+1)\n    dfs(dp,1,edges,order)\n    #print(order)\n    #print(dp)\n    for i in range(n):\n        indices[order[i]] = i\n\n    ans = []\n    for i in range(q):\n        u,k = list(map(int,input().split()))\n        solve(u,k,dp,order,indices,ans)\n\n    for i in ans:\n        print(i)\n\n\nmain()\n", "# itne me hi thakk gaye?\nn, q = list(map(int, input().split()))\nparent = [-1] + [int(x) -1 for x in input().split()]\n# parent = [i-1 for i in parent]\nstart = [0 for i in range(n)]\nend = [1 for i in range(n)]\nsize = [1 for i in range(n)]\npath = [0 for i in range(n)]\nfor i in range(n-1, 0, -1):\n    size[parent[i]] += size[i]\nfor v in range(1, n):\n\tstart[v] = end[parent[v]]\n\tend[v] = start[v] + 1\n\tend[parent[v]] += size[v]\n\tpath[start[v]] = v\nfor j in range(q):\n\tu, k = [int(x) -1 for x in input().split()]\n\tif k>= size[u]:\n\t\tprint(-1)\n\telse:\n\t\tprint(path[start[u] + k] + 1)\n", "n,q=list(map(int,input().split()))\nfrom heapq import heappush as pu\nfrom heapq import heappop as po\nfrom bisect import bisect_right as br \n\ntr=[[] for i in range(n)]\nsize=[1 for i in range(n)]\n\np=list(map(int,input().split()))\np=[i-1 for i in p]\n\nfor i in range(n-1):\n\ttr[p[i]].append(i+1)\nfor i in range(n):\n\ttr[i].sort(reverse=True)\n\nh={}\nh[0]=0\ns=[0]\nm=[]\nwhile s:\n\tx=s.pop()\n\tm.append(x)\n\tfor i in tr[x]:\n\t\ts.append(i)\n\t\th[i]=h[x]+1\n\nd=[(i,h[i]) for i in range(n)]\nd.sort(key=lambda x:x[1])\nd=[i[0] for i in d]\n\nfor i in range(n-1,0,-1):\n\tsize[p[d[i]-1]]+=size[d[i]]\nind={}\nfor i in range(n):\n\tind[m[i]]=i\nfor _ in range(q):\n\tu,k=list(map(int,input().split()))\n\tu-=1\n\tif k>size[u]:\n\t\tprint(-1)\n\telse:\n\t\ti=ind[u]\n\t\tprint(m[i+k-1]+1)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tself.parent = [-1 for i in range(self.n)]\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\torder.append(element)\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\ttemp=[]\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\ttemp.append(i)\n\t\t\t# print (element,temp)\n\t\t\ttemp.sort(reverse=True)\n\t\t\tfor i in temp:\n\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tm += ans[i]\n\t\t\tans[element] = m+1\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef ifcycle(self):\n\t\tself.bfs(0)\n\t\tqueue = [0]\n\t\tvis = [0]*n\n\t\tqueue = deque(queue)\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in graph[element]:\n\t\t\t\tif vis[i]==1 and i!=parent[element]:\n\t\t\t\t\treturn True\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tvis[i] = 1\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\n\n\nn,q = list(map(int,input().split()))\ng = Graph(n,False)\ng.parent = [-1]+list(map(int,input().split()))\nfor i in range(1,n):\n\tg.parent[i] -= 1\n\tg.addEdge(g.parent[i],i)\ncount = [0]*n\norder = []\ng.dfs(0, count)\n# print (count)\n# print (order)\nrank = {}\nfor i in range(n):\n\trank[order[i]] = i\nfor i in range(q):\n\ta,k = list(map(int,input().split()))\n\tif k>count[a-1]:\n\t\tprint(-1)\n\telse:\n\t\tprint(order[rank[a-1]+k-1]+1)\n\n"]