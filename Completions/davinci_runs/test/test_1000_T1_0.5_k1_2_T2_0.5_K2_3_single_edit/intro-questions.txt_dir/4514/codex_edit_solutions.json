["\n\nimport sys\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\ndef build_tree(preorder, inorder):\n    if not preorder:\n        return None\n    root = Node(preorder[0])\n    if len(preorder) == 1:\n        return root\n    root_inorder = inorder.index(preorder[0])\n    root.left = build_tree(preorder[1:root_inorder+1], inorder[:root_inorder])\n    root.right = build_tree(preorder[root_inorder+1:], inorder[root_inorder+1:])\n    return root\n\n\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.value, end=' ')\n        inorder(root.right)\n\n\ndef preorder(root):\n    if root:\n        print(root.value, end=' ')\n        preorder(root.left)\n        preorder(root.right)\n\n\ndef main():\n    preorder_list = [int(x) for x in sys.stdin.readline().split()]\n    inorder_list = [int(x) for x in sys.stdin.readline().split()]\n    root = build_tree(preorder_list, inorder_list)\n    preorder(root)\n    print()\n    inorder(root)\n\n\nif __name__ == \"__main__\":\n    main()\n", "from collections import deque\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        # self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        # self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        # root.visited = True\n        for c in root.children:\n            res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [int(x) for x in sys.stdin.readline().split()]\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n)]\n    for i in range(1, n):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k-1:\n            return u\n        for v in tree[u]:\n            res = dfs(tree, v, k, visited)\n            if res:\n                return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    # n, q = [int(x) for x in sys.stdin.readline().split()]\n    # adj = [0]\n    # adj.extend([int(x) for x in sys.stdin.readline().split()])\n    # queries = []\n    # for _ in range(q):\n    #     queries.append([int(x) for x in sys.stdin.readline().split()])\n    # return n, q, adj, queries\n    return 9, 5, [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9]]\n\n\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    # n, q, adj, queries = read_input()\n    # tree = build_tree(n, adj)\n    # for u, k in queries:\n    #     visited = set()\n    #     res = dfs(tree, u, k, visited)\n    #     if res:\n    #         print(res)\n    #     else:\n    #         print(-1)\n    n, q, adj, queries = read_input()\n    print(n, q, adj, queries)\n\nif __name__ == \"__main__\":\n    main()\n", "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\n\nif __name__ == '__main__':\n    main()\n"]