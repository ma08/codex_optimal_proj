2022-04-15 22:39:20.048172 num operations 1
2022-04-15 22:39:20.048182 size on input set 1
2022-04-15 22:39:27.864909 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = -1\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    if max_paths != -1:\n        print(max_paths)\n        print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 1\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650062361,
  "object": "edit"
}
2022-04-15 22:39:27.865181 fix syntax errors 3 ['\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = -1\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    if max_paths != -1:\n        print(max_paths)\n        print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 1\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-15 22:39:27.865391 size on output set 3
2022-04-15 22:39:27.865419 num operations 1
2022-04-15 22:39:27.865426 size on input set 1
2022-04-15 22:39:49.916256 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    tree[v1].append(v2)\n    tree[v2].append(v1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2, v3):\n    cnt1, edges1 = dfs(v1, v2)\n    cnt2, edges2 = dfs(v2, v1)\n    cnt3, edges3 = dfs(v3, v1)\n    cnt4, edges4 = dfs(v3, v2)\n    return edges1 + edges2 + edges3 + edges4 + cnt1 * cnt2 + cnt1 * cnt3 + cnt2 * cnt4\n\n\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    }
  ],
  "created": 1650062368,
  "object": "edit"
}
2022-04-15 22:39:49.916462 fix syntax errors 3 ['import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    tree[v1].append(v2)\n    tree[v2].append(v1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2, v3):\n    cnt1, edges1 = dfs(v1, v2)\n    cnt2, edges2 = dfs(v2, v1)\n    cnt3, edges3 = dfs(v3, v1)\n    cnt4, edges4 = dfs(v3, v2)\n    return edges1 + edges2 + edges3 + edges4 + cnt1 * cnt2 + cnt1 * cnt3 + cnt2 * cnt4\n\n\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n']
2022-04-15 22:39:49.916512 size on output set 3
