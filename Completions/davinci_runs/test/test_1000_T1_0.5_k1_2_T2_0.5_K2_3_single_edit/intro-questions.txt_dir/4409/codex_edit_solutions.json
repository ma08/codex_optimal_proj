["\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))[:t]\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()] \n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]: \n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])-1\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])-1\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])+1\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])+1\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n", "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]!=a[i-1] and a[i]!=a[i+1]:\n        if a[i]<a[i-1]:\n            a[i]=a[i]+abs(a[i]-a[i-1])\n            print(1,i+1,i)\n            c+=1\n        elif a[i]<a[i+1]:\n            a[i]=a[i]+abs(a[i]-a[i+1])\n            print(1,i+1,i+2)\n            c+=1\n        elif a[i]>a[i-1]:\n            a[i]=a[i]-abs(a[i]-a[i-1])\n            print(2,i+1,i)\n            c+=1\n        elif a[i]>a[i+1]:\n            a[i]=a[i]-abs(a[i]-a[i+1])\n            print(2,i+1,i+2)\n            c+=1\nprint(c)\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join(str(x) for x in op))\n    \nif __name__ == '__main__':\n    main()\n"]