2022-04-16 00:30:10.145586 num operations 1
2022-04-16 00:30:10.145602 size on input set 1
2022-04-16 00:30:22.362616 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[2] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v-1] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v-1] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[2])\n\n    # zero out the maximum cost edge\n    max_edge[2] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0]-1)\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a][b] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[2])\n\n    # create a disjoint set of vertices (disjoint sets are indexed from 0)\n    ds = DisjointSet(n-1)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex from s\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n)) - {s}\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s][u-1] = min(dist[s][u-1], dist[s][v] + w)\n                dist[s][w-1] = min(dist[s][w-1], dist[s][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n"
    }
  ],
  "created": 1650069010,
  "object": "edit"
}
2022-04-16 00:30:22.363013 fix syntax errors 3 ["\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[2] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v-1] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v-1] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[2])\n\n    # zero out the maximum cost edge\n    max_edge[2] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0]-1)\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a][b] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[2])\n\n    # create a disjoint set of vertices (disjoint sets are indexed from 0)\n    ds = DisjointSet(n-1)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex from s\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n)) - {s}\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s][u-1] = min(dist[s][u-1], dist[s][v] + w)\n                dist[s][w-1] = min(dist[s][w-1], dist[s][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n"]
2022-04-16 00:30:22.363131 size on output set 3
2022-04-16 00:30:22.363142 num operations 1
2022-04-16 00:30:22.363147 size on input set 1
2022-04-16 00:30:26.847364 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict())\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = defaultdict(lambda: float('inf'))\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, input().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, input().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, input().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650069022,
  "object": "edit"
}
2022-04-16 00:30:26.847571 fix syntax errors 3 ["\nimport sys\n\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict())\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = defaultdict(lambda: float('inf'))\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, input().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, input().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, input().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 00:30:26.847622 size on output set 3
