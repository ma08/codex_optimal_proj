["\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\n", "\n# fix syntax errors\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n#\n#!/bin/python3\n\nimport os\nimport sys\n#\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n#\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n#\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n#\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n#\n    fptr.close()\n", "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n\n# Complete the knightlOnAChessboard function below.\ndef knightlOnAChessboard(n):\n    # Write your code here.\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    #fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    #fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    #fptr.write('\\n')\n\n    #fptr.close()\n", "def min_steps(n): \n    if n == 1: \n        return 0\n    elif n == 2: \n        return 2\n    elif n == 3: \n        return 3\n    else: \n        return n - 1\n  \nn = 4\nprint(min_steps(n)) \n", "\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\ndef isValid(r, c):\n    return r >= 0 and r < n and c >= 0 and c < n\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n\nimport sys\nfrom collections import deque\n\n# read the input \nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n\n#!/usr/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n\n\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "import queue\n\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "import sys\nsys.setrecursionlimit(100000)\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans, board\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef main():\n    pass\n\nmain()\n", "\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n\nimport sys\nsys.setrecursionlimit(10000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 0 and i < N and j >= 0 and j < N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 0 and j == 0:\n    if board[i][j] == '#':\n        return sys.maxsize\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    x = sys.maxsize\n    for i1 in range(i-2, i+3):\n        for j1 in range(j-2, j+3):\n            if isValid(i1, j1, N):\n                x = min(x, findMinSteps(i1, j1, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\nfrom queue import Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if 0 <= new_r < n and 0 <= new_c < n and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\n\ndef is_valid(r, c):\n\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    # read the input\n    N = int(sys.stdin.readline())\n    board = []\n    for i in range(N):\n        board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"]