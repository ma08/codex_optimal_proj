2022-04-24 19:37:58.497288 num operations 2
2022-04-24 19:37:58.497298 size on input set 1
2022-04-24 19:37:58.497415 using api key soukgp
2022-04-24 19:38:12.051691 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 1,
      "text": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndfs(0, -1)\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    }
  ],
  "created": 1650829078,
  "object": "edit"
}
2022-04-24 19:38:12.051921 fix spelling mistakes 3 ['\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', 'import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndfs(0, -1)\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n']
2022-04-24 19:38:12.051973 size on output set 3
2022-04-24 19:38:12.051980 size on input set 3
2022-04-24 19:38:12.052122 using api key sunu
2022-04-24 19:38:23.726799 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << (k - 1)) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1 << 0] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(n):\n            if j & (1 << k) != 0 or edges[k] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 2,
      "text": "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    }
  ],
  "created": 1650829092,
  "object": "edit"
}
2022-04-24 19:38:23.726999 fix syntax errors 3 ['\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << (k - 1)) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1 << 0] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(n):\n            if j & (1 << k) != 0 or edges[k] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', 'import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n']
2022-04-24 19:38:23.727247 using api key derek
2022-04-24 19:38:32.815629 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570 \ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << (k - 1)) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    }
  ],
  "created": 1650829103,
  "object": "edit"
}
2022-04-24 19:38:32.815872 fix syntax errors 3 ['\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i番目までの頂点を使って、jを含む場合のパターン数 \ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << (k - 1)) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n']
2022-04-24 19:38:32.816032 using api key sunu
2022-04-24 19:39:16.834987 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n\ndef dfs(v, p, d):\n    depth[v] = d\n    for u in edges[v]:  # \u96a3\u63a5\u3059\u308b\u9802\u70b9\u3092\u63a2\u7d22\n        if u == p:  # \u89aa\u306f\u63a2\u7d22\u3057\u306a\u3044\n            continue  # \u6b21\u306e\u96a3\u63a5\u3059\u308b\u9802\u70b9\u306b\u9032\u3080\n        dfs(u, v, d + 1)  # \u518d\u5e30\u7684\u306b\u63a2\u7d22\n\n\ndef bfs(s):\n    q = deque([s])  # \u5148\u982d\u304b\u3089\u8981\u7d20\u3092\u53d6\u308a\u51fa\u3059\n    seen = [False] * n\n    seen[s] = True\n    while q:\n        v = q.popleft()\n        for u in edges[v]:\n            if seen[u]:\n                continue\n            seen[u] = True\n            q.append(u)\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ndfs(0, -1)\n"
    },
    {
      "index": 1,
      "text": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n            continue\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndfs(0, -1)\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 2,
      "text": "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\ndef bfs(v):\n    que = deque()\n    que.append(v)\n    while que:\n        v = que.popleft()\n        for u in edges[v]:\n            if visited[u]:\n                continue\n            visited[u] = True\n            que.append(u)\n\n    visited[v] = True\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n        dfs(u, v)\n            continue\n\n\n# n, m = map(int, input().split())\n# edges = [[] for _ in range(n)]\n# for _ in range(m):\n#     a, b = map(int, input().split())\n#     a -= 1\n#     b -= 1\n#     edges[a].append(b)\n#     edges[b].append(a)\n# visited = [False] * n\n\n# visited = [False] * n\n# bfs(0)\n\ndfs(0, -1)\n\n# n, m = map(int, input().split())\n# edges = [[] for _ in range(n)]\n# for _ in range(m):\n#     a, b = map(int, input().split())\n#     a -= 1\n#     b -= 1\n#     edges[a].append(b)\n#     edges[b].append(a)\n\n\n# # DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\n# dp = [[0] * (1 << n) for _ in range(n)]\n# dp[0][1] = 1\n# for i in range(n - 1):\n#     for j in range(1 << n):\n#         if dp[i][j] == 0:\n#             continue\n#         for k in range(1, n + 1):\n#             if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n#                 continue\n#             dp[i + 1][j | (1 << k)] += dp[i][j]\n# print(dp[n - 1][2 ** n - 1])\n"
    }
  ],
  "created": 1650829112,
  "object": "edit"
}
2022-04-24 19:39:16.835333 fix syntax errors 3 ['import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n\ndef dfs(v, p, d):\n    depth[v] = d\n    for u in edges[v]:  # 隣接する頂点を探索\n        if u == p:  # 親は探索しない\n            continue  # 次の隣接する頂点に進む\n        dfs(u, v, d + 1)  # 再帰的に探索\n\n\ndef bfs(s):\n    q = deque([s])  # 先頭から要素を取り出す\n    seen = [False] * n\n    seen[s] = True\n    while q:\n        v = q.popleft()\n        for u in edges[v]:\n            if seen[u]:\n                continue\n            seen[u] = True\n            q.append(u)\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ndfs(0, -1)\n', 'import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n            continue\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndfs(0, -1)\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', 'import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\ndef bfs(v):\n    que = deque()\n    que.append(v)\n    while que:\n        v = que.popleft()\n        for u in edges[v]:\n            if visited[u]:\n                continue\n            visited[u] = True\n            que.append(u)\n\n    visited[v] = True\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n        dfs(u, v)\n            continue\n\n\n# n, m = map(int, input().split())\n# edges = [[] for _ in range(n)]\n# for _ in range(m):\n#     a, b = map(int, input().split())\n#     a -= 1\n#     b -= 1\n#     edges[a].append(b)\n#     edges[b].append(a)\n# visited = [False] * n\n\n# visited = [False] * n\n# bfs(0)\n\ndfs(0, -1)\n\n# n, m = map(int, input().split())\n# edges = [[] for _ in range(n)]\n# for _ in range(m):\n#     a, b = map(int, input().split())\n#     a -= 1\n#     b -= 1\n#     edges[a].append(b)\n#     edges[b].append(a)\n\n\n# # DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\n# dp = [[0] * (1 << n) for _ in range(n)]\n# dp[0][1] = 1\n# for i in range(n - 1):\n#     for j in range(1 << n):\n#         if dp[i][j] == 0:\n#             continue\n#         for k in range(1, n + 1):\n#             if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n#                 continue\n#             dp[i + 1][j | (1 << k)] += dp[i][j]\n# print(dp[n - 1][2 ** n - 1])\n']
2022-04-24 19:39:16.835476 size on output set 8
2022-04-24 19:39:16.835490 num operations 2
2022-04-24 19:39:16.835496 size on input set 1
2022-04-24 19:39:16.835621 using api key kouti
2022-04-24 19:39:29.234226 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\na = [1, 2, 3]\nprint(a[1:3])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    }
  ],
  "created": 1650829156,
  "object": "edit"
}
2022-04-24 19:39:29.234415 fix spelling mistakes 3 ['\n\na = [1, 2, 3]\nprint(a[1:3])\n', '\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n']
2022-04-24 19:39:29.234447 size on output set 3
2022-04-24 19:39:29.234454 size on input set 3
2022-04-24 19:39:29.234606 using api key derek
2022-04-24 19:39:47.491985 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n        ans %= 10 ** 9 + 7\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    N, M = map(int, input().split())\n\n    tree = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n\n        tree[b-1].append(a-1)\n\n    def dfs(v, visited):\n        visited.add(v)\n        for child in tree[v]:\n            if child not in visited:\n                dfs(child, visited)\n\n\n    visited = set()\n    dfs(0, visited)\n\n    if len(visited) != N:\n        print(0)\n        sys.exit()\n\n    ans = 1\n    for i in range(N):\n        if i == 0:\n            continue\n        if len(tree[i]) > 1:\n            ans *= len(tree[i])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\na.sort()\nb.sort()\nc.sort()\nprint(a, b, c)\n"
    }
  ],
  "created": 1650829169,
  "object": "edit"
}
2022-04-24 19:39:47.492201 fix syntax errors 3 ['\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n        ans %= 10 ** 9 + 7\nprint(ans)\n', 'import sys\n\ndef main():\n    N, M = map(int, input().split())\n\n    tree = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n\n        tree[b-1].append(a-1)\n\n    def dfs(v, visited):\n        visited.add(v)\n        for child in tree[v]:\n            if child not in visited:\n                dfs(child, visited)\n\n\n    visited = set()\n    dfs(0, visited)\n\n    if len(visited) != N:\n        print(0)\n        sys.exit()\n\n    ans = 1\n    for i in range(N):\n        if i == 0:\n            continue\n        if len(tree[i]) > 1:\n            ans *= len(tree[i])\n\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\na.sort()\nb.sort()\nc.sort()\nprint(a, b, c)\n']
2022-04-24 19:39:47.492352 using api key soukgp
2022-04-24 19:39:54.888790 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\na = [1, 2, 3, 4, 5, 6]\nprint(a[1:5:2])\n"
    },
    {
      "index": 1,
      "text": "\n\na = [1, 2, 3]\nprint(a[1:3]) \n"
    },
    {
      "index": 2,
      "text": "\n\na = [1, 2, 3]\nprint(a[1:2])\n"
    }
  ],
  "created": 1650829187,
  "object": "edit"
}
2022-04-24 19:39:54.888965 fix syntax errors 3 ['\na = [1, 2, 3, 4, 5, 6]\nprint(a[1:5:2])\n', '\n\na = [1, 2, 3]\nprint(a[1:3]) \n', '\n\na = [1, 2, 3]\nprint(a[1:2])\n']
2022-04-24 19:39:54.889098 using api key derek
2022-04-24 19:40:13.976449 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nN, M = map(int, input().split())\n\ntree = [set() for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].add(b-1)\n    tree[b-1].add(a-1)\n\ndef dfs(v):\n    visited = set()\n    stack = [v]\n    while stack:\n        v = stack.pop()\n        if v in visited:\n            continue\n        visited.add(v)\n        stack.extend(tree[v])\n    return visited\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**6)\n\nN = int(input())\nA = list(map(int, input().split()))\n\nprint(sum(A))\n"
    },
    {
      "index": 2,
      "text": "import sys\n"
    }
  ],
  "created": 1650829194,
  "object": "edit"
}
2022-04-24 19:40:13.976635 fix syntax errors 3 ['import sys\n\nN, M = map(int, input().split())\n\ntree = [set() for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].add(b-1)\n    tree[b-1].add(a-1)\n\ndef dfs(v):\n    visited = set()\n    stack = [v]\n    while stack:\n        v = stack.pop()\n        if v in visited:\n            continue\n        visited.add(v)\n        stack.extend(tree[v])\n    return visited\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**6)\n\nN = int(input())\nA = list(map(int, input().split()))\n\nprint(sum(A))\n', 'import sys\n']
2022-04-24 19:40:13.976771 size on output set 9
