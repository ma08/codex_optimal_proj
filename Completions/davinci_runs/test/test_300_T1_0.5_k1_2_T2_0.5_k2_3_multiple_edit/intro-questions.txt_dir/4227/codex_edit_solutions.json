["import sys\n\nN, M = map(int, input().split())\n\ntree = [set() for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].add(b-1)\n    tree[b-1].add(a-1)\n\ndef dfs(v):\n    visited = set()\n    stack = [v]\n    while stack:\n        v = stack.pop()\n        if v in visited:\n            continue\n        visited.add(v)\n        stack.extend(tree[v])\n    return visited\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n", "\na = [1, 2, 3, 4, 5, 6]\nprint(a[1:5:2])\n", "import sys\n\ndef main():\n    N, M = map(int, input().split())\n\n    tree = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n\n        tree[b-1].append(a-1)\n\n    def dfs(v, visited):\n        visited.add(v)\n        for child in tree[v]:\n            if child not in visited:\n                dfs(child, visited)\n\n\n    visited = set()\n    dfs(0, visited)\n\n    if len(visited) != N:\n        print(0)\n        sys.exit()\n\n    ans = 1\n    for i in range(N):\n        if i == 0:\n            continue\n        if len(tree[i]) > 1:\n            ans *= len(tree[i])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**6)\n\nN = int(input())\nA = list(map(int, input().split()))\n\nprint(sum(A))\n", "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1 << 0] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(n):\n            if j & (1 << k) != 0 or edges[k] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n", "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n\n\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n            continue\n            continue\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndfs(0, -1)\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\na.sort()\nb.sort()\nc.sort()\nprint(a, b, c)\n", "import sys\n", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n", "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << (k - 1)) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n", "\n\na = [1, 2, 3]\nprint(a[1:2])\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\n\ndef dfs(v, p, d):\n    depth[v] = d\n    for u in edges[v]:  # \u96a3\u63a5\u3059\u308b\u9802\u70b9\u3092\u63a2\u7d22\n        if u == p:  # \u89aa\u306f\u63a2\u7d22\u3057\u306a\u3044\n            continue  # \u6b21\u306e\u96a3\u63a5\u3059\u308b\u9802\u70b9\u306b\u9032\u3080\n        dfs(u, v, d + 1)  # \u518d\u5e30\u7684\u306b\u63a2\u7d22\n\n\ndef bfs(s):\n    q = deque([s])  # \u5148\u982d\u304b\u3089\u8981\u7d20\u3092\u53d6\u308a\u51fa\u3059\n    seen = [False] * n\n    seen[s] = True\n    while q:\n        v = q.popleft()\n        for u in edges[v]:\n            if seen[u]:\n                continue\n            seen[u] = True\n            q.append(u)\n\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ndfs(0, -1)\n", "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# dp[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570 \ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << (k - 1)) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n", "\n\na = [1, 2, 3]\nprint(a[1:3]) \n", "\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n        ans %= 10 ** 9 + 7\nprint(ans)\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\ndef bfs(v):\n    que = deque()\n    que.append(v)\n    while que:\n        v = que.popleft()\n        for u in edges[v]:\n            if visited[u]:\n                continue\n            visited[u] = True\n            que.append(u)\n\n    visited[v] = True\ndef dfs(v, p):\n    for u in edges[v]:\n        if u == p:\n        dfs(u, v)\n            continue\n\n\n# n, m = map(int, input().split())\n# edges = [[] for _ in range(n)]\n# for _ in range(m):\n#     a, b = map(int, input().split())\n#     a -= 1\n#     b -= 1\n#     edges[a].append(b)\n#     edges[b].append(a)\n# visited = [False] * n\n\n# visited = [False] * n\n# bfs(0)\n\ndfs(0, -1)\n\n# n, m = map(int, input().split())\n# edges = [[] for _ in range(n)]\n# for _ in range(m):\n#     a, b = map(int, input().split())\n#     a -= 1\n#     b -= 1\n#     edges[a].append(b)\n#     edges[b].append(a)\n\n\n# # DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\n# dp = [[0] * (1 << n) for _ in range(n)]\n# dp[0][1] = 1\n# for i in range(n - 1):\n#     for j in range(1 << n):\n#         if dp[i][j] == 0:\n#             continue\n#         for k in range(1, n + 1):\n#             if j & (1 << k) != 0 or len(edges[k - 1]) == 0:\n#                 continue\n#             dp[i + 1][j | (1 << k)] += dp[i][j]\n# print(dp[n - 1][2 ** n - 1])\n"]