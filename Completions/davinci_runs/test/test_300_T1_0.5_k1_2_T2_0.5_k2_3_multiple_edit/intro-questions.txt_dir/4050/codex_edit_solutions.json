["\n\ndef find_block(a):\n\tn = len(a)\n\td = {}\n\tfor i in range(n):\n\t\tfor j in range(i, n):\n\t\t\ts = sum(a[i:j+1])\n\t\t\tif s not in d:\n\t\t\t\td[s] = [(i, j)]\n\t\t\telse:\n\t\t\t\td[s].append((i, j))\n\tres = []\n\tfor i in range(n):\n\t\tfor j in range(i, n):\n\t\t\ts = sum(a[i:j+1])\n\t\t\tif s in d:\n\t\t\t\tfor l, r in d[s]:\n\t\t\t\t\tif l > j or r < i:\n\t\t\t\t\t\tres.append((i, j))\n\treturn res\n\ndef main():\n\tn = int(input())\n\ta = [int(s) for s in input().split()]\n\tres = find_block(a)\n\tprint(len(res))\n\tfor l, r in res:\n\t\tprint(l+1, r+1)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sums = [0] + [sum(a[:i]) for i in range(1, n + 1)]\n    blocks = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            blocks.append([i, j, sums[j] - sums[i]])\n    blocks.sort(key=lambda x: x[2])\n    blocks.sort(key=lambda x: x[1])\n    res = []\n    while len(blocks) > 0:\n        i = blocks[0][0]\n        j = blocks[0][1]\n        blocks.pop(0)\n        res.append([i, j])\n        for k in range(len(blocks)):\n            if blocks[k][0] < j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i in res:\n        print(i[0] + 1, i[1])\n\nmain()\n", "\n\ndef main():\n    res = []\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sums = [0] + [sum(a[:i]) for i in range(1, n+1)]\n    blocks = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            blocks.append([i, j, sums[j] - sums[i]])\n    blocks.sort(key=lambda x: x[2])\n    blocks.sort(key=lambda x: x[1])\n    while len(blocks) > 0:\n        i = blocks[0][0]\n        j = blocks[0][1]\n        blocks.pop(0)\n        res.append([i, j])\n        for k in range(len(blocks)):\n            if blocks[k][0] < j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i in res:\n        print(i[0] + 1, i[1])\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]#\n    sums = [0]\n    for i in range(n):\n        sums.append(sums[-1] + a[i])\n    sums.append(sums[-1])\n    blocks = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            blocks.append([i, j, sums[j] - sums[i]])\n    blocks.sort(key=lambda x: x[2])\n    blocks.sort(key=lambda x: x[1])\n    res = []\n    while len(blocks) > 0:\n        i = blocks[0][0]\n        j = blocks[0][1]\n        blocks.pop(0)\n        res.append([i, j])\n        for k in range(len(blocks)):\n            if blocks[k][0] < j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i in res:\n        print(i[0] + 1, i[1])\n\nmain()\n", "\n\ndef find_blocks(a):  # O(n^2)\n    n = len(a)\n    d = {}\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j + 1])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    res = []\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j + 1])\n            if s in d:\n                for l, r in d[s]:\n                    if l > j or r < i:\n                        res.append((i, j))\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [int(s) for s in input().split()]\n    res = find_blocks(a)\n    print(len(res))\n    for l, r in res:\n        print(l+1, r+1)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef find_pairs(a):\n    n = len(a)\n    d = {}\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j+1])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    res = []\n    for i in range(n-1):\n        for j in range(i+1, n):\n            s = sum(a[i:j+1])\n            if s in d:\n                for l, r in d[s]:\n                    if l > j or r < i:\n                        res.append((i, j))\n    return res\n\ndef main():\n    n = int(input())\n    a = [int(s) for s in input().split()]\n    res = find_pairs(a)\n    print(len(res))\n    for l, r in res:\n        print(l+1, r+1)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef find_block(a):\n    n = len(a)\n    d = {}\n        s = 0\n        for j in range(i, n):\n            s += a[j]\n            if s not in d:\n                d[s] = [(i, j)]\n            elif d[s][-1][0] < i:\n                d[s].append((i, j))\n    res_set = set()\n    for i in range(n-1):\n        for j in range(i+1, n):\n            s = sum(a[i:j])\n            for l, k in d[s]:\n                if k < i and j < l:\n                    res_set.add((i, j))\n    return list(res_set)\n\n\ndef main():\n    n = int(input().strip())\n    a = [int(s) for s in input().strip().split()]\n    res = find_block(a)\n    print(len(res))\n    for l, r in res:\n        print(l+1, r+1)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sums = [0] + [sum(a[:i]) for i in range(1, n+1)]\n    blocks = []\n    for i in range(n):\n        for j in range(i+1, n+1): \n            blocks.append([i, j, sums[j] - sums[i]])\n    blocks.sort(key=lambda x: x[2])\n    blocks.sort(key=lambda x: x[1])\n    res = []\n    while len(blocks) > 0:\n        i = blocks[0][0]\n        j = blocks[0][1]\n        blocks.pop(0)\n        res.append([i, j])\n        for k in range(len(blocks)):\n            if blocks[k][0] < j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i in res:\n        print(i[0] + 1, i[1])\n\nmain()\n", "\n\ndef find_pairs(a):\n    pass\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef find_blocks(a):  # O(n^2)\n    n = len(a)\n    d = {}\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j + 1])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    res = []\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j + 1])\n            if s in d:\n                for l, r in d[s]:\n                    if l > j or r < i:\n                        res.append((i, j))\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [int(s) for s in input().split()]\n    res = find_blocks(a)\n    print(len(res))\n    for l, r in res:\n        print(l + 1, r + 1)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef find_block(a):\n    n = len(a)\n    d = {}\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j + 1])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    res = []\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j + 1])\n            if s in d:\n                for l, r in d[s]:\n                    if l > j or r < i:\n                        res.append((i, j))\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [int(s) for s in input().split()]\n    res = find_block(a)\n    print(len(res))\n    for l, r in res:\n        print(l + 1, r + 1)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef find_pairs(a):\n    n = len(a)\n    d = {}\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j+1])\n            if s not in d:\n                d[s] = [(i, j)]\n            else:\n                d[s].append((i, j))\n    res = []\n    for i in range(n):\n        for j in range(i, n):\n            s = sum(a[i:j+1])\n            if s in d:\n                for l, r in d[s]:\n                    if l > j or r < i:\n                        res.append((i, j))\n    return res\n\n# def main():\n#     n = int(input())\n#     a = [int(s) for s in input().split()]\n#     res = find_pairs(a)\n#     print(len(res))\n#     for l, r in res:\n#         print(l+1, r+1)\n\n# if __name__ == \"__main__\":\n#     main()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sum = [0]\n    for i in a:\n        sum.append(sum[-1] + i)\n    sum.append(sum[-1])\n    blocks = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            blocks.append([i, j, sum[j] - sum[i]])\n    blocks.sort(key=lambda x: x[2])\n    blocks.sort(key=lambda x: x[1])\n    res = []\n    while len(blocks) > 0:\n        i = blocks[0][0]\n        j = blocks[0][1]\n        blocks.pop(0)\n        res.append([i, j])\n        for k in range(len(blocks)):\n            if blocks[k][0] < j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i in res:\n        print(i[0] + 1, i[1])\n\nmain()\n", "def binarySearch(a, x):\n    left = 0\n    right = len(a) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] == x:\n            return mid\n        elif a[mid] > x:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    n = int(input())\n    a.sort()\n    a = [int(x) for x in input().split()]\n    sums = [0]\n    for i in range(n):\n        sums.append(sums[-1] + a[i])\n    sums.append(sums[-1])\n    blocks = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            blocks.append([i, j, sums[j] - sums[i]])\n    blocks.sort(key=lambda x: x[1])\n    blocks.sort(key=lambda x: x[2])\n    res = []\n    while len(blocks) > 0:\n        i, j, _ = blocks[0]\n        blocks.pop(0)\n        res.append([i+1, j])\n        for k in range(len(blocks)):\n            if blocks[k][1] <= j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i, j in res:\n        print(i, j)\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    sums = [0]\n    for i in a:\n        sums.append(sums[-1] + i)\n    sums.append(sums[-1])\n    blocks = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            blocks.append([i, j, sums[j] - sums[i]])\n    blocks.sort(key=lambda x: x[2])\n    blocks.sort(key=lambda x: x[1])\n    res = []\n    while len(blocks) > 0:\n        i = blocks[0][0]\n        j = blocks[0][1]\n        blocks.pop(0)\n        res.append([i, j])\n        for k in range(len(blocks)):\n            if blocks[k][0] < j:\n                blocks.pop(k)\n                k -= 1\n    print(len(res))\n    for i in res:\n        print(i[0] + 1, i[1])\n\nmain()\n"]