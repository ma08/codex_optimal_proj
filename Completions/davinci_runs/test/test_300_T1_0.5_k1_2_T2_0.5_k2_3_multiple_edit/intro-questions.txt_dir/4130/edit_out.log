2022-04-24 17:36:22.376109 num operations 2
2022-04-24 17:36:22.376119 size on input set 1
2022-04-24 17:36:22.376243 using api key jaanu
2022-04-24 17:36:32.464640 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight we've seen.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is larger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we cannot change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650821782,
  "object": "edit"
}
2022-04-24 17:36:32.464859 fix spelling mistakes 3 ["\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight we've seen.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is larger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we cannot change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-24 17:36:32.464905 size on output set 3
2022-04-24 17:36:32.464912 size on input set 3
2022-04-24 17:36:32.465027 using api key kouti
2022-04-24 17:36:48.447443 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION 1\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n# SOLUTION 2\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\nimport sys\nreadline = sys.stdin.readline\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650821792,
  "object": "edit"
}
2022-04-24 17:36:48.447735 fix syntax errors 3 ["\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION 1\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n# SOLUTION 2\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n)\n\nimport sys\nreadline = sys.stdin.readline\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\nif __name__ == '__main__':\n    main()\n"]
2022-04-24 17:36:48.447924 using api key jaanu
2022-04-24 17:37:01.048679 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight we've seen.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n# SOLUTION\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight we've seen.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# SOLUTION \n# The idea is to sort the weights and then go over them, \n# keeping track of the previous weight we've seen. \n# If we are at a weight that is the same as the previous one, \n# we can increase it by one and then we are sure that it will be \n# different from the previous weight. \n# If we are at a weight that is bigger than the previous one \n# by more than one, we can decrease it by one, and we are sure \n# that it will be different from the previous weight. \n# Otherwise, we can't change the weight at all. \n# We can do this in linear time, so overall complexity is O(n). \n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650821808,
  "object": "edit"
}
2022-04-24 17:37:01.048864 fix syntax errors 3 ["\n\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight we've seen.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n# SOLUTION\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight we've seen.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION \n# The idea is to sort the weights and then go over them, \n# keeping track of the previous weight we've seen. \n# If we are at a weight that is the same as the previous one, \n# we can increase it by one and then we are sure that it will be \n# different from the previous weight. \n# If we are at a weight that is bigger than the previous one \n# by more than one, we can decrease it by one, and we are sure \n# that it will be different from the previous weight. \n# Otherwise, we can't change the weight at all. \n# We can do this in linear time, so overall complexity is O(n). \n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-24 17:37:01.049086 using api key derek
2022-04-24 17:37:12.369358 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION \n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is larger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we cannot change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is larger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we cannot change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n"
    }
  ],
  "created": 1650821821,
  "object": "edit"
}
2022-04-24 17:37:12.369562 fix syntax errors 3 ["\n\n# SOLUTION \n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is larger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we cannot change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is larger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we cannot change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", '\n']
2022-04-24 17:37:12.369599 size on output set 9
2022-04-24 17:37:12.369610 num operations 2
2022-04-24 17:37:12.369615 size on input set 1
2022-04-24 17:37:12.369794 using api key sunu
2022-04-24 17:37:18.949770 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650821832,
  "object": "edit"
}
2022-04-24 17:37:18.950008 fix spelling mistakes 3 ['\n\n#\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-24 17:37:18.950035 size on output set 3
2022-04-24 17:37:18.950042 size on input set 3
2022-04-24 17:37:18.950167 using api key jaanu
2022-04-24 17:37:28.607093 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input()) \na = list(map(int, input().split())) \na.sort() \ncount = 1 \nfor i in range(1, n): \n    if a[i] != a[i-1]: \n        count += 1 \nprint(count) \n"
    }
  ],
  "created": 1650821838,
  "object": "edit"
}
2022-04-24 17:37:28.607267 fix syntax errors 3 ['\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input()) \na = list(map(int, input().split())) \na.sort() \ncount = 1 \nfor i in range(1, n): \n    if a[i] != a[i-1]: \n        count += 1 \nprint(count) \n']
2022-04-24 17:37:28.607412 using api key kouti
2022-04-24 17:37:35.536380 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# \n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n#\n#\n\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650821848,
  "object": "edit"
}
2022-04-24 17:37:35.536568 fix syntax errors 3 ['\n\n# \n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\n#\n#\n\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-24 17:37:35.536778 using api key sunu
2022-04-24 17:37:50.815571 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "n = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "'''\nn = int(input())\na = list(map(int, input().split()))\n'''\na = [1, 2, 3, 2, 1, 2, 3]\nn = len(a)\n\na.sort() # [1, 1, 2, 2, 2, 3, 3]\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input())\na = list(map(int, input().split())) \n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650821855,
  "object": "edit"
}
2022-04-24 17:37:50.815754 fix syntax errors 3 ['n = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', "'''\nn = int(input())\na = list(map(int, input().split()))\n'''\na = [1, 2, 3, 2, 1, 2, 3]\nn = len(a)\n\na.sort() # [1, 1, 2, 2, 2, 3, 3]\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n", '\nn = int(input())\na = list(map(int, input().split())) \n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-24 17:37:50.815779 size on output set 8
