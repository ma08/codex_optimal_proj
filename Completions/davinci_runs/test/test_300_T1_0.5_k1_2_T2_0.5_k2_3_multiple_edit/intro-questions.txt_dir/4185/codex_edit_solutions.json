["\ndef get_min_moves(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j + 1:\n                moves += 1\n    return moves\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix))\n", "\ndef get_min_moves(matrix):\n    n, m = len(matrix), len(matrix[0])\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j + 1:\n                moves += 1\n    return moves\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix))\n", "\ndef get_min_moves(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j + 1:\n                moves += 1\n    return moves\n\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix))\n", "\n# fix syntax errors\n\ndef get_min_moves(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j + 1:\n                moves += 1\n    return moves\n\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix))\n", "def get_min_moves(matrix):\n    n = len(matrix)  # num rows\n    m = len(matrix[0])  # num cols\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j + 1:  # if not in place\n                moves += 1\n    return moves\n\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix))\n", "def get_min_moves(matrix, n, m):\n    # n = len(matrix)\n    # m = len(matrix[0])\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j:\n                moves += 1\n    return moves\n\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix, n, m))\n", "def get_min_moves(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != (i * m) + j + 1:\n                moves += 1\n    return moves\n\n\nif __name__ == \"__main__\":\n    n, m = list(map(int, input().split()))\n\n\ndef solution(A):\n    n = len(A)\n    if n == 0:\n        return -1\n    if n == 1:\n        return 0\n\n    peaks = []\n    for i in range(1, n - 1):\n        if A[i - 1] < A[i] > A[i + 1]:\n            peaks.append(i)\n\n    if len(peaks) == 0:\n        return 0\n\n    for size in range(len(peaks), 0, -1):\n        if n % size == 0:\n            block_size = n // size\n            found = [False] * size\n            found_cnt = 0\n            for peak in peaks:\n                block_index = peak // block_size\n                if found[block_index] == False:\n                    found[block_index] = True\n                    found_cnt += 1\n\n            if found_cnt == size:\n                return size\n\n    return 0\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n\n    print(get_min_moves(matrix))\n"]