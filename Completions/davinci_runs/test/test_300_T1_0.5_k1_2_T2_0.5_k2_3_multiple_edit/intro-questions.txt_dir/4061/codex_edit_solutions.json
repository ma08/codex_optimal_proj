["\n\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp)) \n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subsequence(string, subseq):\n    if not subseq:\n        return True\n    i = 0\n    for c in string:\n        if c == subseq[i]:\n            i += 1\n            if i == len(subseq):\n                return True\n    return False\n\ndef solve(string, subseq):\n    start = 0\n    end = len(string)\n    while start < end:\n        mid = (start + end) // 2\n        if subsequence(string[:mid], subseq):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint solve(raw_input(), raw_input())\n", "import sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subSequence(string, sub):\n    if not sub:\n        return True\n    i = 0\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub):\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subSequence(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint(solve(input(), input()))\n", "\n\ndef subSequence(string, sub):\n    if not sub:\n        return True\n    i = 0\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub):\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) // 2\n        if subSequence(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint(solve(input(), input()))\n", "\"\"\"\nWe can note that for each character in s, we can either keep it or remove it. \nWe can keep it if it is in t. \nWe can remove it if it is not in t (or if we have already removed it). \nThis leads to a simple dp solution. \nWe keep a list of the length of the longest possible substring we can remove ending at each index in s. \n\"\"\"\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subSequence(string, sub):\n    if sub == '':\n        return True\n    i = 0\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub):\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0\n    end = len(string) - 1\n    while start != end:\n        mid = (start + end) // 2\n        if subSequence(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end - 1\n\nprint solve(raw_input(), raw_input())\n", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it. We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it). This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subsequence(string, sub_string):\n    if not sub_string:\n        return True\n    i = 0\n    for c in string:\n        if c == sub_string[i]:\n            i += 1\n            if i == len(sub_string):\n                return True\n    return False\n\ndef solve(string, sub_string):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string[:mid], sub_string):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint solve(raw_input(), raw_input())\n", "\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    print(s)\n    print(t)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subsequence(string, subseq):\n    if not subseq:\n        return True\n    i = 0\n    for c in string:\n        if c == subseq[i]:\n            i += 1\n            if i == len(subseq):\n                return True\n    return False\n\ndef solve(string, subseq):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string[:mid], subseq):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint(solve(input(), input()))\n", "\n\n\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove\n    it. We can keep it if it is in t. We can remove it if it is not in t (or if\n    we have already removed it). This leads to a simple dp solution. We keep a\n    list of the length of the longest possible substring we can remove ending at\n    each index in s\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subsequence(string, sub_string):\n    if not sub_string:\n        return True\n    i = 0\n    for c in string:\n        if c == sub_string[i]:\n            i += 1\n            if i == len(sub_string):\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint solve(raw_input(), raw_input())\n", "import sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it. \n    We can keep it if it is in t. \n    We can remove it if it is not in t (or if we have already removed it). \n    This leads to a simple dp solution. \n    We keep a list of the length of the longest possible substring we can remove ending at each index in s. \n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n"]