2022-04-24 19:52:25.663335 num operations 2
2022-04-24 19:52:25.663345 size on input set 1
2022-04-24 19:52:25.663455 using api key kouti
2022-04-24 19:52:35.149686 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\n    return(f.readline().split())\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650829945,
  "object": "edit"
}
2022-04-24 19:52:35.149966 fix spelling mistakes 3 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\n    return(f.readline().split())\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-24 19:52:35.150135 size on output set 3
2022-04-24 19:52:35.150145 size on input set 3
2022-04-24 19:52:35.150278 using api key sunu
2022-04-24 19:52:42.367139 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1),end='')\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(f.readline())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 2,
      "text": "\n#fix syntax errors\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650829955,
  "object": "edit"
}
2022-04-24 19:52:42.367351 fix syntax errors 3 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1),end='')\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(f.readline())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n#fix syntax errors\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp(): \n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-24 19:52:42.367632 using api key sunu
2022-04-24 19:52:52.830276 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\nf = sys.stdin\no = sys.stdout\ndef inp():\n    return(int(f.readline()))\n    return(f.readline().split())\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\ndef invr():\n    return(map(int,f.readline().split()))\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(f.readline())\n\n    return(f.readline().split())\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return(f.readline().split())\n\ndef inlr():\n    return list(map(int,f.readline().split()))\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650829962,
  "object": "edit"
}
2022-04-24 19:52:52.830488 fix syntax errors 3 ["\nimport sys\nimport os\nimport heapq\nimport math\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\nf = sys.stdin\no = sys.stdout\ndef inp():\n    return(int(f.readline()))\n    return(f.readline().split())\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\ndef invr():\n    return(map(int,f.readline().split()))\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(f.readline())\n\n    return(f.readline().split())\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return(f.readline().split())\n\ndef inlr():\n    return list(map(int,f.readline().split()))\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-24 19:52:52.830759 using api key derek
2022-04-24 19:53:14.401292 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(f.readline().strip())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef main():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child,path):\n    vis[V] = 1\n    path.append(V)\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child,path)\n\ndef bfs(V,G,vis,parent,child,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        path.append(V)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path_node(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path_node(i,G,vis,path)\n\ndef bfs_path_node(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        path.append(V)\n        for i in G[V]:\n            if vis[i] == 0:\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    path = []\n    dfs(1,G,vis,parent,child,path)\n    #bfs(1,G,vis,parent,child,path)\n    #print(child)\n    vis = [0]*(n+1)\n    path_node = []\n    dfs_path_node(1,G,vis,path_node)\n    #bfs_path_node(1,G,vis,path_node)\n    #print(path)\n    for i in range(len(path_node)-1):\n        if path_node[i+1] in child[path_node[i]]:\n            print('YES')\n            print('1'*(len(path_node)-1))\n            return\n    print('YES')\n    print('0'*(len(path_node)-1),end='')\n    for i in range(1,n+1):\n        if i not in path_node:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1),end='')\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650829972,
  "object": "edit"
}
2022-04-24 19:53:14.401522 fix syntax errors 3 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(f.readline().strip())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef main():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nmain()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child,path):\n    vis[V] = 1\n    path.append(V)\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child,path)\n\ndef bfs(V,G,vis,parent,child,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        path.append(V)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path_node(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path_node(i,G,vis,path)\n\ndef bfs_path_node(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        path.append(V)\n        for i in G[V]:\n            if vis[i] == 0:\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    path = []\n    dfs(1,G,vis,parent,child,path)\n    #bfs(1,G,vis,parent,child,path)\n    #print(child)\n    vis = [0]*(n+1)\n    path_node = []\n    dfs_path_node(1,G,vis,path_node)\n    #bfs_path_node(1,G,vis,path_node)\n    #print(path)\n    for i in range(len(path_node)-1):\n        if path_node[i+1] in child[path_node[i]]:\n            print('YES')\n            print('1'*(len(path_node)-1))\n            return\n    print('YES')\n    print('0'*(len(path_node)-1),end='')\n    for i in range(1,n+1):\n        if i not in path_node:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1),end='')\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-24 19:53:14.401707 size on output set 9
2022-04-24 19:53:14.401723 num operations 2
2022-04-24 19:53:14.401729 size on input set 1
2022-04-24 19:53:14.401863 using api key sunu
2022-04-24 19:53:22.585817 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650829994,
  "object": "edit"
}
2022-04-24 19:53:22.586009 fix spelling mistakes 3 ['\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-24 19:53:22.586155 size on output set 3
2022-04-24 19:53:22.586164 size on input set 3
2022-04-24 19:53:22.586285 using api key derek
2022-04-24 19:53:30.928175 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(2, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(2, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(2, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n        print()\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650830002,
  "object": "edit"
}
2022-04-24 19:53:30.928383 fix syntax errors 3 ['\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(2, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(2, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(2, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n        print()\nif __name__ == "__main__":\n    solve()\n']
2022-04-24 19:53:30.928629 using api key sunu
2022-04-24 19:53:38.133691 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            print(\"NO\")\n            return \n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return \n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            print(\"NO\")\n            return \n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650830010,
  "object": "edit"
}
2022-04-24 19:53:38.133908 fix syntax errors 3 ['\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            print("NO")\n            return \n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return \n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            print("NO")\n            return \n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-24 19:53:38.134177 using api key kouti
2022-04-24 19:53:45.762028 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            print(\"NO\")\n            return \n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 2,
      "text": "import sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650830018,
  "object": "edit"
}
2022-04-24 19:53:45.762261 fix syntax errors 3 ['\n\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            print("NO")\n            return \n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', 'import sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic (tree) and connected, then it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-24 19:53:45.762391 size on output set 9
