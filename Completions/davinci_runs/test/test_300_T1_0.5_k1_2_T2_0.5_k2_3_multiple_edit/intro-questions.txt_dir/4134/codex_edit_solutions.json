["\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n\n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n\n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x ^ grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x ^ grid[i-1][j-1]] += dp[i][j-1][x]\n\n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\n#\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]%k] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][(x^grid[i-1][j-1])%k] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][(x^grid[i-1][j-1])%k] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\ndef solve(n, m, k, grid, dp):\n    return dp\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    max_value = -1\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] + k\n            max_value = max(max_value, dp[i][j])\n    print(max_value)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, grid, start, end):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    start = tuple(map(int, input().split()))\n    end = tuple(map(int, input().split()))\n    print(solve(n, m, grid, start, end))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, k, grid, start, end, dirs):\n    return\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    start = tuple(map(int, input().split()))\n    end = tuple(map(int, input().split()))\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    print(solve(n, m, k, grid, start, end, dirs))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, k, mat):\n    return 1\n\ndef main():\n    n, m, k = map(int, input().split())\n    mat = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, mat))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef solve(n, m, k, grid, dp):\n    return dp\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[-1 for _ in range(m)] for _ in range(n)]\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    max_value = -1\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n            max_value = max(max_value, dp[i][j])\n    print(max_value, file=sys.stderr)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n\n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n\n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n\n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\ndef solve(n, m, k, grid):\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    max_value = -1\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n            max_value = max(max_value, dp[i][j])\n    return max_value\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n#\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-2][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-2]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\n\ndef solve(n, m, k, mat):\n    return 0;\n\ndef main():\n    n, m, k = map(int, input().split());\n    mat = [list(map(int, input().split())) for _ in range(n)];\n    print(solve(n, m, k, mat));\n\nif __name__ == '__main__':\n    main();\n", "\n\ndef solve(n, m, k, mat, r, c):\n    if n == 1 and m == 1:\n        return 0\n    if r == n - 1 and c == m - 1:\n        return 0\n    if r == n - 1:\n        return solve(n, m, k, mat, r, c + 1)\n    if c == m - 1:\n        return solve(n, m, k, mat, r + 1, c)\n    if mat[r + 1][c] > mat[r][c + 1]:\n        return 1 + solve(n, m, k, mat, r, c + 1)\n    else:\n        return 1 + solve(n, m, k, mat, r + 1, c)\n\ndef main():\n    n, m, k = map(int, input().split())\n    mat = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, mat, 0, 0))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\n# Solution by Andrew Xing.\n\ndef main():\n\n  n, m, k = [int(x) for x in raw_input().split()]\n  grid = [[int(x) for x in raw_input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\n\ndef solve(n, m, k, grid, start, end, p, q):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    start = tuple(map(int, input().split()))\n    end = tuple(map(int, input().split()))\n    p, q = map(int, input().split())\n    print(solve(n, m, k, grid, start, end, p, q))\n\nif __name__ == '__main__':\n    main()\n"]