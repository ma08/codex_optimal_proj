2022-04-24 14:42:46.918185 num operations 2
2022-04-24 14:42:46.918203 size on input set 1
2022-04-24 14:42:46.918357 using api key sunu
2022-04-24 14:43:00.808429 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\" * len(l))\n    else:\n        print(len(r))\n        print(\"R\" * len(r))\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] > left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] > right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] <= left[-1] and a[right_index] <= right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print(\"L\"*len(left))\n    else:\n        print(len(right))\n        print(\"R\"*len(right))\n"
    },
    {
      "index": 2,
      "text": "\n\n\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    }
  ],
  "created": 1650811367,
  "object": "edit"
}
2022-04-24 14:43:00.808638 fix spelling mistakes 3 ['\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L" * len(l))\n    else:\n        print(len(r))\n        print("R" * len(r))\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] > left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] > right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] <= left[-1] and a[right_index] <= right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print("L"*len(left))\n    else:\n        print(len(right))\n        print("R"*len(right))\n', '\n\n\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n']
2022-04-24 14:43:00.808676 size on output set 3
2022-04-24 14:43:00.808683 size on input set 3
2022-04-24 14:43:00.808798 using api key derek
2022-04-24 14:43:12.811996 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] > left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] > right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] <= left[-1] and a[right_index] <= right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print(\"L\"*len(left))\n    else:\n        print(len(right))\n        print(\"R\"*len(right))\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] >= left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] >= right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] < left[-1] and a[right_index] < right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print(\"L\"*len(left))\n    else:\n        print(len(right))\n        print(\"R\"*len(right))\n"
    },
    {
      "index": 2,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] > left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] > right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] <= left[-1] and a[right_index] <= right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print(\"L\"*len(left))\n    else:\n        print(len(right))\n        print(\"R\"*len(right))\n"
    }
  ],
  "created": 1650811381,
  "object": "edit"
}
2022-04-24 14:43:12.812221 fix syntax errors 3 ['\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] > left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] > right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] <= left[-1] and a[right_index] <= right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print("L"*len(left))\n    else:\n        print(len(right))\n        print("R"*len(right))\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] >= left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] >= right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] < left[-1] and a[right_index] < right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print("L"*len(left))\n    else:\n        print(len(right))\n        print("R"*len(right))\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    left = [a[0]]\n    right = [a[n-1]]\n    left_index = 1\n    right_index = n-2\n    while left_index < right_index:\n        if a[left_index] > left[-1]:\n            left.append(a[left_index])\n            left_index += 1\n        if a[right_index] > right[-1]:\n            right.append(a[right_index])\n            right_index -= 1\n        if a[left_index] <= left[-1] and a[right_index] <= right[-1]:\n            break\n    if len(left) > len(right):\n        print(len(left))\n        print("L"*len(left))\n    else:\n        print(len(right))\n        print("R"*len(right))\n']
2022-04-24 14:43:12.812529 using api key jaanu
2022-04-24 14:43:19.957710 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# https://codeforces.com/problemset/problem/1335/B\n\n\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 1,
      "text": "\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 2,
      "text": "\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    }
  ],
  "created": 1650811393,
  "object": "edit"
}
2022-04-24 14:43:19.957892 fix syntax errors 3 ['# https://codeforces.com/problemset/problem/1335/B\n\n\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n']
2022-04-24 14:43:19.958037 using api key kouti
2022-04-24 14:43:32.466176 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i <= r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\" * len(l))\n    else:\n        print(len(r))\n        print(\"R\" * len(r))\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1, \"R\")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l), \"L\" * len(l))\n    else:\n        print(len(r))\n        print(\"R\" * len(r))\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0], a[1]]\n    r = [a[n - 1], a[n - 2]]\n    l_i = 2\n    r_i = n - 3\n    while l_i <= r_i:\n        if a[l_i] >= l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] >= r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] < l[-1] and a[r_i] < r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\" * len(l))\n    else:\n        print(len(r))\n        print(\"R\" * len(r))\n"
    }
  ],
  "created": 1650811400,
  "object": "edit"
}
2022-04-24 14:43:32.466361 fix syntax errors 3 ['\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i <= r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L" * len(l))\n    else:\n        print(len(r))\n        print("R" * len(r))\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1, "R")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l), "L" * len(l))\n    else:\n        print(len(r))\n        print("R" * len(r))\n', '\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0], a[1]]\n    r = [a[n - 1], a[n - 2]]\n    l_i = 2\n    r_i = n - 3\n    while l_i <= r_i:\n        if a[l_i] >= l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] >= r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] < l[-1] and a[r_i] < r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L" * len(l))\n    else:\n        print(len(r))\n        print("R" * len(r))\n']
2022-04-24 14:43:32.466398 size on output set 9
2022-04-24 14:43:32.466410 num operations 2
2022-04-24 14:43:32.466415 size on input set 1
2022-04-24 14:43:32.466546 using api key sunu
2022-04-24 14:43:39.731687 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 1,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 2,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    }
  ],
  "created": 1650811412,
  "object": "edit"
}
2022-04-24 14:43:39.732010 fix spelling mistakes 3 ['\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n']
2022-04-24 14:43:39.732148 size on output set 1
2022-04-24 14:43:39.732158 size on input set 1
2022-04-24 14:43:39.732287 using api key sunu
2022-04-24 14:43:54.925189 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 1,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \tthe stack will be empty and we can add the new element to the stack.\n# If we take the last element from the left,\n# \tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n# If we take the last element from the left,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 2,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in d):\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    }
  ],
  "created": 1650811419,
  "object": "edit"
}
2022-04-24 14:43:54.925488 fix syntax errors 3 ['\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \tthe stack will be empty and we can add the new element to the stack.\n# If we take the last element from the left,\n# \tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n# If we take the last element from the left,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in d):\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n']
2022-04-24 14:43:54.925609 size on output set 3
