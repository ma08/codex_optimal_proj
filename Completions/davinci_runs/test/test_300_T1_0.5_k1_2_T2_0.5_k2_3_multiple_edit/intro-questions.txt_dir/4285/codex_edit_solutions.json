["\nimport collections\nimport sys, re\nimport math\nfrom collections import defaultdict\nfrom collections import deque\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom itertools import accumulate\nfrom operator import itemgetter\nfrom functools import reduce\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom bisect import bisect\nfrom heapq import heappop\nfrom heapq import heappush\nfrom heapq import heapify\nfrom queue import deque\nfrom math import ceil\nfrom math import floor\nfrom math import sqrt\nfrom copy import deepcopy\nimport numpy as np\nimport scipy as sp\nimport math\nimport sys\nsys.setrecursionlimit(10**9)\nmod = 10**9+7\nINF = 10**19\n# input = sys.stdin.readline\ndef inp(): return int(input())\ndef inp_list(): return list(map(int, input().split()))\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\ndef lcm_list(nums): return reduce(lcm, nums, 1)\ndef gcd_list(nums): return reduce(gcd, nums, nums[0])\ndef gcd(x, y): return math.gcd(x, y)\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\ndef lcm(a,b): return (a*b)/gcd(a,b)\nsys.setrecursionlimit(10**6)\n \nS = input()\n \n \ndef main():\n    for i in range(len(S)):\n        if S[i] == '?':\n            if S[i-1] == 'P':\n                S = S[:i] + 'D' + S[i+1:]\n            elif S[i-1] == 'D':\n                S = S[:i] + 'P' + S[i+1:]\n            else:\n                S = S[:i] + 'D' + S[i+1:]\n    print(S)\n \nif __name__ == '__main__':\n    main()\n", "# https://atcoder.jp/contests/abc156/tasks/abc156_d\n\n\n\ndef solve(n, s):\n    \"\"\"\n    >>> solve(6, 'ac?b?c')\n    24\n    >>> solve(7, '???????')\n    2835\n    >>> solve(9, 'cccbbbaaa')\n    0\n    >>> solve(5, 'a???c')\n    46\n    \"\"\"\n    mod = int(1e9 + 7)\n    # dp[i][j] : number of subsequences ending at index i with character j\n    dp = [[0] * 3 for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(3):\n            if s[i - 1] == '?':\n                for k in range(3):\n                    dp[i][k] += dp[i - 1][j]\n            elif 'a' <= s[i - 1] <= 'c':\n                dp[i][ord(s[i - 1]) - ord('a')] += dp[i - 1][j]\n        for j in range(3):\n            dp[i][j] %= mod\n    return sum(dp[n]) % mod\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    print('Hello, world!')\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    # read lines\n    lines = [line.strip() for line in sys.stdin]\n\n    # count number of a, b, c, ?\n    na = s.count('a')\n    nb = s.count('b')\n    nc = s.count('c')\n    nq = s.count('?')\n\n    # if there are no ? in s, check if there is a subsequence abc\n    if nq == 0:\n        if 'abc' in s:\n            print(1)\n        else:\n            print(0)\n        return\n\n    # if there are no a, b, c in s, count number of subsequences abc\n    if na == 0 and nb == 0 and nc == 0:\n        print(3 ** nq)\n        return\n\n    # prepare a list of possible positions of ?\n    qs = [i for i in range(n) if s[i] == '?']\n\n    # count number of subsequences abc\n    count = 0\n\n    for i in range(3 ** nq):\n        # replace ? with a, b, c\n        t = s\n        for j, q in enumerate(qs):\n            t = t[:q] + 'abc'[i // (3 ** (nq - j - 1)) % 3] + t[q + 1:]\n\n        # count number of subsequences abc\n        if 'abc' in t:\n            count += 1\n\n    # print result\n    print(count)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    # read number of chars\n    n = int(sys.stdin.readline())\n    # read chars\n    s = sys.stdin.readline().strip()\n\n    # count number of a, b, c, ?\n    na = s.count('a')\n    nb = s.count('b')\n    nc = s.count('c')\n    nq = s.count('?')\n\n    # if there are no ? in s, check if there is a subsequence abc\n    if nq == 0:\n        if 'abc' in s:\n            print(1)\n        else:\n            print(0)\n        return\n\n    # if there are no a, b, c in s, count number of subsequences\n    if na == 0 and nb == 0 and nc == 0:\n        print(3 ** nq)\n        return\n\n    # prepare a list of possible positions of ?\n    qs = [i for i in range(n) if s[i] == '?']\n\n    # count number of subsequences\n    count = 0\n\n    for i in range(3 ** nq):\n        # replace ? with a, b, c\n        t = s\n        for j, q in enumerate(qs):\n            t = t[:q] + 'abc'[i // (3 ** (nq - j - 1)) % 3] + t[q + 1:]\n\n        # count number of subsequences abc\n        if 'abc' in t:\n            count += 1\n\n    # print result\n    print(count)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    # read number of chars\n    n = int(sys.stdin.readline())\n    # read chars\n    s = sys.stdin.readline().strip()\n\n    # count number of a, b, c, ?\n    na = s.count('a')\n    nb = s.count('b')\n    nc = s.count('c')\n    nq = s.count('?')\n\n    # if there are no ? in s, check if there is a subsequence abc\n    if nq == 0:\n        if 'abc' in s:\n            print(1)\n        else:\n            print(0)\n        return\n\n    # if there are no a, b, c in s, count number of subsequences\n    if na == 0 and nb == 0 and nc == 0:\n        print(3 ** nq)\n        return\n\n    # prepare a list of possible positions of ?\n    qs = [i for i in range(n) if s[i] == '?']\n\n    # count number of subsequences\n    count = 0\n\n    for i in range(3 ** nq):\n        # replace ? with a, b, c\n        t = s\n        for j, q in enumerate(qs):\n            t = t[:q] + 'abc'[i // (3 ** (nq - j - 1)) % 3] + t[q + 1:]\n\n        # count number of subsequences abc\n        if 'abc' in t:\n            count += 1\n\n    # print result\n    print(count)\n\nif __name__ == '__main__':\n    main()\n", "# https://atcoder.jp/contests/abc119/tasks/abc119_d\n# https://atcoder.jp/contests/abc119/submissions/4340376\n\nimport sys\n\ndef main():\n    # read A, B, Q\n    A, B, Q = [int(x) for x in sys.stdin.readline().split()]\n\n    # read S\n    S = [int(x) for x in sys.stdin.readline().split()]\n    S.sort()\n    S.insert(0, -10 ** 18 - 1)\n    S.append(10 ** 18 + 1)\n\n    # read T\n    T = [int(x) for x in sys.stdin.readline().split()]\n    T.sort()\n    T.insert(0, -10 ** 18 - 1)\n    T.append(10 ** 18 + 1)\n\n    # read X\n    X = [int(x) for x in sys.stdin.readline().split()]\n\n    # calculate distances\n    for x in X:\n        # find closest points in S and T\n        s = bisect.bisect_right(S, x)\n        t = bisect.bisect_right(T, x)\n\n        # calculate distances\n        d = 10 ** 18\n        for s1 in [S[s - 1], S[s]]:\n            for t1 in [T[t - 1], T[t]]:\n                d = min(d, abs(x - s1) + abs(s1 - t1))\n        for t1 in [T[t - 1], T[t]]:\n            for s1 in [S[s - 1], S[s]]:\n                d = min(d, abs(x - t1) + abs(t1 - s1))\n\n        # print result\n        print(d)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nimport sys\n\ndef main():\n    # read number of chars\n    n = int(sys.stdin.readline())\n    # read chars\n    s = sys.stdin.readline().strip()\n\n    # count number of a, b, c, ?\n    na = s.count('a')\n    nb = s.count('b')\n    nc = s.count('c')\n    nq = s.count('?')\n\n    # if there are no ? in s, check if there is a subsequence abc\n    if nq == 0:\n        if 'abc' in s:\n            print(1)\n        else:\n            print(0)\n        return\n\n    # if there are no a, b, c in s, count number of subsequences\n    if na == 0 and nb == 0 and nc == 0:\n        print(3 ** nq)\n        return\n\n    # prepare a list of possible positions of ?\n    qs = [i for i in range(n) if s[i] == '?']\n\n    # count number of subsequences\n    count = 0\n\n    for i in range(3 ** nq):\n        # replace ? with a, b, c\n        t = s\n        for j, q in enumerate(qs):\n            t = t[:q] + 'abc'[i // (3 ** (nq - j - 1)) % 3] + t[q + 1:]\n\n        # count number of subsequences abc\n        if 'abc' in t:\n            count += 1\n\n    # print result\n    print(count)\n\nif __name__ == '__main__':\n    main()\n", "\ndef solve(n, s):\n    \"\"\"\n    >>> solve(6, 'ac?b?c')\n    24\n    >>> solve(7, '???????')\n    2835\n    >>> solve(9, 'cccbbbaaa')\n    0\n    >>> solve(5, 'a???c')\n    46\n    \"\"\"\n    mod = int(1e9 + 7)\n    # dp[i][j] : number of substrings ending at index i with character j\n    dp = [[0] * 3 for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(3):\n            if s[i - 1] == '?':\n                for k in range(3):\n                    dp[i][k] += dp[i - 1][j]\n            elif 'a' <= s[i - 1] <= 'c':\n                dp[i][ord(s[i - 1]) - ord('a')] += dp[i - 1][j]\n        for j in range(3):\n            dp[i][j] %= mod\n    return sum(dp[n]) % mod\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n", "\n# https://atcoder.jp/contests/abc156/tasks/abc156_d\ndef solve(n, s):\n    \"\"\"\n    >>> solve(6, 'ac?b?c')\n    24\n    >>> solve(7, '???????')\n    2835\n    >>> solve(9, 'cccbbbaaa')\n    0\n    >>> solve(5, 'a???c')\n    46\n    \"\"\"\n    mod = int(1e9 + 7)\n    # dp[i][j] : number of subsequences ending at index i with character j\n    dp = [[0] * 3 for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(3):\n            if s[i - 1] == '?':\n                for k in range(3):\n                    dp[i][k] += dp[i - 1][j]\n            elif 'a' <= s[i - 1] <= 'c':\n                dp[i][ord(s[i - 1]) - ord('a')] += dp[i - 1][j]\n        for j in range(3):\n            dp[i][j] %= mod\n    return sum(dp[n]) % mod\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n", "\n#\n\n#\ndef solve(n, s):\n    \"\"\"\n    >>> solve(6, 'ac?b?c')\n    24\n    >>> solve(7, '???????')\n    2835\n    >>> solve(9, 'cccbbbaaa')\n    0\n    >>> solve(5, 'a???c')\n    46\n    \"\"\"\n    mod = int(1e9 + 7)\n    # dp[i][j] : number of substrings ending at index i with character j\n    dp = [[0] * 3 for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(3):\n            if s[i - 1] == '?':\n                for k in range(3):\n                    dp[i][k] += dp[i - 1][j]\n            elif 'a' <= s[i - 1] <= 'c':\n                dp[i][ord(s[i - 1]) - ord('a')] += dp[i - 1][j]\n        for j in range(3):\n            dp[i][j] %= mod\n    return sum(dp[n]) % mod\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n", "\n\n# https://atcoder.jp/contests/abc156/tasks/abc156_d\ndef solve(n, s):\n    \"\"\"\n    >>> solve(6, 'ac?b?c')\n    24\n    >>> solve(7, '???????')\n    2835\n    >>> solve(9, 'cccbbbaaa')\n    0\n    >>> solve(5, 'a???c')\n    46\n    \"\"\"\n    mod = int(1e9 + 7)\n    # dp[i][j] : number of subsequences ending at index i with character j\n    dp = [[0] * 3 for _ in range(n + 1)]  # noqa: E741\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(3):\n            if s[i - 1] == '?':\n                for k in range(3):\n                    dp[i][k] += dp[i - 1][j]\n            elif 'a' <= s[i - 1] <= 'c':\n                dp[i][ord(s[i - 1]) - ord('a')] += dp[i - 1][j]\n        for j in range(3):\n            dp[i][j] %= mod\n    return sum(dp[n]) % mod\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n"]