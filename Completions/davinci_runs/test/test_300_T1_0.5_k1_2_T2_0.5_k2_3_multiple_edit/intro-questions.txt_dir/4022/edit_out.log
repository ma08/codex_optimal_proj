2022-04-24 15:04:52.703872 num operations 2
2022-04-24 15:04:52.703890 size on input set 1
2022-04-24 15:04:52.704036 using api key derek
2022-04-24 15:05:00.110755 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution 1 (O(n^2))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2))\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution 1: O(nlogn)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650812692,
  "object": "edit"
}
2022-04-24 15:05:00.110991 fix spelling mistakes 3 ['\n\n# Solution 1 (O(n^2))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2))\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1: O(nlogn)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-24 15:05:00.111038 size on output set 3
2022-04-24 15:05:00.111045 size on input set 3
2022-04-24 15:05:00.111175 using api key kouti
2022-04-24 15:05:07.566843 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n'''\n# Solution 1: O(nlogn)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n'''\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution 1: O(nlogn)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution 1: O(n*log(n))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n*n)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650812700,
  "object": "edit"
}
2022-04-24 15:05:07.567100 fix syntax errors 3 ["\n'''\n# Solution 1: O(nlogn)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n'''\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n", '\n\n# Solution 1: O(nlogn)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1: O(n*log(n))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2: O(n*n)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-24 15:05:07.567259 using api key jaanu
2022-04-24 15:05:15.074706 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution 1 (O(n^2))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2) - time limit)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution 1 (O(n^2)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution 1 (O(n))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2))\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650812707,
  "object": "edit"
}
2022-04-24 15:05:15.074892 fix syntax errors 3 ['\n\n# Solution 1 (O(n^2))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2) - time limit)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1 (O(n^2)\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2)\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1 (O(n))\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2 (O(n^2))\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-24 15:05:15.075057 using api key soukgp
2022-04-24 15:05:28.201938 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - y[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())  # \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u043e \u043f\u0440\u043e\u0431\u0435\u043b\u0443\n    x.append(a)\n    y.append(b)\n\nx.sort()  # \u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:  # \u0435\u0441\u043b\u0438 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u0435\u0442\u0441\u044f \u043d\u0430\u0447\u0430\u043b\u043e \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0430\n        a += 1\n    if y[i] == y[i + 1]:  # \u0435\u0441\u043b\u0438 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0435\u0446 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0430\n        b += 1\n\nif a == n - 1 or b == n - 1:  # \u0435\u0441\u043b\u0438 \u0432\u0441\u0435 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u044b \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\n    print(0)\nelse:\n    print(y[b] - x[a])  # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0434\u043b\u0438\u043d\u043d\u0443 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0430 \u0441 \u0440\u0430\u0437\u043d\u044b\u043c\u0438 \u043a\u043e\u043d\u0446\u0430\u043c\u0438\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[n - 1] - x[0])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650812715,
  "object": "edit"
}
2022-04-24 15:05:28.202228 fix syntax errors 3 ['\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - y[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())  # разделяем по пробелу\n    x.append(a)\n    y.append(b)\n\nx.sort()  # по возрастанию\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:  # если повторяется начало интервала\n        a += 1\n    if y[i] == y[i + 1]:  # если повторяется конец интервала\n        b += 1\n\nif a == n - 1 or b == n - 1:  # если все интервалы совпадаю\n    print(0)\nelse:\n    print(y[b] - x[a])  # выводим длинну интервала с разными концами\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[n - 1] - x[0])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-24 15:05:28.202309 size on output set 9
2022-04-24 15:05:28.202323 num operations 2
2022-04-24 15:05:28.202329 size on input set 1
2022-04-24 15:05:28.202450 using api key derek
2022-04-24 15:06:01.239173 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 1,
      "text": "\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n"
    },
    {
      "index": 2,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the smallest intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the smallest intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the smallest intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# smallest.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nsmallest_intersection = float('inf')\n\nfor l, r in segments:\n    smallest_intersection = min(smallest_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(smallest_intersection)\n"
    }
  ],
  "created": 1650812728,
  "object": "edit"
}
2022-04-24 15:06:01.239438 fix spelling mistakes 3 ["\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n", "\n\n# SOLUTION\n# The problem is to find the segment with the smallest intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the smallest intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the smallest intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# smallest.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nsmallest_intersection = float('inf')\n\nfor l, r in segments:\n    smallest_intersection = min(smallest_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(smallest_intersection)\n"]
2022-04-24 15:06:01.239525 size on output set 3
2022-04-24 15:06:01.239533 size on input set 3
2022-04-24 15:06:01.239649 using api key kouti
2022-04-24 15:06:17.301449 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous segment\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 2,
      "text": "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    }
  ],
  "created": 1650812761,
  "object": "edit"
}
2022-04-24 15:06:17.301772 fix syntax errors 3 ["\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous segment\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If\n# we sort the segments by their left endpoints, we can consider the problem as\n# finding the segment with the least intersection length with the segment\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"]
2022-04-24 15:06:17.301935 using api key kouti
2022-04-24 15:06:39.153737 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n#############################\n# SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n#############################\n# SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n"
    },
    {
      "index": 2,
      "text": "\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n"
    }
  ],
  "created": 1650812777,
  "object": "edit"
}
2022-04-24 15:06:39.154012 fix syntax errors 3 ["\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n", "\n\n# SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n#############################\n# SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n#############################\n# SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n", "\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# #############################\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n"]
2022-04-24 15:06:39.154254 using api key sunu
2022-04-24 15:06:54.689574 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\nheap = [1, 2, 3, 4, 5, 6, 7]\nheapq.heapify(heap)\nprint(heap)\nheapq.heappush(heap, 10)\nprint(heap)\nprint(heapq.heappop(heap))\nprint(heap)\n"
    },
    {
      "index": 1,
      "text": "\n\n#\n"
    },
    {
      "index": 2,
      "text": "\n"
    }
  ],
  "created": 1650812799,
  "object": "edit"
}
2022-04-24 15:06:54.689774 fix syntax errors 3 ['\n\nimport heapq\nheap = [1, 2, 3, 4, 5, 6, 7]\nheapq.heapify(heap)\nprint(heap)\nheapq.heappush(heap, 10)\nprint(heap)\nprint(heapq.heappop(heap))\nprint(heap)\n', '\n\n#\n', '\n']
2022-04-24 15:06:54.689796 size on output set 8
