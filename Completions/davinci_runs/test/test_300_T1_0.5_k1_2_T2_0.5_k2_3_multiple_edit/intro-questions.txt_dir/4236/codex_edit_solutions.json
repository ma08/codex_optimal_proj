["import sys\nsys.stdin = open('input.txt', 'r')\n\nT = int(input())\nfor tc in range(1, T+1):\n    N, M = map(int, input().split())\n    l = [0] * N\n    r = [0] * N\n    for i in range(N):\n        l[i], r[i] = map(int, input().split())\n    left = [0] * (M + 1)\n    right = [0] * (M + 1)\n    for i in range(N):\n        left[l[i]] += 1\n        right[r[i]] += 1\n    counter = 0\n    for i in range(1, M + 1):\n        if left[i] == right[i]:\n            counter += 1\n        elif left[i] > right[i]:\n            print('#{} {}'.format(tc, counter))\n            break\n    else:\n        print('#{} {}'.format(tc, counter))\n", "import sys\nimport math\nimport heapq\n\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for i in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for i2 in range(j)]\ndef dp3(ini, i, j, k): return [[[ini]*i for i2 in range(j)] for i3 in range(k)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\n\n\nn, m = map(int, input().split())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\nsegments.sort(key=lambda x: x[0])\n# print(segments)\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]:\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "\nfrom bisect import bisect_left\n\nn, m = map(int, input().split())\n\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort(key=lambda x: x[0])\n\n# print(segments)\n\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]:\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "\nn, m = map(int, input().split())\nleft = [0] * (m + 2)\nright = [0] * (m + 2)\nfor i in range(n):\n    l, r = map(int, input().split())\n    left[l] += 1\n    right[r] += 1\ncounter = 0\nfor i in range(1, m + 2):\n    if left[i] == right[i]:\n        counter += 1\n    elif left[i] > right[i]:\n        print(counter)\n        break\nelse:\n    print(counter)\n", "n, m = map(int, input().split())\n\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\nsegments.sort(key=lambda x: x[0])\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]:\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "\nn, m = map(int, input().split()) # n = number of lines, m = number of columns\n\nleft = [0] * (m + 1) # left = array of zeros with size of m + 1\nright = [0] * (m + 1) # right = array of zeros with size of m + 1\n\nfor i in range(n):\n    l, r = map(int, input().split()) # l = starting point of line, r = ending point of line\n    left[l] += 1 # increment number of lines that start at index l\n    right[r] += 1 # increment number of lines that end at index r\n\ncounter = 0\nfor i in range(1, m + 1):\n    if left[i] == right[i]:\n        counter += 1\n    elif left[i] > right[i]:\n        print(counter)\n        break\nelse:\n    print(counter)\n", "import sys\n\n\nn, m = map(int, sys.stdin.readline().split())\n\nsegments = []\nfor i in range(n):\n    l, r = map(int, sys.stdin.readline().split())\n    segments.append((l, r))\n\nsegments.sort(key=lambda x: x[0])\n\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]:\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "\n\nimport sys\nsys.stdin = open('input.txt', 'r')\n\nT = int(input())\nfor tc in range(1, T+1):\n    N, M = map(int, input().split())\n    l = [0] * (N + 1)\n    r = [0] * (N + 1)\n    for i in range(N):\n        l[i], r[i] = map(int, input().split())\n    left = [0] * (M)\n    right = [0] * (M)\n    for i in range(N):\n        left[l[i]] += 1\n        right[r[i]] += 1\n    counter = 0\n    for i in range(1, M):\n        if left[i] == right[i]:\n            counter += 1\n        elif left[i] > right[i]:\n            print('#{} {}'.format(tc, counter))\n            break\n    else:\n        print('#{} {}'.format(tc, counter))\n", "\n\nn, m = map(int, input().split())  # n = number of lines, m = number of columns\n\nleft = [0] * (m + 1)  # left = array of zeros with size of m + 1\nright = [0] * (m + 1)  # right = array of zeros with size of m + 1\n\nfor i in range(n):\n    l, r = map(int, input().split())  # l = starting point of line, r = ending point of line\n    left[l] += 1  # increment number of lines that start at index l\n    right[r] += 1  # increment number of lines that end at index r\n\ncounter = 0\nfor i in range(1, m + 1):\n    if left[i] == right[i]:\n        counter += 1\n    elif left[i] > right[i]:\n        print(counter)\n        break\nelse:\n    print(counter)\n", "\nn, m = map(int, input().split())\n\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort(key=lambda x: x[0])\n\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]:\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "\nn, m = map(int, input().split())\n\narr = list(map(int, input().split()))\narr.sort()\n\n# print(arr)\n\nres = [0] * m\n\nfor i in range(n):\n    left, right = arr[i], arr[i] + m - 1\n\n    # print(left, right)\n\n    if left < 0:\n        left = 0\n\n    if right > m - 1:\n        right = m - 1\n\n    res[left] = 1\n    res[right] = -1\n\n\n# print(res)\n\nfor i in range(1, m):\n    res[i] += res[i - 1]\n\n# print(res)\n\nprint(res.count(0))\n", "\n\nimport sys\nsys.stdin = open('input.txt', 'r')\n\nT = int(input())\nfor tc in range(1, T+1):\n    N, M = map(int, input().split())\n    l = [0] * M\n    r = [0] * M\n    for i in range(N):\n        l[i], r[i] = map(int, input().split())\n    left = [0] * (M + 1)\n    right = [0] * (M + 1)\n    for i in range(N):\n        left[l[i]] += 1\n        right[r[i]] += 1\n    counter = 0\n    for i in range(1, M + 1):\n        if left[i] == right[i]:\n            counter += 1\n        elif left[i] > right[i]:\n            print('#{} {}'.format(tc, counter))\n            break\n    else:\n        print('#{} {}'.format(tc, counter))\n", "\n\nn, m = map(int, input().split())\n\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort(key=lambda x: x[0])\n\n# print(segments)\n\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]:  # if i is not a starting or ending point of a segment\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "\n\nn, m = map(int, input().split())\n\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort(key=lambda x: x[0])\n\nprint(segments)\n\nres = []\nfor i in range(1, m + 1):\n    if i not in [seg[0] for seg in segments] and i not in [seg[1] for seg in segments]: # if i is not a starting or ending point of a segment\n        res.append(i)\n\nprint(len(res))\nprint(*res)\n", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na.sort()\nb.sort()\nprint(sum([a[i] * b[i] for i in range(n)]))\n", "\nn, m = map(int, input().split())\n\nleft = [0] * (m + 2)\nright = [0] * (m + 2)\nfor i in range(n):\n    l, r = map(int, input().split())\n    left[l] += 1\n    right[r] += 1\ncounter = 0\nfor i in range(1, m + 2):\n    if left[i] == right[i]:\n        counter += 1\n    elif left[i] > right[i]:\n        print(counter)\n        break\nelse:\n    print(counter)\n"]