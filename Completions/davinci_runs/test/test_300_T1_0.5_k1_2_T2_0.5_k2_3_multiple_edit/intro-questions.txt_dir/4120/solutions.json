["import sys\nimport os\n\nclass Path():\n    def __init__(self, idx, s, d):\n        self.idx = idx\n        self.s = s\n        self.d = d\n\n    def __eq__(self, rhs):\n        return self.s == rhs.s and self.d == rhs.d\n\n    def __hash__(self):\n        return self.s * 100000 + self.d\n\ndef shortestPath(n, k, paths):\n    ps = dict()\n    for p in paths:\n        if p.s not in ps:\n            ps[p.s] = [p]\n        else:\n            ps[p.s].append(p)\n\n        if p.d not in ps:\n            ps[p.d] = [p]\n        else:\n            ps[p.d].append(p)\n\n    d = set()\n    open = set()\n\n    d.add(1)\n    for e in paths:\n        if e.s == 1 or e.d == 1:\n            open.add(e)\n\n    general_edges = []\n    general_choices = []\n    while len(d) < n:\n        newd = set()\n        choices = dict()\n        for e in open:\n            oe = e.s\n            if e.s in d:\n                oe = e.d\n\n            newd.add(oe)\n\n            if oe not in choices:\n                choices[oe] = [e.idx]\n            else:\n                choices[oe].append(e.idx)\n\n        d.update(newd)\n        for oe, p in choices.items():\n            if len(p) > 1:\n                general_choices.append(p)\n            else:\n                general_edges.append(p[0])\n\n        open = set()\n        for node in newd:\n            for p in ps[node]:\n                if (p.s in d) != (p.d in d):\n                    open.add(p)\n\n    maxk = 1\n    for choice in general_choices:\n        maxk *= len(choice)\n\n    k = min(k, maxk)\n    print(k)\n    output = ['0'] * len(paths)\n    for e in general_edges:\n        output[e] = '1'\n    for e in general_choices:\n        output[e[0]] = '1'\n\n    for i in range(k):\n        print(''.join(output))\n\n        for choice in general_choices:\n            done = False\n            for i in range(len(choice) - 1):\n                if output[choice[i]] == '1':\n                    output[choice[i]] = '0'\n                    output[choice[i + 1]] = '1'\n                    done = True\n                    break\n\n            if done:\n                break\n\n            output[choice[len(choice) - 1]] = '0'\n            output[choice[0]] = '1'\n\ndef main():\n    n, m, k = (int(x) for x in input().split())\n    paths = []\n    for i in range(m):\n        path = [int(x) for x in input().split()]\n        paths.append(Path(i, path[0], path[1]))\n    shortestPath(n, k, paths)\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import inf\nimport heapq\n\nn, m, k = map(int, input().split(' '))\n\nedge = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = map(int, input().split(' '))\n    edge[a-1].append((i, b-1))\n    edge[b-1].append((i, a-1))\n\nd = [inf  for _ in range(n)]\nd[0] = 0\n\nq = [0 for _ in range(n)]\nf = 0\nr = 1\nwhile f < r:\n    i = q[f]\n    f += 1\n    for (_, j) in edge[i]:\n        if d[j] == inf:\n            d[j] = d[i]+1\n            q[r] = j\n            r += 1\n\n#print(d)\n\npre = [[] for _ in range(n)]\n\nfor i in range(n):\n    for (ind, j) in edge[i]:\n        if d[j] == d[i]-1:\n            pre[i].append((ind, j))\n\n#print(pre)\n\ns = [0 for _ in range(n)]\ntop = n\nsol = []\nwhile top > 0:\n    #print(top, s)\n    if top == n:\n        u = ['0' for _ in range(m)]\n        #print(s)\n        for i in range(1,n):\n            u[pre[i][s[i]][0]] = '1'\n        sol.append(\"\".join(u))\n        if len(sol) == k:\n            break\n        top -= 1\n    else:\n        s[top] += 1\n        if s[top] == len(pre[top]):\n            top -= 1\n            #s[top] += 1\n        else:\n            top += 1\n            if top < n:\n                s[top] = -1\n\nprint(len(sol))\nfor x in sol:\n    print(x)", "n, m, k = [int(x) for x in input().split()]\nE = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = [int(x) for x in input().split()]\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\n\nQ = [0]\nINFTY = n + 1\nlevels = [INFTY] * n\nlevels[0] = 0\nE_min = [[] for _ in range(n)]\n# bfs\nwhile len(Q) > 0:\n    city = Q.pop(0)\n    for adj, i in E[city]:\n        if levels[city] + 1 <= levels[adj]:\n            if levels[adj] == INFTY:\n                Q.append(adj)\n            levels[adj] = levels[city] + 1\n            E_min[adj].append(i)\n\ndef gen_poss(city, selected, all_poss, next_choice, poss):\n    if len(all_poss) >= k:\n        return\n\n    if poss >= k:\n        all_poss.append(''.join(selected))\n        return\n\n    if city == n:\n        all_poss.append(''.join(selected))\n    else:\n        # choose one from E_min[edge]\n        for i in E_min[city]:\n            selected[i] = '1'\n            next_city = next_choice[city]   # skip edges with only one choice\n            gen_poss(next_city, selected, all_poss, next_choice, poss * len(E_min[city]))\n            selected[i] = '0'\n\n\nnext_choice = [0] * n\nselected = ['0'] * m\nnc = n\nfor i in range(n - 1, -1, -1):\n    next_choice[i] = nc\n    if len(E_min[i]) > 1:\n        nc = i\n    if len(E_min[i]) >= 1:\n        selected[E_min[i][0]] = '1'\nall_poss = []\ngen_poss(next_choice[0], selected, all_poss, next_choice, 1)\n\nprint('{}\\n{}'.format(len(all_poss), '\\n'.join(all_poss)))", "from math import inf\n\nnmk = list(map(int, input().split(' ')))\nn = nmk[0]\nm = nmk[1]\nk = nmk[2]\n\na = []\n\nfor i in range(m):\n\ta.append(list(map(int, input().split(' '))))\n\nsmej = [[] for j in range(n)]\nnums = {}\n\nt = 0\nfor i in a:\n\tnums.update({(i[0], i[1]):t})\n\tt += 1\n\tsmej[i[0]-1].append(i[1]-1)\n\tsmej[i[1]-1].append(i[0]-1)\n\t\ndists = [inf for i in range(n)]\ndists[0] = 0\nq = [0]\n\nwhile len(q) > 0:\n\tu = q.pop(0)\n\t\n\tfor i in smej[u]:\n\t\tif (dists[i] == inf):\n\t\t\tq.append(i)\n\t\t\tdists[i] = dists[u] + 1\n\t\t\t\t\np = [[] for i in range(n)]\n\t\t\t\nfor i in range(1, n):\n\tfor j in smej[i]:\n\t\tif(dists[j] == dists[i]-1):\n\t\t\ttry:\n\t\t\t\tp[i].append(nums[(j+1,i+1)])\n\t\t\texcept:\n\t\t\t\tp[i].append(nums[(i+1,j+1)])\n\nam = 1\np.pop(0)\n\nfor i in range(len(p)):\n\tam *= len(p[i])\n\nif(am < k):\n\tprint(am)\nelse:\n\tprint(k)\n\nf = [0 for i in range(len(p))]\nans = []\n\nfor i in range(k):\n\ts = ['0'for i in range(m)]\n\t\n\tfor j in range(len(p)):\n\t\ts[p[j][f[j]]] = '1'\n\t\n\ts = ''.join(s)\n\tans.append(s)\n\n\tok = False\n\tfirst = True\n\t\n\tfor j in range(len(p)-1, -1, -1):\n\t\tif first:\n\t\t\tfirst = False\n\t\t\tif(f[j]+1 == len(p[j])):\n\t\t\t\tif(j == 0):\n\t\t\t\t\tok = True\n\t\t\t\t\tbreak\n\t\t\t\tf[j] = 0\n\t\t\t\tf[j-1]+= 1\n\t\t\telse:\n\t\t\t\tf[j]+= 1\n\t\t\t\tbreak\n\t\telse:\n\t\t\tif(f[j] == len(p[j])):\n\t\t\t\tif(j == 0):\n\t\t\t\t\tok = True\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tf[j] = 0\n\t\t\t\t\tf[j-1] += 1\n\tif ok:\n\t\tbreak\n\nfor j in range(len(ans)):\n\tprint(ans[j])\n\n\n\n\n\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n", "import sys\ninput=lambda:sys.stdin.readline().rstrip()\nsys.setrecursionlimit(200001)\nn,m,k=list(map(int,input().split()))\nedge=[[]for _ in range(n)]\ndi={}\nfor i in range(m):\n  a,b=list(map(int,input().split()))\n  a-=1\n  b-=1\n  if a>b:a,b=b,a\n  di[(a,b)]=i\n  edge[a].append(b)\n  edge[b].append(a)\nd=[10**10]*n\nd[0]=0\nroot=[set()for _ in range(n)]\nqueue=[0]\nfor node in queue:\n  for mode in edge[node]:\n    if d[mode]!=10**10:\n      if d[mode]+1==d[node]:\n        root[node].add(mode)\n      elif d[mode]==d[node]+1:\n        root[mode].add(node)\n      continue\n    d[mode]=d[node]+1\n    queue.append(mode)\nfor i in range(n):root[i]=list(root[i])\nt=1\nfor i in range(1,n):t*=len(root[i])\nprint(min(t,k))\nfor i in range(min(t,k)):\n  ans=[\"0\"]*m\n  for j in range(1,n):\n    i,jj=divmod(i,len(root[j]))\n    ans[di[(min(j,root[j][jj]),max(j,root[j][jj]))]]=\"1\"\n  print(\"\".join(ans))\n"]