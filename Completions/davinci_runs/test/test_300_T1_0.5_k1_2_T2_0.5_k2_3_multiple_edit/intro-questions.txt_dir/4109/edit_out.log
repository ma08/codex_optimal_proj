2022-04-24 17:07:56.996050 num operations 2
2022-04-24 17:07:56.996070 size on input set 1
2022-04-24 17:07:56.996204 using api key kouti
2022-04-24 17:08:14.933850 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u4f4e\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    }
  ],
  "created": 1650820077,
  "object": "edit"
}
2022-04-24 17:08:14.934059 fix spelling mistakes 3 ['\n\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以上になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も低いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以下であれば、コストの最小値を更新する\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以下になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n']
2022-04-24 17:08:14.934231 size on output set 3
2022-04-24 17:08:14.934242 size on input set 3
2022-04-24 17:08:14.934363 using api key sunu
2022-04-24 17:08:22.552371 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n# \u5168\u63a2\u7d22\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 2,
      "text": "\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    }
  ],
  "created": 1650820094,
  "object": "edit"
}
2022-04-24 17:08:22.552572 fix syntax errors 3 ['\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以上になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n\n# 全探索\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以上になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以上になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n']
2022-04-24 17:08:22.552810 using api key derek
2022-04-24 17:08:29.101166 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u4f4e\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 1,
      "text": "\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u4f4e\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    },
    {
      "index": 2,
      "text": "# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u4f4e\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    }
  ],
  "created": 1650820102,
  "object": "edit"
}
2022-04-24 17:08:29.101369 fix syntax errors 3 ['\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も低いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以下であれば、コストの最小値を更新する\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以下になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も低いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以下であれば、コストの最小値を更新する\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以下になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n', '# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も低いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以下であれば、コストの最小値を更新する\n    if all(x <= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以下になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n']
2022-04-24 17:08:29.101616 using api key sunu
2022-04-24 17:08:45.530623 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nc, *a = map(int, input().split())\nprint(c)\nprint(a)\n"
    },
    {
      "index": 1,
      "text": "\n\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n"
    },
    {
      "index": 2,
      "text": "\n# \u5168\u63a2\u7d22\n# \u5168\u63a2\u7d22\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u306f\u3001\u5404\u66f8\u7c4d\u306e\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0b\u306b\u306a\u308b\u304b\u3069\u3046\u304b\u3067\u5224\u5b9a\u3067\u304d\u308b\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # \u5404\u66f8\u7c4d\u306b\u3064\u3044\u3066\u3001\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u3068\u8cfc\u5165\u3059\u308b\u3001\u7acb\u3063\u3066\u3044\u306a\u3044\u3068\u8cfc\u5165\u3057\u306a\u3044\n    # \u3053\u306e\u6642\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u3064\u3044\u3066\u3001\u8cfc\u5165\u3057\u305f\u66f8\u7c4d\u306e\u5185\u3001\u5404\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\n    # \u3053\u308c\u304cX\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # \u8cfc\u5165\u3059\u308b\u66f8\u7c4d\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u30b3\u30b9\u30c8\u306e\u6700\u5c0f\u5024\u3092\u66f4\u65b0\u3059\u308b\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# \u3059\u3079\u3066\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u30ec\u30d9\u30eb\u304cX\u4ee5\u4e0a\u306b\u306a\u308c\u3070\u3001\u30b3\u30b9\u30c8\u304c\u6700\u5c0f\u5024\u306b\u306a\u308b\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n"
    }
  ],
  "created": 1650820109,
  "object": "edit"
}
2022-04-24 17:08:45.530854 fix syntax errors 3 ['\nc, *a = map(int, input().split())\nprint(c)\nprint(a)\n', '\n\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n', '\n# 全探索\n# 全探索できるかどうかは、各書籍のコストの総和がX以下になるかどうかで判定できる\nN, M, X = map(int, input().split())\nA = []\nC = []\nfor _ in range(N):\n    c, *a = map(int, input().split())\n    A.append(a)\n    C.append(c)\n\nans = 10**10\nfor i in range(1 << N):\n    # 各書籍について、ビットが立っていると購入する、立っていないと購入しない\n    # この時、各アルゴリズムについて、購入した書籍の内、各アルゴリズムのレベルが最も高いものを足し合わせる\n    # これがX以下になればOK\n    cost = 0\n    level = [0] * M\n    for j in range(N):\n        # 購入する書籍\n        if i & (1 << j):\n            cost += C[j]\n            for k in range(M):\n                level[k] = max(level[k], A[j][k])\n    # すべてのアルゴリズムのレベルがX以上であれば、コストの最小値を更新する\n    if all(x >= X for x in level):\n        ans = min(ans, cost)\n\n# すべてのアルゴリズムのレベルがX以上になれば、コストが最小値になる\nif ans == 10**10:\n    print(-1)\nelse:\n    print(ans)\n']
2022-04-24 17:08:45.530902 size on output set 7
2022-04-24 17:08:45.530915 num operations 2
2022-04-24 17:08:45.530921 size on input set 1
2022-04-24 17:08:45.531034 using api key sunu
2022-04-24 17:08:53.247866 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is i\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    }
  ],
  "created": 1650820125,
  "object": "edit"
}
2022-04-24 17:08:53.248113 fix spelling mistakes 3 ['\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is i\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n']
2022-04-24 17:08:53.248165 size on output set 2
2022-04-24 17:08:53.248172 size on input set 2
2022-04-24 17:08:53.248297 using api key soukgp
2022-04-24 17:09:03.918731 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = []\n    A = []\n    for i in range(N):\n        c, *a = map(int, input().split())\n        C.append(c)\n        A.append(a)\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef solve(N, M, X, C, A):  # N: number of books, M: number of algorithms, X: the understanding level required to achieve the goal, C: the cost of each book, A: the level of understanding each algorithm provides\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    }
  ],
  "created": 1650820133,
  "object": "edit"
}
2022-04-24 17:09:03.918932 fix syntax errors 3 ['\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = []\n    A = []\n    for i in range(N):\n        c, *a = map(int, input().split())\n        C.append(c)\n        A.append(a)\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\ndef solve(N, M, X, C, A):  # N: number of books, M: number of algorithms, X: the understanding level required to achieve the goal, C: the cost of each book, A: the level of understanding each algorithm provides\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\n\nimport heapq\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is x\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n']
2022-04-24 17:09:03.919166 using api key derek
2022-04-24 17:09:18.674300 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is i\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is i\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for j in range(1, N + 1):\n        for i in range(M + 1):\n            if i + A[j - 1] <= M:\n                dp[i + A[j - 1]][j] = min(dp[i + A[j - 1]][j], dp[i][j - 1] + C[j - 1])\n            dp[i][j] = min(dp[i][j], dp[i][j - 1])\n    if dp[M][N] >= float('inf'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is j\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[j - 1] <= M:\n                dp[j + A[j - 1]][i] = min(dp[j + A[j - 1]][i], dp[j][i - 1] + C[j - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float('inf') or dp[M][N] > X:\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [0] * N\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())[1:]\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == \"__main__\":\n    test()\n    main()\n"
    }
  ],
  "created": 1650820143,
  "object": "edit"
}
2022-04-24 17:09:18.674498 fix syntax errors 3 ['\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first i books and the understanding level of the j-th algorithm is i\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[i - 1] <= M:\n                dp[j + A[i - 1]][i] = min(dp[j + A[i - 1]][i], dp[j][i - 1] + C[i - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\n\nimport heapq\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is i\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for j in range(1, N + 1):\n        for i in range(M + 1):\n            if i + A[j - 1] <= M:\n                dp[i + A[j - 1]][j] = min(dp[i + A[j - 1]][j], dp[i][j - 1] + C[j - 1])\n            dp[i][j] = min(dp[i][j], dp[i][j - 1])\n    if dp[M][N] >= float(\'inf\'):\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [[0] * M for _ in range(N)]\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n', '\n\n\ndef solve(N, M, X, C, A):\n    # dp[i][j]: the minimum cost to achieve the goal when we have already read the first j books and the understanding level of the i-th algorithm is j\n    dp = [[float(\'inf\')] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 0\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j + A[j - 1] <= M:\n                dp[j + A[j - 1]][i] = min(dp[j + A[j - 1]][i], dp[j][i - 1] + C[j - 1])\n            dp[j][i] = min(dp[j][i], dp[j][i - 1])\n    if dp[M][N] == float(\'inf\') or dp[M][N] > X:\n        return -1\n    return dp[M][N]\n\n\ndef main():\n    N, M, X = map(int, input().split())\n    C = [0] * N\n    A = [0] * N\n    for i in range(N):\n        C[i], *A[i] = map(int, input().split())[1:]\n    print(solve(N, M, X, C, A))\n\n\ndef test():\n    assert solve(3, 2, 10, [10, 2, 5], [[3, 2], [4, 1], [1, 4]]) == 7\n    assert solve(4, 3, 10, [6, 2, 3, 5], [[4, 2, 3], [3, 3, 2], [2, 3, 4], [4, 2, 1]]) == -1\n    assert solve(3, 4, 10, [5, 4, 3], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 12\n    assert solve(1, 1, 10, [100], [[10]]) == 100\n\n\nif __name__ == "__main__":\n    test()\n    main()\n']
2022-04-24 17:09:18.674549 size on output set 6
