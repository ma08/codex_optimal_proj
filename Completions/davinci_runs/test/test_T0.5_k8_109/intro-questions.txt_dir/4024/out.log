2022-04-09 22:46:54.035592 """
The only difference between the easy and the hard versions is constraints.

A subsequence is a string that can be derived from another string by deleting some or no symbols without changing the order of the remaining symbols. Characters to be deleted are not required to go successively, there can be any gaps between them. For example, for the string "abaca" the following strings are subsequences: "abaca", "aba", "aaa", "a" and "" (empty string). But the following strings are not subsequences: "aabaca", "cb" and "bcaa".

You are given a string $s$ consisting of $n$ lowercase Latin letters.

In one move you can take any subsequence $t$ of the given string and add it to the set $S$. The set $S$ can't contain duplicates. This move costs $n - |t|$, where $|t|$ is the length of the added subsequence (i.e. the price equals to the number of the deleted characters).

Your task is to find out the minimum possible total cost to obtain a set $S$ of size $k$ or report that it is impossible to do so.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le n, k \le 100$) — the length of the string and the size of the set, correspondingly.

The second line of the input contains a string $s$ consisting of $n$ lowercase Latin letters.


-----Output-----

Print one integer — if it is impossible to obtain the set $S$ of size $k$, print -1. Otherwise, print the minimum possible total cost to do it.


-----Examples-----
Input
4 5
asdf

Output
4

Input
5 6
aaaaa

Output
15

Input
5 7
aaaaa

Output
-1

Input
10 100
ajihiushda

Output
233



-----Note-----

In the first example we can generate $S$ = { "asdf", "asd", "adf", "asf", "sdf" }. The cost of the first element in $S$ is $0$ and the cost of the others is $1$. So the total cost of $S$ is $4$.
"""
2022-04-09 22:46:54.035614 --------------------------
2022-04-09 22:47:38.912965 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef solve(n, k, s):\n    # Write your code here\n    return -1\n\n\nn, k = [int(i) for i in input().split()]\ns = input()\nout_ = solve(n, k, s)\nprint (out_)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# We can use dynamic programming to solve this problem. Let dp[i][j] be the minimum cost for the first i characters,\n# and j subsequences.\n# The base case is dp[0][0] = 0, because for the empty string, there is no cost to create the first subsequence.\n# The recurrence relation is dp[i][j] = min(dp[i][j], dp[i-k][j-1] + i-k), where k is a subsequence of the first i characters.\n# We can use a binary search to find the maximum length of a subsequence, and then use a prefix sum to find the cost.\n# The time complexity is O(n^2 * log(n)), and the space complexity is O(n^2).\n\nimport sys\nfrom bisect import bisect_right\n\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\ns = input()\n\ndp = [[float('inf') for j in range(k+1)] for i in range(n+1)]\ndp[0][0] = 0\n\nprefix_sum = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = prefix_sum[i-1] + i\n\nfor i in range(1, n+1):\n    for j in range(1, min(i+1, k+1)):\n        dp[i][j] = min(dp[i][j], dp[i-1][j-1] + i)\n        l = 1\n        r = i+1\n        while l < r:\n            m = (l+r) // 2\n            if s[i-m:i] == s[i-m:i-m+m]:\n                l = m+1\n            else:\n                r = m\n            dp[i][j] = min(dp[i][j], dp[i-l][j-1] + (prefix_sum[i] - prefix_sum[i-l]))\n\nif dp[n][k] == float('inf'):\n    print(-1)\nelse:\n    print(dp[n][k])"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn, k = [int(i) for i in input().split()]\ns = input()\n\ndp = [[-1 for i in range(k+1)] for j in range(n+1)]\n\nfor i in range(n+1):\n    dp[i][0] = 0\n\nfor i in range(1, n+1):\n    for j in range(1, k+1):\n        dp[i][j] = dp[i-1][j]\n        for x in range(i-1, -1, -1):\n            if dp[x][j-1] != -1:\n                dp[i][j] = min(dp[i][j], dp[x][j-1] + (i-x-1))\n\nif dp[n][k] == -1:\n    print(-1)\nelse:\n    print(dp[n][k])"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn, k = map(int,input().split())\ns = input()\n\n# n, k = 4, 5\n# s = \"asdf\"\n\ndef get_subsequences(s):\n    if len(s) == 0:\n        return [\"\"]\n    else:\n        subseqs = get_subsequences(s[1:])\n        return subseqs + [s[0] + subseq for subseq in subseqs]\n\nsubseqs = get_subsequences(s)\nsubseqs.sort()\n\nif len(subseqs) < k:\n    print(-1)\nelse:\n    total_cost = 0\n    for subseq in subseqs[:k]:\n        total_cost += n - len(subseq)\n    print(total_cost)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    if k > n:\n        print(-1)\n        return\n    if n == k:\n        print(n * (n + 1) // 2)\n        return\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + i\n    print(dp[k - 1] + (n - k) * k)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\nfrom sys import stdin\nfrom itertools import product\nfrom functools import lru_cache\nfrom heapq import heappush, heappop\n\n\ndef solve(s, k):\n    n = len(s)\n    d = defaultdict(list)\n    for i in range(n):\n        d[s[i]].append(i)\n    d = list(d.values())\n    d.sort(key=len)\n    d = [tuple(x) for x in d]\n    @lru_cache(maxsize=None)\n    def f(i, j, x):\n        if j == 0:\n            return 0\n        if i == n:\n            return float('inf')\n        if x == 0:\n            return float('inf')\n\n        best = float('inf')\n        for y in range(len(d[i])):\n            if d[i][y] >= j:\n                best = min(best, f(i + 1, d[i][y], x - 1) + d[i][y] - j)\n            else:\n                best = min(best, f(i + 1, d[i][y], x - 1) + d[i][y] + n - j)\n        return best\n    best = float('inf')\n    for x in range(n):\n        best = min(best, f(0, x, k))\n    if best == float('inf'):\n        return -1\n    return best\n\n\ndef main():\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline()\n    print(solve(s, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\ns = input()\n\n# We will use dynamic programming to solve the problem.\n# The idea is to find the minimum cost for each subsequence of the string.\n# We will use a 2D array to store the minimum cost for each subsequence.\n# The array will be filled with the following values:\n# 0 if the subsequence is empty\n# 1 if the subsequence is a single character\n# -1 if the subsequence is not a subsequence of the original string\n# The minimum cost for the subsequence if it is a subsequence of the original string\n#\n# The array will be filled in the following manner:\n# 1. If the current subsequence is not a subsequence of the original string,\n#    we will mark it as -1\n# 2. If the current subsequence is a subsequence of the original string,\n#    we will find the minimum cost of the subsequence by finding the minimum\n#    cost of all the substrings of the current subsequence.\n#\n# Once the array is filled, we will find the minimum cost for the subsequence\n# of length n. If the cost is k, we are done. Else, we will try to find the cost\n# for subsequences of length n-1, n-2 and so on.\n#\n# The time complexity of the algorithm is O(n^3)\n\n# We will use a 2D array to store the minimum cost for each subsequence.\n# The array will be filled with the following values:\n# 0 if the subsequence is empty\n# 1 if the subsequence is a single character\n# -1 if the subsequence is not a subsequence of the original string\n# The minimum cost for the subsequence if it is a subsequence of the original string\ncost = [[0 for i in range(n)] for j in range(n)]\n\n# Fill the cost array\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            # The subsequence is a single character\n            cost[i][j] = 1\n        elif i > j:\n            # The subsequence is empty\n            cost[i][j] = 0\n        else:\n            # Check if the subsequence is a subsequence of the original string\n            is_subsequence = True\n            for k in range(i, j+1):\n                if s[k] not in s[i:j+1]:\n                    is_subsequence = False\n                    break\n            if is_subsequence:\n                # Find the minimum cost of the subsequence\n                # by finding the minimum cost of all the substrings\n                # of the current subsequence\n                min_cost = float('inf')\n                for k in range(i, j+1):\n                    for l in range(k, j+1):\n                        if cost[k][l] != -1:\n                            min_cost = min(min_cost, cost[k][l])\n                cost[i][j] = min_cost\n            else:\n                # The subsequence is not a subsequence of the original string\n                cost[i][j] = -1\n\n# Find the minimum cost for the subsequence of length n\nmin_cost = cost[0][n-1]\n\n# Try to find the cost for subsequences of length n-1, n-2 and so on\nfor i in range(n-1, 0, -1):\n    if cost[0][i-1] != -1:\n        min_cost = min(min_cost, cost[0][i-1])\n\nif min_cost == k:\n    print(cost[0][n-1])\nelse:\n    print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n# Solution\n\ndef main():\n    n, k = list(map(int, input().split()))\n    s = input()\n\n    if k > n:\n        print(-1)\n        return\n    \n    if k == n:\n        print(0)\n        return\n\n    print(n*k - (n*(n+1)//2))\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649558814,
  "id": "cmpl-4vHtGJ6qJuOGKAAy7ntftlxfufrrC",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 22:47:38.913345 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef solve(n, k, s):\n    # Write your code here\n    return -1\n\n\nn, k = [int(i) for i in input().split()]\ns = input()\nout_ = solve(n, k, s)\nprint (out_)"
}
2022-04-09 22:47:38.913384 REASON stop
2022-04-09 22:47:38.914506 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# We can use dynamic programming to solve this problem. Let dp[i][j] be the minimum cost for the first i characters,\n# and j subsequences.\n# The base case is dp[0][0] = 0, because for the empty string, there is no cost to create the first subsequence.\n# The recurrence relation is dp[i][j] = min(dp[i][j], dp[i-k][j-1] + i-k), where k is a subsequence of the first i characters.\n# We can use a binary search to find the maximum length of a subsequence, and then use a prefix sum to find the cost.\n# The time complexity is O(n^2 * log(n)), and the space complexity is O(n^2).\n\nimport sys\nfrom bisect import bisect_right\n\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\ns = input()\n\ndp = [[float('inf') for j in range(k+1)] for i in range(n+1)]\ndp[0][0] = 0\n\nprefix_sum = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = prefix_sum[i-1] + i\n\nfor i in range(1, n+1):\n    for j in range(1, min(i+1, k+1)):\n        dp[i][j] = min(dp[i][j], dp[i-1][j-1] + i)\n        l = 1\n        r = i+1\n        while l < r:\n            m = (l+r) // 2\n            if s[i-m:i] == s[i-m:i-m+m]:\n                l = m+1\n            else:\n                r = m\n            dp[i][j] = min(dp[i][j], dp[i-l][j-1] + (prefix_sum[i] - prefix_sum[i-l]))\n\nif dp[n][k] == float('inf'):\n    print(-1)\nelse:\n    print(dp[n][k])"
}
2022-04-09 22:47:38.914574 REASON stop
2022-04-09 22:47:38.915247 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn, k = [int(i) for i in input().split()]\ns = input()\n\ndp = [[-1 for i in range(k+1)] for j in range(n+1)]\n\nfor i in range(n+1):\n    dp[i][0] = 0\n\nfor i in range(1, n+1):\n    for j in range(1, k+1):\n        dp[i][j] = dp[i-1][j]\n        for x in range(i-1, -1, -1):\n            if dp[x][j-1] != -1:\n                dp[i][j] = min(dp[i][j], dp[x][j-1] + (i-x-1))\n\nif dp[n][k] == -1:\n    print(-1)\nelse:\n    print(dp[n][k])"
}
2022-04-09 22:47:38.915332 REASON stop
2022-04-09 22:47:38.915669 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn, k = map(int,input().split())\ns = input()\n\n# n, k = 4, 5\n# s = \"asdf\"\n\ndef get_subsequences(s):\n    if len(s) == 0:\n        return [\"\"]\n    else:\n        subseqs = get_subsequences(s[1:])\n        return subseqs + [s[0] + subseq for subseq in subseqs]\n\nsubseqs = get_subsequences(s)\nsubseqs.sort()\n\nif len(subseqs) < k:\n    print(-1)\nelse:\n    total_cost = 0\n    for subseq in subseqs[:k]:\n        total_cost += n - len(subseq)\n    print(total_cost)"
}
2022-04-09 22:47:38.915701 REASON stop
2022-04-09 22:47:38.915885 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    if k > n:\n        print(-1)\n        return\n    if n == k:\n        print(n * (n + 1) // 2)\n        return\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + i\n    print(dp[k - 1] + (n - k) * k)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 22:47:38.915914 REASON stop
2022-04-09 22:47:38.916128 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\nfrom sys import stdin\nfrom itertools import product\nfrom functools import lru_cache\nfrom heapq import heappush, heappop\n\n\ndef solve(s, k):\n    n = len(s)\n    d = defaultdict(list)\n    for i in range(n):\n        d[s[i]].append(i)\n    d = list(d.values())\n    d.sort(key=len)\n    d = [tuple(x) for x in d]\n    @lru_cache(maxsize=None)\n    def f(i, j, x):\n        if j == 0:\n            return 0\n        if i == n:\n            return float('inf')\n        if x == 0:\n            return float('inf')\n\n        best = float('inf')\n        for y in range(len(d[i])):\n            if d[i][y] >= j:\n                best = min(best, f(i + 1, d[i][y], x - 1) + d[i][y] - j)\n            else:\n                best = min(best, f(i + 1, d[i][y], x - 1) + d[i][y] + n - j)\n        return best\n    best = float('inf')\n    for x in range(n):\n        best = min(best, f(0, x, k))\n    if best == float('inf'):\n        return -1\n    return best\n\n\ndef main():\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline()\n    print(solve(s, k))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 22:47:38.916154 REASON stop
2022-04-09 22:47:38.916350 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\ns = input()\n\n# We will use dynamic programming to solve the problem.\n# The idea is to find the minimum cost for each subsequence of the string.\n# We will use a 2D array to store the minimum cost for each subsequence.\n# The array will be filled with the following values:\n# 0 if the subsequence is empty\n# 1 if the subsequence is a single character\n# -1 if the subsequence is not a subsequence of the original string\n# The minimum cost for the subsequence if it is a subsequence of the original string\n#\n# The array will be filled in the following manner:\n# 1. If the current subsequence is not a subsequence of the original string,\n#    we will mark it as -1\n# 2. If the current subsequence is a subsequence of the original string,\n#    we will find the minimum cost of the subsequence by finding the minimum\n#    cost of all the substrings of the current subsequence.\n#\n# Once the array is filled, we will find the minimum cost for the subsequence\n# of length n. If the cost is k, we are done. Else, we will try to find the cost\n# for subsequences of length n-1, n-2 and so on.\n#\n# The time complexity of the algorithm is O(n^3)\n\n# We will use a 2D array to store the minimum cost for each subsequence.\n# The array will be filled with the following values:\n# 0 if the subsequence is empty\n# 1 if the subsequence is a single character\n# -1 if the subsequence is not a subsequence of the original string\n# The minimum cost for the subsequence if it is a subsequence of the original string\ncost = [[0 for i in range(n)] for j in range(n)]\n\n# Fill the cost array\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            # The subsequence is a single character\n            cost[i][j] = 1\n        elif i > j:\n            # The subsequence is empty\n            cost[i][j] = 0\n        else:\n            # Check if the subsequence is a subsequence of the original string\n            is_subsequence = True\n            for k in range(i, j+1):\n                if s[k] not in s[i:j+1]:\n                    is_subsequence = False\n                    break\n            if is_subsequence:\n                # Find the minimum cost of the subsequence\n                # by finding the minimum cost of all the substrings\n                # of the current subsequence\n                min_cost = float('inf')\n                for k in range(i, j+1):\n                    for l in range(k, j+1):\n                        if cost[k][l] != -1:\n                            min_cost = min(min_cost, cost[k][l])\n                cost[i][j] = min_cost\n            else:\n                # The subsequence is not a subsequence of the original string\n                cost[i][j] = -1\n\n# Find the minimum cost for the subsequence of length n\nmin_cost = cost[0][n-1]\n\n# Try to find the cost for subsequences of length n-1, n-2 and so on\nfor i in range(n-1, 0, -1):\n    if cost[0][i-1] != -1:\n        min_cost = min(min_cost, cost[0][i-1])\n\nif min_cost == k:\n    print(cost[0][n-1])\nelse:\n    print(-1)"
}
2022-04-09 22:47:38.916379 REASON stop
2022-04-09 22:47:38.916566 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n# Solution\n\ndef main():\n    n, k = list(map(int, input().split()))\n    s = input()\n\n    if k > n:\n        print(-1)\n        return\n    \n    if k == n:\n        print(0)\n        return\n\n    print(n*k - (n*(n+1)//2))\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 22:47:38.916609 REASON stop
