2022-04-09 23:42:38.369271 """
You are given a text consisting of $n$ space-separated words. There is exactly one space character between any pair of adjacent words. There are no spaces before the first word and no spaces after the last word. The length of text is the number of letters and spaces in it. $w_i$ is the $i$-th word of text. All words consist only of lowercase Latin letters.

Let's denote a segment of words $w[i..j]$ as a sequence of words $w_i, w_{i + 1}, \dots, w_j$. Two segments of words $w[i_1 .. j_1]$ and $w[i_2 .. j_2]$ are considered equal if $j_1 - i_1 = j_2 - i_2$, $j_1 \ge i_1$, $j_2 \ge i_2$, and for every $t \in [0, j_1 - i_1]$ $w_{i_1 + t} = w_{i_2 + t}$. For example, for the text "to be or not to be" the segments $w[1..2]$ and $w[5..6]$ are equal, they correspond to the words "to be".

An abbreviation is a replacement of some segments of words with their first uppercase letters. In order to perform an abbreviation, you have to choose at least two non-intersecting equal segments of words, and replace each chosen segment with the string consisting of first letters of the words in the segment (written in uppercase). For example, for the text "a ab a a b ab a a b c" you can replace segments of words $w[2..4]$ and $w[6..8]$ with an abbreviation "AAA" and obtain the text "a AAA b AAA b c", or you can replace segments of words $w[2..5]$ and $w[6..9]$ with an abbreviation "AAAB" and obtain the text "a AAAB AAAB c".

What is the minimum length of the text after at most one abbreviation?


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 300$) — the number of words in the text.

The next line contains $n$ space-separated words of the text $w_1, w_2, \dots, w_n$. Each word consists only of lowercase Latin letters.

It is guaranteed that the length of text does not exceed $10^5$.


-----Output-----

Print one integer — the minimum length of the text after at most one abbreviation.


-----Examples-----
Input
6
to be or not to be

Output
12

Input
10
a ab a a b ab a a b c

Output
13

Input
6
aa bb aa aa bb bb

Output
11



-----Note-----

In the first example you can obtain the text "TB or not TB".

In the second example you can obtain the text "a AAAB AAAB c".

In the third example you can obtain the text "AB aa AB bb".
"""
2022-04-09 23:42:38.369301 --------------------------
2022-04-09 23:43:39.083173 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = input().split()\n\ncurr = -1\nfor i in range(n):\n    if a[i] != a[i-1]:\n        curr += 1\n\nif curr == 0:\n    print(len(a[0]))\nelse:\n    print(len(a[0]) + curr - 1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\nw = input().split()\n\n# create a list of the unique words\nunique = []\n\nfor word in w:\n    if word not in unique:\n        unique.append(word)\n\n# create a dictionary of the number of times each word appears\ncount = {}\n\nfor word in unique:\n    count[word] = 0\n\nfor word in w:\n    count[word] += 1\n\n# create a list of the number of times each word appears\nnum = []\n\nfor word in unique:\n    num.append(count[word])\n\n# create a list of the lengths of the words\nlengths = []\n\nfor word in unique:\n    lengths.append(len(word))\n\n# create a list of the lengths of the words multiplied by the number of times each word appears\nproduct = []\n\nfor i in range(len(unique)):\n    product.append(lengths[i] * num[i])\n\n# create a list of the lengths of the words multiplied by the number of times each word appears minus the number of times each word appears\ndifference = []\n\nfor i in range(len(unique)):\n    difference.append(product[i] - num[i])\n\n# sum the list of the lengths of the words multiplied by the number of times each word appears minus the number of times each word appears\nsum_difference = sum(difference)\n\n# if the sum is less than the number of words in the text, then the length of the text after at most one abbreviation is the sum of the lengths of the words\nif sum_difference < n:\n    print(sum_difference)\n# if the sum is greater than or equal to the number of words in the text, then the length of the text after at most one abbreviation is the number of words in the text\nelse:\n    print(n)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    Space Complexity: O(n)\n    Time Complexity: O(n)\n    \"\"\"\n    input()\n    arr = input().split()\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = len(arr[0])\n    for i in range(1, n):\n        dp[i] = dp[i - 1] + len(arr[i]) + 1\n        if arr[i] == arr[i - 1]:\n            dp[i] = min(dp[i], dp[i - 2] + 1 if i > 1 else 1)\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n = int(input())\n    text = input().split()\n    text = \" \".join(text)\n\n    # find all possible abbrs\n    abbrs = set()\n    for i in range(len(text)):\n        for j in range(i + 1, len(text)):\n            if text[i] == text[j]:\n                abbrs.add(text[i:j + 1])\n\n    # find all possible abbrs with 1st letter uppercase\n    abbrs_uppercase = set()\n    for abbr in abbrs:\n        abbrs_uppercase.add(abbr[0].upper() + abbr[1:])\n\n    min_length = len(text)\n    for abbr in abbrs_uppercase:\n        if text.count(abbr) > 1:\n            length = len(text.replace(abbr, abbr[0].upper()))\n            if length < min_length:\n                min_length = length\n\n    print(min_length)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(100000)\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.suffix_link = None\n        self.parent = None\n        self.end_pos = -1\n        self.end_pos_in_parent = -1\n        self.depth = -1\n\nclass SuffixTree:\n    def __init__(self, s):\n        s += '$'\n        self.root = Node('')\n        self.root.depth = 0\n        self.root.end_pos = -1\n        self.s = s\n        self.n = len(s)\n\n    def _add_char(self, node, i, depth):\n        node.children[self.s[i]] = Node(self.s[i])\n        node.children[self.s[i]].parent = node\n        node.children[self.s[i]].depth = depth\n        node.children[self.s[i]].end_pos = i\n        node.children[self.s[i]].end_pos_in_parent = i\n\n    def _get_suffix_link(self, node):\n        if node.suffix_link is not None:\n            return node.suffix_link\n        if node == self.root or node.parent == self.root:\n            node.suffix_link = self.root\n            return self.root\n        node.suffix_link = self.get_suffix_link(node.parent.suffix_link, node.end_pos_in_parent)\n        return node.suffix_link\n\n    def get_suffix_link(self, node, i):\n        if i == -1:\n            return self.root\n        if self.s[i] in node.children:\n            return node.children[self.s[i]]\n        if node == self.root:\n            return self.root\n        return self.get_suffix_link(node.suffix_link, i)\n\n    def build(self):\n        for i in range(self.n):\n            node = self.root\n            for j in range(i, self.n):\n                if self.s[j] in node.children:\n                    node = node.children[self.s[j]]\n                    continue\n                self._add_char(node, j, j - i + 1)\n                node = node.children[self.s[j]]\n                sl = self._get_suffix_link(node)\n                while sl != self.root:\n                    if self.s[i + sl.depth] in sl.children:\n                        node.suffix_link = sl.children[self.s[i + sl.depth]]\n                        break\n                    sl = sl.suffix_link\n                if sl == self.root:\n                    node.suffix_link = self.root\n\n    def get_leaves(self, node):\n        res = []\n        if len(node.children) == 0:\n            res.append(node)\n        else:\n            for child in node.children.values():\n                res += self.get_leaves(child)\n        return res\n\n    def get_leaves_count(self, node):\n        res = 0\n        if len(node.children) == 0:\n            res += 1\n        else:\n            for child in node.children.values():\n                res += self.get_leaves_count(child)\n        return res\n\ndef get_min_text_length(s):\n    st = SuffixTree(s)\n    st.build()\n    leaves = st.get_leaves(st.root)\n    leaves_count = st.get_leaves_count(st.root)\n    if leaves_count == 1:\n        return len(s)\n    leaves = sorted(leaves, key=lambda x: x.depth, reverse=True)\n    for i in range(len(leaves) - 1):\n        if leaves[i].depth == leaves[i + 1].depth:\n            return len(s) - leaves[i].depth * 2\n    return len(s)\n\ndef main():\n    n = int(input())\n    s = input().split()\n    s = ' '.join(s)\n    print(get_min_text_length(s))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    words = input().split()\n    words_count = {}\n    for word in words:\n        words_count[word] = words_count.get(word, 0) + 1\n    print(len(words) + sum(1 for word in words_count if words_count[word] > 1))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649562158,
  "id": "cmpl-4vIlCsWImvUdG1tjhZ2fHwefGbMso",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 23:43:39.083645 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = input().split()\n\ncurr = -1\nfor i in range(n):\n    if a[i] != a[i-1]:\n        curr += 1\n\nif curr == 0:\n    print(len(a[0]))\nelse:\n    print(len(a[0]) + curr - 1)"
}
2022-04-09 23:43:39.083762 REASON stop
2022-04-09 23:43:39.096447 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\nw = input().split()\n\n# create a list of the unique words\nunique = []\n\nfor word in w:\n    if word not in unique:\n        unique.append(word)\n\n# create a dictionary of the number of times each word appears\ncount = {}\n\nfor word in unique:\n    count[word] = 0\n\nfor word in w:\n    count[word] += 1\n\n# create a list of the number of times each word appears\nnum = []\n\nfor word in unique:\n    num.append(count[word])\n\n# create a list of the lengths of the words\nlengths = []\n\nfor word in unique:\n    lengths.append(len(word))\n\n# create a list of the lengths of the words multiplied by the number of times each word appears\nproduct = []\n\nfor i in range(len(unique)):\n    product.append(lengths[i] * num[i])\n\n# create a list of the lengths of the words multiplied by the number of times each word appears minus the number of times each word appears\ndifference = []\n\nfor i in range(len(unique)):\n    difference.append(product[i] - num[i])\n\n# sum the list of the lengths of the words multiplied by the number of times each word appears minus the number of times each word appears\nsum_difference = sum(difference)\n\n# if the sum is less than the number of words in the text, then the length of the text after at most one abbreviation is the sum of the lengths of the words\nif sum_difference < n:\n    print(sum_difference)\n# if the sum is greater than or equal to the number of words in the text, then the length of the text after at most one abbreviation is the number of words in the text\nelse:\n    print(n)"
}
2022-04-09 23:43:39.096743 REASON stop
2022-04-09 23:43:39.097634 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    Space Complexity: O(n)\n    Time Complexity: O(n)\n    \"\"\"\n    input()\n    arr = input().split()\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = len(arr[0])\n    for i in range(1, n):\n        dp[i] = dp[i - 1] + len(arr[i]) + 1\n        if arr[i] == arr[i - 1]:\n            dp[i] = min(dp[i], dp[i - 2] + 1 if i > 1 else 1)\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:43:39.097720 REASON stop
2022-04-09 23:43:39.098269 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n = int(input())\n    text = input().split()\n    text = \" \".join(text)\n\n    # find all possible abbrs\n    abbrs = set()\n    for i in range(len(text)):\n        for j in range(i + 1, len(text)):\n            if text[i] == text[j]:\n                abbrs.add(text[i:j + 1])\n\n    # find all possible abbrs with 1st letter uppercase\n    abbrs_uppercase = set()\n    for abbr in abbrs:\n        abbrs_uppercase.add(abbr[0].upper() + abbr[1:])\n\n    min_length = len(text)\n    for abbr in abbrs_uppercase:\n        if text.count(abbr) > 1:\n            length = len(text.replace(abbr, abbr[0].upper()))\n            if length < min_length:\n                min_length = length\n\n    print(min_length)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:43:39.098348 REASON stop
2022-04-09 23:43:39.098745 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\nsys.setrecursionlimit(100000)\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.suffix_link = None\n        self.parent = None\n        self.end_pos = -1\n        self.end_pos_in_parent = -1\n        self.depth = -1\n\nclass SuffixTree:\n    def __init__(self, s):\n        s += '$'\n        self.root = Node('')\n        self.root.depth = 0\n        self.root.end_pos = -1\n        self.s = s\n        self.n = len(s)\n\n    def _add_char(self, node, i, depth):\n        node.children[self.s[i]] = Node(self.s[i])\n        node.children[self.s[i]].parent = node\n        node.children[self.s[i]].depth = depth\n        node.children[self.s[i]].end_pos = i\n        node.children[self.s[i]].end_pos_in_parent = i\n\n    def _get_suffix_link(self, node):\n        if node.suffix_link is not None:\n            return node.suffix_link\n        if node == self.root or node.parent == self.root:\n            node.suffix_link = self.root\n            return self.root\n        node.suffix_link = self.get_suffix_link(node.parent.suffix_link, node.end_pos_in_parent)\n        return node.suffix_link\n\n    def get_suffix_link(self, node, i):\n        if i == -1:\n            return self.root\n        if self.s[i] in node.children:\n            return node.children[self.s[i]]\n        if node == self.root:\n            return self.root\n        return self.get_suffix_link(node.suffix_link, i)\n\n    def build(self):\n        for i in range(self.n):\n            node = self.root\n            for j in range(i, self.n):\n                if self.s[j] in node.children:\n                    node = node.children[self.s[j]]\n                    continue\n                self._add_char(node, j, j - i + 1)\n                node = node.children[self.s[j]]\n                sl = self._get_suffix_link(node)\n                while sl != self.root:\n                    if self.s[i + sl.depth] in sl.children:\n                        node.suffix_link = sl.children[self.s[i + sl.depth]]\n                        break\n                    sl = sl.suffix_link\n                if sl == self.root:\n                    node.suffix_link = self.root\n\n    def get_leaves(self, node):\n        res = []\n        if len(node.children) == 0:\n            res.append(node)\n        else:\n            for child in node.children.values():\n                res += self.get_leaves(child)\n        return res\n\n    def get_leaves_count(self, node):\n        res = 0\n        if len(node.children) == 0:\n            res += 1\n        else:\n            for child in node.children.values():\n                res += self.get_leaves_count(child)\n        return res\n\ndef get_min_text_length(s):\n    st = SuffixTree(s)\n    st.build()\n    leaves = st.get_leaves(st.root)\n    leaves_count = st.get_leaves_count(st.root)\n    if leaves_count == 1:\n        return len(s)\n    leaves = sorted(leaves, key=lambda x: x.depth, reverse=True)\n    for i in range(len(leaves) - 1):\n        if leaves[i].depth == leaves[i + 1].depth:\n            return len(s) - leaves[i].depth * 2\n    return len(s)\n\ndef main():\n    n = int(input())\n    s = input().split()\n    s = ' '.join(s)\n    print(get_min_text_length(s))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 23:43:39.098821 REASON stop
2022-04-09 23:43:39.099056 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": ""
}
2022-04-09 23:43:39.099082 REASON stop
2022-04-09 23:43:39.099306 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    words = input().split()\n    words_count = {}\n    for word in words:\n        words_count[word] = words_count.get(word, 0) + 1\n    print(len(words) + sum(1 for word in words_count if words_count[word] > 1))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:43:39.099330 REASON stop
2022-04-09 23:43:39.099630 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:43:39.099702 REASON stop
