["\n\ndef main():\n    # read input\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        tiles = [[0, 0, 0, 0] for _ in range(n)]\n        for i in range(n):\n            tiles[i][0], tiles[i][1] = map(int, input().split())\n            tiles[i][2], tiles[i][3] = map(int, input().split())\n        # check if tiles can be used to construct square\n        print(\"YES\" if check(tiles, m) else \"NO\")\n\ndef check(tiles, m):\n    # check if tiles can be used to construct square\n    return False\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n# This problem can be solved by using a bipartite graph, where the\n# vertices on the left correspond to the squares of the board, and\n# the vertices on the right correspond to the tiles.\n#\n# There is an edge between a square and a tile if the tile can be\n# placed on the square. We can check this by comparing the values\n# of the tile with the values of the squares on the left and right.\n#\n# We can then find the maximum matching of the graph using the\n# Hopcroft-Karp algorithm, which runs in O(E sqrt(V)), or\n# O(n^3 * m^3) in our case.\n#\n# If the maximum matching is equal to the number of squares, then\n# there is a way to place the tiles, otherwise there is not.\n\nimport sys\nimport heapq\nfrom collections import deque\n\nsys.setrecursionlimit(10000)\n\ndef hopcroftKarp(graph, n, m):\n    \"\"\"\n    Finds the maximum matching of a bipartite graph using the\n    Hopcroft-Karp algorithm.\n    \"\"\"\n    match = [-1] * n\n    dist = [-1] * n\n    queue = deque()\n\n    def bfs():\n        \"\"\"\n        Performs a breadth-first search to find the shortest path\n        to an unmatched vertex.\n        \"\"\"\n        for i in range(n):\n            if match[i] == -1:\n                dist[i] = 0\n                queue.append(i)\n            else:\n                dist[i] = -1\n\n        dist[-1] = -1\n        while queue:\n            u = queue.popleft()\n            if u != -1:\n                for v in graph[u]:\n                    if dist[match[v]] == -1:\n                        dist[match[v]] = dist[u] + 1\n                        queue.append(match[v])\n\n        return dist[-1] != -1\n\n    def dfs(u):\n        \"\"\"\n        Performs a depth-first search to find an augmenting path.\n        \"\"\"\n        if u != -1:\n            for v in graph[u]:\n                if dist[match[v]] == dist[u] + 1 and dfs(match[v]):\n                    match[v] = u\n                    match[u] = v\n                    return True\n            dist[u] = -1\n            return False\n        return True\n\n    matching = 0\n    while bfs():\n        for i in range(n):\n            if match[i] == -1 and dfs(i):\n                matching += 1\n\n    return matching\n\ndef solve(n, m):\n    \"\"\"\n    Returns whether it is possible to place the tiles in the board\n    such that the board is symmetric.\n    \"\"\"\n    board = [[0] * (m + 1) for _ in range(m + 1)]\n    tiles = [[0] * 4 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(4):\n            tiles[i][j] = int(input())\n\n    for i in range(1, m + 1):\n        for j in range(1, m + 1):\n            board[i][j] = int(input())\n\n    graph = [[] for _ in range(m * m + n)]\n\n    # Add edges between each square and each tile that can be placed\n    # on that square.\n    for i in range(1, m + 1):\n        for j in range(1, m + 1):\n            for k in range(n):\n                if (board[i][j] == tiles[k][0] and board[i][m - j + 1] == tiles[k][1] and\n                        board[m - i + 1][j] == tiles[k][2] and board[m - i + 1][m - j + 1] == tiles[k][3]):\n                    graph[(i - 1) * m + j - 1].append(m * m + k)\n                    graph[m * m + k].append((i - 1) * m + j - 1)\n\n    return hopcroftKarp(graph, m * m, n) == m * m\n\nt = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n\n    if solve(n, m):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        tiles = []\n        for j in range(n):\n            t1 = list(map(int, input().split()))\n            t2 = list(map(int, input().split()))\n            tiles.append([t1, t2])\n        yield n, m, tiles\n\ndef is_symmetric(n, m, tiles):\n    for i in range(m):\n        for j in range(m):\n            if i == j:\n                continue\n            if not any([t[0][0] == tiles[i][j] and t[1][0] == tiles[j][i] for t in tiles]):\n                return False\n    return True\n\nif __name__ == '__main__':\n    for n, m, tiles in get_input():\n        print('YES' if is_symmetric(n, m, tiles) else 'NO')", "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n,m = [int(x) for x in input().split()]\n        tiles = []\n        for _ in range(n):\n            tiles.append([int(x) for x in input().split()] + [int(x) for x in input().split()])\n        if is_possible(tiles,m):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\ndef is_possible(tiles,m):\n    for i in range(m):\n        for j in range(m):\n            for k in range(len(tiles)):\n                if tiles[k][0] == i and tiles[k][1] == j:\n                    if tiles[k][2] == i and tiles[k][3] == j:\n                        return False\n                    if tiles[k][2] == m-j-1 and tiles[k][3] == m-i-1:\n                        return False\n    return True\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        n, m = map(int, input().split())\n        tiles = [None] * n\n        for i in range(n):\n            tiles[i] = [[0] * 2 for _ in range(2)]\n            tiles[i][0][0], tiles[i][0][1] = map(int, input().split())\n            tiles[i][1][0], tiles[i][1][1] = map(int, input().split())\n        if m % 2 == 1:\n            print('NO')\n            continue\n        ans = False\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][0][0] == tiles[j][1][1] and tiles[i][0][1] == tiles[j][1][0] and tiles[i][1][0] == tiles[j][0][1] and tiles[i][1][1] == tiles[j][0][0]:\n                    ans = True\n                    break\n        if ans:\n            print('YES')\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    t = int(raw_input())\n    for i in range(t):\n        n, m = map(int, raw_input().split())\n        tiles = []\n        for j in range(n):\n            tiles.append(map(int, raw_input().split()))\n            tiles[j].extend(map(int, raw_input().split()))\n        if m % 2 == 0 and m > 2:\n            print 'YES'\n        else:\n            print 'NO'\n\nmain()"]