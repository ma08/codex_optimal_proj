["\n\n#def count_problems(N,d_lst,K):\n#    count=0\n#    for d in d_lst:\n#        if d>=K:\n#            count+=1\n#    return count\n\n#def main():\n#    N=int(input())\n#    d_lst=list(map(int,input().split()))\n#    count=0\n#    d_lst.sort()\n#    if N%2==1:\n#        print(0)\n#        exit()\n#    else:\n#        for K in range(1,max(d_lst)+1):\n#            if count_problems(N,d_lst,K)==N/2:\n#                count+=1\n#        print(count)\n\ndef main():\n    N=int(input())\n    d_lst=list(map(int,input().split()))\n    d_lst.sort()\n    count=0\n    for i in range(N):\n        if d_lst[i]==d_lst[N//2]:\n            count+=1\n    print(count)\n\nif __name__==\"__main__\":\n    main()", "\n\n# -----Solution-----\n\nn = int(input())\ndifficulties = list(map(int, input().split()))\n\ndifficulties.sort()\n\n# We know that n is even, so we can just round down and round up\n# the middle two numbers and compare them to the rest of the list\n# to get the number of choices for K that make the number of problems\n# for ARCs and the number of problems for ABCs the same.\n# This is O(n) time complexity.\n\n# This is the number of choices for K that make the number of problems\n# for ARCs and the number of problems for ABCs the same.\nnum_choices = 0\n\nmid_num_1 = difficulties[(n//2)-1]\nmid_num_2 = difficulties[n//2]\n\n# The number of problems for ARCs and ABCs are the same when K is equal to\n# the lower of the two middle numbers.\nif mid_num_1 == mid_num_2:\n    num_choices = 1\n\n# The number of problems for ARCs and ABCs are the same when K is equal to\n# the lower of the two middle numbers or the higher of the two middle numbers.\nelif mid_num_1 + 1 == mid_num_2:\n    num_choices = 2\n\nprint(num_choices)", "\n\nn = int(input())\ndifficulties = list(map(int, input().split()))\ndifficulties.sort()\n\n# The difference between the number of problems for ARCs and the number of problems for ABCs is\n# the number of problems with difficulty larger than K minus the number of problems with difficulty smaller than K.\n# If the difference is 0, then the number of problems for ARCs and the number of problems for ABCs are the same.\n# Therefore, the problem is equivalent to finding the number of K's that make the difference 0.\n#\n# We can find the number of K's that make the difference 0 by adding 1 to the number of K's that make the difference 1,\n# and subtracting 1 from the number of K's that make the difference -1.\n# This is because we can make the difference 0 by subtracting 1 from the number of problems for ARCs and adding 1 to the number of problems for ABCs.\n#\n# We can find the number of K's that make the difference 1 or -1 by counting the number of problems with difficulty larger or smaller than K, respectively.\n#\n# We can count the number of problems with difficulty larger than K by using binary search.\n# The lower bound of binary search is the smallest difficulty, and the upper bound is the largest difficulty.\n# Since we want to find the number of problems with difficulty larger than K, we want to find the largest K that makes the difference 1.\n# Therefore, we want to find the lower bound of the largest K that makes the difference 1.\n# We can find the lower bound of the largest K that makes the difference 1 by using lower_bound function.\n#\n# We can count the number of problems with difficulty smaller than K by using binary search.\n# The lower bound of binary search is the smallest difficulty, and the upper bound is the largest difficulty.\n# Since we want to find the number of problems with difficulty smaller than K, we want to find the smallest K that makes the difference -1.\n# Therefore, we want to find the upper bound of the smallest K that makes the difference -1.\n# We can find the upper bound of the smallest K that makes the difference -1 by using upper_bound function.\n\n# The number of K's that make the difference 0.\nnum_of_k_that_make_difference_0 = 0\n\n# The number of K's that make the difference 1.\nnum_of_k_that_make_difference_1 = bisect.bisect_left(difficulties, difficulties[n // 2])\n\n# The number of K's that make the difference -1.\nnum_of_k_that_make_difference_minus_1 = n - bisect.bisect_right(difficulties, difficulties[n // 2])\n\n# Add 1 to the number of K's that make the difference 1, and subtract 1 from the number of K's that make the difference -1.\nnum_of_k_that_make_difference_0 += num_of_k_that_make_difference_1 + 1\nnum_of_k_that_make_difference_0 -= num_of_k_that_make_difference_minus_1 - 1\n\nprint(num_of_k_that_make_difference_0)", "\n\nimport sys\n\ndef main():\n    N = int(sys.stdin.readline())\n    d = [int(x) for x in sys.stdin.readline().rstrip().split()]\n    d.sort()\n\n    l = 0\n    r = N//2\n    ans = 0\n    while l <= r:\n        m = (l+r)//2\n        if d[m] == d[N//2]:\n            ans += 1\n            l += 1\n        elif d[m] < d[N//2]:\n            l += 1\n        else:\n            r -= 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\n#Input\nN = int(input())\ndifficulties = list(map(int, input().split()))\n\n#Initialize\ndifficulties.sort()\n\n#Process\nARCs = 0\nABCs = 0\n\nfor difficulty in difficulties:\n    if difficulty >= difficulties[N//2]:\n        ARCs += 1\n    else:\n        ABCs += 1\n\nprint(ARCs)", "\n\nN = int(input())\ndifficulties = list(map(int, input().split()))\n\narc_problems = 0\nfor i in range(N):\n    if difficulties[i] >= N // 2:\n        arc_problems += 1\n\nif arc_problems == N // 2:\n    print(1)\nelse:\n    print(0)", "\n\nN = int(input())\nd = list(map(int, input().split()))\n\n# d\u3092\u30bd\u30fc\u30c8\u3057\u3066\u3001\u305d\u308c\u305e\u308c\u306e\u5024\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u8abf\u3079\u308b\nd.sort()\n# \u540c\u3058\u5024\u304c\u8907\u6570\u3042\u308b\u5834\u5408\u306f1\u3064\u306b\u307e\u3068\u3081\u308b\nd_uniq = []\ntemp = d[0]\ncount = 1\nfor i in range(1, N):\n    if d[i] == temp:\n        count += 1\n    else:\n        d_uniq.append([temp, count])\n        temp = d[i]\n        count = 1\nd_uniq.append([temp, count])\n\n# \u7d2f\u7a4d\u548c\u3092\u6c42\u3081\u308b\nd_uniq_sum = []\nsum = 0\nfor i in range(len(d_uniq)):\n    sum += d_uniq[i][1]\n    d_uniq_sum.append([d_uniq[i][0], sum])\n\n# \u6761\u4ef6\u3092\u6e80\u305f\u3059K\u306e\u500b\u6570\u3092\u6c42\u3081\u308b\nans = 0\nfor i in range(len(d_uniq_sum)):\n    if d_uniq_sum[i][1] == (N - d_uniq_sum[i][1]):\n        ans += 1\nprint(ans)"]