["\n\n# n, m, d = 4, 5, 1\n# edges = [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]\n\nn, m, d = 4, 5, 3\nedges = [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]\n\n# n, m, d = 4, 4, 3\n# edges = [[1, 2], [1, 4], [2, 3], [3, 4]]\n\n# n, m, d = map(int, input().split())\n# edges = [[int(x) for x in input().split()] for _ in range(m)]\n\ndef find_spanning_tree(n, m, d, edges):\n    if m < n - 1:\n        return \"NO\"\n    if d > n - 1:\n        return \"NO\"\n    if m == n - 1:\n        if d == n - 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    # Build adjacency list\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0] - 1].append(edge[1] - 1)\n        adj_list[edge[1] - 1].append(edge[0] - 1)\n\n    # Find a spanning tree\n    visited = set()\n    queue = [0]\n    tree = []\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                tree.append([node + 1, neighbor + 1])\n\n    # Check if the spanning tree has the right degree\n    if len(tree) != n - 1:\n        return \"NO\"\n    if len(adj_list[0]) == d:\n        return \"YES\\n\" + \"\\n\".join([str(edge[0]) + \" \" + str(edge[1]) for edge in tree])\n    else:\n        return \"NO\"\n\nprint(find_spanning_tree(n, m, d, edges))", "\n\n\ndef main():\n    n, m, d = map(int, input().split())\n    if d == n - 1:\n        print('YES')\n        for i in range(2, n + 1):\n            print(1, i)\n    elif d == 1:\n        print('YES')\n        for i in range(1, n):\n            print(i, i + 1)\n    elif m == n - 1:\n        print('NO')\n    else:\n        print('YES')\n        for i in range(2, n):\n            print(1, i)\n        print(1, n)\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport queue\n\ninput = sys.stdin.readline\n\ndef solve():\n    n, m, D = map(int, input().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges[v - 1].append(u - 1)\n        edges[u - 1].append(v - 1)\n\n    if len(edges[0]) > D:\n        print('NO')\n        return\n\n    q = queue.Queue()\n    q.put(0)\n    visited = [False] * n\n    visited[0] = True\n    res = []\n    while not q.empty():\n        v = q.get()\n        for u in edges[v]:\n            if not visited[u]:\n                visited[u] = True\n                q.put(u)\n                res.append((v + 1, u + 1))\n\n    if len(res) == n - 1:\n        print('YES')\n        for v, u in res:\n            print(v, u)\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    solve()", "\n\nimport sys\nimport math\n\n#sys.stdin = open(\"input.txt\", \"r\")\n#sys.stdout = open(\"output.txt\", \"w\")\n\nn, m, D = map(int, input().split())\n\nif D > n - 1:\n    print(\"NO\")\n    sys.exit(0)\n\ndeg = [0 for i in range(n)]\nedges = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n    deg[a - 1] += 1\n    deg[b - 1] += 1\n\nif deg[0] < D:\n    print(\"NO\")\n    sys.exit(0)\n\nprint(\"YES\")\n\nfor i in range(m):\n    if deg[edges[i][0] - 1] > deg[edges[i][1] - 1]:\n        edges[i][0], edges[i][1] = edges[i][1], edges[i][0]\n\nedges.sort(key=lambda x: x[1])\n\nfor i in range(n - 1):\n    print(edges[i][0], edges[i][1])", "\n\nfrom collections import defaultdict\nfrom queue import Queue\n\nn, m, D = map(int, input().split())\n\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v, u = map(int, input().split())\n    adj_list[v].append(u)\n    adj_list[u].append(v)\n\nvisited = set()\n\ndef bfs(start):\n    q = Queue()\n    q.put(start)\n    visited.add(start)\n    while q.qsize():\n        curr = q.get()\n        for nbr in adj_list[curr]:\n            if nbr not in visited:\n                visited.add(nbr)\n                q.put(nbr)\n\nbfs(1)\n\nif len(visited) != n:\n    print('NO')\nelse:\n    if D == 0:\n        print('YES')\n    else:\n        for nbr in adj_list[1]:\n            if nbr in visited:\n                visited.remove(nbr)\n        if len(visited) == D:\n            print('YES')\n            for v in visited:\n                print(1, v)\n        else:\n            print('NO')", "\n\nimport sys, threading\nsys.setrecursionlimit(10**7) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [0]*n\n        self.rank = [1]*n\n        self.edge = [0]*n\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id = self.find(i)\n        j_id = self.find(j)\n        if i_id == j_id:\n            return False\n        if self.rank[i_id] > self.rank[j_id]:\n            self.parent[j_id] = i_id\n            self.edge[i_id] += self.edge[j_id] + 1\n        else:\n            self.parent[i_id] = j_id\n            self.edge[j_id] += self.edge[i_id] + 1\n            if self.rank[i_id] == self.rank[j_id]:\n                self.rank[j_id] += 1\n        return True\n\n    def get_edges(self, i):\n        return self.edge[self.find(i)]\n\n\ndef Is_Tree(edges, n):\n    tree = Tree(n)\n    for edge in edges:\n        if not tree.union(edge[0]-1, edge[1]-1):\n            return False\n    return tree.get_edges(0) == D\n\n\ndef main():\n    global D\n    n, m, D = map(int, input().split())\n    edges = [list(map(int, input().split())) for i in range(m)]\n    if Is_Tree(edges, n):\n        print(\"YES\")\n        tree = Tree(n)\n        for edge in edges:\n            if tree.union(edge[0]-1, edge[1]-1):\n                print(edge[0], edge[1])\n    else:\n        print(\"NO\")\n\nthreading.Thread(target=main).start()", "\n\nfrom collections import defaultdict\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def BFS(self, s, degree):\n        visited = [False] * self.V\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            s = queue.popleft()\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n                    if self.graph[i]:\n                        degree += 1\n        return degree\n\n\nif __name__ == \"__main__\":\n    n, m, degree = map(int, input().split())\n    g = Graph(n)\n    for i in range(m):\n        u, v = map(int, input().split())\n        g.addEdge(u-1, v-1)\n    degree = g.BFS(0, degree)\n    if degree == n-1:\n        print(\"YES\")\n        for i in range(n):\n            for j in g.graph[i]:\n                if i < j:\n                    print(i+1, j+1)\n    else:\n        print(\"NO\")"]