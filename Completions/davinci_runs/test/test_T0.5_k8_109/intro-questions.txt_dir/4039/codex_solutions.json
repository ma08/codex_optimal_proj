["\n\n\ndef main():\n    n, r = map(int, input().split())\n    projects = []\n    for i in range(n):\n        projects.append(tuple(map(int, input().split())))\n    projects.sort(key=lambda x: x[1])\n    for i in range(n):\n        r -= projects[i][0]\n        if r < 0:\n            print(\"NO\")\n            return\n        r += projects[i][1]\n    print(\"YES\")\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, r = map(int, input().split())\n    projects = []\n    for _ in range(n):\n        projects.append(tuple(map(int, input().split())))\n\n    # sort by a_i (ascending order)\n    projects.sort(key=lambda x: x[0])\n\n    # start with the lowest a_i\n    for a_i, b_i in projects:\n        if r < a_i:\n            print(\"NO\")\n            return\n        r += b_i\n        if r < 0:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()", "", "\n\nn, r = map(int, input().split())\na = []\nb = []\nfor i in range(n):\n    a_i, b_i = map(int, input().split())\n    a.append(a_i)\n    b.append(b_i)\n\na.sort()\nb.sort()\n\nif (a[0] > r):\n    print(\"NO\")\nelse:\n    r += b[-1]\n    if (r < 0):\n        print(\"NO\")\n    else:\n        print(\"YES\")", "\n\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import Counter\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import OrderedDict\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom math import ceil\nfrom math import inf\nimport sys\n\nsys.setrecursionlimit(500000)\n\n\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\n\n\nn, r = LI()\np = LIR(n)\n\nfor i in range(n):\n    r -= p[i][0]\n    if r < 0:\n        print('NO')\n        exit()\n    r += p[i][1]\n\nprint('YES')", "\n\nimport sys\n\ndef main():\n    n, r = [int(x) for x in sys.stdin.readline().split()]\n    a = []\n    b = []\n    for i in range(n):\n        ai, bi = [int(x) for x in sys.stdin.readline().split()]\n        a.append(ai)\n        b.append(bi)\n    for i in range(n):\n        if r < a[i]:\n            print(\"NO\")\n            return\n        r += b[i]\n        if r < 0:\n            print(\"NO\")\n            return\n    print(\"YES\")\n\n\nif __name__ == '__main__':\n    main()", "\n\nn, r = [int(x) for x in input().split()]\n\nfor i in range(n):\n    a, b = [int(x) for x in input().split()]\n    if a > r:\n        print(\"NO\")\n        exit()\n    r += b\n\nif r >= 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "\n\nn, r = map(int, input().split())\n\nprojects = []\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\ndef solve(n, r, projects):\n    projects.sort(key=lambda x: x[1])\n    for i in range(n):\n        r += projects[i][1]\n        if r < projects[i][0]:\n            return \"NO\"\n    return \"YES\"\n\nprint(solve(n, r, projects))"]