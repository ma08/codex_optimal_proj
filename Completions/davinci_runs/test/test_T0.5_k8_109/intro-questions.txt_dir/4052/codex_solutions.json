["\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    if s == t:\n        print(\"0\")\n        return\n    if len(set(s)) == 1:\n        print(\"-1\")\n        return\n    r = []\n    for i in range(n):\n        if s[i] != t[i]:\n            if s[i+1] != t[i] and i+1 < n:\n                r.append(i+1)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n            else:\n                r.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n    if s != t:\n        print(\"-1\")\n        return\n    else:\n        print(len(r))\n        print(*r)\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\ns = input()\nt = input()\n\ndef check(s, t):\n    if s == t:\n        return True\n    else:\n        return False\n\ndef move(s, t, c):\n    if c == n:\n        return check(s, t)\n    else:\n        return move(s, t, c+1) or move(s[:c] + s[c+1] + s[c] + s[c+2:], t, c+1) or move(s[:c] + s[c+2] + s[c+1] + s[c] + s[c+3:], t, c+1)\n\nif move(s, t, 0):\n    print(0)\nelse:\n    print(-1)", "\n\nn = int(input())\ns = input()\nt = input()\n\nif s == t:\n    print(0)\n    exit()\n\n# check if it is possible to transform s to t\nfor i in range(n):\n    if s[i] != t[i]:\n        break\n\nif i == n - 1:\n    print(-1)\n    exit()\n\n# find the first occurrence of a letter in t that is not in s\nfor j in range(i + 1, n):\n    if t[j] not in s[i:j]:\n        break\n\n# find the first occurrence of the letter in s\nfor k in range(i, j):\n    if s[k] == t[j]:\n        break\n\n# swap the letters\ns = s[:k] + t[j] + s[k + 1:j] + s[k] + s[j + 1:]\n\n# print the number of moves and the indices of the letters to be swapped\nprint(1)\nprint(k, j)", "\n\nimport sys\n\ndef main():\n    # read input\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    # init\n    moves = []\n    for i in range(n):\n        if s[i] != t[i]:\n            moves.append(i)\n\n    # check if possible\n    if len(moves) > 10000:\n        print('-1')\n        return\n\n    # print moves\n    print(len(moves))\n    for i in moves:\n        print(i + 1, end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    if s == t:\n        print(0)\n        return\n\n    # Create a hash table of all positions of each letter in s\n    s_hash = {}\n    for i in range(n):\n        if s[i] in s_hash:\n            s_hash[s[i]].append(i)\n        else:\n            s_hash[s[i]] = [i]\n\n    # Create an array of all positions of each letter in t\n    t_arr = []\n    for i in range(n):\n        t_arr.append(s_hash[t[i]].pop(0))\n\n    # Count how many times each letter occurs in t\n    t_hash = {}\n    for i in range(n):\n        if t[i] in t_hash:\n            t_hash[t[i]] += 1\n        else:\n            t_hash[t[i]] = 1\n\n    # Create a list of all moves needed to move each letter to its correct position\n    moves = []\n    for i in range(n):\n        # If the letter at index i is not in the correct position\n        if t_arr[i] != i:\n            # Get the index of the letter currently at index i in t\n            index = t_arr.index(i)\n\n            # Swap the letter at index i with the letter at index index\n            t_arr[i], t_arr[index] = t_arr[index], t_arr[i]\n\n            # Add the move to the list\n            moves.append(index)\n\n    # If the number of moves is greater than 10^4, it is impossible to transform s into t using less than 10^4 moves\n    if len(moves) > 10000:\n        print(\"-1\")\n        return\n\n    # Print the number of moves\n    print(len(moves))\n\n    # Print the list of moves\n    for i in range(len(moves)):\n        print(moves[i], end=\" \")\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    s_idx = 0\n    t_idx = 0\n    swaps = 0\n    swap_idxs = []\n\n    while t_idx < n:\n        if s[s_idx] == t[t_idx]:\n            s_idx += 1\n            t_idx += 1\n        else:\n            # swap\n            swaps += 1\n            swap_idxs.append(s_idx)\n            s_idx += 2\n            if s_idx > n:\n                print(-1)\n                return\n\n    if swaps > 10000:\n        print(-1)\n        return\n\n    print(swaps)\n    print(' '.join(map(str, swap_idxs)))\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(n, s, t):\n    \"\"\"\n    >>> solve(6, \"abcdef\", \"abdfec\")\n    '4\\\\n3 5 4 5 '\n    >>> solve(4, \"abcd\", \"accd\")\n    '-1'\n    \"\"\"\n\n    # # brute force\n    # # O(n * 2^n)\n    # # dp[s] = min(dp[s], dp[s[:i] + s[i+1:j] + s[i] + s[j+1:]] + 1)\n    # # dp[s] = min(dp[s], dp[s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]] + 1)\n    # dp = {s : 0}\n    # for i in range(n):\n    #     for j in range(i + 1, n):\n    #         for s in dp.keys():\n    #             if s[i] != s[j]:\n    #                 dp[s[:i] + s[i+1:j] + s[i] + s[j+1:]] = min(dp.get(s[:i] + s[i+1:j] + s[i] + s[j+1:], float('inf')), dp[s] + 1)\n    #                 dp[s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]] = min(dp.get(s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:], float('inf')), dp[s] + 1)\n    # if t not in dp:\n    #     return '-1'\n    # return '{}\\\\n{}'.format(dp[t], ' '.join(map(str, [i for i in range(n - 1) if dp[s[:i] + s[i+1:]] + 1 == dp[t]])))\n\n    # O(n)\n    # 1. find the first mismatch\n    # 2. find the first match after mismatch\n    # 3. swap\n    # 4. repeat 1-3 until all matches\n    # 5. swap the rest\n    i = 0\n    while i < n:\n        if s[i] == t[i]:\n            i += 1\n        else:\n            break\n    j = i\n    while j < n:\n        if s[j] == t[j]:\n            j += 1\n        else:\n            break\n    if j == n:\n        return '-1'\n    if j == n - 1:\n        return '1\\\\n{}'.format(i)\n    if j == i + 1:\n        return '2\\\\n{} {}'.format(i, j)\n    return '{}\\\\n{} {} {}'.format(j - i, i, j, j)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    # n = int(raw_input())\n    # s = raw_input()\n    # t = raw_input()\n    # print solve(n, s, t)", "\n\n\ndef get_swaps(s, t):\n    if s == t:\n        return 0, []\n    swaps = []\n    for i in range(len(s) - 1):\n        if s[i:i+2] == t[i:i+2]:\n            continue\n        if s[i:i+2] == t[i+1:i+3]:\n            swaps.append(i)\n            s = s[:i] + t[i:i+2] + s[i+2:]\n        elif s[i:i+2] == t[i-1:i+1]:\n            swaps.append(i-1)\n            s = s[:i-1] + t[i-1:i+1] + s[i+1:]\n    return len(swaps), swaps\n\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    k, swaps = get_swaps(s, t)\n    if k > 10000:\n        print(-1)\n    else:\n        print(k)\n        print(*swaps)\n\n\nif __name__ == \"__main__\":\n    main()"]