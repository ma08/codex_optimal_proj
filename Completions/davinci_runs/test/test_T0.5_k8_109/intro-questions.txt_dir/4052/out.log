2022-04-09 23:12:36.164861 """
You are given two strings $s$ and $t$. Both strings have length $n$ and consist of lowercase Latin letters. The characters in the strings are numbered from $1$ to $n$.

You can successively perform the following move any number of times (possibly, zero):  swap any two adjacent (neighboring) characters of $s$ (i.e. for any $i = \{1, 2, \dots, n - 1\}$ you can swap $s_i$ and $s_{i + 1})$. 

You can't apply a move to the string $t$. The moves are applied to the string $s$ one after another.

Your task is to obtain the string $t$ from the string $s$. Find any way to do it with at most $10^4$ such moves.

You do not have to minimize the number of moves, just find any sequence of moves of length $10^4$ or less to transform $s$ into $t$.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 50$) — the length of strings $s$ and $t$.

The second line of the input contains the string $s$ consisting of $n$ lowercase Latin letters.

The third line of the input contains the string $t$ consisting of $n$ lowercase Latin letters.


-----Output-----

If it is impossible to obtain the string $t$ using moves, print "-1".

Otherwise in the first line print one integer $k$ — the number of moves to transform $s$ to $t$. Note that $k$ must be an integer number between $0$ and $10^4$ inclusive.

In the second line print $k$ integers $c_j$ ($1 \le c_j < n$), where $c_j$ means that on the $j$-th move you swap characters $s_{c_j}$ and $s_{c_j + 1}$.

If you do not need to apply any moves, print a single integer $0$ in the first line and either leave the second line empty or do not print it at all.


-----Examples-----
Input
6
abcdef
abdfec

Output
4
3 5 4 5 

Input
4
abcd
accd

Output
-1



-----Note-----

In the first example the string $s$ changes as follows: "abcdef" $\rightarrow$ "abdcef" $\rightarrow$ "abdcfe" $\rightarrow$ "abdfce" $\rightarrow$ "abdfec".

In the second example there is no way to transform the string $s$ into the string $t$ through any allowed moves.
"""
2022-04-09 23:12:36.164938 --------------------------
2022-04-09 23:13:22.629444 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\nt = input()\n\nif s == t:\n    print(0)\n    exit()\n\n# check if it is possible to transform s to t\nfor i in range(n):\n    if s[i] != t[i]:\n        break\n\nif i == n - 1:\n    print(-1)\n    exit()\n\n# find the first occurrence of a letter in t that is not in s\nfor j in range(i + 1, n):\n    if t[j] not in s[i:j]:\n        break\n\n# find the first occurrence of the letter in s\nfor k in range(i, j):\n    if s[k] == t[j]:\n        break\n\n# swap the letters\ns = s[:k] + t[j] + s[k + 1:j] + s[k] + s[j + 1:]\n\n# print the number of moves and the indices of the letters to be swapped\nprint(1)\nprint(k, j)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef solve(n, s, t):\n    \"\"\"\n    >>> solve(6, \"abcdef\", \"abdfec\")\n    '4\\\\n3 5 4 5 '\n    >>> solve(4, \"abcd\", \"accd\")\n    '-1'\n    \"\"\"\n\n    # # brute force\n    # # O(n * 2^n)\n    # # dp[s] = min(dp[s], dp[s[:i] + s[i+1:j] + s[i] + s[j+1:]] + 1)\n    # # dp[s] = min(dp[s], dp[s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]] + 1)\n    # dp = {s : 0}\n    # for i in range(n):\n    #     for j in range(i + 1, n):\n    #         for s in dp.keys():\n    #             if s[i] != s[j]:\n    #                 dp[s[:i] + s[i+1:j] + s[i] + s[j+1:]] = min(dp.get(s[:i] + s[i+1:j] + s[i] + s[j+1:], float('inf')), dp[s] + 1)\n    #                 dp[s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]] = min(dp.get(s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:], float('inf')), dp[s] + 1)\n    # if t not in dp:\n    #     return '-1'\n    # return '{}\\\\n{}'.format(dp[t], ' '.join(map(str, [i for i in range(n - 1) if dp[s[:i] + s[i+1:]] + 1 == dp[t]])))\n\n    # O(n)\n    # 1. find the first mismatch\n    # 2. find the first match after mismatch\n    # 3. swap\n    # 4. repeat 1-3 until all matches\n    # 5. swap the rest\n    i = 0\n    while i < n:\n        if s[i] == t[i]:\n            i += 1\n        else:\n            break\n    j = i\n    while j < n:\n        if s[j] == t[j]:\n            j += 1\n        else:\n            break\n    if j == n:\n        return '-1'\n    if j == n - 1:\n        return '1\\\\n{}'.format(i)\n    if j == i + 1:\n        return '2\\\\n{} {}'.format(i, j)\n    return '{}\\\\n{} {} {}'.format(j - i, i, j, j)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    # n = int(raw_input())\n    # s = raw_input()\n    # t = raw_input()\n    # print solve(n, s, t)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    if s == t:\n        print(0)\n        return\n\n    # Create a hash table of all positions of each letter in s\n    s_hash = {}\n    for i in range(n):\n        if s[i] in s_hash:\n            s_hash[s[i]].append(i)\n        else:\n            s_hash[s[i]] = [i]\n\n    # Create an array of all positions of each letter in t\n    t_arr = []\n    for i in range(n):\n        t_arr.append(s_hash[t[i]].pop(0))\n\n    # Count how many times each letter occurs in t\n    t_hash = {}\n    for i in range(n):\n        if t[i] in t_hash:\n            t_hash[t[i]] += 1\n        else:\n            t_hash[t[i]] = 1\n\n    # Create a list of all moves needed to move each letter to its correct position\n    moves = []\n    for i in range(n):\n        # If the letter at index i is not in the correct position\n        if t_arr[i] != i:\n            # Get the index of the letter currently at index i in t\n            index = t_arr.index(i)\n\n            # Swap the letter at index i with the letter at index index\n            t_arr[i], t_arr[index] = t_arr[index], t_arr[i]\n\n            # Add the move to the list\n            moves.append(index)\n\n    # If the number of moves is greater than 10^4, it is impossible to transform s into t using less than 10^4 moves\n    if len(moves) > 10000:\n        print(\"-1\")\n        return\n\n    # Print the number of moves\n    print(len(moves))\n\n    # Print the list of moves\n    for i in range(len(moves)):\n        print(moves[i], end=\" \")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    s_idx = 0\n    t_idx = 0\n    swaps = 0\n    swap_idxs = []\n\n    while t_idx < n:\n        if s[s_idx] == t[t_idx]:\n            s_idx += 1\n            t_idx += 1\n        else:\n            # swap\n            swaps += 1\n            swap_idxs.append(s_idx)\n            s_idx += 2\n            if s_idx > n:\n                print(-1)\n                return\n\n    if swaps > 10000:\n        print(-1)\n        return\n\n    print(swaps)\n    print(' '.join(map(str, swap_idxs)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n\ndef get_swaps(s, t):\n    if s == t:\n        return 0, []\n    swaps = []\n    for i in range(len(s) - 1):\n        if s[i:i+2] == t[i:i+2]:\n            continue\n        if s[i:i+2] == t[i+1:i+3]:\n            swaps.append(i)\n            s = s[:i] + t[i:i+2] + s[i+2:]\n        elif s[i:i+2] == t[i-1:i+1]:\n            swaps.append(i-1)\n            s = s[:i-1] + t[i-1:i+1] + s[i+1:]\n    return len(swaps), swaps\n\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    k, swaps = get_swaps(s, t)\n    if k > 10000:\n        print(-1)\n    else:\n        print(k)\n        print(*swaps)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\nt = input()\n\ndef check(s, t):\n    if s == t:\n        return True\n    else:\n        return False\n\ndef move(s, t, c):\n    if c == n:\n        return check(s, t)\n    else:\n        return move(s, t, c+1) or move(s[:c] + s[c+1] + s[c] + s[c+2:], t, c+1) or move(s[:c] + s[c+2] + s[c+1] + s[c] + s[c+3:], t, c+1)\n\nif move(s, t, 0):\n    print(0)\nelse:\n    print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    # read input\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    # init\n    moves = []\n    for i in range(n):\n        if s[i] != t[i]:\n            moves.append(i)\n\n    # check if possible\n    if len(moves) > 10000:\n        print('-1')\n        return\n\n    # print moves\n    print(len(moves))\n    for i in moves:\n        print(i + 1, end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    if s == t:\n        print(\"0\")\n        return\n    if len(set(s)) == 1:\n        print(\"-1\")\n        return\n    r = []\n    for i in range(n):\n        if s[i] != t[i]:\n            if s[i+1] != t[i] and i+1 < n:\n                r.append(i+1)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n            else:\n                r.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n    if s != t:\n        print(\"-1\")\n        return\n    else:\n        print(len(r))\n        print(*r)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649560356,
  "id": "cmpl-4vII8pnsg0mVLRe906eCMuPIQISst",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 23:13:22.629767 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\nt = input()\n\nif s == t:\n    print(0)\n    exit()\n\n# check if it is possible to transform s to t\nfor i in range(n):\n    if s[i] != t[i]:\n        break\n\nif i == n - 1:\n    print(-1)\n    exit()\n\n# find the first occurrence of a letter in t that is not in s\nfor j in range(i + 1, n):\n    if t[j] not in s[i:j]:\n        break\n\n# find the first occurrence of the letter in s\nfor k in range(i, j):\n    if s[k] == t[j]:\n        break\n\n# swap the letters\ns = s[:k] + t[j] + s[k + 1:j] + s[k] + s[j + 1:]\n\n# print the number of moves and the indices of the letters to be swapped\nprint(1)\nprint(k, j)"
}
2022-04-09 23:13:22.629891 REASON stop
2022-04-09 23:13:22.641765 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef solve(n, s, t):\n    \"\"\"\n    >>> solve(6, \"abcdef\", \"abdfec\")\n    '4\\\\n3 5 4 5 '\n    >>> solve(4, \"abcd\", \"accd\")\n    '-1'\n    \"\"\"\n\n    # # brute force\n    # # O(n * 2^n)\n    # # dp[s] = min(dp[s], dp[s[:i] + s[i+1:j] + s[i] + s[j+1:]] + 1)\n    # # dp[s] = min(dp[s], dp[s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]] + 1)\n    # dp = {s : 0}\n    # for i in range(n):\n    #     for j in range(i + 1, n):\n    #         for s in dp.keys():\n    #             if s[i] != s[j]:\n    #                 dp[s[:i] + s[i+1:j] + s[i] + s[j+1:]] = min(dp.get(s[:i] + s[i+1:j] + s[i] + s[j+1:], float('inf')), dp[s] + 1)\n    #                 dp[s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]] = min(dp.get(s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:], float('inf')), dp[s] + 1)\n    # if t not in dp:\n    #     return '-1'\n    # return '{}\\\\n{}'.format(dp[t], ' '.join(map(str, [i for i in range(n - 1) if dp[s[:i] + s[i+1:]] + 1 == dp[t]])))\n\n    # O(n)\n    # 1. find the first mismatch\n    # 2. find the first match after mismatch\n    # 3. swap\n    # 4. repeat 1-3 until all matches\n    # 5. swap the rest\n    i = 0\n    while i < n:\n        if s[i] == t[i]:\n            i += 1\n        else:\n            break\n    j = i\n    while j < n:\n        if s[j] == t[j]:\n            j += 1\n        else:\n            break\n    if j == n:\n        return '-1'\n    if j == n - 1:\n        return '1\\\\n{}'.format(i)\n    if j == i + 1:\n        return '2\\\\n{} {}'.format(i, j)\n    return '{}\\\\n{} {} {}'.format(j - i, i, j, j)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    # n = int(raw_input())\n    # s = raw_input()\n    # t = raw_input()\n    # print solve(n, s, t)"
}
2022-04-09 23:13:22.641866 REASON stop
2022-04-09 23:13:22.642681 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    if s == t:\n        print(0)\n        return\n\n    # Create a hash table of all positions of each letter in s\n    s_hash = {}\n    for i in range(n):\n        if s[i] in s_hash:\n            s_hash[s[i]].append(i)\n        else:\n            s_hash[s[i]] = [i]\n\n    # Create an array of all positions of each letter in t\n    t_arr = []\n    for i in range(n):\n        t_arr.append(s_hash[t[i]].pop(0))\n\n    # Count how many times each letter occurs in t\n    t_hash = {}\n    for i in range(n):\n        if t[i] in t_hash:\n            t_hash[t[i]] += 1\n        else:\n            t_hash[t[i]] = 1\n\n    # Create a list of all moves needed to move each letter to its correct position\n    moves = []\n    for i in range(n):\n        # If the letter at index i is not in the correct position\n        if t_arr[i] != i:\n            # Get the index of the letter currently at index i in t\n            index = t_arr.index(i)\n\n            # Swap the letter at index i with the letter at index index\n            t_arr[i], t_arr[index] = t_arr[index], t_arr[i]\n\n            # Add the move to the list\n            moves.append(index)\n\n    # If the number of moves is greater than 10^4, it is impossible to transform s into t using less than 10^4 moves\n    if len(moves) > 10000:\n        print(\"-1\")\n        return\n\n    # Print the number of moves\n    print(len(moves))\n\n    # Print the list of moves\n    for i in range(len(moves)):\n        print(moves[i], end=\" \")\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:13:22.642799 REASON stop
2022-04-09 23:13:22.643382 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n\n    s_idx = 0\n    t_idx = 0\n    swaps = 0\n    swap_idxs = []\n\n    while t_idx < n:\n        if s[s_idx] == t[t_idx]:\n            s_idx += 1\n            t_idx += 1\n        else:\n            # swap\n            swaps += 1\n            swap_idxs.append(s_idx)\n            s_idx += 2\n            if s_idx > n:\n                print(-1)\n                return\n\n    if swaps > 10000:\n        print(-1)\n        return\n\n    print(swaps)\n    print(' '.join(map(str, swap_idxs)))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 23:13:22.643462 REASON stop
2022-04-09 23:13:22.643724 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n\ndef get_swaps(s, t):\n    if s == t:\n        return 0, []\n    swaps = []\n    for i in range(len(s) - 1):\n        if s[i:i+2] == t[i:i+2]:\n            continue\n        if s[i:i+2] == t[i+1:i+3]:\n            swaps.append(i)\n            s = s[:i] + t[i:i+2] + s[i+2:]\n        elif s[i:i+2] == t[i-1:i+1]:\n            swaps.append(i-1)\n            s = s[:i-1] + t[i-1:i+1] + s[i+1:]\n    return len(swaps), swaps\n\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    k, swaps = get_swaps(s, t)\n    if k > 10000:\n        print(-1)\n    else:\n        print(k)\n        print(*swaps)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:13:22.643761 REASON stop
2022-04-09 23:13:22.643953 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\nt = input()\n\ndef check(s, t):\n    if s == t:\n        return True\n    else:\n        return False\n\ndef move(s, t, c):\n    if c == n:\n        return check(s, t)\n    else:\n        return move(s, t, c+1) or move(s[:c] + s[c+1] + s[c] + s[c+2:], t, c+1) or move(s[:c] + s[c+2] + s[c+1] + s[c] + s[c+3:], t, c+1)\n\nif move(s, t, 0):\n    print(0)\nelse:\n    print(-1)"
}
2022-04-09 23:13:22.643980 REASON stop
2022-04-09 23:13:22.644166 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    # read input\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    # init\n    moves = []\n    for i in range(n):\n        if s[i] != t[i]:\n            moves.append(i)\n\n    # check if possible\n    if len(moves) > 10000:\n        print('-1')\n        return\n\n    # print moves\n    print(len(moves))\n    for i in moves:\n        print(i + 1, end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 23:13:22.644190 REASON stop
2022-04-09 23:13:22.644382 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    if s == t:\n        print(\"0\")\n        return\n    if len(set(s)) == 1:\n        print(\"-1\")\n        return\n    r = []\n    for i in range(n):\n        if s[i] != t[i]:\n            if s[i+1] != t[i] and i+1 < n:\n                r.append(i+1)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n            else:\n                r.append(i)\n                s = s[:i] + s[i+1] + s[i] + s[i+2:]\n    if s != t:\n        print(\"-1\")\n        return\n    else:\n        print(len(r))\n        print(*r)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 23:13:22.644408 REASON stop
