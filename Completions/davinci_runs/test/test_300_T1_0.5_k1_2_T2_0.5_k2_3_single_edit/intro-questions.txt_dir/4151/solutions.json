["mod = 998244353\n\nn = int(input())\n\na = list(map(int, input().split()))\n\nd = {}\n\nfor i in range(n):\n\tif a[i] not in d:\n\t\td[a[i]] = (i, i)\n\telse:\n\t\td[a[i]] = (d[a[i]][0], i)\n\nd2 = {}\n\nfor k, v in list(d.items()):\n\tif v[0] != v[1]:\n\t\td2[k] = v\n\nactive, ans = 0, 1\n\nfor i in range(n - 1):\n\tif a[i] in d2:\n\t\tif i == d2[a[i]][0]:\n\t\t\tactive += 1\n\t\tif i == d2[a[i]][1]:\n\t\t\tactive -= 1\n\tif active == 0:\n\t\tans = (ans * 2) % mod\n\nprint(ans)\n", "import math\nmod=998244353 \nn=int(input())\narr=list(map(int,input().split()))\ndict1={}\ndict2={}\nfor i in range(len(arr)):\n    try:\n        dict1[arr[i]]+=1\n        dict1[arr[i]]-=1\n        try:\n            dict2[arr[i]][1]=i+1\n        except:\n            KeyError\n            dict2[arr[i]]=[dict1[arr[i]]]\n            dict2[arr[i]].append(i+1)\n    except:\n        KeyError\n        dict1[arr[i]]=i+1\narrx=[]\nfor i in list(dict2.keys()):\n    arrx.append((dict2[i][0],dict2[i][1]))\narrx.sort()\n#print(*arrx)\ncount=0\nindexes=0\nif(len(arrx)==0):\n    print(pow(2,n-1,mod))\nelse:\n    flag=0\n    minval=arrx[0][0]\n    maxval=arrx[0][1]\n    if(minval==1):\n        count=-1\n        flag=1\n    indexes=maxval-minval+1\n    for i in range(1,len(arrx)):\n        if(arrx[i][0]>maxval):\n            count+=1\n            minval=arrx[i][0]\n            maxval=arrx[i][1]\n            indexes+=maxval-minval+1\n        else:\n            indexes+=max(0,arrx[i][1]-maxval)\n            maxval=max(maxval,arrx[i][1])\n    count+=1\n    rem=n-indexes\n    #print(rem,count)\n    if(flag==1):\n        countx=count+rem\n    else:\n        countx=count+rem-1\n    print(pow(2,countx,mod))\n", "class SegmentTree(object):\n    __slots__ = [\"elem_size\", \"tree\", \"default\", \"op\"]\n\n    def __init__(self, a: list, default: int, op):\n        import math\n        real_size = len(a)\n        self.elem_size = elem_size = 1 << math.ceil(math.log(real_size, 2))\n        self.tree = tree = [default] * (elem_size * 2)\n        tree[elem_size:elem_size+real_size] = a\n        self.default = default\n        self.op = op\n\n        for i in range(elem_size - 1, 0, -1):\n            tree[i] = op(tree[i << 1], tree[(i << 1)+1])\n\n    def get_value(self, x: int, y: int) -> int:\n        l, r = x + self.elem_size, y + self.elem_size\n        tree, result, op = self.tree, self.default, self.op\n        while l < r:\n            if l & 1:\n                result = op(tree[l], result)\n                l += 1\n            if r & 1:\n                r -= 1\n                result = op(tree[r], result)\n            l, r = l >> 1, r >> 1\n\n        return result\n\n    def set_value(self, i: int, value: int) -> None:\n        k = self.elem_size + i\n        self.tree[k] = value\n        self.update(k)\n\n    def update(self, i: int) -> None:\n        op, tree = self.op, self.tree\n        while i > 1:\n            i >>= 1\n            tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n\ndef __starting_point():\n    from collections import defaultdict\n    N = int(input())\n    a = list(map(int, input().split()))\n    index_dict = defaultdict(list)\n    for i, n in enumerate(a):\n        index_dict[n].append(i)\n\n    last_num = 0\n    ans = []\n    append = ans.append\n    segtree = SegmentTree([10**6]*(N+1), 10**6, min)\n    getv, setv = segtree.get_value, segtree.set_value\n\n    for i, n in enumerate(a):\n        if not index_dict[n]:\n            continue\n        last_num = min(last_num+1, getv(i+1, N+1))\n        for j in index_dict[n]:\n            setv(j, last_num)\n        append(last_num)\n        index_dict[n] = []\n\n    mod = 998244353\n\n    ans = pow(2, len(set(ans))-1, mod)\n    print(ans)\n__starting_point()", "n=int(input())\na=[int(i) for i in input().split()]\ns=list(set(a))\nN=len(s)\nd={}\nl={}\nfor i in range(N):\n\td[s[i]]=0\n\tl[s[i]]=0\nfor i in range(n):\n\td[a[i]]+=1\nans=0\n#print(d)\ncting=0\nfor i in range(n):\n\ttemp=d[a[i]]\n\tif temp>1 and l[a[i]]==0:\n\t\tl[a[i]]=1\n\t\tcting+=1\n\t\tif cting==1:\n\t\t\tans+=1\n\t\td[a[i]]-=1\n\t\t\t\n\telif l[a[i]]==1:\n\t\td[a[i]]-=1\n\t\tif temp-1==0:\n\t\t\tcting-=1\n\t\n\telif cting==0:\n\t\tans+=1\n\t\t\nprint(pow(2,ans-1,998244353))\n\n\n", "n = int(input())\na = [int(x) for x in input().split()]\n\nlasts = {}\nfor i in range(n):\n\tlasts[a[i]] = i\n\ndss = {x: x for x in a}\nchanged = True\nwhile changed:\n\tchanged = False\n\tfor i in range(1, n):\n\t\tif dss[a[i-1]] != dss[a[i]] or lasts[a[i-1]] != lasts[a[i]]:\n\t\t\tif lasts[a[i-1]] >= i:\n\t\t\t\tchanged = True\n\t\t\t\tlasts[a[i-1]] = lasts[a[i]] = max(lasts[a[i-1]], lasts[a[i]])\n\t\t\t\tdss[a[i-1]] = dss[a[i]] = min(dss[a[i-1]], dss[a[i]])\n\nM = 998244353\n\ndef powmod(x, p, m = M):\n\tif x == 0:\n\t\treturn 0\n\tif p == 0:\n\t\treturn 1\n\treturn (powmod(x*x, p//2)%m) * (x if p%2 == 1 else 1) % m\n\nkinds = len(set(dss.values()))\nans = powmod(2, kinds-1)\n\n#print(n, a, dss, lasts, kinds)\n#print([powmod(2, i, 13) for i in range(10)])\n\nprint(ans)", "\nn = int(input())\n\nL = [int(x) for x in input().split()]\n\nD = {}\n\nfor i in L:\n    if i in D:\n        D[i] += 1\n    else:\n        D[i] = 1\n        \nP = {}\n\nfor i in range(n):\n    P[L[i]] = i\n\nans = 1\nindex = 0\nfor i in range(n):\n    if i <= index:\n        if D[L[i]] > 1:\n            index = max(P[L[i]],index)\n    else:\n        ans *= 2\n        ans = ans % 998244353\n        index = P[L[i]]\n\nprint(ans)", "mod = 998244353\nn = int(input())\n\na = list(map(int,input().split()))\n\nd = {}\n\nfor i in range(n):\n\tif a[i] in d:\n\t\td[a[i]].append(i)\n\telse:\n\t\td[a[i]] = [i,]\n\ni = 1\nans = 1\ncurr = 0\nd2 = {}\nma = d[a[0]][-1]\nd2[a[0]] = 1\n\nwhile i<n:\n\tl = d[a[i]]\n\tif a[i] in d2:\n\t\ti += 1\n\telif i>ma:\n\t\tans = (ans * 2)%mod\n\t\td2[a[i]] = 1\n\telse:\n\t\td2[a[i]] = 1\n\tma = max(ma,l[-1])\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nmod=998244353\n\n\nINIT=dict()\nLAST=dict()\n\nfor i in range(n):\n    if INIT.get(A[i])==None:\n        INIT[A[i]]=i\n    LAST[A[i]]=i\n\n\n\nANS=0\nNOW=0\ni=0\nwhile i<n:\n    NOW=LAST[A[i]]\n    while i<n and i<=NOW:\n        if LAST[A[i]]>NOW:\n            NOW=LAST[A[i]]\n\n        i+=1\n\n    if i==n:\n        break\n    else:\n        ANS+=1\n        \n\nprint(pow(2,ANS,mod))\n\n    \n    \n", "from sys import stdin, stdout\nfrom math import *\nfrom heapq import *\nfrom collections import *\n\ndef main():\n    n=int(stdin.readline())\n    a=[int(x) for x in stdin.readline().split()]\n    b=[2]*(n+2)\n    maxR={}\n    minL={}\n    for i in range(n):\n        x=a[i]\n        maxR[x]=i\n        minL[x]=minL.get(x,i)\n    f=[0]*(n+2)\n    for i in range(n):\n        x=a[i]\n        l=minL[x]\n        r=maxR[x]\n        if (l<r):\n            if (r==l-1):\n                b[r]=1\n            else:\n                f[l+1]=f[l+1]+1\n                f[r+1]=f[r+1]-1\n    res=1\n    for i in range(1,n):\n        f[i]=f[i]+f[i-1]\n        if (f[i]>0):\n            b[i]=1\n        res=(res*b[i])%998244353 \n    stdout.write(str(res))\n    return 0\n\ndef __starting_point():\n    main()\n__starting_point()", "def read(type = 1):\n    if type:\n        file = open(\"input.dat\", \"r\")\n        n = int(file.readline())\n        line = list(map(int, file.readline().split()))\n        file.close()\n    else:\n        n = int(input().strip())\n        line = list(map(int, input().strip().split()))\n    return n, line\n\n\ndef solve():\n    MOD = 998244353\n    sol = 0.5\n    ranges = {}\n    pos = 0\n    for v in a:\n        if v not in ranges:\n            ranges[v] = (pos, pos)\n        else:\n            ranges[v] = (ranges[v][0], pos)\n        pos += 1\n    pos = 0\n    ranges = list(ranges.items())\n    i = 0\n    while pos < n:\n        while 1:\n            if ranges[i][1][0] <= pos:\n                if ranges[i][1][1] > pos:\n                    pos = ranges[i][1][1]\n                i += 1\n                if i == len(ranges):\n                    break\n            else:\n                break\n        sol = int(2 * sol)\n        sol %= MOD\n        pos += 1\n    return sol\n\n\nn, a = read(0)\nsol = solve()\nprint(sol)", "n = int(input())\na = list(map(int, input().strip().split()))\n\nfirst_appearance = dict()\nlast_appearance = dict()\nfor idx, elem in enumerate(a):\n    last_appearance[elem] = idx\n    if elem not in first_appearance:\n        first_appearance[elem] = idx\n\n\n# print(first_appearance)\n# print(last_appearance)\n\nlast_last = -1\nnum_choice_elem = 0\nfor idx, elem in enumerate(a):\n    if idx > 0:\n        if first_appearance[elem] == idx and last_last <= idx:\n            num_choice_elem += 1\n            # print(idx, elem)\n\n    temp = last_appearance[elem]\n    if temp >= idx and last_last <= temp:\n        last_last = temp\n\n\nfinal = 1\nfor _ in range(num_choice_elem):\n    final *= 2\n    final = final % 998244353\n\nprint(final)", "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\nH1 = [0] * (10 ** 5)\nH2 = [0] * (10 ** 5)\nM = []\n\nfor i in range (0, n):\n    x = a[i]\n    h = ((x + 1234) ** 2) % 94999\n    if H1[h] == 0:\n        H1[h] = []\n        H2[h] = []\n    if x not in H1[h]:\n        H1[h].append(x)\n        H2[h].append(i)\n        M.append(i)\n    else:\n        j = H2[h][H1[h].index(x)]\n        while j < M[-1]:\n            M.pop()\n\nm = len(M) - 1\nanswer = 1\np = 2\nwhile m > 0:\n    if m % 2 == 1:\n        answer = (answer * p) % 998244353\n        m = m - 1\n    p = (p * p) % 998244353\n    m = m // 2\n\nprint(answer)", "# import math\n# import sys\nn = int(input().strip())\na = [int(x) for x in input().strip().split(\" \")]\nmod = 998244353\nd = {}\n# c = {}\nf = [0]*(n+2)\nt = [1]*n\nt[0]=0\nfor i in range(n):\n\tif a[i] in d:\n\t\tf[d[a[i]][-1]+1]+=1\n\t\tf[i+1]-=1\n\t\td[a[i]].append(i)\n\telse:\n\t\td[a[i]]=[i]\ns=0\nfor i in range(n):\n\ts+=f[i]\n\tif s>0:\n\t\tt[i]=0\nprint(pow(2,sum(t),mod))", "n = int(input())\nk = [True] * n\na = input().split()\nnum = {}\nline = []\nsweeping = []\n\n\nfor i in range( n ):\n    try:\n        line.append([ num[ a[i] ], i ])\n    except:\n        num[ a[i] ] = i\n\nline.sort()\nif len(line) > 0:\n    sweeping.append(line[0])\n\nfor i in line:\n    start = i[0]\n    end = i[1]\n    if start > sweeping[-1][1]:\n        sweeping.append(i)\n    elif start <= sweeping[-1][1] and end > sweeping[-1][1]:\n        sweeping[-1][1] = end\n\n\nif len(sweeping) == 0:\n    n -= 1\n    ans = 1\n    for i in range(n):\n        ans*=2\n        ans%=998244353\n\nelse:\n    ans = 1\n    for i in range(sweeping[0][0]):\n        ans*=2\n    for i in range(1, len(sweeping) ):\n        for j in range( sweeping[i][0] - sweeping[i-1][1] ):\n            ans*=2\n            ans%=998244353\n    for i in range( n - sweeping[-1][1] - 1):\n        ans*=2\n        ans%=998244353\n\nprint (ans)", "from collections import defaultdict\nn = int(input())\na = [int(x) for x in input().split()]\nd = defaultdict(list)\nfor i in range(n):\n    if a[i] not in d:\n        d[a[i]] = [i,i]\n    d[a[i]][1] = i\n\ncmax = 0\nnum = -1\nfor i in range(n):\n    if d[a[i]][1] > cmax:\n        cmax = d[a[i]][1]\n    if cmax==i:\n        num +=1\nprint(pow(2,num,998244353))", "def step(x):\n    ans = 1\n    for i in range(x):\n        ans = (ans * 2) % 998244353\n    return ans\n\nn = int(input())\narr = input().split()\narr = list(map(lambda x: int(x),arr))\ncounter = 0\nfirst = {}\nlast = {}\nfor x in range(len(arr)):\n    if (arr[x] not in first):\n        first[arr[x]] = x\n        last[arr[x]] = x\n    else:\n        last[arr[x]] = x\narr2 = [0] * n\nfor x in first:\n    arr2[first[x]] += 1\n    arr2[last[x]] -= 1\nsum = 0\nfor i in arr2:\n    if (sum == 0):\n        counter += 1\n    sum += i\ncounter -= 1\nprint(step(counter))", "''' Thruth can only be found at one place - THE CODE '''\n\n''' Copyright 2018, SATYAM KUMAR'''\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\noptimiseForReccursion = False #Can not be used clubbed with TestCases\ndef is_Valid(a,b):\n    #print(a,b)\n    x = min(a,b)\n    y = max(a,b)\n    diff = (y-x)\n    y = y-2*diff\n    x = x-1*diff\n    if x>=0 and y>=0 and x%3==0 and y%3==0:\n        return True\n    return False\n\ndef main():\n    n=get_int()\n    li = get_list()\n    si=dict()\n    ei=dict()\n    index=0\n    for i in li:\n        if i in si:\n            ei[i]=index\n        else:\n            ei[i]=index\n            si[i]=index\n        index+=1\n    g=0\n    g_active=False\n    g_last = -1\n    for i,ele in enumerate(li):\n        if si[ele]==ei[ele] and not g_active:\n            g+=1\n            continue\n        if not g_active and si[ele]!=ei[ele]:\n            g_active=True\n            g_last=ei[ele]\n            g+=1\n        if g_active:\n            g_last=max(g_last,ei[ele])\n            if g_last==i:\n                g_active=False\n    print(pow(2,g-1,998244353))\n    \n\n\n\n\n# --------------------------------------------------------------------- END\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "mod = 998244353\n\nn = int(input())\na = list(map(int,input().split()))\nd = {}\n\nfor i in range(n):\n\td[a[i]] = i\n\ni = 1\nans = 1\nd2 = {}\nma = d[a[0]]\nd2[a[0]] = 1\n\nwhile i<n:\n\ttmp = d[a[i]]\n\tif a[i] in d2:\n\t\ti += 1\n\telif i>ma:\n\t\tans = (ans * 2)%mod\n\t\td2[a[i]] = 1\n\telse:\n\t\td2[a[i]] = 1\n\tma = max(ma,tmp)\n\nprint(ans)", "mod = 998244353\n\nn = int(input())\na = list(map(int,input().split()))\nd = {}\n\nfor i in range(n):\n\td[a[i]] = i\n\ni = 1\nans = 1\nd2 = {}\nma = d[a[0]]\nd2[a[0]] = 1\n\nwhile i<n:\n\ttmp = d[a[i]]\n\tif a[i] in d2:\n\t\ti += 1\n\telif i>ma:\n\t\tans = (ans * 2)%mod\n\t\td2[a[i]] = 1\n\telse:\n\t\td2[a[i]] = 1\n\tma = max(ma,tmp)\n\nprint(ans)", "n=int(input())\na=list(map(int,input().split()))\nintervals={}\nfor i in range(n):\n    if a[i] in intervals:\n        intervals[a[i]][1]=i\n    else:\n        intervals[a[i]]=[i,i]\nnew=[intervals[guy] for guy in intervals]\nnew.sort()\npower=new[0][0]\nlong=new[0][1]\nfor i in range(len(new)-1):\n    if new[i+1][0]<=long:\n        long=max(long,new[i+1][1])\n    else:\n        power+=new[i+1][0]-long\n        long=new[i+1][1]\npower+=n-1-long\nprod=1\nfor i in range(power):\n    prod*=2\n    prod%=998244353\nprint(prod)", "from collections import defaultdict\n\ndef solve():\n    n = int(input())\n    A = [int(k) for k in input().split()]\n\n    mod = 998244353\n    \n    freq = defaultdict(list)\n    \n    for i in range(n):\n        freq[A[i]].append(i)\n    \n    C = []\n    i = 0\n    cache = set()\n    \n    while i < n:\n        C.append(0)\n        cache.add(A[i])\n        \n        start = i\n        i = freq[A[i]][-1]\n        end = i\n        \n        for j in range(start, end):\n            if A[j] not in cache:\n                if freq[A[j]][-1] > i:\n                    i = freq[A[j]][-1]\n\n                cache.add(A[j])\n        \n        start = end\n        end = i\n        \n        for j in range(start, end):\n            if A[j] not in cache:\n                if freq[A[j]][-1] > i:\n                    i = freq[A[j]][-1]\n                cache.add(A[j])\n\n        i += 1\n        \n    print(pow(2, len(C)-1, mod))\n    \nsolve()\n        \n", "n = int(input())\narr = dict()\nl = 0\nst = 0\nfor i in input().split():\n    i = int(i)\n    if(i in arr):\n        arr[i].append(l)\n    else:\n        arr[i] = [l]\n    if(l == 0): st = i\n    l+=1\n    '''\nfor i in arr:\n    arr[i].sort()\n    '''\n\n\n\nsets = 1\nkeys = list(arr.keys())\n\nma = arr[st][-1]\nl = len(keys)\nfor j in range(l-1):\n    i = keys[j]\n    k = keys[j+1]\n    if(ma<arr[k][0]):\n        sets+=1\n        ma = arr[k][-1]\n        #print(ma,k)\n        \n    elif(ma<arr[k][-1]):\n        ma = arr[k][-1]\n#print(sets)\nprint(pow(2,sets-1,998244353))", "MOD = 998244353\ndef pwr(x,y):\n\tif y==0:\n\t\treturn 1\n\tp = pwr(x,y//2)%MOD\n\tp = (p*p) % MOD\n\t\n\tif y%2 == 0:\n\t\treturn p\n\telse:\n\t\treturn ((x*p)%MOD)\nn=int(input())\na=list(map(int,input().split()))\nc = 0\nf=[0]*n\nd={}\nfor i in range(n):\n\td[a[i]]=i\nfor i in range(n):\n\tif i==0:\n\t\tc=0\n\telif f[i]==0:\n\t\tc+=1\n\tif f[i]==0:\n\t\tj=i+1\n\t\tk = d[a[i]]\n\t\twhile j<=k:\n\t\t\tf[j]=1\n\t\t\tk=max(k,d[a[j]])\n\t\t\tj+=1\n\nans = pwr(2,c)\nprint(ans)\n"]