2022-04-19 18:45:01.102327 num operations 1
2022-04-19 18:45:01.102349 size on input set 1
2022-04-19 18:45:01.102595 using api key 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
2022-04-19 18:45:05.909325 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef solve(n, m, k, grid, a, b):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    a, b = map(int, input().split())\n    print(solve(n, m, k, grid, a, b))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef solve(n, m, grid):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n    # for i, row in enumerate(grid):\n    #     for j, cell in enumerate(row):\n    #         if cell == 1:\n    #             if i > 0 and grid[i-1][j] == 0:\n    #                 return 1\n    #             if j > 0 and grid[i][j-1] == 0:\n    #                 return 1\n    #             if i < n-1 and grid[i+1][j] == 0:\n    #                 return 1\n    #             if j < m-1 and grid[i][j+1] == 0:\n    #                 return 1\n    # return 0\ndef solve(n, m, k, grid):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650393901,
  "object": "edit"
}
2022-04-19 18:45:05.909597 fix syntax errors 3 ["\n\ndef solve(n, m, k, grid, a, b):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    a, b = map(int, input().split())\n    print(solve(n, m, k, grid, a, b))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, grid):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n\n    # for i, row in enumerate(grid):\n    #     for j, cell in enumerate(row):\n    #         if cell == 1:\n    #             if i > 0 and grid[i-1][j] == 0:\n    #                 return 1\n    #             if j > 0 and grid[i][j-1] == 0:\n    #                 return 1\n    #             if i < n-1 and grid[i+1][j] == 0:\n    #                 return 1\n    #             if j < m-1 and grid[i][j+1] == 0:\n    #                 return 1\n    # return 0\ndef solve(n, m, k, grid):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-19 18:45:05.909632 size on output set 3
2022-04-19 18:45:05.909643 num operations 1
2022-04-19 18:45:05.909648 size on input set 1
2022-04-19 18:45:05.909822 using api key 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
2022-04-19 18:45:17.708542 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1 # initialize first square\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:  # check row above\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x] # add number of paths from row above\n        if j > 1:  # check column to the left\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x] # add number of paths from column to the left\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for y in range(k+1)] for x in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n"
    },
    {
      "index": 2,
      "text": "\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in raw_input().split()]\n  grid = [[int(x) for x in raw_input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n"
    }
  ],
  "created": 1650393905,
  "object": "edit"
}
2022-04-19 18:45:17.708815 fix syntax errors 3 ['\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1 # initialize first square\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:  # check row above\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x] # add number of paths from row above\n        if j > 1:  # check column to the left\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x] # add number of paths from column to the left\n  \n  print(dp[n][m][k])\n\nif __name__ == "__main__":\n  main()\n', '\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for y in range(k+1)] for x in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == "__main__":\n  main()\n', '\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in raw_input().split()]\n  grid = [[int(x) for x in raw_input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == "__main__":\n  main()\n']
2022-04-19 18:45:17.708858 size on output set 3
