2022-04-12 21:36:01.927949 num operations 2
2022-04-12 21:36:01.927964 size on input set 1
2022-04-12 21:36:05.281811 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "from collections import defaultdict\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799362,
  "object": "edit"
}
2022-04-12 21:36:05.282039 fix spelling mistakes 3 ['\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', 'from collections import defaultdict\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:36:05.282090 size on output set 3
2022-04-12 21:36:05.282097 size on input set 3
2022-04-12 21:36:14.130375 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from collections import defaultdict\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n - 1):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "from collections import defaultdict\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "def main():\n    n = int(input())\n    for i in range(n):\n        print(\"Case #{}: \".format(i + 1), end = \"\")\n        solve()\n\ndef solve():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799365,
  "object": "edit"
}
2022-04-12 21:36:14.130676 fix syntax errors 3 ['from collections import defaultdict\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n - 1):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', 'from collections import defaultdict\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\n\nif __name__ == "__main__":\n    main()\n', 'def main():\n    n = int(input())\n    for i in range(n):\n        print("Case #{}: ".format(i + 1), end = "")\n        solve()\n\ndef solve():\n    pass\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:36:19.831928 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, raw_input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split()) # n is number of nodes, m is number of queries\n    graph = defaultdict(list)\n    for _ in range(n - 1): # input edges\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m): # input queries\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end): # returns distance between start and end node\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query): # checks if a query is valid\n    start = query[0]\n    for v in query[1:]: # checks if all nodes are at distance 1 from start node\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799374,
  "object": "edit"
}
2022-04-12 21:36:19.832129 fix syntax errors 3 ['\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, raw_input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split()) # n is number of nodes, m is number of queries\n    graph = defaultdict(list)\n    for _ in range(n - 1): # input edges\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m): # input queries\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end): # returns distance between start and end node\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query): # checks if a query is valid\n    start = query[0]\n    for v in query[1:]: # checks if all nodes are at distance 1 from start node\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(m):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef bfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if bfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:36:23.676225 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n - 1):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom collections import defaultdict, deque\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        node, dist = queue.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799379,
  "object": "edit"
}
2022-04-12 21:36:23.676407 fix syntax errors 3 ['\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom collections import defaultdict\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n - 1):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, dist = stack.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom collections import defaultdict, deque\n\ndef read_data():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    queries = []\n    for _ in range(n):\n        k = int(input())\n        v = list(map(int, input().split()))\n        queries.append(v)\n    return graph, queries\n\ndef dfs(graph, start, end):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        node, dist = queue.pop()\n        if node == end:\n            return dist\n        if node not in visited:\n            visited.add(node)\n            for child in graph[node]:\n                if child not in visited:\n                    stack.append((child, dist + 1))\n\ndef check_query(graph, query):\n    start = query[0]\n    for v in query[1:]:\n        if dfs(graph, start, v) == 1:\n            return True\n    return False\n\ndef main():\n    graph, queries = read_data()\n    for query in queries:\n        if check_query(graph, query):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:36:23.676454 size on output set 9
2022-04-12 21:36:23.676465 num operations 2
2022-04-12 21:36:23.676470 size on input set 1
2022-04-12 21:36:28.952832 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution \n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    }
  ],
  "created": 1649799383,
  "object": "edit"
}
2022-04-12 21:36:28.953112 fix spelling mistakes 3 ['\n\n# Solution \n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n']
2022-04-12 21:36:28.953200 size on output set 3
2022-04-12 21:36:28.953207 size on input set 3
2022-04-12 21:36:35.733647 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline()\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input.split())\n\ndef read_array(f=int):\n    return list(map(f, input.split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input.split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution to https://codeforces.com/contest/1324/problem/E\n\nimport sys\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n# https://www.hackerrank.com/challenges/even-tree/problem\n# Solution\n\nimport sys\nimport math\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).__next__\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    }
  ],
  "created": 1649799388,
  "object": "edit"
}
2022-04-12 21:36:35.733924 fix syntax errors 3 ['\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline()\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input.split())\n\ndef read_array(f=int):\n    return list(map(f, input.split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input.split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n\n# Solution to https://codeforces.com/contest/1324/problem/E\n\nimport sys\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n# https://www.hackerrank.com/challenges/even-tree/problem\n# Solution\n\nimport sys\nimport math\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).__next__\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n']
2022-04-12 21:36:51.702676 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline # replace with open(filename).readline()\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline # replace with open(filename).readline()\n\ndef read():\n    return tuple(map(int, input().split()))\n\ndef read_array(f=int):\n    return list(map(f, input().split()))\n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n\ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).__next__\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n# input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    }
  ],
  "created": 1649799395,
  "object": "edit"
}
2022-04-12 21:36:51.702958 fix syntax errors 3 ['\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline # replace with open(filename).readline()\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline # replace with open(filename).readline()\n\ndef read():\n    return tuple(map(int, input().split()))\n\ndef read_array(f=int):\n    return list(map(f, input().split()))\n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads H lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n\ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).__next__\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n# input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read\n# If you need to read a space-separated list of integers, use read_array\n# If you need to read a space-separated matrix of integers, use read_matrix\n# If you need to read a space-separated list of integers of unknown length, use read_tuple\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n']
2022-04-12 21:36:58.043542 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Apr  1 00:00:23 2020\n\n@author: ritambasu\n\"\"\"\n\n\"\"\"\nThis is a template file, you can use it to solve all the sub-problems of the \nproblem set. You can use the read_* functions to read the input, and then write\nyour code to solve the problem.\n\nIf you have any trouble, please do not hesitate to contact us!\n\nGood luck!\n\"\"\"\n\n# Solution \n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution \n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter(['10 6', '1 2', '1 3', '1 4', '2 5', '2 6', '3 7', '7 8', '7 9', '9 10', '4 3 8 9 10', '3 2 4 6', '3 2 1 5', '3 4 8 2', '2 6 10', '3 5 4 7']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split()))\n\ndef read_matrix(H, W, f=int):\n    '''\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n\ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print(\"YES\")\n    else:\n        print(\"YES\" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else \"NO\")\n"
    }
  ],
  "created": 1649799411,
  "object": "edit"
}
2022-04-12 21:36:58.043965 fix syntax errors 3 ['#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\nCreated on Wed Apr  1 00:00:23 2020\n\n@author: ritambasu\n"""\n\n"""\nThis is a template file, you can use it to solve all the sub-problems of the \nproblem set. You can use the read_* functions to read the input, and then write\nyour code to solve the problem.\n\nIf you have any trouble, please do not hesitate to contact us!\n\nGood luck!\n"""\n\n# Solution \n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n\n# Solution \n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split())) \n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n    \ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n', '\n\n# Solution\n\nimport sys\nimport math\nimport numpy as np\ninput = sys.stdin.readline\n\n#input = iter([\'10 6\', \'1 2\', \'1 3\', \'1 4\', \'2 5\', \'2 6\', \'3 7\', \'7 8\', \'7 9\', \'9 10\', \'4 3 8 9 10\', \'3 2 4 6\', \'3 2 1 5\', \'3 4 8 2\', \'2 6 10\', \'3 5 4 7\']).readline\n\ndef read():\n    return map(int, input().split())\n\ndef read_array(f=int):\n    return list(map(f, input().split()))\n\ndef read_matrix(H, W, f=int):\n    \'\'\'\n    Reads an H of lines of space-separated elements of length W,\n    and returns a matrix (list of lists) of integers.\n    \'\'\'\n    ret = []\n    for _ in range(H):\n        ret.append(read_array(f))\n    return ret\n\ndef read_tuple(typ):\n    return tuple(map(typ, input().split()))\n\ndef read_tuple_array(typ):\n    return [read_tuple(typ)]\n\n# If you need to read a single integer, use read()\n# If you need to read a space-separated list of integers, use read_array()\n# If you need to read a space-separated matrix of integers, use read_matrix()\n# If you need to read a space-separated list of integers of unknown length, use read_tuple()\n# If you need to read a space-separated list of tuples of integers, use read_tuple_array()\n\nN, M = read()\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.visited = [False] * V\n        \n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def dfs(self, u):\n        self.visited[u] = True\n        for v in self.adj[u]:\n            if not self.visited[v]:\n                self.dfs(v)\n    \n    def is_connected(self):\n        self.dfs(0)\n        return all(self.visited)\n    \n    def is_path(self, u, v):\n        self.visited = [False] * self.V\n        self.dfs(u)\n        return self.visited[v]\n    \n    def __repr__(self):\n        return str(self.adj)\n\ng = Graph(N)\n\nfor _ in range(N-1):\n    u, v = read()\n    g.add_edge(u-1, v-1)\n\nfor _ in range(M):\n    k = read_array()\n    k = k[0]\n    nodes = read_array()\n    nodes = [n-1 for n in nodes]\n    \n    #print(nodes)\n    if k == 1:\n        print("YES")\n    else:\n        print("YES" if all(g.is_path(nodes[0], n) for n in nodes[1:]) else "NO")\n']
2022-04-12 21:36:58.044099 size on output set 9
