["\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'M' + route[i+1:])\n    return route\n\ndef encode(route):\n    return route[0] + encode(route[1:]) if len(route) > 1 else route\n\ndef decode(route):\n    return route[1] + decode(route[1:]) if len(route) > 1 and route[0] == 'M' else route[0] + decode(route[1:])\n\ndef expand(route):\n    return route[1] + expand(route[1:]) if len(route) > 1 and route[0] == 'M' else route[0] + expand(route[1:])\n\nif __name__ == '__main__':\n    route = input()\n    print(len(encode(compress(route))))\n", "import math\n\nimport sys\n\ndef main():\n    for i in range(int(input())):\n        road = input()\n        road = list(road)\n        road.reverse()\n        curr_move = road.pop()\n        curr_count = 1\n        while road:\n            next_move = road.pop()\n            if next_move == curr_move:\n                curr_count += 1\n            else:\n                curr_move = next_move\n                curr_count = 1\n        print(curr_count)\n\nmain()\n", "\n#-----Solution-----\n\ndef min_chars(route):\n    \"\"\"\n    Returns the minimum number of characters needed to transmit a route to a rover\n    \"\"\"\n    # The minimum number of characters needed to transmit the route\n    min_chars = len(route)\n    \n    # The number of characters in the route\n    num_chars = len(route)\n    \n    # The number of characters in the marker\n    num_marker = 1\n    \n    while num_marker < num_chars:\n        \n        # The number of times the marker appears in the route\n        num_times = 0\n        \n        # The length of the marker\n        marker = route[:num_marker]\n        \n        # Loop through the route\n        for i in range(num_chars - num_marker + 1):\n            \n            # If the route at the current index is equal to the marker, the marker is used\n            if route[i:i+num_marker] == marker:\n                num_times += 1\n                \n        # If the number of times the marker appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars = min(min_chars, num_times + num_marker)\n            \n        # The length of the marker is increased\n        num_marker += 1\n        \n    return min_chars\n\n#-----Test Cases-----\n\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))\n", "\nimport sys\n\ndef main():\n    data = sys.stdin.readline()\n    data = data.strip()\n    print(len(data))\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys,os\n\ndef main():\n    print(os.path.abspath(\"file.py\"))\n    print(os.path.exists(\"file.py\"))\n    print(os.path.isdir(\"file.py\"))\n    print(os.path.isfile(\"file.py\"))\n    print(os.path.getsize(\"file.py\"))\n    print(os.path.split(\"file.py\"))\n    print(os.path.splitext(\"file.py\"))\n    print(os.path.join(\"/home/peng\",\"file.py\"))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    macro = []\n    road = []\n    road_string = raw_input()\n    road_len = len(road_string)\n    for i in range(road_len):\n        road.append(road_string[i])\n    while len(road) > 0:\n        if len(road) == 1:\n            macro.append(road[0])\n            del road[0]\n        else:\n            if road[0] == road[1]:\n                macro.append('M')\n                del road[0]\n                del road[0]\n            else:\n                macro.append(road[0])\n                del road[0]\n    print(len(macro))\n\nmain()\n", "\n\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZW, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be\n# able to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence\n# of moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with an 'M' and continue to build the\n# macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller of the two.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "\n\nimport sys\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZ, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "\nimport sys\n\ndef main():\n    for line in sys.stdin:\n        data = line.strip()\n        print(len(data))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys,os\n\ndef main():\n    print(os.path.abspath(\"file.py\")) #\u83b7\u53d6\u6587\u4ef6\u7684\u7edd\u5bf9\u8def\u5f84\n    print(os.path.exists(\"file.py\")) #\u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728\n    print(os.path.isdir(\"file.py\")) #\u5224\u65ad\u662f\u5426\u662f\u76ee\u5f55\n    print(os.path.isfile(\"file.py\")) #\u5224\u65ad\u662f\u5426\u662f\u6587\u4ef6\n    print(os.path.getsize(\"file.py\")) #\u83b7\u53d6\u6587\u4ef6\u5927\u5c0f\n    print(os.path.split(\"file.py\")) #\u5206\u5272\u6587\u4ef6\u540d\u4e0e\u8def\u5f84\n    print(os.path.splitext(\"file.py\")) #\u5206\u5272\u6587\u4ef6\u540d\u4e0e\u6269\u5c55\u540d\n    print(os.path.join(\"/home/peng\",\"file.py\")) #\u5c06\u76ee\u5f55\u548c\u6587\u4ef6\u540d\u5408\u6210\u4e00\u4e2a\u8def\u5f84\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    data = sys.stdin.readline().strip()\n    print(data)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n#-----Solution-----\n\ndef min_chars(route_in):\n    \"\"\"\n    Returns the minimum number of characters needed to transmit a route to a rover\n    \"\"\"\n    # The minimum number of characters needed to transmit the route\n    min_chars_out = len(route_in)\n    \n    # The number of characters in the route\n    num_chars = len(route_in)\n    \n    # The number of characters in the pattern\n    num_pattern = 1\n    \n    while num_pattern < num_chars:\n        \n        # The number of times the pattern appears in the route\n        num_times = 0\n        \n        # The length of the pattern\n        pattern = route_in[:num_pattern]\n        \n        # Loop through the route\n        for i in range(num_chars - num_pattern + 1):\n            \n            # If the route at the current index is equal to the pattern, the pattern is used\n            if route_in[i:i+num_pattern] == pattern:\n                num_times += 1\n                \n        # If the number of times the pattern appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars_out = min(min_chars_out, num_times + num_pattern)\n            \n        # The length of the pattern is increased\n        num_pattern += 1\n        \n    return min_chars_out\n\n#-----Test Cases-----\n\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))\n", "\n\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZ, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a \"M\" and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == \"\":\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = \"\"\n  \n  # The macro string.\n  macro = \"\"\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == \"\":\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += \"M\"\n          \n          # Reset the macro.\n          macro = \"\"\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != \"\":\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "import sys\nimport math\n\ndef main():\n    path = input()\n    path = list(path)\n    path.reverse()\n    curr_move = path.pop()\n    curr_count = 1\n    while path:\n        next_move = path.pop()\n        if next_move == curr_move:\n            curr_count += 1\n        else:\n            curr_move = next_move\n            curr_count = 1\n    print(curr_count)\n\nmain()\n", "\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence) - i + 1):\n            substring = sequence[j:j+i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        macro_string = []\n        route_string = list(input())\n        while len(route_string) > 0:\n            if len(route_string) == 1:\n                macro_string.append(route_string[0])\n                del route_string[0]\n            else:\n                if route_string[0] == route_string[1]:\n                    macro_string.append('M')\n                    del route_string[0]\n                    del route_string[0]\n                else:\n                    macro_string.append(route_string[0])\n                    del route_string[0]\n        print(len(macro_string))\n\nmain()\n", "\n\n# -----Solution-----\n\ndef min_chars(route):\n    \"\"\"\n    Returns the minimum number of characters needed to transmit a route to a rover\n    \"\"\"\n    # The minimum number of characters needed to transmit the route (defaults to the length of the route)\n    min_chars = len(route)\n\n    # The number of characters in the route\n    num_chars = len(route)\n\n    # The number of characters in the macro\n    num_macro = 1\n\n    # Loop through possible macro lengths\n    while num_macro < num_chars:\n\n        # The number of times the macro appears in the route\n        num_times = 0\n\n        # The length of the macro\n        macro = route[:num_macro]\n\n        # Loop through the route\n        for i in range(num_chars - num_macro + 1):\n\n            # If the route at the current index is equal to the macro, the macro is used\n            if route[i:i+num_macro] == macro:\n                num_times += 1\n\n        # If the number of times the macro appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars = min(min_chars, num_times + num_macro)\n\n        # The length of the macro is increased\n        num_macro += 1\n\n    return min_chars\n\n# -----Test Cases-----\n\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))\n", "\n\ndef main():\n    macro_string = []\n    route_string = list(input().strip())\n    while len(route_string) > 0:\n        if len(route_string) == 1:\n            macro_string.append(route_string[0])\n            del route_string[0]\n        else:\n            if route_string[0] == route_string[1]:\n                macro_string.append('M')\n                del route_string[0]\n                del route_string[0]\n            else:\n                macro_string.append(route_string[0])\n                del route_string[0]\n    print(len(macro_string))\n\nmain()\n", "\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZW, Huffman, etc.) \n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "# https://open.kattis.com/problems/macro\n\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence)-i+1):\n            substring = sequence[j:j+i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()\n", "\n#-----Solution-----\n\ndef min_chars(route):\n    \"\"\"\n    Returns the minimum number of characters needed to transmit a route to a rover\n    \"\"\"\n    # The minimum number of characters needed to transmit the route\n    min_chars = len(route)\n    \n    # The number of characters in the route\n    num_chars = len(route)\n    \n    # The number of characters in the marker\n    num_marker = 1\n    \n    while num_marker < num_chars:\n        \n        # The number of times the marker appears in the route\n        num_times = 0\n        \n        # The length of the marker\n        marker = route[:num_marker]\n        \n        # Loop through the route\n        for i in range(num_chars - num_marker + 1):\n            \n            # If the route at the current index is equal to the marker, the marker is used\n            if route[i:i+num_marker] == marker:\n                num_times += 1\n                \n        # If the number of times the marker appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars = min(min_chars, num_times + num_marker)\n            \n        # The length of the marker is increased\n        num_marker += 1\n        \n    return min_chars\n\n#-----Test Cases-----\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))\n", "\n\n\ndef main():\n    macro = []\n    road = []\n    road_string = input().strip()\n    road_len = len(road_string)\n    for i in range(road_len):\n        road.append(road_string[i])\n    while len(road) > 0:\n        if len(road) == 1:\n            macro.append(road[0])\n            del road[0]\n        else:\n            if road[0] == road[1]:\n                macro.append('M')\n                del road[0]\n            else:\n                macro.append(road[0])\n                del road[0]\n    print(len(macro))\n\nmain()\n", "\nimport sys\n\ndef main():\n    data = sys.stdin.readline().strip()\n    print(data)\n\nif __name__ == \"__main__\":\n\n\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    path = input()\n    path = list(path.strip())\n    path.reverse()\n    curr_move = path.pop()\n    curr_count = 1\n    while path:\n        next_move = path.pop()\n        if next_move == curr_move:\n            curr_count += 1\n            print(curr_count)\n        else:\n            curr_move = next_move\n            curr_count = 1\n\nmain()\n", "\n\ndef min_chars(route):\n    # The minimum number of characters needed to transmit the route\n    # (defaults to the length of the route)\n    min_chars = len(route)\n\n    # The number of characters in the route\n    num_chars = len(route)\n\n    # The number of characters in the macro\n    num_macro = 1\n\n    # Loop through possible macro lengths\n    while num_macro < num_chars:\n\n        # The number of times the macro appears in the route\n        num_times = 0\n        \n        # The length of the macro\n        macro = route[:num_macro]\n        \n        # Loop through the route\n        for i in range(num_chars - num_macro + 1):\n            \n            # If the route at the current index is equal to the macro, the macro is used\n            if route[i:i+num_macro] == macro:\n                num_times += 1\n                \n        # If the number of times the macro appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars = min(min_chars, num_times + num_macro)\n            \n        # The length of the macro is increased\n        num_macro += 1\n        \n    return min_chars\n\n#-----Test Cases-----\n\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))\n", "\n\nimport sys, os\nimport glob\nimport string\ndef main():\n    cwd = os.getcwd()\n    for file in os.listdir(cwd):\n        if file.endswith(\".txt\"):\n            print(os.path.join(cwd, file))\n            f = open(file, \"r\")\n            data = f.read()\n            f.close()\n            print(len(data))\n            print(data)\n            print(data[0])\n            print(data[1])\n            print(data[2])\n            print(data[-1])\n            print(data[-2])\n            print(data[-3])\n            print(data[0:5])\n            print(data[:-5])\n            print(data[5:])\n            print(data[0:len(data)])\n            print(data.replace(\"\\n\", \" \"))\n            print(data.replace(\"\\t\", \" \"))\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \"))\n            print(string.punctuation)\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)))\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split())\n            print(len(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split()))\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split()[0])\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split()[-1])\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split()[0:5])\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split()[-5:])\n            print(data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split()[0:len(data)])\n            for word in data.replace(\"\\n\", \" \").replace(\"\\t\", \" \").translate(str.maketrans('', '', string.punctuation)).split():\n                print(word)\n                print(len(word))\n                print(word[0])\n                print(word[-1])\n                print(word[0:5])\n                print(word[-5:])\n                print(word[0:len(word)])\n                print(word.upper())\n                print(word.lower())\n                print(word.replace(\"e\", \"3\"))\n                print(word.replace(\"o\", \"0\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\").replace(\"A\", \"4\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\").replace(\"A\", \"4\").replace(\"I\", \"1\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\").replace(\"A\", \"4\").replace(\"I\", \"1\").replace(\"T\", \"7\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\").replace(\"A\", \"4\").replace(\"I\", \"1\").replace(\"T\", \"7\").replace(\"S\", \"5\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\").replace(\"A\", \"4\").replace(\"I\", \"1\").replace(\"T\", \"7\").replace(\"S\", \"5\").replace(\"B\", \"8\"))\n                print(word.replace(\"e\", \"3\").replace(\"o\", \"0\").replace(\"a\", \"4\").replace(\"i\", \"1\").replace(\"t\", \"7\").replace(\"s\", \"5\").replace(\"b\", \"8\").replace(\"g\", \"6\").replace(\"l\", \"1\").replace(\"E\", \"3\").replace(\"O\", \"0\").replace(\"A\", \"4\").replace(\"I\", \"1\").replace(\"T\", \"7\").replace(\"S\", \"5\").replace(\"B\", \"8\").replace(\"G\", \"6\"))\n               \n\nif __name__ == \"__main__\":\n\n\n    main()\n", "\n\nimport sys\nimport math\n \n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZW, Huffman, etc.) \n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    road = list(input())\n    road.reverse()\n    curr_move = road.pop()\n    curr_count = 1\n    while road:\n        next_move = road.pop()\n        if next_move == curr_move:\n            curr_count += 1\n        else:\n            curr_move = next_move\n            curr_count = 1\n    print(curr_count)\n\nmain()\n", "\n\nroute = input()#input route\n\ndef compress(route):#compress route\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'M' + route[i+1:])\n    return route\n\ndef encode(route):#encode route\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):#decode route\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):#expand route\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nprint(len(encode(compress(route))))#print length of compressed route\n", "\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n    sequence = \"WNEENWENEEENE\"\n    sequence = \"NSEW\"\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence)-i+1):\n            substring = sequence[j:j+i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()\n", "\nroute = input()  # input route\n\ndef compress(route):#compress route\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i - 1]:\n            return compress(route[:i - 1] + 'M' + route[i + 1:])\n    return route\n\n\ndef encode(route):  # encode route\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\n\n\ndef decode(route):  # decode route\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):#expand route\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nprint(len(encode(compress(route))))\n", "\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'M' + route[i+1:])\n    return route\n\ndef encode(route):\n    if len(route) < 2:\n        return route\n    return route[0] + encode(route[1:])\n\ndef decode(route):\n    if len(route) < 2:\n        return route\n    if route[0] == 'M':\n        return route[1] + decode(route[1:])\n    return route[0] + decode(route[1:])\n\ndef expand(route):\n    if len(route) < 2:\n        return route\n    if route[0] == 'M':\n        return route[1] + expand(route[1:])\n    return route[0] + expand(route[1:])\n\nif __name__ == '__main__':\n    route = input()\n    print(len(encode(compress(route))))\n", "\n\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n\n\nmain()\n", "\nimport sys\n\ndef main():\n    data = sys.stdin.readline().strip()\n    print(len(data))\n\nif __name__ == \"__main__\":\n\n\n    main()\n", "\n\nroute = input().strip()\n\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'm' + route[i+1:])\n    return route\n\ndef encode(route):\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'm':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'm':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nprint(len(encode(compress(route))))\n", "\n\nroute = input()#input route\n\ndef compress(route):#compress route\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'M' + route[i+1:])\n    return route\n\ndef encode(route):#encode route\n    if len(route) < 1:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):#decode route\n    if len(route) < 1:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):#expand route\n    if len(route) < 1:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nprint(len(encode(compress(route))))\n", "\n\ndef main():\n    macro = []\n    road = []\n    road_string = raw_input()\n    road_len = len(road_string)\n    for i in range(road_len):\n        road.append(road_string[i])\n    while len(road) > 0:\n        if len(road) == 1:\n            macro.append(road[0])\n            del road[0]\n        else:\n            if road[0] == road[1]:\n                macro.append('M')\n                del road[0]\n            else:\n                macro.append(road[0])\n                del road[0]\n    print(len(macro))\n\nmain()\n", "\n#-----Solution-----\n\ndef min_chars(route):\n    \"\"\"\n    Returns the minimum number of characters needed to transmit a route to a rover\n    \"\"\"\n    # The minimum number of characters needed to transmit the route\n    min_chars = len(route)\n    \n    # The number of characters in the route\n    num_chars = len(route)\n    \n    # The number of characters in the pattern\n    num_pattern = 1\n    \n    while num_pattern < num_chars:\n        \n        # The number of times the pattern appears in the route\n        num_times = 0\n        \n        # The length of the pattern\n        pattern = route[:num_pattern]\n        \n        # Loop through the route\n        for i in range(num_chars - num_pattern + 1):\n            \n            # If the route at the current index is equal to the pattern, the pattern is used\n            if route[i:i+num_pattern] == pattern:\n                num_times += 1\n                \n        # If the number of times the pattern appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars = min(min_chars, num_times + num_pattern)\n            \n        # The length of the pattern is increased\n        num_pattern += 1\n        \n    return min_chars\n\n#-----Test Cases-----\n\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))\n", "\n\nroute = input().strip()\n\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'm' + route[i:])\n    return route\n\ndef encode(route):\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'm':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'm':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nprint(len(encode(compress(route))))\n", "\nprint(\"Hello World\")\n", "\n\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZW, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n\n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n\n  # The compressed string.\n  compressed = ''\n\n  # The macro string.\n  macro = ''\n\n  # The current index in the input string.\n  index = 0\n\n  # The length of the input string.\n  length = len(s)\n\n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n\n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n\n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n\n          # Add the macro to the compressed string.\n          compressed += 'M'\n\n          # Reset the macro.\n          macro = ''\n\n          # Reset the index.\n          index = 0\n\n          # Reset the length of the input string.\n          length = len(s)\n\n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n\n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n\n    # Increase the index.\n    index += 1\n\n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n\n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n\n  # Compress the input string.\n  compressed = compress(s)\n\n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "\nimport sys\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence)-i+1):\n            substring = sequence[j:j+i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()\n", "\ndef main():\n    macro_string = []\n    route_string = list(input())\n    while len(route_string) > 0:\n        if len(route_string) == 1:\n            macro_string.append(route_string[0])\n            del route_string[0]\n        else:\n            if route_string[0] == route_string[1]:\n                macro_string.append('M')\n                del route_string[0]\n                del route_string[0]\n            else:\n                macro_string.append(route_string[0])\n                del route_string[0]\n    print(len(macro_string))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    macro = []\n    road = []\n    road_string = input()\n    road_len = len(road_string)\n    for i in range(road_len):\n        road.append(road_string[i])\n    while len(road) > 0:\n        if len(road) == 1:\n            macro.append(road[0])\n            del road[0]\n        else:\n            if road[0] == road[1]:\n                macro.append('M')\n                del road[0]\n                del road[0]\n            else:\n                macro.append(road[0])\n                del road[0]\n    print(len(macro))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZ, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "\n\ndef main():\n    macro = []\n    road_string = input()\n    road_len = len(road_string)\n    road = list(road_string)\n    while len(road) > 0:\n        if len(road) == 1:\n            macro.append(road[0])\n            del road[0]\n        else:\n            if road[0] == road[1]:\n                macro.append('M')\n                del road[0]\n            else:\n                macro.append(road[0])\n                del road[0]\n    print(len(macro))\n\nmain()\n", "\n\nimport sys,os\n\ndef main():\n    print(os.path.abspath(\"file.py\"))\n    print(os.path.exists(\"file.py\"))\n    print(os.path.isdir(\"file.py\"))\n    print(os.path.isfile(\"file.py\"))\n    print(os.path.getsize(\"file.py\"))\n    print(os.path.split(\"/home/peng/file.py\"))\n    print(os.path.splitext(\"/home/peng/file.py\"))\n    print(os.path.join(\"/home/peng\",\"file.py\"))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZW, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with an 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller of the two.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence)-i+1):\n            substring = sequence[j:j+i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()\n", "\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence) - i + 1):\n            substring = sequence[j:j + i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    path = input()\n    path = list(path)\n    curr_move = path.pop()\n    curr_count = 1\n    while path:\n        next_move = path.pop(0)\n        if next_move == curr_move:\n            curr_count += 1\n            print(curr_count)\n        else:\n            curr_move = next_move\n            curr_count = 1\n    print(curr_count, end=\"\")\n\nmain()\n", "\nimport sys\nroute = input()\n\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'm' + route[i+1:])\n    return route\n\ndef encode(route):\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'm':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'm':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nsys.stdout.write(str(len(encode(compress(route)))))\n", "\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'M' + route[i+1:])\n    return route\n\ndef encode(route):\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nif __name__ == '__main__':\n    route = input()\n    print(len(route))\n    print(len(encode(compress(route)))\n", "\nimport sys\nimport math\n\ndef main():\n    road = input()\n    road = list(road)\n    road.reverse()\n    curr_move = road.pop()\n    curr_count = 1\n    while road:\n        next_move = road.pop()\n        if next_move == curr_move:\n            curr_count += 1\n        else:\n            curr_move = next_move\n            curr_count = 1\n    print(curr_count)\n\nmain()\n", "\n\ndef main():\n    macro = []\n    road = []\n    road_string = raw_input()\n    road_len = len(road_string)\n    for i in range(road_len):\n        road.append(road_string[i])\n    while len(road) > 0:\n        if len(road) == 1:\n            macro.append(road[0])\n            del road[0]\n        else:\n            if road[0] == road[1]:\n                macro.append('M')\n                del road[0]\n                del road[0]\n            else:\n                macro.append(road[0])\n                del road[0]\n    print len(macro)\n\nmain()\n"]