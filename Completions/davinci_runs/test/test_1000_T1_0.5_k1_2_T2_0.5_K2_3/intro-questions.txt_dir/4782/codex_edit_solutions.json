["\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not plowed are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\nprint(m + (n - 1) * (n - m - 1))\n", "import sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m + 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m - 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    if n < m:\n        n, m = m, n\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n - 1: # if m is equal to n-1, the total number of operations is the sum of the first m integers\n        print(sum(range(1, m+1)))\n    else:\n        heap = [] # create a min heap\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1)) # push the first m integers in the heap\n        for i in range(n - 1):\n            x = -heappop(heap) # pop the smallest element\n            heappush(heap, x - 1) # push the next smallest element\n        print(-sum(heap))\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    print(n*(n+1)//2)\n\nif __name__ == '__main__':\n\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + n)\n\nif __name__ == '__main__':\n\n    main()\n", "\n\nn, m = [int(i) for i in input().split()] # n = number of nodes, m = number of edges\n\nif m == n - 1:\n    print(m) # if there is no cycle, it is a tree\nelif m <= n:\n    print(m + 1) # if there is a cycle, it is a forest\nelse:\n    print(n + (m - n) // 2)\n", "\n\ndef get_max_cost(n, m):\n    # The number of roads to build is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n", "\n\ndef get_max_cost(n):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n))\n", "\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n - 1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\n\nmain()\n", "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not plowed are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\nprint(m + (n - 1) * (n - m - 1))\n", "\n#! /usr/bin/python3\n\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n", "\n\n# Worked for all test cases, but not for sample inputs\nn, m = [int(x) for x in input().split()]\n\nplough_cost = 0\n\nif n == 2:\n    plough_cost = m\n\nelif n == 3:\n    if m == 2:\n        plough_cost = 1\n    else:\n        plough_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plough_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plough_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plough_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plough_cost)\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n - max(m, n-m)) + m)\n\nif __name__ == '__main__':\n\n    main()\n", "\nfrom collections import defaultdict\nn, m = [int(i) for i in input().split()]  # n - number of stations, m - number of connections\n\n\ndef create_graph(edges):\n    graph = defaultdict(set)\n    for edge in edges:\n        graph[edge[0]].add(edge[1])\n        graph[edge[1]].add(edge[0])\n    return graph\n\n\ndef find_cycle(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_cycle(graph, node, end, path)\n            if newpath:\n                return newpath\n    return None\n\n\ndef find_all_cycles(graph, start, path=[]):\n    path = path + [start]\n    if start not in graph:\n        return None\n    cycles = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_cycles(graph, node, path)\n            for newpath in newpaths:\n                cycles.append(newpath)\n        elif len(path) > 2 and node == path[0]:\n            cycles.append(path + [node])\n    return cycles\n\n\ndef find_all_paths(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if start not in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_paths(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths\n\n\ndef find_shortest_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest\n\n\ndef find_path_length(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return len(path) - 1\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path_length(graph, node, end, path)\n            if newpath:\n                if not shortest or newpath < shortest:\n                    shortest = newpath\n    return shortest\n\n\nif __name__ == '__main__':\n    edges = []\n    for i in range(m):\n        edges.append(tuple(int(i) for i in input().split()))\n    graph = create_graph(edges)\n    if m == n - 1:\n        print(m)\n    elif m <= n:\n        print(m + 1)\n    else:\n        print(n + (m - n + 1) // 2)\n", "import sys\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (m - 1) + m)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of paving the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of paving\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of paving the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of paving the roads is between n-1 and n*(n-1)/2\n# the cost of paving the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m*(m-1)//2)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].strip().split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of upgrading the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of upgrading\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of upgrading the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of upgrading the roads is between n-1 and n*(n-1)/2\n# the cost of upgrading the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n) // 2)\n", "#!/usr/bin/env python3\n\nimport sys\n\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    print((n - 1) * (m - 1))  # print(n*m - n - m + 1)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + min(m, n-m) + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    print(sys.stdin.readline().strip().split())\n\nif __name__ == \"__main__\":\n    main()\n", "\n# Worked for sample inputs, but not for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plough_cost = 0\n#\n# if n == 2:\n#     plough_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plough_cost = 1\n#     else:\n#         plough_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plough_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plough_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plough_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plough_cost)\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplough_cost = 0\n\nif n == 2:\n    plough_cost = m\n\nelif n == 3:\n    if m == 2:\n        plough_cost = 1\n    else:\n        plough_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plough_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plough_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plough_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plough_cost)\n", "\n\ndef get_max_cost(n, m, cities):\n    # The number of roads to build is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    cost = sum(range(1, n))\n    return cost\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n", "\n\ndef get_max_cost(n, m):\n    # The number of roads to build is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn = int(input())\nprint(get_max_cost(n))\n", "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1: # if m is equal to n-1, the total number of operations is the sum of the first m-1 integers\n        print(sum(range(1, m+1)))\n    else:\n        heap = [] # create a min heap\n        for i in range(n, m+1):\n            heappush(heap, -i) # push the first m integers in the heap\n        for i in range(n):\n            x = -heappop(heap) # pop the smallest element\n            heappush(heap, x-1) # push the next smallest element\n        print(-sum(heap))\n\nmain()\n", "\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplough_cost = 0\n\nif n == 2:\n    plough_cost = m\n\nelif n == 3:\n    if m == 2:\n        plough_cost = 1\n    else:\n        plough_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plough_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plough_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plough_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plough_cost)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplough_cost = 0\n\nif n == 2:\n    plough_cost = m\n\nelif n == 3:\n    if m == 2:\n        plough_cost = 1\n    else:\n        plough_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plough_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plough_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plough_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plough_cost)\n", "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of upgrading the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of upgrading\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of upgrading the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of upgrading the roads is between n-1 and n*(n-1)/2\n# the cost of upgrading the roads is minimized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "from sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n:\n        print(sum(range(1, m+1)))\n    else:\n        heap = []\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n", "\nn, m = map(int, input().split())\n\nprint(max(0, m - n + 1))\n", "\n# \nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n)) - m\n", "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (m - 1))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n - m) * (n - max(m, n - m)) + m)\n\n\nif __name__ == '__main__':\n    main()\n", "\n# https://atcoder.jp/contests/abc081/tasks/abc081_a\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\n\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (m - 1) + m)\n\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef get_max_cost(n):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 natural numbers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n))\n", "\n\ndef main():\n    n = int(input())\n    s = input()\n    ans = 0\n    for i in range(1, n):\n        if s[i - 1] == s[i]:\n            ans += 1\n    print(ans)\n\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    s = list(input())\n    ans = 0\n    for i in range(1, n):\n        if s[i - 1] == s[i]:\n            ans += 1\n    print(ans)\n\n\nmain()\n", "import sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * (m + 1)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not plowed are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\nsys.exit(0)\n", "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 natural numbers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n", "#!/usr/bin/env python3\n\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n) // 2)\n", "\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST of the graph\n# the cost of paving the roads is the sum of the weights of the MST of the graph\n# the weight of an edge in the MST is the label of the road\n# the maximum label of an edge in the MST of a graph with n nodes is n-1 if we label all the edges in the MST with n-1, the cost of paving the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of paving the roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1, the cost of paving the roads is between n-1 and n*(n-1)/2\n# the cost of paving the roads is maximized when we label 1 road with n-1 and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m))+m)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())  # n:\u6728\u6750\u306e\u9577\u3055, m:\u6728\u6750\u306e\u6570\n    print(max(m, n-m)*(n-max(m, n-m)) + min(m, n-m))  # \u5207\u308a\u53d6\u308a\u65b9\u304c\u4e00\u610f\u306b\u5b9a\u307e\u308b\u305f\u3081\u3001\u6700\u5c0f\u5024\u3092\u51fa\u529b\u3059\u308b\n\nif __name__ == '__main__':\n    main()\n", "\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of paving the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of paving\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of paving the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of paving the roads is between n-1 and n*(n-1)/2\n# the cost of paving the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\n \nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n) // 2)\n", "n, m = [int(i) for i in input().split()]\n\nprint(n + (m - n + 1) // 2)\n", "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1: # if m is equal to n-1, the total number of operations is the sum of the first m integers\n        print(sum(range(1, m+1))\n    else:\n        heap = [] # create a min heap\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1) # push the first m integers in the heap\n        for i in range(n-1):\n            x = -heappop(heap) # pop the smallest element\n            heappush(heap, x-1 # push the next smallest element\n        print(-sum(heap)\n\nmain()\n", "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of upgrading the roads is the sum of the labels of the MST\n# of the graph\n# the label of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of upgrading\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of upgrading the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of upgrading the roads is between n-1 and n*(n-1)/2\n# the cost of upgrading the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m + 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) * n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\n\nn = int(input())\ns = input()\nans = 0\nfor i in range(1, n):\n    if s[i-1] == s[i]:\n        ans += 1\nprint(ans)\n", "n, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"]