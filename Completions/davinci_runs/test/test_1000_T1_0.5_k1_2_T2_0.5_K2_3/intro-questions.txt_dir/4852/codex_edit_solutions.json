["\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPGP expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPGP expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef dp(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dp(string[:i]) * dp(string[i+1:])\n        return count\n\n\nif __name__ == '__main__':\n    print(dp(input()))\n", "\n\n#Solved by: Andrew Xing and Andrew Zhang and Andrew Zhang\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef parse(s, i, op, op_prev, num_prev):\n    num = int(s[i])\n    if i == len(s) - 1:\n        if op_prev == '+':\n            return num_prev + num\n        elif op_prev == '*':\n            return num_prev * num\n        else:\n            return num\n    if s[i + 1] == '+':\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op, num_prev + num) + parse(s, i + 2, '*', op, num_prev + num)\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op, num_prev * num) + parse(s, i + 2, '*', op, num_prev * num)\n        else:\n            return parse(s, i + 2, '+', op, num) + parse(s, i + 2, '*', op, num)\n    elif s[i + 1] == '*':\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op, num_prev + num) + parse(s, i + 2, '*', op, num_prev + num)\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op, num_prev * num) + parse(s, i + 2, '*', op, num_prev * num)\n        else:\n            return parse(s, i + 2, '+', op, num) + parse(s, i + 2, '*', op, num)\n\ns = sys.stdin.readline()\ns = s[:-1]\nprint parse(s, 0, '+', '+', 0)\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        # dp[i][j] means the number of expression that sum up to line[i:j+1]\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j-2]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\nimport sys\n\n# define the method which will be called recursively\n# s is the string to be parsed\n# i is the current index in the string\n# o is the operator to use for this call\n# o_prev is the operator used in the previous call\n# returns the number of distinct values\ndef parse(s, i, o, o_prev):\n    # get the next number\n    num = int(s[i])\n    # if we are at the end of the string, return 1\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', o) + parse(s, i + 2, '*', o)\n    # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities\n        if o_prev == '+':\n            return parse(s, i + 2, '+', o) + parse(s, i + 2, '*', o)\n        # if the previous operator was a star sign, return the product of the two possibilities\n        elif o_prev == '*':\n            return parse(s, i + 2, '+', o) * parse(s, i + 2, '*', o)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)] # dp[i][j] means the number of expression that sum up to line[i:j+1]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n') \n\nmain()\n", "\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n#Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n,\n        # which is the same as the number of ways to choose k operators\n        # out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2\n        # and n is even.\n        #\n        # We know that this is equal to (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is equal to\n        # n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to:\n        # n! / (n!!)^2\n        num_subsets = factorial(n) / (factorial(n // 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) - int(s[i + 2]))\n        elif s[i + 1] == '-':\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout, stderr\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0 and line[i] == line[i-1]*10 + line[i]: # 1+1+1\n                dp[i-1][i] = 1\n            if i > 1 and line[i] == line[i-2]*100 + line[i-1]*10 + line[i]: # 1+11+1\n                dp[i-2][i] = 1\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]: # 1+1\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) - int(s[i + 2]))\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) + int(s[i + 2]))\n        elif s[i + 1] == '-':\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\n\ndef parse(s, i, op, op_prev):\n    # get the next number.\n    num = int(s[i])\n    # if we are at the end of the string, return 1.\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities.\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    # if the next operator is a star sign, return the product of the two possibilities.\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities.\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        # if the previous operator was a star sign, return the product of the two possibilities.\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input.\ns = sys.stdin.readline()\n# remove the newline character from the string.\ns = s[:-1]\n# call the function to get the number of distinct values.\nprint parse(s, 0, '+', '+')\n", "\n\ndef dpg(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count\n\nprint(dpg(input()))\n", "\n\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\"\\n\")\n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the list can be evaluated\n\tcount = 0\n\tfor i in range(1,len(s)):\n\t\tcount += len(s) - i\n\tprint count\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1: return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+': res.append(int(s[i]) - int(s[i + 2]))\n        else: res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPGP expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPGP expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    if start == end:\n        return count + 1\n    if expression[start] == \"+\":\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    else:\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is the same as \n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)^2\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is equal to\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is equal to (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is equal to\n        # n! / ((n/2)!)**2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to:\n        # n! / (n!!)**2\n        num_subsets = factorial(n) / (factorial(n // 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)] # dp[i][j] means the number of expressions that sum up to line[i:j+1]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\n#Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(s[i] + s[i + 2])\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ^ n\n        # The number of ways to choose k operators out of n is the same as\n        # the number of ways to pick a subset of n operators.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)**2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)**2\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\ndef dp(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dp(string[:i]) * dp(string[i+1:])\n        return count\n\nprint(dp(input()))\n", "\n\n#Solved by: Andrew Xing and Andrew Zhang \n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2**n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is the same as\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)**2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)**2\n        num_subsets = factorial(n) / (factorial(n // 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\"\\n\")\n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the list can be evaluated\n\tcount = 0\n\tfor i in range(1,len(s)):\n\t\tcount += len(s) - i - 1\n\tprint(count)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\n#Solved by: Andrew Xing and Yash Bhalgat (yashbhalgat)\n\nimport sys\n\ndef num_of_eval(expression):\n    #expression = list(expression)\n    expression = expression.split('+')\n    expression = [int(x) for x in expression]\n    return 1+sum([len(str(x)) for x in expression])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef parse(s, i, op, op_prev, memo):\n    num = int(s[i])\n    if i == len(s) - 1:\n        return 1, num\n\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n\n    elif s[i + 1] == '*':\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n\ndef main():\n    s = sys.stdin.readline()\n    s = s[:-1]\n    print parse(s, 0, '+', '+')\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin, stdout, stderr\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0 and line[i] == line[i-1]*10 + line[i]:\n                dp[i-1][i] = 1\n            if i > 1 and line[i] == line[i-2]*100 + line[i-1]*10 + line[i]:\n                dp[i-2][i] = 1\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\ndef dpg(string):  # dynamic programming\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count\n\n\nprint(dpg(input()))\n", "\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n# Complete the countApplesAndOranges function below.\ndef countApplesAndOranges(s, t, a, b, apples, oranges):\n    apples_inside = 0\n    oranges_inside = 0\n    for i in range(len(apples)):\n        if apples[i] + a >= s and apples[i] + a <= t:\n            apples_inside += 1\n    for i in range(len(oranges)):\n        if oranges[i] + b >= s and oranges[i] + b <= t:\n            oranges_inside += 1\n    print(apples_inside)\n    print(oranges_inside)\n\nif __name__ == '__main__':\n    st = input().split()\n\n    s = int(st[0])\n\n    t = int(st[1])\n\n    ab = input().split()\n\n    a = int(ab[0])\n\n    b = int(ab[1])\n\n    mn = input().split()\n\n    m = int(mn[0])\n\n    n = int(mn[1])\n\n    apples = list(map(int, input().rstrip().split()))\n\n    oranges = list(map(int, input().rstrip().split()))\n\n    countApplesAndOranges(s, t, a, b, apples, oranges)\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPGP expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression))\n\ndef count_distinct_integers_helper(expression, start, end):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPGP expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end) + \\\n               count_distinct_integers_helper(expression, start + 1, end)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\n# define the method which will be called recursively.\n# s is the string to be parsed\n# i is the current index in the string\n# op is the operator to use for this call\n# op_prev is the operator used in the previous call\n# returns the number of distinct values\ndef parse(s, i, op, op_prev):\n    # get the next number.\n    num = int(s[i])\n    # if we are at the end of the string, return 1.\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities.\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op_prev) + parse(s, i + 2, '*', op_prev)\n    # if the next operator is a star sign, return the product of the two possibilities.\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities.\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op_prev) + parse(s, i + 2, '*', op_prev)\n        # if the previous operator was a star sign, return the product of the two possibilities.\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\n\ndef dpg(string): #dynamic programming\n    if '+' not in string: #base case\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count\n\nprint(dpg(input()))\n", "\n\n#Solved by: Andrew Xing and Yash Bhalgat \n\nimport sys\n\ndef num_of_eval(expression):\n    #expression = list(expression)\n    expression = expression.split('+')\n    expression = [int(x) for x in expression]\n    return 1+sum([len(str(x)) for x in expression])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom sys import stdin\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) - int(s[i + 2]))\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# define the method which will be called recursively.\n# s is the string to be parsed\n# i is the current index in the string\n# returns the number of distinct values\ndef parse(s, i):\n    # get the next number.\n    num = int(s[i])\n    # if we are at the end of the string, return 1.\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities.\n    if s[i + 1] == '+':\n        return parse(s, i + 2) + parse(s, i + 2)\n    # if the next operator is a star sign, return the product of the two possibilities.\n    elif s[i + 1] == '*':\n        return parse(s, i + 2) * parse(s, i + 2)\n\n# get the input.\ns = sys.stdin.readline()\n# remove the newline character from the string.\ns = s[:-1]\n# call the function to get the number of distinct values.\nprint parse(s, 0, '+', '+')\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is equal to\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is equal to (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is equal to\n        # n! / ((n/2)!)**2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to:\n        # n! / (n!!)**2\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('*')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] %= 1000000007\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression. \n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number\n    # of pluses. For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solved by: Andrew Xing and Yash Bhalgat\n\nimport sys\n\n\ndef num_of_eval(expression):\n    # expression = list(expression)\n    expression = expression.split('+')\n    expression = [int(x) for x in expression]\n    return 1 + sum([len(str(x)) for x in expression])\n\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef dp(string, i):\n    if i == len(string):\n        return 1\n    if string[i] == '+':\n        return dp(string, i+1) + dp(string, i+2)\n    return dp(string, i+1)\n\nprint(dp(input()))\n", "\n\ndef dpg(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count\n\nprint(dpg(input(\"Enter string\")))\n", "\n\ndef main():\n    # Read the input\n    s = sys.stdin.readline()\n    s = s.replace(\"+\",\"\\n\")\n    s = s.split(\"\\n\")\n\n    # Convert the input to a list of integers\n    for i in range(len(s)):\n        s[i] = int(s[i])\n\n    # Count the number of ways the list can be evaluated\n    count = 0\n    for i in range(1,len(s)):\n        count += len(s) - i\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split()))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0 and line[i] == line[i-1]*10 + line[i]:\n                dp[i-1][i] = 1\n            if i > 1 and line[i] == line[i-2]*100 + line[i-1]*10 + line[i]:\n                dp[i-2][i] = 1\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('*')))[1:]\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('*')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if j > i+1 and line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\ndef main():\n    expression = input()\n\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression. \n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + count_distinct_integers_helper(\n            expression, start + 1, end, count)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start])) + count_distinct_integers_helper(expression, start + 1, end, count)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2**n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is the same as\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)**2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)**2\n        num_subsets = factorial(n) / (factorial(n / 2)) ** 2\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is the same as\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)^2\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n"]