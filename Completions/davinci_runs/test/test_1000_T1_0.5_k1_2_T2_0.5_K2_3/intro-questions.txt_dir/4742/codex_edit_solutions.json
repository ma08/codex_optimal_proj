["\n\ndef is_transposition(m1, m2):\n    # m1 is a transposition of m2 if m2 can be obtained by shifting m1 by some number of semitones.\n    # A transposition is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_retrograde(m1, m2):\n    # m1 is a retrograde of m2 if m2 is the reverse of m1.\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[len(m1) - i]:\n            return False\n    return True\n\ndef is_inversion(m1, m2):\n    # m1 is an inversion of m2 if m2 can be obtained by inverting m1 about the first note in m1.\n    # An inversion is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(1, len(m1)):\n        if m1[i] != m2[len(m1) - i - 1]:\n            return False\n    return True\n\ndef is_nonsense(m1, m2):\n    return not (is_transposition(m1, m2) or is_retrograde(m1, m2) or is_inversion(m1, m2))\n\ndef main():\n    # read the number of notes in each melody\n    l = int(input())\n    # read the first melody\n    m1 = input().split()\n    # read the second melody\n    m2 = input().split()\n    if is_transposition(m1, m2):\n        print(\"Transposition\")\n    elif is_retrograde(m1, m2):\n        print(\"Retrograde\")\n    elif is_inversion(m1, m2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    # Read the input\n    length = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition\n    if melody2 == [transpose(note) for note in melody1]:  # List comprehension\n        print(\"Transposition\")\n    # Check if retrograde\n    elif melody2 == melody1[::-1]:  # Slicing\n        print(\"Retrograde\")\n    # Check if inverse\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:  # List comprehension\n        print(\"Inverse\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()  # make list of notes\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 != m2:\n        if m1 == m2[::-1]:\n            print(\"Retrograde\")\n        elif m2 == m1[::-1]:\n            print(\"Retrograde\")\n        else:\n            for i in range(len(m1)):\n                if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                    print(\"Transposition\")\n                    break\n                if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:\n                    print(\"Inversion\")\n                    break\n            else:\n                print(\"Nonsense\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\"\"\"\nReads two lines of input, each with a list of notes, and determines if the second list is a transposition, retrograde, inverse, or nonsense.\n\"\"\"\n\nimport sys\n\n    \"\"\"\n    Reads two lines of input, each with a list of notes, and determines if the second list is a transposition, retrograde, inverse, or nonsense.\n    \"\"\"\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition\n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde\n    elif melody2 == melody1[::-1]:\n        print(\"Retrograde\")\n    # Check if inverse\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:\n        print(\"Inverse\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()  # make list of notes\n    n = int(input().strip())\n    m1 = input().strip().split()\n    # check if m1 == m2\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1 == m2[::-1]:\n        print(\"Retrograde\")\n    elif m2 == m1[::-1]:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0])) % 12]):\n                print(\"Inversion\")\n                break\n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef transposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#']\n            return False\n    return True\n\n    \ndef retrograde(melody1, melody2):\n    for i in range(len(melody1)):\n    if len(melody1) != len(melody2):\n        return False\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#']\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print(\"Transposition\")\n    elif retrograde(melody1, melody2):\n        print(\"Retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition\n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde\n    elif melody2 == melody1[::-1]:  # Slicing\n        print(\"Retrograde\")\n    # Check if inversion\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:  # List comprehension\n        print(\"Inversion\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative of the difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive of the difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef is_transposition(m1, m2):\n    # m1 is a transposition of m2 if m2 can be obtained by shifting m1 by some\n    # number of semitones (1 semitone is the distance between two adjacent notes)\n    # A transposition is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_retrograde(m1, m2):\n    # m1 is a retrograde of m2 if m2 is the reverse of m1\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[len(m1) - i - 1]:\n            return False\n    return True\n\ndef is_inversion(m1, m2):\n    # m1 is an inversion of m2 if m2 can be obtained by inverting m1 about the\n    # first note in m1 (inverting a melody means reversing the order of the\n    # notes and then reversing the direction of each note)\n    # An inversion is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(1, len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_nonsense(m1, m2):\n    return not (is_transposition(m1, m2) or is_retrograde(m1, m2) or\n                is_inversion(m1, m2))\n\ndef main():\n    # read the number of notes in each melody\n    l = int(input())\n    # read the first melody\n    m1 = input().split()\n    # read the second melody\n    m2 = input().split()\n    if is_transposition(m1, m2):\n        print(\"Transposition\")\n    elif is_retrograde(m1, m2):\n        print(\"Retrograde\")\n    elif is_inversion(m1, m2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1[::-1] == m2:\n        print(\"Retrograde\")\n    elif m2[::-1] == m1:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12] or m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:\n                if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                    print(\"Transposition\")\n                else:\n                    print(\"Inversion\")\n                break                \n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\ndef main():\n    length = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Transposition\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i + 1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length - i - 1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0])) % 12]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition (transpose each note up by one semitone)\n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde (reverse the melody)\n    elif melody2 == melody1[::-1]:\n        print(\"Retrograde\")\n    # Check if inversion (invert each note around the first note)\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:\n        print(\"Inversion\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\ndef transpose(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\ndef retrograde_inversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\ndef invert(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transpose(melody1, melody2):\n        print(\"Transposition\")\n    elif retrograde_inversion(melody1, melody2):\n        print(\"Retrograde\")\n    elif invert(melody1, melody2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\nif __name__ == \"__main__\":\n    main()\n", "\n\n# NOTES:\n# 1)\n# 2)\n# 3)\n\n# SOLUTIONS:\n\n\n# 1)\ndef isTransposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef isRetrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - 1 - i]:\n            return False\n    return True\n\n\ndef isInversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            # check for inversion about first note\n            if melody1[0] == melody2[0]:\n                return False\n            else:\n                # find the distance between the first note and the current note\n                distance = 0\n                for j in range(len(melody1)):\n                    if melody1[j] == melody1[0]:\n                        break\n                    distance += 1\n                # check for inversion about the first note\n                for k in range(len(melody1)):\n                    if melody1[k] != melody2[k]:\n                        if melody1[0] == melody2[0]:\n                            if melody1[k] != melody2[k + distance]:\n                                return False\n                        else:\n                            return False\n    return True\n\n\ndef isNonsense(melody1, melody2):\n    return not isTransposition(melody1, melody2) and not isRetrograde(melody1, melody2) and not isInversion(melody1, melody2)\n\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2)\n# 3)\n", "\n\ndef is_transposition(m1, m2):\n    # m1 is a transposition of m2 if m2 can be obtained by shifting m1 by some number of semitones (1 semitone is the distance between two adjacent notes)\n    # A transposition is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_retrograde(m1, m2):\n    # m1 is a retrograde of m2 if m2 is the reverse of m1\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[len(m2) - i - 1]:\n            return False\n    return True\n\ndef is_inversion(m1, m2):\n    # m1 is an inversion of m2 if m2 can be obtained by inverting m1 about the first note in m1 (inverting a melody means reversing the order of the notes and then reversing the direction of each note)\n    # An inversion is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(1, len(m1)):\n        if m1[i] != m2[len(m2) - i - 1]:\n            return False\n    return True\n\ndef is_nonsense(m1, m2):\n    return not (is_transposition(m1, m2) or is_retrograde(m1, m2) or is_inversion(m1, m2))\n\ndef main():\n    # read the number of notes in each melody\n    l = int(input())\n    # read the first melody\n    m1 = input().split()\n    # read the second melody\n    m2 = input().split()\n    if is_transposition(m1, m2):\n        print(\"Transposition\")\n    elif is_retrograde(m1, m2):\n        print(\"Retrograde\")\n    elif is_inversion(m1, m2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'H']\n\ndef transposition(melody1, melody2):\n    if melody1[0] == melody2[0] or (melody1[0] == 'C' and melody2[0] == 'H') or (melody1[0] == 'H' and melody2[0] == 'C'):\n        return True\n    return False\n\ndef retrograde(melody1, melody2):\n    if melody1 == melody2[::-1]:\n        return True\n    else:\n        return False\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    else:\n        for i in range(1, len(melody1)):\n            if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print('Transposition')\n    elif retrograde(melody1, melody2):\n        print('Retrograde')\n    elif inversion(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\", \"C\"]\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i+1)%length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length-i-1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0])) % 13]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef transposition(melody1, melody2):\n    if len(melody1) != len(melody2):\n        return False\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n    if len(melody1) != len(melody2):\n        return False\ndef retrograde(melody1, melody2):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#']\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#']\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print(\"Transposition\")\n    elif retrograde(melody1, melody2):\n        print(\"Retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1 == m2[::-1] or m2 == m1[::-1]:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:\n                print(\"Inversion\")\n                break\n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition (cycle shift)\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i+1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length-i-1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0])) % 12]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# NOTES:\n# 1)\n# 2)\n# 3)\n# SOLUTIONS:\n\n\n# 1)\ndef isTransposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef isRetrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - 1 - i]:\n            return False\n    return True\n\n\ndef isInversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            # check for inversion about first note\n            if melody1[0] == melody2[0]:\n                return False\n            else:\n                # find the distance between the first note and the current note\n                distance = 0\n                for j in range(len(melody1)):\n                    if melody1[j] == melody1[0]:\n                        break\n                    distance += 1\n                # check for inversion about the first note\n                for k in range(len(melody1)):\n                    if melody1[k] != melody2[k]:\n                        if melody1[0] == melody2[0]:\n                            if melody1[k] != melody2[k + distance]:\n                                return False\n                        else:\n                            return False\n    return True\n\n\ndef isNonsense(melody1, melody2):\n    return not isTransposition(melody1, melody2) and not isRetrograde(\n        melody1, melody2) and not isInversion(melody1, melody2)\n\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2)\n# 3)\n", "\n\n# NOTES:\n# 1)\n# 2)\n# 3)\n\n# SOLUTIONS:\n# 1)\ndef isTransposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef isRetrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - 1 - i]:\n            return False\n    return True\n\ndef isInversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            # check for inversion about first note\n            if melody1[0] == melody2[0]:\n                return False\n            else:\n                # find the distance between the first note and the current note\n                distance = 0\n                for j in range(len(melody1)):\n                    if melody1[j] == melody1[0]:\n                        break\n                    distance += 1\n                # check for inversion about the first note\n                for k in range(len(melody1)):\n                    if melody1[k] != melody2[k]:\n                        if melody1[0] == melody2[0]:\n                            if melody1[k] != melody2[len(melody2) - 1 - (k + distance)]:\n                                return False\n                        else:\n                            return False\n    return True\n\ndef isNonsense(melody1, melody2):\n    return not isTransposition(melody1, melody2) and not isRetrograde(melody1, melody2) and not isInversion(melody1, melody2)\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2)\n# 3)\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition\n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde\n    elif melody2 == melody1[::-1]:\n        print(\"Retrograde\")\n    # Check if inverse\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:\n        print(\"Inverse\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef retrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\n\ndef main():\n    l = int(input(\"Length of melody: \"))\n    melody1 = input(\"Melody 1: \").split()\n    melody2 = input(\"Melody 2: \").split()\n    if transposition(melody1, melody2):\n        print(\"transposition\")\n    elif retrograde(melody1, melody2):\n        print(\"retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"inversion\")\n    else:\n        print(\"nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nNOTES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i + 1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length - i - 1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != NOTES[(NOTES.index(melody2[i]) + NOTES.index(melody2[0])) % 12]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# NOTES:\n# 1)\n# 2)\n# 3)\n\n# SOLUTIONS:\n# 1)\ndef isTransposition(melody1, melody2): # O(n)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef isRetrograde(melody1, melody2): # O(n)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2)-1-i]:\n            return False\n    return True\n\ndef isInversion(melody1, melody2): # O(n^2)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            # check for inversion about first note\n            if melody1[0] == melody2[0]:\n                return False\n            else:\n                # find the distance between the first note and the current note\n                distance = 0\n                for j in range(len(melody1)):\n                    if melody1[j] == melody1[0]:\n                        break\n                    distance += 1\n                # check for inversion about the first note\n                for k in range(len(melody1)):\n                    if melody1[k] != melody2[k]:\n                        if melody1[0] == melody2[0]:\n                            if melody1[k] != melody2[k + distance]:\n                                return False\n                        else:\n                            return False\n    return True\n\ndef isNonsense(melody1, melody2): # O(n^2)\n    return not isTransposition(melody1, melody2) and not isRetrograde(melody1, melody2) and not isInversion(melody1, melody2)\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2)\n# 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transposition(melody1, melody2):\n    if melody1[0] == melody2[0]:\n        return True\n    elif melody1[0] == 'B' and melody2[0] == 'C':\n        return True\n    elif melody1[0] == 'C' and melody2[0] == 'B':\n        return True\n    else:\n        return False\n\ndef retrograde(melody1, melody2):\n    if melody1 == melody2[::-1]:\n        return True\n    else:\n        return False\n\ndef inversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n            return False\n    return True \n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print('Transposition')\n    elif retrograde(melody1, melody2):\n        print('Retrograde')\n    elif inversion(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition\n    if melody2 == [transpose(note) for note in melody1] or melody2 == [transpose(note) for note in melody1[::-1]]:\n        print(\"Transposition\")\n    # Check if retrograde\n    elif melody2 == melody1[::-1] or melody2 == [transpose(note) for note in melody1[::-1]]:\n        print(\"Retrograde\")\n    # Check if inversion\n    elif melody2 == [invert(note, melody1[0]) for note in melody1] or melody2 == [invert(note, melody1[0]) for note in melody1[::-1]]:\n        print(\"Inversion\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative of the difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive of the difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'H']\n\ndef transposition(melody1, melody2):\n    if melody1[0] == melody2[0] or (melody1[0] == 'C' and melody2[0] == 'H') or (melody1[0] == 'H' and melody2[0] == 'C'):\n        return True\n    else:\n        return False\n\ndef retrograde(melody1, melody2):\n    if melody1 == melody2[::-1] and melody1[0] == melody2[0]:\n        return True\n    else:\n        return False\n\ndef inversion(melody1, melody2):\n    for i in range(0, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n            return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print('Transposition')\n    elif retrograde(melody1, melody2):\n        print('Retrograde')\n    elif inversion(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transpose(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef retrograde_inversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transpose(melody1, melody2):\n        print(\"Transposition\")\n    elif retrograde_inversion(melody1, melody2):\n        print(\"Retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef transposition(melody1, melody2):\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'B#']\n\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    if len(melody1) != len(melody2):\n            return False\n    return True\n\n    if len(melody1) != len(melody2):\n        return False\ndef retrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print(\"Transposition\")\n    elif retrograde(melody1, melody2):\n        print(\"Retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transpose(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef retrograde_inversion(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef invert(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if (notes.index(melody1[i]) + notes.index(melody1[0])) % 12 != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[len(melody2) - i - 1]:\n                return False\n        else:\n            if melody1[i] != melody2[len(melody2) - i - 1]:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if retrograde_inversion(melody1, melody2):\n        print(\"Retrograde\")\n    elif transpose(melody1, melody2):\n        print(\"Transposition\")\n    elif invert(melody1, melody2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\", \"C\"]\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i + 1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length - i - 1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + \n            notes.index(melody2[0])) % 13]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\", \"C\"]\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i+1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length-i-1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0])) % len(notes)]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transposition_retrograde(melody1, melody2):\n    if melody1[0] == melody2[0]:\n        return True\n    elif melody1[0] == 'C' and melody2[0] == 'B':\n        return True\n    elif melody1[0] == 'B' and melody2[0] == 'C':\n        return True\n    else:\n        return False\n\ndef retrograde_transposition(melody1, melody2):\n    if melody1 == melody2[::-1]:\n        return True\n    else:\n        return False\n\ndef inversion_retrograde(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    else:\n        for i in range(1, len(melody1) - 1):\n            if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition_retrograde(melody1, melody2):\n        print('Transposition')\n    elif retrograde_transposition(melody1, melody2):\n        print('Retrograde')\n    elif inversion_retrograde(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'H']\n\ndef transposition(melody1, melody2):\n    if melody1[0] == melody2[0] or melody1[0] == 'C' and melody2[0] == 'H' or melody1[0] == 'H' and melody2[0] == 'C':\n        return True\n    else:\n        return False\n\ndef retrograde(melody1, melody2):\n    return melody1 == melody2[::-1]\n\ndef inversion(melody1, melody2):\n    return melody1[0] == melody2[0] and all(notes.index(melody1[i]) + notes.index(melody2[i]) == 11 for i in range(1, len(melody1)))\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print('Transposition')\n    elif retrograde(melody1, melody2):\n        print('Retrograde')\n    elif inversion(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1 == m2[::-1]:\n        print(\"Inversion\")\n    elif m2 == m1[::-1]:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0])) + 12) % 12]:\n                print(\"Inversion\")\n                break\n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# NOTES:\n# 1) O(n)\n# 2) O(n)\n# 3) O(n^2)\n\n# SOLUTIONS:\n# 1) O(n)\ndef isTransposition(melody1, melody2): # O(n)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef isRetrograde(melody1, melody2): # O(n)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2)-1-i]:\n            return False\n    return True\n\ndef isInversion(melody1, melody2): # O(n^2)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            # check for inversion about first note\n            if melody1[0] == melody2[0]:\n                return False\n            else:\n                # find the distance between the first note and the current note\n                distance = 0\n                for j in range(len(melody1)):\n                    if melody1[j] == melody1[0]:\n                        break\n                    distance += 1\n                # check for inversion about the first note\n                for k in range(len(melody1)):\n                    if melody1[k] != melody2[k]:\n                        if melody1[0] == melody2[0]:\n                            if melody1[k] != melody2[k + distance]:\n                                return False\n                        else:\n                            return False\n    return True\n\ndef isNonsense(melody1, melody2): # O(n^2)\n    return not isTransposition(melody1, melody2) and not isRetrograde(melody1, melody2) and not isInversion(melody1, melody2)\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2) O(n)\n# 3) O(n^2)\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C']\n\ndef transposition(melody1, melody2):\n    if melody1[0] == melody2[0]:\n        return True\n    elif melody1[0] == 'C' and melody2[0] == 'B' and len(melody1) == len(melody2):\n        return True\n    elif melody1[0] == 'B' and melody2[0] == 'C' and len(melody1) == len(melody2):\n        return True\n    else:\n        return False\n\ndef retrograde(melody1, melody2):\n    if melody1 == melody2[::-1] and len(melody1) == len(melody2):\n        return True\n    else:\n        return False\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0] or len(melody1) != len(melody2):\n        return False\n    else:\n        for i in range(1, len(melody1)):\n            if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print('Transposition')\n    elif retrograde(melody1, melody2):\n        print('Retrograde')\n    elif inversion(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\ndef main():\n    length = int(input());\n    melody1 = input().split();\n    melody2 = input().split();\n\n    # Transposition\n    if melody1 == melody2:\n        print(\"Nonsense\");\n        return;\n    transposed = True;\n    for i in range(length):\n        if melody1[i] != melody2[(i + 1) % length]:\n            transposed = False;\n            break;\n    if transposed:\n        print(\"Transposition\");\n        return;\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length - i - 1]:\n            retrograde = False;\n            break;\n    if retrograde:\n        print(\"Retrograde\");\n        return;\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue;\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0])) % 12]:\n            inversion = False;\n            break;\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# NOTES:\n# 1)\n# 2)\n# 3)\n\n# SOLUTIONS:\n# 1)\ndef isTransposition(melody1, melody2): # O(n)\n    return melody1 == melody2\n\ndef isRetrograde(melody1, melody2): # O(n)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[-1-i]:\n            return False\n    return True\n\ndef isInversion(melody1, melody2): # O(n^2)\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            # find the distance between the first note and the current note\n            distance = 0\n            for j in range(len(melody1)):\n                if melody1[j] == melody1[0]:\n                    break\n                distance += 1\n            # check for inversion about the first note\n            for k in range(len(melody1)):\n                if melody1[k] != melody2[k]:\n                    if melody1[0] == melody2[0]:\n                        if melody1[k] != melody2[k + distance]:\n                            return False\n                    else:\n                        return False\n    return True\n\ndef isNonsense(melody1, melody2): # O(n^2)\n    return not isTransposition(melody1, melody2) and not isRetrograde(melody1, melody2) and not isInversion(melody1, melody2) \n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2)\n# 3)\n", "\n\ndef is_transposition(m1, m2):\n    # m1 is a transposition of m2 if m2 can be obtained by shifting m1 by some number of semitones\n    # (1 semitone is the distance between two adjacent notes)\n    # A transposition is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_retrograde(m1, m2):\n    # m1 is a retrograde of m2 if m2 is the reverse of m1\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[len(m1) - i - 1]:\n            return False\n    return True\n\ndef is_inversion(m1, m2):\n    # m1 is an inversion of m2 if m2 can be obtained by inverting m1 about the first note in m1 (inverting a melody means reversing the order of the notes and then reversing the direction of each note)\n    # An inversion is only possible if the number of notes in m1 and m2 are the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(1, len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_nonsense(m1, m2):\n    return not (is_transposition(m1, m2) or is_retrograde(m1, m2) or is_inversion(m1, m2))\n\ndef main():\n    # read the number of notes in each melody\n    l = int(input())\n    # read the first melody\n    m1 = input().split()\n    # read the second melody\n    m2 = input().split()\n    if is_transposition(m1, m2):\n        print(\"Transposition\")\n    elif is_retrograde(m1, m2):\n        print(\"Retrograde\")\n    elif is_inversion(m1, m2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition\n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde\n    elif melody2 == melody1[::-1]:\n        print(\"Retrograde\")\n    # Check if inversion\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:\n        print(\"Inversion\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # Invert the difference\n    difference = -difference\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()  # all notes\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1 == m2[::-1]:\n        print(\"Inversion\")\n    elif m2 == m1[::-1]:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:  # inversion\n                print(\"Inversion\")\n                break\n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# NOTES:\n# 1)\n# 2)\n# 3)\n\n# SOLUTIONS:\n# 1)\ndef isTransposition(melody1, melody2):\n    if len(melody1) == len(melody2):\n        for i in range(len(melody1)):\n            if melody1[i] != melody2[i]:\n                return False\n        return True\n    return False\n\ndef isRetrograde(melody1, melody2):\n    if len(melody1) == len(melody2):\n        for i in range(len(melody1)):\n            if melody1[i] != melody2[len(melody2)-1-i]:\n                return False\n        return True\n    return False\n\ndef isInversion(melody1, melody2):\n    if len(melody1) == len(melody2):\n        for i in range(len(melody1)):\n            if melody1[i] != melody2[i]:\n                # check for inversion about first note\n                if melody1[0] == melody2[0]:\n                    return False\n                else:\n                    # find the distance between the first note and the current note\n                    distance = 0\n                    for j in range(len(melody1)):\n                        if melody1[j] == melody1[0]:\n                            break\n                        distance += 1\n                    # check for inversion about the first note\n                    for k in range(len(melody1)):\n                        if melody1[k] != melody2[k]:\n                            if melody1[0] == melody2[0]:\n                                if melody1[k] != melody2[len(melody2)-1-(k + distance)]:\n                                    return False\n                            else:\n                                return False\n        return True\n    return False\n\ndef isNonsense(melody1, melody2):\n    if len(melody1) == len(melody2):\n        for i in range(len(melody1)):\n            if melody1[i] != melody2[i]:\n                # check for inversion about first note\n                if melody1[0] == melody2[0]:\n                    return False\n                else:\n                    # find the distance between the first note and the current note\n                    distance = 0\n                    for j in range(len(melody1)):\n                        if melody1[j] == melody1[0]:\n                            break\n                        distance += 1\n                    # check for inversion about the first note\n                    for k in range(len(melody1)):\n                        if melody1[k] != melody2[k]:\n                            if melody1[0] == melody2[0]:\n                                if melody1[k] != melody2[len(melody2)-1-(k + distance)]:\n                                    return False\n                            else:\n                            return False\n        return False\n    return True\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n    print(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n    print(\"Retrograde\")\nelif isInversion(melody1, melody2):\n    print(\"Inversion\")\nelse:\n    print(\"Nonsense\")\n\n# 2)\n# 3)\n", "\n\n# NOTES: \n# 1) \n# 2) \n# 3) \n\n# SOLUTIONS:\n# 1) \ndef isTransposition(melody1, melody2):\n\tfor i in range(len(melody1)):\n\t\tif melody1[i] != melody2[i]:\n\t\t\treturn False\n\treturn True\n\ndef isRetrograde(melody1, melody2):\n\tfor i in range(len(melody1)):\n\t\tif melody1[i] != melody2[len(melody2)-1-i]:\n\t\t\treturn False\n\treturn True\n\ndef isInversion(melody1, melody2):\n\tfor i in range(len(melody1)):\n\t\tif melody1[i] != melody2[i]:\n\t\t\t# check for inversion about first note\n\t\t\tif melody1[0] == melody2[0]:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\t# find the distance between the first note and the current note\n\t\t\t\tdistance = 0\n\t\t\t\tfor j in range(len(melody1)):\n\t\t\t\t\tif melody1[j] == melody1[0]:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdistance += 1\n\t\t\t\t# check for inversion about the first note\n\t\t\t\tfor k in range(len(melody1)):\n\t\t\t\t\tif melody1[k] != melody2[k]:\n\t\t\t\t\t\tif melody1[0] == melody2[0]:\n\t\t\t\t\t\t\tif melody1[k] != melody2[len(melody2)-1-(k + distance)]:\n\t\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\treturn False\n\treturn True\n\ndef isNonsense(melody1, melody2):\n\treturn not isTransposition(melody1, melody2) and not isRetrograde(melody1, melody2) and not isInversion(melody1, melody2)\n\nmelody1 = input().split()\nmelody2 = input().split()\nif isTransposition(melody1, melody2):\n\tprint(\"Transposition\")\nelif isRetrograde(melody1, melody2):\n\tprint(\"Retrograde\")\nelif isInversion(melody1, melody2):\n\tprint(\"Inversion\")\nelse:\n\tprint(\"Nonsense\")\n\n# 2) \n# 3) \n", "\nimport sys\n\ndef main():\n    # Read the input\n    length = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition (transpose each note up by one semitone)\n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde (reverse the melody)\n    elif melody2 == melody1[::-1]:\n        print(\"Retrograde\")\n    # Check if inversion (invert each note around the first note)\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:\n        print(\"Inversion\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # Invert the difference\n    difference = -difference\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition (cycle shift)\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i+1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length-i-1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0])) % 13]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n#\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C']\n\ndef transposition(melody1, melody2):\n    if melody1[0] == melody2[0]:\n        return True\n    elif melody1[0] == 'C' and melody2[0] == 'B':\n        return True\n    elif melody1[0] == 'B' and melody2[0] == 'C':\n        return True\n    else:\n        return False\n\ndef retrograde(melody1, melody2):\n    if melody1 == melody2[::-1]:\n        return True\n    else:\n        return False\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    else:\n        for i in range(1, len(melody1)):\n            if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print('Transposition')\n    elif retrograde(melody1, melody2):\n        print('Retrograde')\n    elif inversion(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef is_transposition(m1, m2):\n    # m1 is a transposition of m2 if m2 can be obtained by shifting m1 by some\n    # number of semitones.\n    # A transposition is only possible if the number of notes in m1 and m2 are\n    # the same\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_retrograde(m1, m2):\n    # m1 is a retrograde of m2 if m2 is the reverse of m1.\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[len(m1) - i - 1]:\n            return False\n    return True\n\ndef is_inversion(m1, m2):\n    # m1 is an inversion of m2 if m2 can be obtained by inverting m1 about the\n    # first note in m1.\n    # An inversion is only possible if the number of notes in m1 and m2 are the\n    # same\n    if len(m1) != len(m2):\n        return False\n    for i in range(1, len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_nonsense(m1, m2):\n    return not (is_transposition(m1, m2) or is_retrograde(m1, m2) or\n                is_inversion(m1, m2))\n\ndef main():\n    # read the number of notes in each melody.\n    l = int(input())\n    # read the first melody.\n    m1 = input().split()\n    # read the second melody.\n    m2 = input().split()\n    if is_transposition(m1, m2):\n        print(\"Transposition\")\n    elif is_retrograde(m1, m2):\n        print(\"Retrograde\")\n    elif is_inversion(m1, m2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    # Read the input\n    l = int(sys.stdin.readline())\n    melody1 = sys.stdin.readline().split()\n    melody2 = sys.stdin.readline().split()\n\n    # Check if transposition (transpose each note up by one semitone) \n    if melody2 == [transpose(note) for note in melody1]:\n        print(\"Transposition\")\n    # Check if retrograde (reverse the melody)\n    elif melody2 == melody1[::-1]:\n        print(\"Retrograde\")\n    # Check if inversion (invert each note around the first note)\n    elif melody2 == [invert(note, melody1[0]) for note in melody1]:\n        print(\"Inversion\")\n    # Else, it's nonsense\n    else:\n        print(\"Nonsense\")\n\ndef transpose(note):\n    \"\"\"\n    Transpose a note up by one semitone.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # If the note is the last note in the list, transpose it to the first note\n    if index == len(notes) - 1:\n        transposed_note = notes[0]\n    # Else, transpose it to the next note\n    else:\n        transposed_note = notes[index + 1]\n\n    return transposed_note\n\ndef invert(note, first_note):\n    \"\"\"\n    Invert a note around the first note.\n    \"\"\"\n    # Create a list of all the notes in order\n    notes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n    # Find the index of the current note\n    index = notes.index(note)\n    # Find the index of the first note\n    first_index = notes.index(first_note)\n    # Find the difference between the two notes\n    difference = index - first_index\n    # If the difference is positive, invert it to the negative difference\n    if difference > 0:\n        difference = -difference\n    # If the difference is negative, invert it to the positive difference\n    elif difference < 0:\n        difference = -difference\n    # If the difference is zero, the note is the same as the first\n    else:\n        return first_note\n    # Find the index of the inverted note\n    inverted_index = first_index + difference\n    # If the inverted note is outside the range of the list, wrap it around to the other end\n    if inverted_index < 0:\n        inverted_index = len(notes) - abs(inverted_index)\n    elif inverted_index > len(notes) - 1:\n        inverted_index = abs(len(notes) - inverted_index)\n    # Find the inverted note\n    inverted_note = notes[inverted_index]\n\n    return inverted_note\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transposition_retrograde(melody1, melody2):\n    if melody1[0] == melody2[0] and melody1[-1] == melody2[-1]:\n        return True\n    elif melody1[0] == 'C' and melody2[0] == 'B' and melody1[-1] == 'C' and melody2[-1] == 'B':\n        return True\n    else:\n        return False\n\ndef retrograde_transposition(melody1, melody2):\n    if melody1 == melody2[::-1]:\n        return True\n    else:\n        return False\n\ndef inversion_retrograde(melody1, melody2):\n    for i in range(0, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n            return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition_retrograde(melody1, melody2):\n        print('Transposition')\n    elif retrograde_transposition(melody1, melody2):\n        print('Retrograde')\n    elif inversion_retrograde(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()\n    n = int(input().strip())  # number of notes\n    m1 = input().strip().split()  # first melody\n    m2 = input().strip().split()  # second melody\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1[::-1] == m2:\n        print(\"Retrograde\")\n    elif m2[::-1] == m1:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) -\n                               (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:\n                print(\"Inversion\")\n                break\n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef is_transposition(m1, m2):\n    \"\"\"\n    m1 is a transposition of m2 if m2 can be obtained by shifting m1 by some number of semitones.\n    A transposition is only possible if the number of notes in m1 and m2 are the same\n    \"\"\"\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_retrograde(m1, m2):\n    \"\"\"\n    m1 is a retrograde of m2 if m2 is the reverse of m1.\n    \"\"\"\n    if len(m1) != len(m2):\n        return False\n    for i in range(len(m1)):\n        if m1[i] != m2[len(m1) - i - 1]:\n            return False\n    return True\n\ndef is_inversion(m1, m2):\n    \"\"\"\n    m1 is an inversion of m2 if m2 can be obtained by inverting m1 about the first note in m1.\n    An inversion is only possible if the number of notes in m1 and m2 are the same\n    \"\"\"\n    if len(m1) != len(m2):\n        return False\n    for i in range(1, len(m1)):\n        if m1[i] != m2[(i + 1) % len(m1)]:\n            return False\n    return True\n\ndef is_nonsense(m1, m2):\n    return not (is_transposition(m1, m2) or is_retrograde(m1, m2) or is_inversion(m1, m2))\n\ndef main():\n    \"\"\"\n    read the number of notes in each melody\n    \"\"\"\n    l = int(input())\n    # read the first melody\n    m1 = input().split()\n    # read the second melody\n    m2 = input().split()\n    if is_transposition(m1, m2):\n        print(\"Transposition\")\n    elif is_retrograde(m1, m2):\n        print(\"Retrograde\")\n    elif is_inversion(m1, m2):\n        print(\"Inversion\")\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1[::-1] == m2:\n        print(\"Inversion\")\n    elif m2[::-1] == m1:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:\n                print(\"Inversion\")\n                break\n        else:\n            print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n\ndef transposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef retrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11:\n            if notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n                return False\n        else:\n            if melody1[i] != melody2[i]:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print(\"transposition\")\n    elif retrograde(melody1, melody2):\n        print(\"retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"inversion\")\n    else:\n        print(\"nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C']\n\ndef transposition(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[i]:\n            return False\n    return True\n\ndef retrograde(melody1, melody2):\n    for i in range(len(melody1)):\n        if melody1[i] != melody2[len(melody2) - i - 1]:\n            return False\n    return True\n\ndef inversion(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    for i in range(1, len(melody1)):\n        if notes.index(melody1[i]) + notes.index(melody1[0]) != 11 and notes[(notes.index(melody1[i]) + notes.index(melody1[0])) % 12] != melody2[i]:\n            return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition(melody1, melody2):\n        print(\"transposition\")\n    elif retrograde(melody1, melody2):\n        print(\"retrograde\")\n    elif inversion(melody1, melody2):\n        print(\"inversion\")\n    else:\n        print(\"nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\", \"C\"]\n\ndef main():\n    length = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n\n    # Transposition (cycle shift)\n    if melody1 == melody2:\n        print(\"Nonsense\")\n        return\n    transposed = True\n    for i in range(length):\n        if melody1[i] != melody2[(i+1) % length]:\n            transposed = False\n            break\n    if transposed:\n        print(\"Transposition\")\n        return\n\n    # Retrograde\n    retrograde = True\n    for i in range(length):\n        if melody1[i] != melody2[length-i-1]:\n            retrograde = False\n            break\n    if retrograde:\n        print(\"Retrograde\")\n        return\n\n    # Inversion\n    inversion = True\n    for i in range(length):\n        if i == 0:\n            continue\n        if melody1[i] != notes[(notes.index(melody2[i]) + notes.index(melody2[0]) + 1) % 13]:\n            inversion = False\n            break\n    if inversion:\n        print(\"Inversion\")\n        return\n\n    print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nnotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'H']\n\ndef transposition_retrograde(melody1, melody2):\n    if melody1[0] == melody2[0]:\n        return True\n    elif melody1[0] == 'C' and melody2[0] == 'H':\n        return True\n    elif melody1[0] == 'H' and melody2[0] == 'C':\n        return True\n    else:\n        return False\n\ndef retrograde_transposition(melody1, melody2):\n    if melody1 == melody2[::-1]:\n        return True\n    else:\n        return False\n\ndef inversion_retrograde(melody1, melody2):\n    if melody1[0] != melody2[0]:\n        return False\n    else:\n        for i in range(1, len(melody1)):\n            if notes.index(melody1[i]) + notes.index(melody2[i]) != 11:\n                return False\n    return True\n\ndef main():\n    l = int(input())\n    melody1 = input().split()\n    melody2 = input().split()\n    if transposition_retrograde(melody1, melody2):\n        print('Transposition')\n    elif retrograde_transposition(melody1, melody2):\n        print('Retrograde')\n    elif inversion_retrograde(melody1, melody2):\n        print('Inversion')\n    else:\n        print('Nonsense')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    notes = \"C C# D D# E F F# G G# A A# B\".split()\n    n = int(input().strip())\n    m1 = input().strip().split()\n    m2 = input().strip().split()\n    if m1 == m2:\n        print(\"Nonsense\")\n    elif m1[::-1] == m2:\n        print(\"Retrograde\")\n    elif m2[::-1] == m1:\n        print(\"Retrograde\")\n    else:\n        for i in range(len(m1)):\n            if m2[i] == notes[(notes.index(m1[i]) + n) % 12]:\n                print(\"Transposition\")\n                break\n            if m2[i] == notes[(notes.index(m1[0]) - (notes.index(m1[i]) - notes.index(m1[0]))) % 12]:\n                print(\"Inversion\")\n                break\n    else:\n        print(\"Nonsense\")\n\nif __name__ == \"__main__\":\n    main()\n"]