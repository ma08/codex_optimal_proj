2022-04-12 21:40:16.679486 num operations 2
2022-04-12 21:40:16.679496 size on input set 1
2022-04-12 21:40:25.326025 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n): \n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    }
  ],
  "created": 1649799616,
  "object": "edit"
}
2022-04-12 21:40:25.326353 fix spelling mistakes 3 ["\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n): \n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"]
2022-04-12 21:40:25.326471 size on output set 3
2022-04-12 21:40:25.326477 size on input set 3
2022-04-12 21:40:31.274847 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n): \n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n): \n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    }
  ],
  "created": 1649799625,
  "object": "edit"
}
2022-04-12 21:40:31.275106 fix syntax errors 3 ["\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n): \n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n): \n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"]
2022-04-12 21:40:38.250107 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u - 1, v - 1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u - 1, v - 1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    }
  ],
  "created": 1649799631,
  "object": "edit"
}
2022-04-12 21:40:38.250327 fix syntax errors 3 ["\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u - 1, v - 1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u - 1, v - 1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(m):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"]
2022-04-12 21:40:56.706312 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef get_graph(n, edges):\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append((edge[1], edge[2]))\n        graph[edge[1]].append((edge[0], edge[2]))\n    return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\n\n\ndef LI_():\n    return [int(x)-1 for x in sys.stdin.readline().split()]\n\n\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\n\n\ndef LS():\n    return sys.stdin.readline().split()\n\n\ndef I():\n    return int(sys.stdin.readline())\n\n\ndef F():\n    return float(sys.stdin.readline())\n\n\ndef pf(s):\n    return print(s, flush=True)\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"
    }
  ],
  "created": 1649799638,
  "object": "edit"
}
2022-04-12 21:40:56.706640 fix syntax errors 3 ["\n\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef get_graph(n, edges):\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append((edge[1], edge[2]))\n        graph[edge[1]].append((edge[0], edge[2]))\n    return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n", "\nimport sys\nimport os\nimport math\nimport collections\nimport heapq\nimport itertools\nimport array\nimport bisect\nimport copy\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\n\n\ndef LI_():\n    return [int(x)-1 for x in sys.stdin.readline().split()]\n\n\ndef LF():\n    return [float(x) for x in sys.stdin.readline().split()]\n\n\ndef LS():\n    return sys.stdin.readline().split()\n\n\ndef I():\n    return int(sys.stdin.readline())\n\n\ndef F():\n    return float(sys.stdin.readline())\n\n\ndef pf(s):\n    return print(s, flush=True)\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# def get_graph(n, edges):\n#     graph = [[] for _ in range(n)]\n#     for edge in edges:\n#         graph[edge[0]].append((edge[1], edge[2]))\n#         graph[edge[1]].append((edge[0], edge[2]))\n#     return graph\n\n# def dfs(graph, v, p, d):\n#     for nv, nd in graph[v]:\n#         if nv == p:\n#             continue\n#         d[nv] = max(d[v], nd)\n#         dfs(graph, nv, v, d)\n\ndef main():\n    n, m = LI()\n    edges = []\n    for i in range(n-1):\n        u, v, w = LI()\n        edges.append((u-1, v-1, w))\n    q = LI()\n\n    uf = UnionFind(n)\n    for u, v, w in edges:\n        uf.union(u, v)\n\n    d = [0] * n\n    for u, v, w in edges:\n        if uf.find(u) == uf.find(v):\n            continue\n        d[uf.find(u)] = max(d[uf.find(u)], w)\n        d[uf.find(v)] = max(d[uf.find(v)], w)\n\n    # graph = get_graph(n, edges)\n    # dfs(graph, 0, -1, d)\n    d.sort()\n\n    for qi in q:\n        ans = bisect.bisect_right(d, qi)\n        print(ans, end=' ')\n    print()\n\nmain()\n"]
2022-04-12 21:40:56.706748 size on output set 9
