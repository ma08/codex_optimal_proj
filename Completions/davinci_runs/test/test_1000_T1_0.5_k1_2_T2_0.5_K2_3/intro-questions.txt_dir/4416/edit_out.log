2022-04-12 20:26:06.074660 num operations 2
2022-04-12 20:26:06.074670 size on input set 1
2022-04-12 20:26:08.484547 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the lowest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    }
  ],
  "created": 1649795166,
  "object": "edit"
}
2022-04-12 20:26:08.484773 fix spelling mistakes 3 ['\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the lowest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n']
2022-04-12 20:26:08.484812 size on output set 3
2022-04-12 20:26:08.484819 size on input set 3
2022-04-12 20:26:14.632787 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    }
  ],
  "created": 1649795168,
  "object": "edit"
}
2022-04-12 20:26:14.632964 fix syntax errors 3 ['import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', 'import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', 'import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n']
2022-04-12 20:26:25.124613 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines()) \n    n, k = next(reader) \n    books = sorted(reader, key=lambda x: x[0]) \n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    }
  ],
  "created": 1649795174,
  "object": "edit"
}
2022-04-12 20:26:25.124802 fix syntax errors 3 ['\n\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines()) \n    n, k = next(reader) \n    books = sorted(reader, key=lambda x: x[0]) \n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n']
2022-04-12 20:26:29.910633 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    print(k)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the lowest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the lowest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    }
  ],
  "created": 1649795185,
  "object": "edit"
}
2022-04-12 20:26:29.910806 fix syntax errors 3 ['\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    print(k)\n\nmain()\n', 'import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the lowest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', 'import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the lowest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n']
2022-04-12 20:26:29.910928 size on output set 5
2022-04-12 20:26:29.910941 num operations 2
2022-04-12 20:26:29.910946 size on input set 1
2022-04-12 20:26:33.697810 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    }
  ],
  "created": 1649795189,
  "object": "edit"
}
2022-04-12 20:26:33.698011 fix spelling mistakes 3 ['\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n']
2022-04-12 20:26:33.698151 size on output set 1
2022-04-12 20:26:33.698159 size on input set 1
2022-04-12 20:26:51.917208 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\na = int(raw_input())\nb = int(raw_input())\nc = int(raw_input())\nd = int(raw_input())\nprint pow(a,b)+pow(c,d)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized. This means, we need to find a set of books with X >= k and sum(t_i) is minimized. Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far. This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far. This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    }
  ],
  "created": 1649795193,
  "object": "edit"
}
2022-04-12 20:26:51.917427 fix syntax errors 3 ['\na = int(raw_input())\nb = int(raw_input())\nc = int(raw_input())\nd = int(raw_input())\nprint pow(a,b)+pow(c,d)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized. This means, we need to find a set of books with X >= k and sum(t_i) is minimized. Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far. This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far. This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n']
2022-04-12 20:26:51.917479 size on output set 3
