["\n\n#-----Solution 2-----\n\n# We iterate through all of the segments.\n# For each segment, we add it to the list of segments to remove.\n# Then, we iterate through all of the segments following the current segment.\n# If the current segment and the following segment overlap, we remove the following segment from the list of segments to remove.\n# We repeat this process until no more segments overlap.\n\n# The number of segments to remove\nsegments_to_remove_count = 0\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments, except for the last segment\nfor i in range(n - 1):\n    # Add the segment to the list of segments to remove\n    segments_to_remove.append(i + 1)\n\n    # Iterate through all of the segments following the current segment, except for the last segment\n    for j in range(i + 1, n - 1):\n        # If the current segment and the following segment overlap\n        if segments[i][1] > segments[j][0]:\n            # Remove the following segment from the list of segments to remove\n            segments_to_remove.remove(j + 1)\n\n# Add the last segment to the list of segments to remove\nsegments_to_remove.append(n)\n\n# Print the number of segments to remove, followed by a space\nprint(len(segments_to_remove), end=\" \")\n\n# Print the segments to remove\nfor segment in segments_to_remove:\n    print(segment, end=\" \")\n", "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\nsegments.sort()\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\nresult.sort(reverse=True)\n\nresult = [i for _, i in result]\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[len(result) - cnt:])\n", "\nn, k = map(int, input().split())  # \u0432\u0432\u043e\u0434 \u0434\u0430\u043d\u043d\u044b\u0445\n\nsegments = []  # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n\nfor _ in range(n):  # \u0432\u0432\u043e\u0434 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n    segments.append(tuple(map(int, input().split())))  # \u0437\u0430\u043f\u0438\u0441\u044c \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n\n# print(segments)\n\nsegments.sort()  # \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u043f\u043e \u043b\u0435\u0432\u043e\u0439 \u0433\u0440\u0430\u043d\u0438\u0446\u0435\n\n# print(segments)\n\nresult = []  # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n\nfor i in range(n):  # \u043f\u0440\u043e\u0431\u0435\u0433\u0430\u0435\u043c\u0441\u044f \u043f\u043e \u0432\u0441\u0435\u043c \u043e\u0442\u0440\u0435\u0437\u043a\u0430\u043c\n    l, r = segments[i]  # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043b\u0435\u0432\u0443\u044e \u0438 \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n    j = i + 1  # \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0441\u043e \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n    while j < n and segments[j][0] <= r:  # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043f\u043e\u043f\u0430\u0434\u0430\u0435\u0442 \u043b\u0438 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0432 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n        if segments[j][1] > r:  # \u0435\u0441\u043b\u0438 \u0434\u0430, \u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 \u043b\u0438 \u043f\u0440\u0430\u0432\u0430\u044f \u0433\u0440\u0430\u043d\u0438\u0446\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n            r = segments[j][1]  # \u0435\u0441\u043b\u0438 \u0434\u0430, \u0442\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443\n        j += 1  # \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0438\u043c \u043a \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0443\n    result.append((r - l + 1, i + 1))  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0438 \u0435\u0433\u043e \u043d\u043e\u043c\u0435\u0440 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n\n# print(result)\n\nresult.sort(reverse=True)  # \u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e \u0434\u043b\u0438\u043d\u044b \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n\n# print(result)\n\nresult = [i for _, i in result]  # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043d\u043e\u043c\u0435\u0440\u0430\u043c\u0438 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0434\u043b\u0438\u043d\u044b\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n", "\n\nn, k = map(int, input().split())  # \u0432\u0432\u043e\u0434 \u0434\u0430\u043d\u043d\u044b\u0445\n\nsegments = []  # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n\nfor _ in range(n):  # \u0432\u0432\u043e\u0434 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n    segments.append(tuple(map(int, input().split())))  # \u0437\u0430\u043f\u0438\u0441\u044c \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n\n# print(segments)\n\nsegments.sort()  # \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u043f\u043e \u043b\u0435\u0432\u043e\u0439 \u0433\u0440\u0430\u043d\u0438\u0446\u0435\n\n# print(segments)\n\nresult = []  # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n\nfor i in range(n):  # \u043f\u0440\u043e\u0431\u0435\u0433\u0430\u0435\u043c\u0441\u044f \u043f\u043e \u0432\u0441\u0435\u043c \u043e\u0442\u0440\u0435\u0437\u043a\u0430\u043c\n    l, r = segments[i]  # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043b\u0435\u0432\u0443\u044e \u0438 \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n    j = i + 1  # \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0441\u043e \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n    while j < n and segments[j][0] <= r:  # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043f\u043e\u043f\u0430\u0434\u0430\u0435\u0442 \u043b\u0438 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0432 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n        if segments[j][1] > r:  # \u0435\u0441\u043b\u0438 \u0434\u0430, \u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 \u043b\u0438 \u043f\u0440\u0430\u0432\u0430\u044f \u0433\u0440\u0430\u043d\u0438\u0446\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n            r = segments[j][1]  # \u0435\u0441\u043b\u0438 \u0434\u0430, \u0442\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443\n        j += 1  # \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0438\u043c \u043a \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0443\n    result.append((r - l + 1, i + 1))  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0438 \u0435\u0433\u043e \u043d\u043e\u043c\u0435\u0440 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n\n# print(result)\n\nresult.sort(reverse=True)  # \u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e \u0434\u043b\u0438\u043d\u044b \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n\n# print(result)\n\nresult = [i for _, i in result]  # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043d\u043e\u043c\u0435\u0440\u0430\u043c\u0438 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0434\u043b\u0438\u043d\u044b\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)  # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\nprint(*result[:len(result) - cnt])  # \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043d\u043e\u043c\u0435\u0440\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n", "n, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n", "\n\n#-----Solution-----\n\n# First, we find the number of segments that covers each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments covers it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that covers the point to the list of segments to remove.\n# We then remove the segments from the list of segments. We repeat the process until we find no more positions to remove.\n\n# The number of segments that covers each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covers by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n", "\n\nn, k = map(int, input().split())  # \u0432\u0432\u043e\u0434 \u0434\u0430\u043d\u043d\u044b\u0445\n\nsegments = []  # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n\nfor _ in range(n):  # \u0432\u0432\u043e\u0434 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432\n    segments.append(tuple(map(int, input().split())))  # \u0437\u0430\u043f\u0438\u0441\u044c \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\n\n# print(segments)\n\nsegments.sort()  # \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u043f\u043e \u043b\u0435\u0432\u043e\u0439 \u0433\u0440\u0430\u043d\u0438\u0446\u0435\n\n# print(segments)\n\nresult = []  # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n\nfor i in range(n):  # \u043f\u0440\u043e\u0431\u0435\u0433\u0430\u0435\u043c\u0441\u044f \u043f\u043e \u0432\u0441\u0435\u043c \u043e\u0442\u0440\u0435\u0437\u043a\u0430\u043c\n    l, r = segments[i]  # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043b\u0435\u0432\u0443\u044e \u0438 \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n    j = i + 1  # \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0443 \u0441\u043e \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n    while j < n and segments[j][0] <= r:  # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043f\u043e\u043f\u0430\u0434\u0430\u0435\u0442 \u043b\u0438 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0432 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n        if segments[j][1] > r:  # \u0435\u0441\u043b\u0438 \u0434\u0430, \u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 \u043b\u0438 \u043f\u0440\u0430\u0432\u0430\u044f \u0433\u0440\u0430\u043d\u0438\u0446\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n            r = segments[j][1]  # \u0435\u0441\u043b\u0438 \u0434\u0430, \u0442\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0430\u0432\u0443\u044e \u0433\u0440\u0430\u043d\u0438\u0446\u0443\n        j += 1  # \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0438\u043c \u043a \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0443\n    result.append((r - l + 1, i))  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0438 \u0435\u0433\u043e \u043d\u043e\u043c\u0435\u0440 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n\n# print(result)\n\nresult.sort(reverse=True)  # \u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e \u0434\u043b\u0438\u043d\u044b \u043e\u0442\u0440\u0435\u0437\u043a\u0430\n\n# print(result)\n\nresult = [i + 1 for _, i in result]  # \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043d\u043e\u043c\u0435\u0440\u0430\u043c\u0438 \u043e\u0442\u0440\u0435\u0437\u043a\u043e\u0432 \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0434\u043b\u0438\u043d\u044b\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n", "\n\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each position\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1]):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n", "n, k = map(int, input().split())\nsegments = []\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\nsegments.sort()\nresult = []\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\nresult.sort(reverse=True)\nresult = [i for _, i in result]\ncnt = 0\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n", "\n\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n\n# The number of segments that cover each position\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nprint(*segments_to_remove)\n", "\n#-----Solution 1-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n\tsegments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n\t# Iterate through all of the points covered by the segment\n\tfor j in range(segments[i][0], segments[i][1] + 1):\n\t\t# Increment the number of segments covering the point\n\t\tsegments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n", "\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\nsegments.sort()\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\nresult.sort(reverse=True)\n\nresult = [i for _, i in result]\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n", "\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each position\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n", "\n#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n# https://codeforces.com/problemset/problem/1165/A\nn, k = map(int, input().split())\nsegments = [list(map(int, input().split())) for _ in range(n)]\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\npositions_to_remove = []\nsegments_to_remove = []\nfor i in range(n):\n    for j in range(segments[i][0], segments[i][1] + 1):\n        segments_covering_point[j] += 1\nfor i in range(2 * (10 ** 5) + 1):\n    if segments_covering_point[i] > k:\n        positions_to_remove.append(i)\nfor position in positions_to_remove:\n    for i in range(n):\n        if segments[i][0] <= position and position <= segments[i][1]:\n            segments_to_remove.append(i + 1)\n            break\nfor segment in segments_to_remove:\n    segments.remove(segments[segment - 1])\nprint(len(segments_to_remove))\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n", "\n\n#-----Solution-----\n\n# First, we find the number of segments that covers each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments covers it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to removes.\n# We also add the segments that covers the point to the list of segments to removes.\n# We then remove the segments from the list of segments. We repeat the process until we find no more positions to removes.\n\n# The number of segments that covers each point.\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to removes.\npositions_to_removes = []\n\n# The segments to removes.\nsegments_to_removes = []\n\n# Read in the number of segments and the maximum number of segments per point.\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments.\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments.\nfor i in range(n):\n    # Iterate through all of the points covers by the segment.\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point.\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points.\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k.\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n", "\n\n#-----Solution-----\n\n# First, we find the number of segments that covers each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments covers it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that covers the point to the list of segments to remove.\n# We then remove the segments from the list of segments. We repeat the process until we find no more positions to remove.\n\n# The number of segments that covers each point\nsegments_covers_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covers by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"]