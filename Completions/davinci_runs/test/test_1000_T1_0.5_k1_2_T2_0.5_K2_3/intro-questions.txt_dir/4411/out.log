2022-04-09 20:03:44.478238 """
The only difference between easy and hard versions is constraints.

You are given $n$ segments on the coordinate axis $OX$. Segments can intersect, lie inside each other and even coincide. The $i$-th segment is $[l_i; r_i]$ ($l_i \le r_i$) and it covers all integer points $j$ such that $l_i \le j \le r_i$.

The integer point is called bad if it is covered by strictly more than $k$ segments.

Your task is to remove the minimum number of segments so that there are no bad points at all.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of segments and the maximum number of segments by which each integer point can be covered.

The next $n$ lines contain segments. The $i$-th line contains two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le 2 \cdot 10^5$) — the endpoints of the $i$-th segment.


-----Output-----

In the first line print one integer $m$ ($0 \le m \le n$) — the minimum number of segments you need to remove so that there are no bad points.

In the second line print $m$ distinct integers $p_1, p_2, \dots, p_m$ ($1 \le p_i \le n$) — indices of segments you remove in any order. If there are multiple answers, you can print any of them.


-----Examples-----
Input
7 2
11 11
9 11
7 8
8 9
7 8
9 11
7 9

Output
3
4 6 7 

Input
5 1
29 30
30 30
29 29
28 30
30 30

Output
3
1 4 5 

Input
6 1
2 3
3 3
2 3
2 2
2 3
2 3

Output
4
1 3 5 6
"""
2022-04-09 20:03:44.478258 --------------------------
2022-04-09 20:04:17.748243 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")"
    }
  ],
  "created": 1649549025,
  "id": "cmpl-4vFLNoYIjirNW6Q67xq1BqdxlGJv5",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 20:04:17.748471 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])"
}
2022-04-09 20:04:17.748517 REASON stop
2022-04-09 20:04:17.749777 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")"
}
2022-04-09 20:04:17.749903 REASON stop
