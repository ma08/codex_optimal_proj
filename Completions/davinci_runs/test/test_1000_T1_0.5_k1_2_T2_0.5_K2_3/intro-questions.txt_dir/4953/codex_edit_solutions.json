["\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = language, cantina[name] = [language], cantina[name] = others\n    patrons = {} #patrons[language] = [name], patrons[language] = language, patrons[language] = others\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, language, others = m.groups()\n        cantina[name] = [language]\n        patrons[language] = language\n        for lang in others.split():\n            if lang not in patrons:\n                patrons[lang] = lang\n            cantina[name].append(lang)\n\n    #print(cantina)\n    #print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if lang == cantina[names[0]][0]:\n            continue\n        else:\n            if len(names) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(names))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages = [char.speaks for char in characters]\n    unique_languages = list(set(unique_languages))\n    unique_languages_counts = [unique_languages.count(characters[i].speaks) for i in range(num_characters)]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(characters[i].can_converse(characters))) for i in range(num_characters)])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, character):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the character speaks the same language as the given character,\n        # then they can converse\n        if self.speaks == character.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in character.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif character.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(students):\n    graph = defaultdict(list)\n    for student in students:\n        for language in students[student]:\n            for other_student in students:\n                if student != other_student and language in students[other_student]:\n                    graph[student].append(other_student)\n                    graph[other_student].append(student)\n\n    visited = defaultdict(bool)\n    components = 0\n    for student in graph:\n        if not visited[student]:\n            dfs(graph, visited, student)\n            components += 1\n    return components\n\ndef main():\n    num_students = int(input())\n    students = defaultdict(set)\n    for i in range(num_students):\n        student, language, *other_languages = input().split()\n        students[student].add(language)\n        for other_language in other_languages:\n            students[student].add(other_language)\n    print(solve(students))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    languages = set()\n    for i in range(n):\n        line = sys.stdin.readline().rstrip().split()\n        languages.update(line[2:])\n    print(n - len(languages))\n\nmain()\n", "\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages_list = [char.speaks for char in characters]\n    unique_languages_list = list(set(unique_languages_list))\n    unique_languages_counts = [unique_languages_list.count(char.speaks) for char in characters if not char.speaks == \"\"]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(char.can_converse(characters))) for char in characters if not char.speaks == \"\"])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, character):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the characters speak the same language, then they can converse\n        if self.speaks == character.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in character.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif character.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# This is a graph problem.\n# Build a directed graph where each node is a person, and each edge is a language.\n# The problem can be solved by finding the strongly connected components and then\n# finding the smallest set of nodes to remove.\n# This is a variant of the problem: https://www.hackerrank.com/challenges/strongly-connected\n\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    # The node with the highest postorder number is the first node in the strongly connected component.\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the edges with the nodes.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\ndef main():\n    graph = read_input()\n    print(get_smallest_set(graph))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages = [char.speaks for char in characters]\n    unique_languages = list(set(unique_languages))\n    unique_languages_counts = [unique_languages.count(char.speaks) for char in characters]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(char.can_converse(characters))) for char in characters])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, character):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the character speaks the same language as the given character,\n        # then they can converse\n        if self.speaks == character.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in character.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif character.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n", "\n#\n#\n\n\nimport fileinput\n\ndef main():\n    # read inputs\n    lines = [line.strip() for line in fileinput.input()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component))\n\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Program to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\n\n# Define graph class\nclass Graph:\n    # Constructor\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n \n    # Add vertex to the graph\n    def add_vertex(self, key):\n        # Check if vertex is already in graph\n        if key in self.vertices:\n            # If key is found, return corresponding vertex object\n            return self.vertices[key]\n        # Instantiate a new vertex\n        new_vertex = Vertex(key)\n        # Add new vertex to the vertices dictionary with key\n        self.vertices[key] = new_vertex\n        # Return the new vertex\n        return new_vertex\n \n    # Add directed edge from vertex with key `from_key` to vertex with key `to_key`\n    def add_directed_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the from and to keys\n        from_vertex = self.add_vertex(from_key)\n        to_vertex = self.add_vertex(to_key)\n        # Add an edge from the from vertex to the to vertex\n        from_vertex.add_edge_to(to_vertex)\n \n    # Add an undirected edge between vertex with key `from_key` and vertex with key `to_key`\n    def add_undirected_edge(self, from_key, to_key):\n        # Add a directed edge from the from key to the to key\n        self.add_directed_edge(from_key, to_key)\n        # Add a directed edge from the to key to the from key\n        self.add_directed_edge(to_key, from_key)\n \n    # Return an array of vertex keys in the graph\n    def get_vertices(self):\n        return self.vertices.keys()\n \n    # Get all the neighbor (adjacent-dependencies) of a vertex specified by the vertex key\n    def get_neighbors(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the neighbors of the given vertex object\n        return vertex.get_neighbors()\n \n    # Return the degree of the vertex specified by the vertex key\n    def vertex_degree(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the degree of the given vertex object\n        return vertex.degree()\n \n    # Find whether there is a vertex with the given vertex key in the graph or not\n    def has_vertex(self, vertex_key):\n        # Return True if the vertex key is found in the graph's vertices\n        return vertex_key in self.vertices\n \n    # Find whether an edge exists between vertices with given `from_key` and `to_key`\n    def has_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the given keys\n        from_vertex = self.vertices[from_key]\n        to_vertex = self.vertices[to_key]\n        # Return True if an edge exists from the from_vertex to the to_vertex\n        return from_vertex.has_edge_to(to_vertex)\n \n# Define vertex class\nclass Vertex:\n    # Constructor\n    def __init__(self, key):\n        # Set the key for the vertex\n        self.key = key\n        # Initialize an empty dictionary for the edges\n        self.edges = {}\n \n    # Add edge to vertex\n    def add_edge_to(self, to_vertex):\n        # Set the value of the edge to be the to_vertex\n        self.edges[to_vertex.key] = to_vertex\n \n    # Get all the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors(self):\n        # Return the values of the edges of this vertex object\n        return self.edges.values()\n \n    # Get all the keys of the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors_keys(self, vertex_key):\n        # Return the keys of the edges of this vertex object\n        vertex = self.vertices[vertex_key]\n        return vertex.get_neighbors_keys()\n \n    # Find whether this vertex has an edge to the vertex with the given key\n    def has_edge_to(self, to_vertex_key):\n        # Return True if the to_vertex_key is found in the edges of this vertex\n        return to_vertex_key in self.edges\n \n    # Return the degree of this vertex\n    def degree(self):\n        # Return the number of edges of this vertex object\n        return len(self.edges)\n \n# Define function to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\ndef minimum_vertices_to_remove(graph):\n    # Create a set to store the vertices of the graph\n    vertices = set(graph.get_vertices())\n    # Create a set to store the vertices to be removed\n    vertices_to_remove = set()\n    # Loop through all vertices in the graph\n    for vertex in vertices:\n        # Remove the vertex from the graph\n        vertices.remove(vertex)\n        # Get all the neighbors of the vertex\n        neighbors = graph.get_neighbors_keys(vertex)\n        # Get all the neighbors of the vertex that are still in the graph\n        neighbors_in_graph = set(neighbors).intersection(vertices)\n        # If no neighbors of the vertex are in the graph, add the vertex to the\n        # vertices_to_remove set\n        if len(neighbors_in_graph) == 0:\n            vertices_to_remove.add(vertex)\n        # Add the vertex back to the vertices set\n        vertices.add(vertex)\n    # Return the set of vertices to be removed\n    return vertices_to_remove\n \n# Create a graph\ngraph = Graph()\n \n# Add an undirected edge between vertex 1 and vertex 2\ngraph.add_undirected_edge(1, 2)\n \n# Add an undirected edge between vertex 1 and vertex 3\ngraph.add_undirected_edge(1, 3)\n \n# Add an undirected edge between vertex 2 and vertex 3\ngraph.add_undirected_edge(2, 3)\n \n# Add an undirected edge between vertex 3 and vertex 4\ngraph.add_undirected_edge(3, 4)\n \n# Add an undirected edge between vertex 4 and vertex 5\ngraph.add_undirected_edge(4, 5)\n \n# Find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\nvertices_to_remove = minimum_vertices_to_remove(graph)\n \n# Print the vertices to be removed\nprint(vertices_to_remove)\n", "\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(patrons):\n    graph = defaultdict(list)\n    for person in patrons:\n        for language in patrons[person]:\n            for other_person in patrons:\n                if person != other_person and language in patrons[other_person]:\n                    graph[person].append(other_person)\n                    graph[other_person].append(person)\n\n    visited = defaultdict(bool)\n    components = 0\n    for person in graph:\n        if not visited[person]:\n            dfs(graph, visited, person)\n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patrons = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split()\n        patrons[patron].add(language)\n        for other_language in other_languages:\n            patrons[patron].add(other_language)\n    print(solve(patrons))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = primary_language\n    patrons = {} #patrons[language] = [name]\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, primary_language, others = m.groups()\n        cantina[name] = primary_language\n        patrons[primary_language] = [name]\n        for other_language in others.split():\n            if other_language not in patrons:\n                patrons[other_language] = []\n            patrons[other_language].append(name)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if len(names) == 1:\n            continue\n        else:\n            if len(patrons[cantina[patrons[lang][0]]]) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(patrons[cantina[patrons[lang][0]]]))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Program to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\n\n# Define graph class\nclass Graph:\n    # Constructor\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n \n    # Add vertex to the graph\n    def add_vertex(self, key):\n        # Check if vertex is already in graph\n        if key in self.vertices:\n            # If key is found, return corresponding vertex object\n            return self.vertices[key]\n        # Instantiate a new vertex\n        new_vertex = Vertex(key)\n        # Add new vertex to the vertices dictionary with key\n        self.vertices[key] = new_vertex\n        # Return the new vertex\n        return new_vertex\n \n    # Add directed edge from vertex with key `from_key` to vertex with key `to_key`\n    def add_directed_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the from and to keys\n        from_vertex = self.add_vertex(from_key)\n        to_vertex = self.add_vertex(to_key)\n        # Add an edge from the from vertex to the to vertex\n        from_vertex.add_edge_to(to_vertex)\n \n    # Add an undirected edge between vertex with key `from_key` and vertex with key `to_key`\n    def add_undirected_edge(self, from_key, to_key):\n        # Add a directed edge from the from key to the to key\n        self.add_directed_edge(from_key, to_key)\n        # Add a directed edge from the to key to the from key\n        self.add_directed_edge(to_key, from_key)\n \n    # Return an array of vertex keys in the graph\n    def get_vertices(self):\n        return self.vertices.keys()\n \n    # Get all the neighbor (adjacent-dependencies) of a vertex specified by the vertex key\n    def get_neighbors(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the neighbors of the given vertex object\n        return vertex.get_neighbors()\n \n    # Return the degree of the vertex specified by the vertex key\n    def vertex_degree(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the degree of the given vertex object\n        return vertex.degree()\n \n    # Find whether there is a vertex with the given vertex key in the graph or not\n    def has_vertex(self, vertex_key):\n        # Return True if the vertex key is found in the graph's vertices\n        return vertex_key in self.vertices\n \n    # Find whether an edge exists between vertices with given `from_key` and `to_key`\n    def has_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the given keys\n        from_vertex = self.vertices[from_key]\n        to_vertex = self.vertices[to_key]\n        # Return True if an edge exists from the from_vertex to the to_vertex\n        return from_vertex.has_edge_to(to_vertex)\n \n# Define vertex class\nclass Vertex:\n    # Constructor\n    def __init__(self, key):\n        # Set the key for the vertex\n        self.key = key\n        # Initialize an empty dictionary for the edges\n        self.edges = {}\n \n    # Add edge to vertex\n    def add_edge_to(self, to_vertex):\n        # Set the value of the edge to be the to_vertex\n        self.edges[to_vertex.key] = to_vertex\n \n    # Get all the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors(self):\n        # Return the values of the edges of this vertex object\n        return self.edges.values()\n \n    # Find whether this vertex has an edge to the vertex with the given key\n    def has_edge_to(self, to_vertex_key):\n        # Return True if the to_vertex_key is found in the edges of this vertex\n        return to_vertex_key in self.edges\n \n    # Return the degree of this vertex\n    def degree(self):\n        # Return the number of edges of this vertex object\n        return len(self.edges)\n \n# Define function to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\ndef minimum_vertices_to_remove(graph):\n    # Create a set to store the vertices of the graph\n    vertices = set(graph.get_vertices())\n    # Create a set to store the vertices to be removed\n    vertices_to_remove = set()\n    # Loop through all vertices in the graph\n    for vertex in vertices:\n        # Remove the vertex from the graph\n        vertices.remove(vertex)\n        # Get all the neighbors of the vertex\n        neighbors = graph.get_neighbors(vertex)\n        # Get all the neighbors of the vertex that are still in the graph\n        neighbors_in_graph = set(neighbors).intersection(vertices)\n        # If no neighbors of the vertex are in the graph, add the vertex to the\n        # vertices_to_remove set\n        if len(neighbors_in_graph) == 0:\n            vertices_to_remove.add(vertex)\n        # Add the vertex back to the vertices set\n        vertices.add(vertex)\n    # Return the set of vertices to be removed\n    return vertices_to_remove\n \n# Create a graph\ngraph = Graph()\n \n# Add an undirected edge between vertex 1 and vertex 2\ngraph.add_undirected_edge(1, 2)\n \n# Add an undirected edge between vertex 1 and vertex 3\ngraph.add_undirected_edge(1, 3)\n \n# Add an undirected edge between vertex 2 and vertex 3\ngraph.add_undirected_edge(2, 3)\n \n# Add an undirected edge between vertex 3 and vertex 4\ngraph.add_undirected_edge(3, 4)\n \n# Add an undirected edge between vertex 4 and vertex 5\ngraph.add_undirected_edge(4, 5)\n \n# Find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\nvertices_to_remove = minimum_vertices_to_remove(graph)\n \n# Print the vertices to be removed\nprint(vertices_to_remove)\n", "import sys\ndef main():\n    n = int(sys.stdin.readline())\n    languages = []\n    for i in range(n):\n        line = sys.stdin.readline().rstrip().split()\n        for lang in line[2:]:\n            languages.append(lang)\n    languages = set(languages)\n    print(n - len(languages))\n\nmain()\n", "\n\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(patrons):\n    graph = defaultdict(list)\n    for patron in patrons:\n        for language in patrons[patron]:\n            for other_patron in patrons:\n                if patron != other_patron and language in patrons[other_patron]:\n                    graph[patron].append(other_patron) \n                    graph[other_patron].append(patron)\n\n    visited = defaultdict(bool)\n    components = 0\n    for patron in patrons:\n        if not visited[patron]: \n            dfs(graph, visited, patron) \n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patrons = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split() \n        patrons[patron].add(language)\n        for other_language in other_languages:\n            patrons[patron].add(other_language)\n    print(solve(patrons))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# This is a graph problem.\n# Build a directed graph where each node is a person, and each edge is a language.\n# The problem can be solved by finding the strongly connected components and then\n# finding the smallest set of nodes to remove.\n# This is a variant of the problem: https://www.hackerrank.com/challenges/strongly-connected\n\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the nodes with the edges.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\ndef main():\n    graph = read_input()\n    print(get_smallest_set(graph))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Program to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\n\n# Define graph class\nclass Graph:\n    # Constructor\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n \n    # Add vertex to the graph\n    def add_vertex(self, key):\n        # Check if vertex is already in graph\n        if key in self.vertices:\n            # If key is found, return corresponding vertex object\n            return self.vertices[key]\n        # Instantiate a new vertex\n        new_vertex = Vertex(key)\n        # Add new vertex to the vertices dictionary with key\n        self.vertices[key] = new_vertex\n        # Return the new vertex\n        return new_vertex\n \n    # Add directed edge from vertex with key `from_key` to vertex with key `to_key`\n    def add_directed_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the from and to keys\n        from_vertex = self.add_vertex(from_key)\n        to_vertex = self.add_vertex(to_key)\n        # Add an edge from the from vertex to the to vertex\n        from_vertex.add_edge_to(to_vertex)\n \n    # Add an undirected edge between vertex with key `from_key` and vertex with key `to_key`\n    def add_undirected_edge(self, from_key, to_key):\n        # Add a directed edge from the from key to the to key\n        self.add_directed_edge(from_key, to_key)\n        # Add a directed edge from the to key to the from key\n        self.add_directed_edge(to_key, from_key)\n \n    # Return an array of vertex keys in the graph\n    def get_vertices(self):\n        return self.vertices.keys()\n \n    # Get all the neighbor (adjacent-dependencies) of a vertex specified by the vertex key\n    def get_neighbors(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the neighbors of the given vertex object\n        return vertex.get_neighbors()\n \n    # Return the degree of the vertex specified by the vertex key\n    def vertex_degree(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the degree of the given vertex object\n        return vertex.degree()\n \n    # Find whether there is a vertex with the given vertex key in the graph or not\n    def has_vertex(self, vertex_key):\n        # Return True if the vertex key is found in the graph's vertices\n        return vertex_key in self.vertices\n \n    # Find whether an edge exists between vertices with given `from_key` and `to_key`\n    def has_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the given keys\n        from_vertex = self.vertices[from_key]\n        to_vertex = self.vertices[to_key]\n        # Return True if an edge exists from the from_vertex to the to_vertex\n        return from_vertex.has_edge_to(to_vertex)\n \n# Define vertex class\nclass Vertex:\n    # Constructor\n    def __init__(self, key):\n        # Set the key for the vertex\n        self.key = key\n        # Initialize an empty dictionary for the edges\n        self.edges = {}\n \n    # Add edge to vertex\n    def add_edge_to(self, to_vertex):\n        # Set the value of the edge to be the to_vertex\n        self.edges[to_vertex.key] = to_vertex\n \n    # Get all the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors(self):\n        # Return the values of the edges of this vertex object\n        return self.edges.values()\n \n    # Get all the keys of the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors_keys(self):\n        # Return the keys of the edges of this vertex object\n        return self.edges.keys()\n \n    # Find whether this vertex has an edge to the vertex with the given key\n    def has_edge_to(self, to_vertex_key):\n        # Return True if the to_vertex_key is found in the edges of this vertex\n        return to_vertex_key in self.edges\n \n    # Return the degree of this vertex\n    def degree(self):\n        # Return the number of edges of this vertex object\n        return len(self.edges)\n \n# Define function to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\ndef minimum_vertices_to_remove(graph):\n    # Create a set to store the vertices of the graph\n    vertices = set(graph.get_vertices())\n    # Create a set to store the vertices to be removed\n    vertices_to_remove = set()\n    # Loop through all vertices in the graph\n    for vertex in vertices:\n        # Remove the vertex from the graph\n        vertices.remove(vertex)\n        # Get all the neighbors of the vertex\n        neighbors = graph.get_neighbors(vertex)\n        # Get all the neighbors of the vertex that are still in the graph\n        neighbors_in_graph = set([neighbor.key for neighbor in neighbors]).intersection(vertices)\n        # If no neighbors of the vertex are in the graph, add the vertex to the\n        # vertices_to_remove set\n        if len(neighbors_in_graph) == 0:\n            vertices_to_remove.add(vertex)\n        # Add the vertex back to the vertices set\n        vertices.add(vertex)\n    # Return the set of vertices to be removed\n    return vertices_to_remove\n \n# Create a graph\ngraph = Graph()\n \n# Add an undirected edge between vertex 1 and vertex 2\ngraph.add_undirected_edge(1, 2)\n \n# Add an undirected edge between vertex 1 and vertex 3\ngraph.add_undirected_edge(1, 3)\n \n# Add an undirected edge between vertex 2 and vertex 3\ngraph.add_undirected_edge(2, 3)\n \n# Add an undirected edge between vertex 3 and vertex 4\ngraph.add_undirected_edge(3, 4)\n \n# Add an undirected edge between vertex 4 and vertex 5\ngraph.add_undirected_edge(4, 5)\n \n# Find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\nvertices_to_remove = minimum_vertices_to_remove(graph)\n \n# Print the vertices to be removed\nprint(vertices_to_remove)\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = language, cantina[name] = [language, language]\n    patrons = {} #patrons[language] = [name, name], patrons[language] = language\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, language, others = m.groups()\n        cantina[name] = [language]\n        patrons[language] = language\n        for lang in others.split():\n            if lang not in patrons:\n                patrons[lang] = lang\n            cantina[name].append(lang)\n\n    #print(cantina)\n    #print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if lang == cantina[names[0]][0]:\n            continue\n        else:\n            if len(names) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(names))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    languages = set()\n    for i in range(n):\n        line = sys.stdin.readline().rstrip().split()\n        for lang in line[2:]:\n            languages.add(lang)\n    print(n - len(languages))\n\nmain()\n", "\nimport fileinput\n\ndef main():\n    # Read input\n    lines = [line.strip() for line in fileinput.input()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # Construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # Find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # Find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component))\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Program to find the minimum number of vertices to remove from the graph to ensure that all remaining vertices are connected\n\n# Define graph class\nclass Graph:\n    # Constructor\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n \n    # Add vertex to the graph\n    def add_vertex(self, key):\n        # Check if vertex is already in graph\n        if key in self.vertices:\n            # If key is found, return corresponding vertex object\n            return self.vertices[key]\n        # Instantiate a new vertex\n        new_vertex = Vertex(key)\n        # Add new vertex to the vertices dictionary with key\n        self.vertices[key] = new_vertex\n        # Return the new vertex\n        return new_vertex\n \n    # Add directed edge from vertex with key `from_key` to vertex with key `to_key`\n    def add_directed_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the from and to keys\n        from_vertex = self.add_vertex(from_key)\n        to_vertex = self.add_vertex(to_key)\n        # Add an edge from the from vertex to the to vertex\n        from_vertex.add_edge_to(to_vertex)\n \n    # Add an undirected edge between vertex with key `from_key` and vertex with key `to_key`\n    def add_undirected_edge(self, from_key, to_key):\n        # Add a directed edge from the from key to the to key\n        self.add_directed_edge(from_key, to_key)\n        # Add a directed edge from the to key to the from key\n        self.add_directed_edge(to_key, from_key)\n \n    # Return an array of vertex keys in the graph\n    def get_vertices(self):\n        return self.vertices.keys()\n \n    # Get all the neighbor (adjacent-dependencies) of a vertex specified by the vertex key\n    def get_neighbors(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the neighbors of the given vertex object\n        return vertex.get_neighbors()\n \n    # Return the degree of the vertex specified by the vertex key\n    def vertex_degree(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the degree of the given vertex object\n        return vertex.degree()\n \n    # Find whether there is a vertex with the given vertex key in the graph or not\n    def has_vertex(self, vertex_key):\n        # Return True if the vertex key is found in the graph's vertices\n        return vertex_key in self.vertices\n \n    # Find whether an edge exists between vertices with given `from_key` and `to_key`\n    def has_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the given keys\n        from_vertex = self.vertices[from_key]\n        to_vertex = self.vertices[to_key]\n        # Return True if an edge exists from the from_vertex to the to_vertex\n        return from_vertex.has_edge_to(to_vertex)\n \n# Define vertex class\nclass Vertex:\n    # Constructor\n    def __init__(self, key):\n        # Set the key for the vertex\n        self.key = key\n        # Initialize an empty dictionary for the edges\n        self.edges = {}\n \n    # Add edge to vertex\n    def add_edge_to(self, to_vertex):\n        # Set the value of the edge to be the to_vertex\n        self.edges[to_vertex.key] = to_vertex\n \n    # Get all the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors(self):\n        # Return the values of the edges of this vertex object\n        return self.edges.values()\n \n    # Get all the keys of the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors_keys(self):\n        # Return the keys of the edges of this vertex object\n        return self.edges.keys()\n \n    # Find whether this vertex has an edge to the vertex with the given key\n    def has_edge_to(self, to_vertex_key):\n        # Return True if the to_vertex_key is found in the edges of this vertex\n        return to_vertex_key in self.edges\n \n    # Return the degree of this vertex\n    def degree(self):\n        # Return the number of edges of this vertex object\n        return len(self.edges)\n \n# Define function to find the minimum number of vertices to remove from the graph to ensure that all remaining vertices are connected\ndef minimum_vertices_to_remove(graph):\n    # Create a set to store the vertices of the graph\n    vertices = set(graph.get_vertices())\n    # Create a set to store the vertices to be removed\n    vertices_to_remove = set()\n    # Loop through all vertices in the graph\n    for vertex in vertices:\n        # Remove the vertex from the graph\n        vertices.remove(vertex)\n        # Get all the neighbors of the vertex\n        neighbors = graph.get_neighbors_keys(vertex)\n        # Get all the neighbors of the vertex that are still in the graph\n        neighbors_in_graph = set(neighbors).intersection(vertices)\n        # If no neighbors of the vertex are in the graph, add the vertex to the\n        # vertices_to_remove set\n        if len(neighbors_in_graph) == 0:\n            vertices_to_remove.add(vertex)\n        # Add the vertex back to the vertices set\n        vertices.add(vertex)\n    # Return the set of vertices to be removed\n    return vertices_to_remove\n \n# Create a graph\ngraph = Graph()\n \n# Add an undirected edge between vertex 1 and vertex 2\ngraph.add_undirected_edge(1, 2)\n \n# Add an undirected edge between vertex 1 and vertex 3\ngraph.add_undirected_edge(1, 3)\n \n# Add an undirected edge between vertex 2 and vertex 3\ngraph.add_undirected_edge(2, 3)\n \n# Add an undirected edge between vertex 3 and vertex 4\ngraph.add_undirected_edge(3, 4)\n \n# Add an undirected edge between vertex 4 and vertex 5\ngraph.add_undirected_edge(4, 5)\n \n# Find the minimum number of vertices to remove from the graph to ensure that all remaining vertices are connected\nvertices_to_remove = minimum_vertices_to_remove(graph)\n \n# Print the vertices to be removed\nprint(vertices_to_remove)\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    languages = []\n    for i in range(n):\n        line = sys.stdin.readline().strip().split()\n        for lang in line[2:]:\n            languages.append(lang)\n    languages = set(languages)\n    print(len(languages))\n\nmain()\n", "\n\nfrom collections import defaultdict, namedtuple\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(patron):\n    graph = defaultdict(list)\n    for p in patron:\n        for language in patron[p]:\n            for other_patron in patron:\n                if p != other_patron and language in patron[other_patron]:\n                    graph[p].append(other_patron)\n                    graph[other_patron].append(p)\n\n    visited = defaultdict(bool)\n    components = 0\n    for p in graph:\n        if not visited[p]:\n            dfs(graph, visited, p)\n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patron = defaultdict(set)\n    for i in range(num_patrons):\n        p, language, *other_languages = input().split()\n        patron[p].add(language)\n        for o in other_languages:\n            patron[p].add(o)\n    print(solve(patron))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Program to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\n\n# Define graph class\nclass Graph:\n    # Constructor\n    def __init__(self):\n        # dictionary containing keys that map to the corresponding vertex object\n        self.vertices = {}\n \n    # Add vertex to the graph\n    def add_vertex(self, key):\n        # Check if vertex is already in graph\n        if key in self.vertices:\n            # If key is found, return corresponding vertex object\n            return self.vertices[key]\n        # Instantiate a new vertex\n        new_vertex = Vertex(key)\n        # Add new vertex to the vertices dictionary with key\n        self.vertices[key] = new_vertex\n        # Return the new vertex\n        return new_vertex\n \n    # Add directed edge from vertex with key `from_key` to vertex with key `to_key`\n    def add_directed_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the from and to keys\n        from_vertex = self.add_vertex(from_key)\n        to_vertex = self.add_vertex(to_key)\n        # Add an edge from the from vertex to the to vertex\n        from_vertex.add_edge_to(to_vertex)\n \n    # Add an undirected edge between vertex with key `from_key` and vertex with key `to_key`\n    def add_undirected_edge(self, from_key, to_key):\n        # Add a directed edge from the from key to the to key\n        self.add_directed_edge(from_key, to_key)\n        # Add a directed edge from the to key to the from key\n        self.add_directed_edge(to_key, from_key)\n \n    # Return an array of vertex keys in the graph\n    def get_vertices(self):\n        return self.vertices.keys()\n \n    # Get all the neighbor (adjacent-dependencies) of a vertex specified by the vertex key\n    def get_neighbors(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the neighbors of the given vertex object\n        return vertex.get_neighbors()\n \n    # Return the degree of the vertex specified by the vertex key\n    def vertex_degree(self, vertex_key):\n        # Get the vertex object with the specified vertex_key\n        vertex = self.vertices[vertex_key]\n        # Return the degree of the given vertex object\n        return vertex.degree()\n \n    # Find whether there is a vertex with the given vertex key in the graph or not\n    def has_vertex(self, vertex_key):\n        # Return True if the vertex key is found in the graph's vertices\n        return vertex_key in self.vertices\n \n    # Find whether an edge exists between vertices with given `from_key` and `to_key`\n    def has_edge(self, from_key, to_key):\n        # Get the vertex objects corresponding to the given keys\n        from_vertex = self.vertices[from_key]\n        to_vertex = self.vertices[to_key]\n        # Return True if an edge exists from the from_vertex to the to_vertex\n        return from_vertex.has_edge_to(to_vertex)\n \n# Define vertex class\nclass Vertex:\n    # Constructor\n    def __init__(self, key):\n        # Set the key for the vertex\n        self.key = key\n        # Initialize an empty dictionary for the edges\n        self.edges = {}\n \n    # Add edge to vertex\n    def add_edge_to(self, to_vertex):\n        # Set the value of the edge to be the to_vertex\n        self.edges[to_vertex.key] = to_vertex\n \n    # Get all the neighbor (adjacent-dependencies) of this vertex\n    def get_neighbors(self):\n        # Return the values of the edges of this vertex object\n        return self.edges.values()\n \n    # Find whether this vertex has an edge to the vertex with the given key\n    def has_edge_to(self, to_vertex_key):\n        # Return True if the to_vertex_key is found in the edges of this vertex\n        return to_vertex_key in self.edges\n \n    # Return the degree of this vertex\n    def degree(self):\n        # Return the number of edges of this vertex object\n        return len(self.edges)\n \n# Define function to find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\ndef minimum_vertices_to_remove(graph):\n    # Create a set to store the vertices of the graph\n    vertices = set(graph.get_vertices())\n    # Create a set to store the vertices to be removed\n    vertices_to_remove = set()\n    # Loop through all vertices in the graph\n    for vertex in vertices:\n        # Remove the vertex from the graph\n        vertices.remove(vertex)\n        # Get all the neighbors of the vertex\n        neighbors = graph.get_neighbors(vertex)\n        # Get all the neighbors of the vertex that are still in the graph\n        neighbors_in_graph = set(neighbors).intersection(vertices) # this line is problematic\n        # If no neighbors of the vertex are in the graph, add the vertex to the\n        # vertices_to_remove set\n        if len(neighbors_in_graph) == 0:\n            vertices_to_remove.add(vertex)\n        # Add the vertex back to the vertices set\n        vertices.add(vertex)\n    # Return the set of vertices to be removed\n    return vertices_to_remove\n \n# Create a graph\ngraph = Graph()\n \n# Add an undirected edge between vertex 1 and vertex 2\ngraph.add_undirected_edge(1, 2)\n \n# Add an undirected edge between vertex 1 and vertex 3\ngraph.add_undirected_edge(1, 3)\n \n# Add an undirected edge between vertex 2 and vertex 3\ngraph.add_undirected_edge(2, 3)\n \n# Add an undirected edge between vertex 3 and vertex 4\ngraph.add_undirected_edge(3, 4)\n \n# Add an undirected edge between vertex 4 and vertex 5\ngraph.add_undirected_edge(4, 5)\n \n# Find the minimum number of vertices to remove from the graph\n# to ensure that all remaining vertices are connected\nvertices_to_remove = minimum_vertices_to_remove(graph)\n \n# Print the vertices to be removed\nprint(vertices_to_remove)\n", "\n\nimport sys\n\ndef main():\n    # read inputs\n    lines = [line.strip() for line in sys.stdin.readlines()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in language[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component))\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = language of name\n    patrons = {} #patrons[language] = [name]\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, language, others = m.groups()\n        cantina[name] = language\n        if language not in patrons:\n            patrons[language] = []\n        patrons[language].append(name)\n        for lang in others.split():\n            if lang not in patrons:\n                patrons[lang] = []\n            patrons[lang].append(name)\n\n    print(cantina)\n    print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if len(names) == 1:\n            continue\n        else:\n            print(names)\n            print(patrons)\n            print(cantina)\n            print(lang)\n            print(patrons[lang])\n            print(cantina[patrons[lang][0]])\n            print(patrons[cantina[patrons[lang][0]]])\n            #if len(patrons[cantina[patrons[lang][0]]]) == 1:\n            #    continue\n            #else:\n            #    min_patrons = min(min_patrons, N - len(patrons[cantina[patrons[lang][0]]]))\n\n    #print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(students):\n    graph = defaultdict(list)\n    for student in students:\n        for language in students[student]:\n            for other_student in students:\n                if student != other_student and language in students[other_student]:\n                    graph[student].append(other_student)\n                    graph[other_student].append(student)\n\n    visited = defaultdict(bool)\n    components = 0\n    for patron in graph:\n        if not visited[patron]:\n            dfs(graph, visited, patron)\n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patrons = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split()\n        patrons[patron].add(language)\n        for other_language in other_languages:\n            patrons[patron].add(other_language)\n    print(solve(patrons))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import defaultdict\n\ndef main():\n    num_patrons = int(input())\n    patrons = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split()\n        patrons[patron].add(language)\n        for other_language in other_languages:\n            patrons[patron].add(other_language)\n    print(solve(patrons))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    characters = {}\n    for i in range(N):\n        line = input().split()\n        name = line[0]\n        lang = line[1]\n        chars = {lang}\n        for j in range(2, len(line)):\n            chars.add(line[j])\n        characters[name] = chars\n    # calculate the set of characters that cannot converse with everyone\n    conversations = []\n    for name in characters.keys():\n        chars = characters[name]\n        for other in characters.keys():\n            if name == other:\n                continue\n            if len(chars.intersection(characters[other])) == 0:\n                conversations.append((name, other))\n    # find the set of characters that should be removed\n    remove = set()\n    for convo in conversations:\n        remove.add(convo[0])\n        remove.add(convo[1])\n    # print the result\n    print(len(remove))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    languages = []\n    for i in range(n):\n        line = sys.stdin.readline().rstrip('\\n').split()\n        for lang in line[2:]:\n            languages.append(lang)\n    languages = set(languages)\n    print(n - len(languages))\n\nmain()\n", "\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = primary_language\n    patrons = {} #patrons[language] = [name]\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, primary_language, others = m.groups()\n        cantina[name] = primary_language\n        patrons[primary_language] = [name]\n        for other_language in others.split():\n            if other_language not in patrons:\n                patrons[other_language] = []\n            patrons[other_language].append(name)\n\n    #print(cantina)\n    #print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if len(names) == 1:\n            continue\n        else:\n            #print(names)\n            #print(patrons)\n            #print(cantina)\n            #print(lang)\n            #print(patrons[lang])\n            #print(cantina[patrons[lang][0]])\n            #print(patrons[cantina[patrons[lang][0]]])\n            if len(patrons[cantina[patrons[lang][0]]]) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(patrons[cantina[patrons[lang][0]]]))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the nodes with the edges.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\ndef main():\n    graph = read_input()\n    print(get_smallest_set(graph))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# This is a graph problem, I assume.\n# Build a directed graph where each node is a person, and each edge is a language.\n# The problem can be solved by finding the strongly connected components and then\n# finding the smallest set of nodes to remove.\n# This is a variant of the problem: https://www.hackerrank.com/challenges/strongly-connected\n\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the nodes with the edges.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\ndef main():\n    graph = read_input()\n    print(get_smallest_set(graph))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# import fileinput\n\ndef main():\n    # read input\n    N = int(input())\n    characters = {}\n    for i in range(N):\n        line = input().split()\n        name = line[0]\n        lang = line[1]\n        chars = {lang}\n        for j in range(2, len(line)):\n            chars.add(line[j])\n        characters[name] = chars\n    # calculate the set of characters that cannot converse with everyone\n    conversations = []\n    for name in characters.keys():\n        chars = characters[name]\n        for other in characters.keys():\n            if name == other:\n                continue\n            if len(chars.intersection(characters[other])) == 0:\n                conversations.append((name, other))\n    # find the set of characters that should be removed\n    remove = set()\n    for convo in conversations:\n        remove.add(convo[0])\n        remove.add(convo[1])\n    # print the result\n    print(len(remove))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    languages = set()\n    for i in range(n):\n        line = sys.stdin.readline().rstrip().split()\n        for lang in line[2:]:\n            languages.add(lang)\n    print(len(languages))\n\nmain()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    languages = []\n    for i in range(n):\n        line = sys.stdin.readline().rstrip().split()\n        for lang in line[2:]:\n            languages.append(lang)\n    languages = set(languages)\n    print(n - len(languages))\n\nmain()\n", "\n\n# This is a graph problem. Build a directed graph where each node is a person,\n# and each edge is a language. The problem can be solved by finding the strongly\n# connected components and then finding the smallest set of nodes to remove.\n# This is a variant of the problem:\n# https://www.hackerrank.com/challenges/strongly-connected\n\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(raw_input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = raw_input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    # The node with the highest postorder number is the first node in the\n    # strongly connected component.\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the edges with the nodes.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\ndef main():\n    graph = read_input()\n    print get_smallest_set(graph)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    characters = {}\n    for i in range(N):\n        line = input().split()\n        name = line[0]\n        lang = line[1]\n        chars = {lang}\n        for j in range(2, len(line)):\n            chars.add(line[j])\n        characters[name] = chars\n    # calculate the set of characters that can converse with everyone else\n    conversations = []\n    for name in characters.keys():\n        chars = characters[name]\n        for other in characters.keys():\n            if name == other:\n                continue\n            if len(chars.intersection(characters[other])) == 0:\n                conversations.append((name, other))\n    # find the set of characters that should be removed to ensure everyone can converse\n    remove = set()\n    for convo in conversations:\n        remove.add(convo[0])\n        remove.add(convo[1])\n    # print the result\n    print(len(remove))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages_list = [char.speaks for char in characters]\n    unique_languages_list = list(set(unique_languages_list))\n    unique_languages_counts = [unique_languages_list.count(characters[i].speaks) for i in range(len(characters))]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(characters[i].can_converse(characters))) for i in range(len(characters))])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, character):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the characters speak the same language, then they can converse\n        if self.speaks == character.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in character.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif character.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    # read input\n    N = int(raw_input())\n    characters = {}\n    for i in range(N):\n        line = raw_input().split()\n        name = line[0]\n        lang = line[1]\n        chars = {lang}\n        for j in range(2, len(line)):\n            chars.add(line[j])\n        characters[name] = chars\n    # calculate the set of characters that can converse with everyone else\n    conversations = []\n    for name in characters.keys():\n        chars = characters[name]\n        for other in characters.keys():\n            if name == other:\n                continue\n            if len(chars.intersection(characters[other])) == 0:\n                conversations.append((name, other))\n    # find the set of characters that should be removed to ensure everyone can converse\n    remove = set()\n    for convo in conversations:\n        remove.add(convo[0])\n        remove.add(convo[1])\n    # print the result\n    print(len(remove))\n\nif __name__ == '__main__':\n    main()\n", "\nimport fileinput\n\ndef main():\n    # read input\n    lines = [line.strip() for line in fileinput.input()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component))\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "\nimport fileinput\n\ndef main():\n    # Read input\n    input = [line.strip() for line in fileinput.input()]\n    n = int(input[0])\n    input = input[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # Construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # Find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # Find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component))\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "\n\n\ndef main():\n    # read input\n    N = int(input())\n    characters = {}\n    for i in range(N):\n        line = input().split()\n        name = line[0]\n        lang = line[1]\n        chars = {lang}\n        for j in range(2, len(line)):\n            chars.add(line[j])\n        characters[name] = chars\n    # calculate the set of characters that can converse with everyone else\n    conversations = []\n    for name in characters.keys():\n        chars = characters[name]\n        for other in characters.keys():\n            if name == other:\n                continue\n            if len(chars.intersection(characters[other])) == 0:\n                conversations.append((name, other))\n    # find the set of characters that should be removed to ensure everyone can converse\n    remove = set()\n    for convo in conversations:\n        remove.add(convo[0])\n        remove.add(convo[1])\n    # print the result\n    print(len(remove))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(patron):\n    graph = defaultdict(list)\n    for person in patron:\n        for language in patron[person]:\n            for other_person in patron:\n                if person != other_person and language in patron[other_person]:\n                    graph[person].append(other_person)\n                    graph[other_person].append(person)\n\n    visited = defaultdict(bool)\n    components = 0\n    for person in graph:\n        if not visited[person]:\n            dfs(graph, visited, person)\n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patron = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split()\n        patron[patron].add(language)\n        for other_language in other_languages:\n            patron[patron].add(other_language)\n    print(solve(patron))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(patrons):\n    graph = defaultdict(list)\n    for person in patrons:\n        for other_person in patrons:\n            if person != other_person and patrons[person] & patrons[other_person]:\n                graph[person].append(other_person)\n                graph[other_person].append(person)\n\n    visited = defaultdict(lambda: False)\n    components = 0\n    for person in graph:\n        if not visited[person]:\n            dfs(graph, visited, person)\n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patrons = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split()\n        patrons[patron].add(language)\n        for other_language in other_languages:\n            patrons[patron].add(other_language)\n    print(solve(patrons))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    # read input\n    N = int(input())\n    characters = {}\n    for i in range(N):\n        line = input().split()\n        name = line[0]\n        lang = line[1]\n        chars = {lang}\n        for j in range(2, len(line)):\n            chars.add(line[j])\n        characters[name] = chars\n    # calculate the set of characters that cannot converse with everyone\n    conversations = []\n    for name in characters.keys():\n        chars = characters[name]\n        for other in characters.keys():\n            if name == other:\n                continue\n            if len(chars.intersection(characters[other])) == 0:\n                conversations.append((name, other))\n    # find the set of characters that should be removed\n    remove = set()\n    for convo in conversations:\n        remove.add(convo[0])\n        remove.add(convo[1])\n    # print the result\n    print(len(remove))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = [language]\n    patrons = {} #patrons[language] = language\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, language, others = m.groups()\n        cantina[name] = [language]\n        patrons[language] = language\n        for lang in others.split():\n            if lang not in patrons:\n                patrons[lang] = lang\n            cantina[name].append(lang)\n\n    #print(cantina)\n    #print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if lang == cantina[names[0]][0]:\n            continue\n        else:\n            if len(names) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(names))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = language of name\n    patrons = {} #patrons[language] = [name]\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    #for i in range(N):\n    line = sys.stdin.readline().strip()\n    m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n    name, language, others = m.groups()\n    cantina[name] = language\n    if language not in patrons:\n        patrons[language] = []\n    patrons[language].append(name)\n    for lang in others.split():\n        if lang not in patrons:\n            patrons[lang] = []\n        patrons[lang].append(name)\n\n    #print(cantina)\n    #print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if len(names) == 1:\n            continue\n        else:\n            #print(names)\n            #print(patrons)\n            #print(cantina)\n            #print(lang)\n            #print(patrons[lang])\n            #print(cantina[patrons[lang][0]])\n            #print(patrons[cantina[patrons[lang][0]]])\n            if len(patrons[cantina[patrons[lang][0]]]) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(patrons[cantina[patrons[lang][0]]]))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport fileinput\n\ndef main():\n    # read inputs\n    lines = [line.strip() for line in fileinput.input()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()[:2]\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component))\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport fileinput\n\ndef main():\n    # Read input\n    lines = [line.strip() for line in fileinput.input()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # Construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # Find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # Find the smallest connected component\n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component)) \n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n\n\nimport sys\n\ndef main():\n    n = int(raw_input())\n    languages = []\n    for i in range(n):\n        line = raw_input().rstrip().split()\n        for lang in line[2:]:\n            languages.append(lang)\n    languages = set(languages)\n    print n - len(languages)\n\nmain()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    languages = []\n    for i in range(n):\n        line = sys.stdin.readline().rstrip().split()\n        for lang in line[2:]:\n            languages.append(lang)\n    languages = set(languages)\n    print(len(languages))\n\nif __name__ == '__main__':\n    main()\n", "\n# This is a graph problem. \n# Build a directed graph where each node is a person, and each edge is a language.\n# The problem can be solved by finding the strongly connected components and then\n# finding the smallest set of nodes to remove.\n# This is a variant of the problem:\n# https://www.hackerrank.com/challenges/strongly-connected\n\n\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(raw_input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = raw_input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the nodes with the edges.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\n\ndef main():\n    graph = read_input()\n    print get_smallest_set(graph)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages = [char.speaks for char in characters]\n    unique_languages = list(set(unique_languages))\n    unique_languages_counts = [unique_languages.count(char.speaks) for char in characters]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(char.can_converse(characters))) for char in characters])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, char):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the characters speak the same language, then they can converse\n        if self.speaks == char.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in char.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif char.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n", "\n# This is a graph problem, I assume.\n# Build a directed graph where each node is a person, and each edge is a language.\n# The problem can be solved by finding the strongly connected components and then\n# finding the smallest set of nodes to remove.\n# This is a variant of the problem: https://www.hackerrank.com/challenges/strongly-connected\n\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n):\n        line = input().split()\n        node = line[0]\n        graph[node] = line[2:]\n    return graph\n\ndef dfs(graph, start, visited, postorder, postorder_index):\n    \"\"\"\n    Depth-first search.\n    \"\"\"\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n    postorder[start] = postorder_index[0]\n    postorder_index[0] -= 1\n\ndef reverse_graph(graph):\n    \"\"\"\n    Reverses the graph by switching the nodes with the edges.\n    \"\"\"\n    reversed_graph = defaultdict(list)\n    for node in graph:\n        for edge in graph[node]:\n            reversed_graph[edge].append(node)\n    return reversed_graph\n\ndef get_strongly_connected_components(graph):\n    \"\"\"\n    Returns a list of strongly connected components.\n    \"\"\"\n    visited = set()\n    postorder = {}\n    postorder_index = [len(graph)]\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited, postorder, postorder_index)\n\n    graph = reverse_graph(graph)\n    visited = set()\n    components = []\n    for node in sorted(postorder, key=postorder.get):\n        if node not in visited:\n            component = []\n            dfs(graph, node, visited, {}, component)\n            components.append(component)\n    return components\n\ndef get_smallest_set(graph):\n    \"\"\"\n    Returns the smallest set of nodes to remove from the graph.\n    \"\"\"\n    components = get_strongly_connected_components(graph)\n    min_size = len(graph)\n    for component in components:\n        min_size = min(min_size, len(graph) - len(component))\n    return min_size\n\ndef main():\n    graph = read_input()\n    print(get_smallest_set(graph))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {}  # cantina[name] = language of name\n    patrons = {}  # patrons[language] = [name]\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, language, others = m.groups()\n        cantina[name] = language\n        if language not in patrons:\n            patrons[language] = []\n        patrons[language].append(name)\n        for lang in others.split():\n            if lang not in patrons:\n                patrons[lang] = []\n            patrons[lang].append(name)\n\n    # print(cantina)\n    # print(patrons)\n\n    #find minimum size set of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if len(names) == 1:\n            continue\n        else:\n            # print(names)\n            # print(patrons)\n            # print(cantina)\n            # print(lang)\n            # print(patrons[lang])\n            # print(cantina[patrons[lang][0]])\n            # print(patrons[cantina[patrons[lang][0]]])\n            if len(patrons[cantina[patrons[lang][0]]]) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(patrons[cantina[patrons[lang][0]]]))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import defaultdict\n\ndef dfs(graph, visited, start):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, visited, node)\n\ndef solve(patrons):\n    graph = defaultdict(list)\n    for person in patrons:\n        for language in patrons[person]:\n            for other_person in patrons:\n                if person != other_person and language in patrons[other_person]:\n                    graph[person].append(other_person)\n                    graph[other_person].append(person)\n\n    visited = defaultdict(lambda: False)\n    components = 0\n    for person in graph:\n        if not visited[person]:\n            dfs(graph, visited, person)\n            components += 1\n    return components\n\ndef main():\n    num_patrons = int(input())\n    patrons = defaultdict(set)\n    for i in range(num_patrons):\n        patron, language, *other_languages = input().split()\n        patrons[patron].add(language)\n        for other_language in other_languages:\n            patrons[patron].add(other_language)\n    print(solve(patrons))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport re\n\ndef main():\n    cantina = {} #cantina[name] = primary_language\n    patrons = {} #patrons[language] = [name]\n\n    #read in cantina\n    N = int(sys.stdin.readline().strip())\n    for i in range(N):\n        line = sys.stdin.readline().strip()\n        m = re.match(r\"(.*)\\s(.*)\\s(.*)\", line)\n        name, primary_language, others = m.groups()\n        cantina[name] = primary_language\n        patrons[primary_language] = [name]\n        for other_language in others.split():\n            if other_language not in patrons:\n                patrons[other_language] = []\n            patrons[other_language].append(name)\n\n    print(cantina)\n    print(patrons)\n\n    #find minimum number of patrons to remove\n    min_patrons = N\n    for lang, names in patrons.items():\n        if len(names) == 1:\n            continue\n        else:\n            print(names)\n            print(patrons)\n            print(cantina)\n            print(lang)\n            print(patrons[lang])\n            print(cantina[patrons[lang][0]])\n            print(patrons[cantina[patrons[lang][0]]])\n            if len(patrons[cantina[patrons[lang][0]]]) == 1:\n                continue\n            else:\n                min_patrons = min(min_patrons, N - len(patrons[cantina[patrons[lang][0]]]))\n\n    print(min_patrons)\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport fileinput\n\ndef main():\n    # read input\n    lines = [line.strip() for line in fileinput.input()]\n    n = int(lines[0])\n    lines = lines[1:]\n    people = []\n    for line in lines:\n        name, language = line.split()\n        languages = set()\n        for l in line.split()[2:]:\n            languages.add(l)\n        people.append((name, language, languages))\n\n    # construct graph\n    graph = {}\n    for person in people:\n        graph[person[0]] = []\n        for person2 in people:\n            if person[0] != person2[0] and person[1] in person2[2] and person2[1] in person[2]:\n                graph[person[0]].append(person2[0])\n\n    # find connected components\n    components = []\n    visited = set()\n    for person in people:\n        if person[0] not in visited:\n            visited.add(person[0])\n            component = set()\n            component.add(person[0])\n            dfs(graph, person[0], visited, component)\n            components.append(component)\n\n    # find the smallest connected component \n    min_component = min(components, key=lambda c: len(c))\n\n    print(len(people) - len(min_component) - 1)\n\ndef dfs(graph, node, visited, component):\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            component.add(neighbor)\n            dfs(graph, neighbor, visited, component)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages = [char.speaks for char in characters]\n    unique_languages = list(set(unique_languages))\n    unique_languages_counts = [unique_languages.count(characters[i].speaks) for i in range(len(characters))]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(characters[i].can_converse(characters))) for i in range(len(characters))])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, character):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the character speaks the same language as the given character,\n        # then they can converse\n        if self.speaks == character.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in character.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif character.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    num_characters = int(input())\n    characters = []\n    for i in range(num_characters):\n        characters.append(Character(input()))\n    print(solve(characters))\n\ndef solve(characters):\n    \"\"\"\n    Solves the problem.\n    \"\"\"\n    # Find all characters who speak a unique language\n    unique_languages = [char.speaks for char in characters]\n    unique_languages = list(set(unique_languages))\n    unique_languages_counts = [unique_languages.count(char.speaks) for char in characters]\n    unique_languages_counts = list(set(unique_languages_counts))\n    # If a character speaks a unique language, then they must leave\n    if 1 in unique_languages_counts:\n        return unique_languages_counts.count(1)\n    # Otherwise, we have to find the largest set of characters who can converse\n    # with each other\n    else:\n        return max([len(set(characters) - set(char.can_converse(characters))) for char in characters])\n\nclass Character:\n    \"\"\"\n    Character class.\n    \"\"\"\n    def __init__(self, input_line):\n        \"\"\"\n        Initializes a character.\n        \"\"\"\n        self.name, self.speaks, *self.understands = input_line.split()\n\n    def can_converse(self, characters):\n        \"\"\"\n        Returns a list of all characters that the character can converse with.\n        \"\"\"\n        can_converse = []\n        # For each character in the list of characters\n        for char in characters:\n            # If the character can converse with the character, then add them\n            # to the list of characters that can converse with the character\n            if char.can_converse_with(self):\n                can_converse.append(char)\n        return can_converse\n\n    def can_converse_with(self, character):\n        \"\"\"\n        Returns True if the character can converse with the given character,\n        otherwise returns False.\n        \"\"\"\n        # If the characters speak the same language, then they can converse\n        if self.speaks == character.speaks:\n            return True\n        # If the character understands the language that the given character\n        # speaks, then they can converse\n        elif self.speaks in character.understands:\n            return True\n        # If the given character understands the language that the character\n        # speaks, then they can converse\n        elif character.speaks in self.understands:\n            return True\n        # Otherwise, the characters cannot converse\n        else:\n            return False\n\nif __name__ == \"__main__\":\n    main()\n"]