["import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort()\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    q = int(sys.stdin.readline())\n    for _ in range(q):\n        m = int(sys.stdin.readline())\n        ans = 0\n        if m < a[0]:\n            ans = -1\n        else:\n            for i in range(n):\n                if m < a[i]:\n                    ans = i\n                    break\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "# https://atcoder.jp/contests/abc176/tasks/abc176_b\n\nimport sys\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Pair:\n    def __init__(self, r, b):\n        self.r = r\n        self.b = b\n\ndef main():\n    n = int(sys.stdin.readline())\n    r = []\n    b = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        r.append(Point(x, y))\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        b.append(Point(x, y))\n    pairs = []\n    for i in range(n):\n        for j in range(n):\n            if r[i].x < b[j].x and r[i].y < b[j].y:\n                pairs.append(Pair(r[i], b[j]))\n    print(len(pairs))\n\nif __name__ == '__main__':\n    main()\n", "\nN = int(input())\n\na = []\nb = []\n\nfor i in range(N):\n    a.append(int(input()))\n\nfor i in range(N):\n    b.append(int(input()))\n\ncount = 0\n\nfor i in range(N):\n    if a[i] > b[i]:\n        count += 1\n\nprint(count)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nred = []\nblue = []\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    red.append((x, y))\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\n# red.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1], reverse=True)\nblue.sort(key=lambda x: x[0])\nblue.sort(key=lambda x: x[1], reverse=True)\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n", "\n\nn = int(input())\n\nred = []\nblue = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    red.append((x, y))\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\nred.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1])\nblue.sort(key=lambda x: x[0])\nblue.sort(key=lambda x: x[1])\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n", "\n\nN = int(input())\n\nred = []\nblue = []\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    red.append((x, y))\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\nred.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1])\nblue.sort(key=lambda x: x[0], reverse=True)\nblue.sort(key=lambda x: x[1])\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n", "import sys\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Pair:\n    def __init__(self, r, b):\n        self.r = r\n        self.b = b\n\ndef main():\n    n = int(sys.stdin.readline())\n    r_list = []\n    b_list = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        r_list.append(Point(x, y))\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        b_list.append(Point(x, y))\n    pairs = []\n    for i in range(n):\n        for j in range(n):\n            if r_list[i].x < b_list[j].x and r_list[i].y < b_list[j].y:\n                pairs.append(Pair(r_list[i], b_list[j]))\n    print(len(pairs))\n\nif __name__ == '__main__':\n    main()\n", "\nn = int(input())\n\nred = []\nblue = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    red.append((x, y))\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\n# red.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1])\nblue.sort(key=lambda x: x[0])\nblue.sort(key=lambda x: x[1])\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n", "import sys\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Pair:\n    def __init__(self, r, b):\n        self.r = r\n        self.b = b\n\ndef main():\n    n = int(sys.stdin.readline())\n    r = []\n    b = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        r.append(Point(x, y))\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        b.append(Point(x, y))\n    pairs = []\n    for i in range(n):\n        for j in range(n):\n            if r[i].x < b[j].x and r[i].y < b[j].y:\n                pairs.append(Pair(r[i], b[j]))\n    print(pairs)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Pair:\n    def __init__(self, r, b):\n        self.r = r\n        self.b = b\n\ndef main():\n    n = int(sys.stdin.readline())\n    r = []\n    b = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        r.append(Point(x, y))\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        b.append(Point(x, y))\n    pairs = []\n    for i in range(n):\n        for j in range(n):\n            if r[i].x < b[j].x and r[i].y < b[j].y:\n                pairs.append(Pair(r[i], b[j]))\n    print(len(pairs)\n\nif __name__ == '__main__':\n    main()\n", "# coding: utf-8\nimport sys\nimport math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Pair:\n    def __init__(self, r, b):\n        self.r = r\n        self.b = b\n\nclass Circle:\n    def __init__(self, x, y, r):\n        self.x = x\n        self.y = y\n        self.r = r\n\n    def is_inside(self, x, y):\n        return (self.x - x)**2 + (self.y - y)**2 <= self.r**2\n\n    def is_intersects(self, other):\n        return (self.x - other.x)**2 + (self.y - other.y)**2 <= (self.r + other.r)**2\n\n    def area(self):\n        return math.pi * self.r**2\n\n    def intersect_area(self, other):\n        if self.is_intersects(other):\n            return self.area() + other.area() - (self.r + other.r)**2\n        else:\n            return 0\n\ndef main():\n    n = int(sys.stdin.readline())\n    r = []\n    b = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        r.append(Point(x, y))\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        b.append(Point(x, y))\n    cnt = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            r_circle = Circle(r[i].x, r[i].y, r[i].x - r[j].x)\n            b_circle = Circle(b[i].x, b[i].y, b[i].x - b[j].x)\n            if r_circle.is_inside(b[j].x, b[j].y):\n                cnt += 1\n            if b_circle.is_inside(r[j].x, r[j].y):\n                cnt += 1\n    print(cnt)\n\nif __name__ == '__main__':\n    main()\n", "\nN = int(input())\n\nred = []\nblue = []\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    red.append((x, y))\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\n# red.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1], reverse=True)\nblue.sort(key=lambda x: x[0])\nblue.sort(key=lambda x: x[1], reverse=True)\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n", "\n\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n\n    red = []\n    blue = []\n\n    for i in range(n):\n        x, y = map(int, input().split())\n        red.append((x, y))\n\n    for i in range(n):\n        x, y = map(int, input().split())\n        blue.append((x, y))\n\n    # red.sort(key=lambda x: x[0])\n    red.sort(key=lambda x: x[1])\n    blue.sort(key=lambda x: x[0])\n    blue.sort(key=lambda x: x[1])\n\n    count = 0\n    for r in red:\n        for b in blue:\n            if r[0] < b[0] and r[1] < b[1]:\n                count += 1\n                blue.remove(b)\n                break\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\nclass Point:\n  def __init__(self, x, y):\n    self.x = x\n    self.y = y\n\nclass Pair:\n  def __init__(self, r, b):\n    self.r = r\n    self.b = b\n\ndef main():\n  n = int(sys.stdin.readline())\n  r = []\n  b = []\n  for _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    r.append(Point(x, y))\n  for _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    b.append(Point(x, y))\n  pairs = []\n  for i in range(n):\n    for j in range(n):\n      if r[i].x < b[j].x and r[i].y < b[j].y:\n        pairs.append(Pair(r[i], b[j]))\n  print(len(pairs))\n\nif __name__ == '__main__':\n  main()\n", "\nN = int(input())\n\nred = []\nblue = []\nfor i in range(N):\n    x, y = map(int, input().split())\n    red.append((x, y))\nfor i in range(N):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\n# red.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1])\nblue.sort(key=lambda x: x[0], reverse=True)\nblue.sort(key=lambda x: x[1])\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n", "\n\nN = int(input())\n\nred = []\nblue = []\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    red.append((x, y))\n\nfor i in range(N):\n    x, y = map(int, input().split())\n    blue.append((x, y))\n\n# red.sort(key=lambda x: x[0])\nred.sort(key=lambda x: x[1], reverse=True)\nblue.sort(key=lambda x: x[0] + x[1])\n\ncount = 0\nfor r in red:\n    for b in blue:\n        if r[0] < b[0] and r[1] < b[1]:\n            count += 1\n            blue.remove(b)\n            break\n\nprint(count)\n"]