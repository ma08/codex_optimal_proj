2022-04-12 23:09:53.831336 num operations 2
2022-04-12 23:09:53.831346 size on input set 1
2022-04-12 23:09:56.107871 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree of each vertex\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    }
  ],
  "created": 1649804993,
  "object": "edit"
}
2022-04-12 23:09:56.108087 fix spelling mistakes 3 ['\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree of each vertex\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n']
2022-04-12 23:09:56.108132 size on output set 3
2022-04-12 23:09:56.108139 size on input set 3
2022-04-12 23:10:06.073651 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 1,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n# read the input and build the graph\nn = int(input())\na = list(map(int, input().split()))\ngraph = defaultdict(list)\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    }
  ],
  "created": 1649804996,
  "object": "edit"
}
2022-04-12 23:10:06.073896 fix syntax errors 3 ['\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n# read the input and build the graph\nn = int(input())\na = list(map(int, input().split()))\ngraph = defaultdict(list)\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n']
2022-04-12 23:10:11.248472 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input()\n    )\na = list(\n    map(\n        int,\n        input().split())\n    )\nedges = [\n    tuple(\n        map(\n            int,\n            input().split())\n        )\n    for i in range(n - 1)\n    ]\n\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n \nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree of each vertex\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree of each vertex\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    }
  ],
  "created": 1649805006,
  "object": "edit"
}
2022-04-12 23:10:11.248677 fix syntax errors 3 ['\n\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input()\n    )\na = list(\n    map(\n        int,\n        input().split())\n    )\nedges = [\n    tuple(\n        map(\n            int,\n            input().split())\n        )\n    for i in range(n - 1)\n    ]\n\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\n\nimport sys\nfrom collections import defaultdict\n \nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree of each vertex\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree of each vertex\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n']
2022-04-12 23:10:14.001278 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n"
    }
  ],
  "created": 1649805011,
  "object": "edit"
}
2022-04-12 23:10:14.001497 fix syntax errors 3 ['\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\n\nimport sys\nfrom collections import defaultdict\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n', '\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n']
2022-04-12 23:10:14.001544 size on output set 9
2022-04-12 23:10:14.001555 num operations 2
2022-04-12 23:10:14.001560 size on input set 1
2022-04-12 23:10:17.648265 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays as well as the result array\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\nresult = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count list\nwhite_count = [0] * n\nblack_count = [0] * n\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result list\nresult = [0] * n\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count lists\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    }
  ],
  "created": 1649805014,
  "object": "edit"
}
2022-04-12 23:10:17.648520 fix spelling mistakes 3 ["\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays as well as the result array\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\nresult = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count list\nwhite_count = [0] * n\nblack_count = [0] * n\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result list\nresult = [0] * n\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count lists\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]
2022-04-12 23:10:17.648594 size on output set 3
2022-04-12 23:10:17.648601 size on input set 3
2022-04-12 23:10:21.661167 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the result array\nresult = [0 for _ in range(n - 1)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    if u != 0:\n        result[u - 1] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split()) - 1\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays as well as the result array\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\nresult = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft() - 1\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft() - 1\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = list(map(int, input_lines.popleft().split()))\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays as well as the result array\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\nresult = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    }
  ],
  "created": 1649805017,
  "object": "edit"
}
2022-04-12 23:10:21.661454 fix syntax errors 3 ["\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the result array\nresult = [0 for _ in range(n - 1)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    if u != 0:\n        result[u - 1] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split()) - 1\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays as well as the result array\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\nresult = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft() - 1\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft() - 1\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = list(map(int, input_lines.popleft().split()))\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays as well as the result array\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\nresult = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]
2022-04-12 23:10:42.977106 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count list\nwhite_count = [0] * n\nblack_count = [0] * n\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result list\nresult = [0] * n\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of lines\nn = int(input_lines.popleft()) \n\n# Read the lines\nlines = [input_lines.popleft() for _ in range(n)]\n\n# Initialize the result\nresult = ''\n\nfor line in lines:\n    # Initialize the stack\n    stack = []\n\n    # Iterate over the line\n    for c in line:\n        # If the character is a closing bracket\n        if c in ')]}':\n            # Get the last character from the stack\n            last = stack.pop()\n\n            # If the character is not a matching opening bracket\n            if not (c == ')' and last == '(' or c == ']' and last == '[' or c == '}' and last == '{'):\n                # Add the character to the stack\n                stack.append(last)\n                stack.append(c)\n\n                # Stop iterating over the line\n                break\n\n        # If the character is an opening bracket\n        elif c in '({[':\n            # Add the character to the stack\n            stack.append(c)\n\n    # If the stack is empty\n    if len(stack) == 0:\n        # Add the line to the result\n        result += line + '\\n'\n\n# Print the result to standard output\nprint(result)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = list(map(int, input_lines.popleft().split()))\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count list\nwhite_count = [0] * n\nblack_count = [0] * n\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result list\nresult = [0] * n\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    }
  ],
  "created": 1649805021,
  "object": "edit"
}
2022-04-12 23:10:42.977418 fix syntax errors 3 ["\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count list\nwhite_count = [0] * n\nblack_count = [0] * n\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result list\nresult = [0] * n\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of lines\nn = int(input_lines.popleft()) \n\n# Read the lines\nlines = [input_lines.popleft() for _ in range(n)]\n\n# Initialize the result\nresult = ''\n\nfor line in lines:\n    # Initialize the stack\n    stack = []\n\n    # Iterate over the line\n    for c in line:\n        # If the character is a closing bracket\n        if c in ')]}':\n            # Get the last character from the stack\n            last = stack.pop()\n\n            # If the character is not a matching opening bracket\n            if not (c == ')' and last == '(' or c == ']' and last == '[' or c == '}' and last == '{'):\n                # Add the character to the stack\n                stack.append(last)\n                stack.append(c)\n\n                # Stop iterating over the line\n                break\n\n        # If the character is an opening bracket\n        elif c in '({[':\n            # Add the character to the stack\n            stack.append(c)\n\n    # If the stack is empty\n    if len(stack) == 0:\n        # Add the line to the result\n        result += line + '\\n'\n\n# Print the result to standard output\nprint(result)\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = list(map(int, input_lines.popleft().split()))\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count list\nwhite_count = [0] * n\nblack_count = [0] * n\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result list\nresult = [0] * n\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]
2022-04-12 23:10:59.160136 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nprint(\"hello world\")\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count lists\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n\n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n\n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n\n        # Set the parent of the neighbor\n        parent[v] = u\n\n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n\n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n\n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n\n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n\n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    },
    {
      "index": 2,
      "text": "\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count lists\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"
    }
  ],
  "created": 1649805043,
  "object": "edit"
}
2022-04-12 23:10:59.160390 fix syntax errors 3 ['\nprint("hello world")\n', "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count lists\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n\n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n\n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n\n        # Set the parent of the neighbor\n        parent[v] = u\n\n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n\n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n\n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n\n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n\n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count lists\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]
2022-04-12 23:10:59.160460 size on output set 9
