["\n\nimport sys\nimport math\n\ndef euclidean_dist(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2, 2) + math.pow(y1-y2, 2))\n\ndef manhattan_dist(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1, y))\n    if x < n-1:\n        neighbors.append((x+1, y))\n    if y > 0:\n        neighbors.append((x, y-1))\n    if y < n-1:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan_dist(path[i][0], path[i][1], path[i+1][0], path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 0:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 0:\n        return 0\n    if k < 0:\n        return -1\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == 1:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_max_dist(n, k, matrix):\n    # Implement your solution here\n    return 0\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_max_dist(n, k, matrix))\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch, or -1 if the game is not possible.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch, or -1 if the game is not possible.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {tiles_to_visit[0]: 0}\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # Loop through the tiles\n            for i2 in range(len(tiles)):\n                for j2 in range(len(tiles[i2])):\n                    curr_tile2 = tiles[i2][j2]\n\n                    # If the current tile is the previous tile\n                    if curr_tile2 == curr_tile - 1:\n                        # Update the minimum distance to the current tile\n                        min_distance[curr_tile] = min(min_distance[curr_tile - 1] + abs(i - i2) + abs(j - j2),\n                                                      min_distance[curr_tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef euclidean_distance(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan_distance(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    print(neighbors)\n    for neighbor in neighbors:\n        print(board[neighbor[0]][neighbor[1]])\n        print(board[x][y])\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            print(\"found\")\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan_distance(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(n, tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order.\n    tiles_to_visit = []\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile.\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile.\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order.\n    for tile in tiles_to_visit:\n        # Loop through the tiles.\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit.\n                if curr_tile == tile:\n                    # Loop through the tiles.\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile.\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile.\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile.\n    return min_distance[k]\n\n\n    Returns whether or not a game of hopscotch is possible.\n\n    :param n: The size of the square board.\ndef possible(n, tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    \"\"\"\n\n    # Return whether or not the game is possible.\n    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible.\n    return False\n\n\ndef main():\n    # Read the input.\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem.\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution.\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to place\n    if k > n*n:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile_count in tile_counts:\n        if tile_count == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile_i = None\n        start_tile_j = None\n        for tile in path:\n            if start_tile_i == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile_i != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile_i = None\n                next_tile_j = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile_i = i\n                            next_tile_j = j\n                            break\n                    if next_tile_i != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile_i - start_tile_i) + abs(next_tile_j - start_tile_j)\n                # print(start_tile_i, start_tile_j, next_tile_i, next_tile_j, path_length)\n                start_tile_i = next_tile_i\n                start_tile_j = next_tile_j\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1 \n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n", "import math\n\n\n\ndef get_max_dist(n, k, matrix):\n    # Implement your solution here\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                matrix[i][j] = 0\n            else:\n                matrix[i][j] = math.inf\n    for i in range(k):\n        for j in range(n):\n            for k in range(n):\n                matrix[j][k] = min(matrix[j][k], matrix[j][i] + matrix[i][k])\n\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            max_dist = max(max_dist, matrix[i][j])\n    return max_dist\n\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_max_dist(n, k, matrix))\n", "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0] - tile[0]) + abs(start[1] - tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "\n \nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Find the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Find the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Find the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Find the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\ndef get_min_dist(n, k, matrix): \n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n", "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())  # n = number of rows/columns, k = number of tiles\n    tiles = [list(map(int, input().split())) for _ in range(n)]  # tile numbers\n    # print(tiles)  # print the tiles\n\n    # Check if there are enough tiles to place\n    if k > n**2:  # if there are more tiles than squares\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)  # count the number of each tile\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:  # if there are no tiles of that number\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):  # try all possible paths\n        # print(path)  # print the path\n        path_length = 0  # length of the path\n        start_tile = None  # start tile\n        for tile in path:\n            if start_tile == None:  # if there is no start tile\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:  # if this is the tile\n                            start_tile = (i, j)  # set it as the start tile\n                            break\n                    if start_tile != None:  # if there is a start tile\n                        break\n            else:  # if there is a start tile\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:  # if this is the tile\n                            next_tile = (i, j)  # set it as the next tile\n                            break\n                    if next_tile != None:  # if there is a next tile\n                        break\n                # Add the distance\n                path_length += math.sqrt((next_tile[0] - start_tile[0])**2 + (next_tile[1] - start_tile[1])**2)\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile  # set the next tile as the start tile for next time\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:  # if this is the best path\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]: # start\ub294 (i, j) \ud615\ud0dc\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for tile_num in range(2, k+1): # i = \ud0c0\uc77c \ubc88\ud638\n            curr_dist = sys.maxsize\n            for tile in tiles[tile_num]: # tile\ub3c4 (i, j) \ud615\ud0dc\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to place\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    n, k = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    start = find_start(board, n, k)\n    end = find_end(board, n, k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start, end))\n    else:\n        print(-1)\n\n\n\ndef find_start(board, n, k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i, j)\n    return None\n\n\ndef find_end(board, n, k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i, j)\n    return None\n\n\ndef manhattan_dist(start, end):\n    return abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef euclidean_distance(x1,y1,x2,y2):\n    return ((x1-x2)**2 + (y1-y2)**2)**0.5\n\ndef manhattan_distance(x1,y1,x2,y2):\n    return (abs(x1-x2) + abs(y1-y2))\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan_distance(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\n    from collections import deque\n    queue = deque()\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    queue.append((0, 0, 0))\n    visited[0][0] = True\n    while queue:\n        i, j, dist = queue.popleft()\n        if i == n - 1 and j == n - 1:\n            return dist\n        for x, y in ((i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)):\n            if 0 <= x < n and 0 <= y < n and not visited[x][y] and mat[x][y] > k:\n                queue.append((x, y, dist + 1))\n                visited[x][y] = True\ndef get_min_dist(n, k, mat):\n    # Implement your solution here\n\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    mat = []\n    for i in range(n):\n        mat.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, mat))  #\n", "\nimport sys\nimport math\n\ndef euclidean_dist(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan_dist(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan_dist(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for j in range(n):\n        if tiles[i][j] == 1:\n            return min_hopscotch_helper(tiles, n, k, i, j)\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return sys.maxsize\n    if i+1 < n and tiles[i+1][j] > 0:\n        return min(min_hopscotch_helper(tiles, n, k-tiles[i][j], i+1, j), min_hopscotch_helper(tiles, n, k-tiles[i][j], i-1, j), min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j+1), min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j-1)) + 1\n    elif i-1 >= 0 and tiles[i-1][j] > 0:\n        return min(min_hopscotch_helper(tiles, n, k-tiles[i][j], i-1, j), min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j+1), min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j-1)) + 1\n    elif j+1 < n and tiles[i][j+1] > 0:\n        return min(min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j+1), min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j-1)) + 1\n    elif j-1 >= 0 and tiles[i][j-1] > 0:\n        return min_hopscotch_helper(tiles, n, k-tiles[i][j], i, j-1) + 1\n    else:\n        return sys.maxsize\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_min_dist(mat):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    mat = []\n    for i in range(n):\n        mat.append([int(x) for x in input().split()])\n    print(get_min_dist(mat))\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(n, k, tiles):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile.\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order.\n    tiles_to_visit = []\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile.\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile.\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order.\n    for tile in tiles_to_visit:\n        # Loop through the tiles.\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit.\n                if curr_tile == tile:\n                    # Loop through the tiles.\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile.\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile.\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile.\n    return min_distance[k]\n\n\ndef possible(n, k, tiles):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                # Loop through the tiles.\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile.\n                        if curr_tile2 == 2:\n                            # Loop through the tiles.\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile.\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles.\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile.\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible.\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible.\n    return False\n\n\ndef main():\n    # Read the input.\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem.\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution.\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    # if not possible(tiles, k):\n    #     return -1\n\n    # Create a dictionary to store the minimum distance to each tile.\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order.\n    tiles_to_visit = []\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile.\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile.\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Set the minimum distance to the first tile to 0.\n    min_distance[1] = 0\n\n    # Loop through the tiles in order.\n    for tile in tiles_to_visit:\n        # Loop through the tiles.\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit.\n                if curr_tile == tile:\n                    # Loop through the tiles.\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile.\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile.\n                                # If the minimum distance to the current tile is not already set.\n                                if tile not in min_distance:\n                                    # Set the minimum distance to the current tile.\n                                    min_distance[tile] = min_distance[tile - 1] + abs(i - i2) + abs(j - j2)\n                                else:\n                                    # Update the minimum distance to the current tile.\n                                    min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile.\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                # Loop through the tiles.\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile.\n                        if curr_tile2 == 2:\n                            # Loop through the tiles.\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile.\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles.\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile.\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible.\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible.\n    return False\n\n\ndef main():\n    # Read the input.\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem.\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution.\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\nimport sys\nimport math\n\ndef euclidean_dist(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2)\n\ndef manhattan_dist(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan_dist(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch, or -1 if the game is not possible.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch, or -1 if the game is not possible.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # If the current tile is not the first tile\n        if tile != 1:\n            # Set the minimum distance to the current tile to infinity\n            min_distance[tile] = float('inf')\n\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile], min_distance[tile - 1] + abs(i - i2) + abs(j - j2))\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize \n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0 \n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize \n            for tile in tiles[i]:\n                if tile in visited:\n                    continue \n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1]) \n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize: \n                break \n            dist += curr_dist \n            visited.add(tile) \n            start = tile \n        if len(visited) == k:\n            min_dist = min(min_dist, dist) \n    if min_dist == sys.maxsize: \n        print(-1) \n    else:\n        print(min_dist) \n\nif __name__ == \"__main__\":\n    main() \n", "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Find the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Find the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Find the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Find the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\nsys.stdout = open(\"output.txt\", \"w\")\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(input().split())\nprint(a)\n", "\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles for each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndx = [1,-1,0,0]\ndy = [0,0,1,-1]\nfrom collections import deque\n\ndef bfs(board,n,k):\n    queue = deque()\n    queue.append((0,0))\n    visited = [[0]*n for _ in range(n)]\n    visited[0][0] = 1\n    while queue:\n        x,y = queue.popleft()\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < n and 0 <= ny < n:\n                if board[nx][ny] == k:\n                    return visited[x][y]\n                if board[nx][ny] == 0 and visited[nx][ny] == 0:\n                    visited[nx][ny] = visited[x][y] + 1\n                    queue.append((nx,ny))\n    return -1\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    print(bfs(board,n,k))\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n, k = map(int, input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board, n, k)\n    end = find_end(board, n, k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start, end))\n    else:\n        print(-1)\n\n\n\ndef find_start(board, n, k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i, j)\n    return None\n\n\ndef find_end(board, n, k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i, j)\n    return None\n\n\ndef manhattan_dist(start, end):\n    return abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(input):\n    n,k = map(int,input.readline().split())\n    board = [list(map(int,input.readline().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main(sys.stdin)\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order.\n    tiles_to_visit = []\n\n    # Loop through the tiles.\n    for i, row in enumerate(tiles):\n        for j, col in enumerate(row):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile.\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile.\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order.\n    for tile in tiles_to_visit:\n        # Loop through the tiles.\n        for i, row in enumerate(tiles):\n            for j, col in enumerate(row):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit.\n                if curr_tile == tile:\n                    # Loop through the tiles.\n                    for i2, row2 in enumerate(tiles):\n                        for j2, col2 in enumerate(row2):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile.\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile.\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile.\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles.\n    for i, row in enumerate(tiles):\n        for j, col in enumerate(row):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                # Loop through the tiles.\n                for i2, row2 in enumerate(tiles):\n                    for j2, col2 in enumerate(row2):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile.\n                        if curr_tile2 == 2:\n                            # Loop through the tiles.\n                            for i3, row3 in enumerate(tiles):\n                                for j3, col3 in enumerate(row3):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile.\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles.\n                                        for i4, row4 in enumerate(tiles):\n                                            for j4, col4 in enumerate(row4):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile.\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible.\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible.\n    return False\n\n\ndef main():\n    # Read the input.\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem.\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution.\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch, or -1 if the game is not possible.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch, or -1 if the game is not possible.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(n, k, tiles):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(n, k, tiles):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a list to store the minimum distance to each tile\n    min_distance = [0] * (k + 1)\n\n    # Create a list to store the tiles to visit in order.\n    tiles_to_visit = []\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile.\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile.\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order.\n    for tile in tiles_to_visit:\n        # Loop through the tiles.\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit.\n                if curr_tile == tile:\n                    # Loop through the tiles.\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile.\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile.\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2),\n                                                         min_distance[tile])\n\n    # Return the minimum distance to the last tile.\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                # Loop through the tiles.\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile.\n                        if curr_tile2 == 2:\n                            # Loop through the tiles.\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile.\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles.\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile.\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible.\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (\n                                                            abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible.\n    return False\n\n\ndef main():\n    # Read the input.\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem.\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution.\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import deque\n\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\n\ndef bfs(board,n,k,start):\n    queue = deque()\n    queue.append(start)\n    visited = [[0]*n for _ in range(n)]\n    visited[start[0]][start[1]] = 1\n    while queue:\n        x,y = queue.popleft()\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < n and 0 <= ny < n:\n                # if board[nx][ny] == k:\n                #     return visited[x][y]\n                if board[nx][ny] == 0 and visited[nx][ny] == 0:\n                    visited[nx][ny] = visited[x][y] + 1\n                    queue.append((nx,ny))\n    return -1\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]: \n                if tile in visited:\n                    continue\n                dist = abs(start[0] - tile[0]) + abs(start[1] - tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(start)\n            start = tiles[i][curr_dist]\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_min_dist(n, k, mat):\n    # Implement your solution here\n    pass\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    mat = []\n    for i in range(n):\n        mat.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, mat))\n", "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)] \n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2: \n        print(-1)\n        return\n\n    # Check if there are enough tiles for each number\n    tile_counts = [0]*(k+1) \n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1 \n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "import itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n): \n            tile_counts[tiles[i][j]] += 1 \n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.readline()\n    n,k = map(int,input().strip().split())\n    board = [list(map(int,input().strip().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\n\ndef find_start(tiles, k):\n    \"\"\"\n    Find the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Find the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Find the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Find the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "import itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0] - tile[0]) + abs(start[1] - tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n, k = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    start = find_start(board, n, k)\n    end = find_end(board, n, k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start, end))\n    else:\n        print(-1)\n\n\ndef find_start(board, n, k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef euclidean_distance(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan_distance(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x, y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1, y))\n    if x < n-1:\n        neighbors.append((x+1, y))\n    if y > 0:\n        neighbors.append((x, y-1))\n    if y < n-1:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x, y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan_distance(path[i][0], path[i][1], path[i+1][0], path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "n, k = map(int, input().split())\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\nn, k = map(int, input().split())\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1) given a list of tiles and the number of tiles\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k) given a list of tiles and the number of tiles\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1) given a list of tiles, the current tile,\n    the current number and the number of tiles\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end given a list of tiles, the current tile,\n    the current number and the number of tiles\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n", "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(n, k, tiles):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile.\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order.\n    tiles_to_visit = []\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile.\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile.\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order.\n    for tile in tiles_to_visit:\n        # Loop through the tiles.\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit.\n                if curr_tile == tile:\n                    # Loop through the tiles.\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile.\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile.\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile.\n    return min_distance[k]\n\n\n    Returns whether or not a game of hopscotch is possible.\n\n    :param n: The size of the square board.\ndef possible(n, k, tiles):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles.\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile.\n            if curr_tile == 1:\n                # Loop through the tiles.\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile.\n                        if curr_tile2 == 2:\n                            # Loop through the tiles.\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile.\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles.\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile.\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible.\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < n\n\n    # Return that the game is not possible.\n    return False\n\n\ndef main():\n    # Read the input.\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem.\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution.\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles for each number\n    tile_counts = [0] * (k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_max_dist(n, k, arr):\n    # Implement your solution here.\n    return 0\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    arr = []\n    for i in range(n):\n        arr.append([int(x) for x in input().split()])\n    print(get_max_dist(n, k, arr))\n", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                curr_dist = min(abs(start[0] - tile[0]) + abs(start[1] - tile[1]), curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]: # start\ub294 (i, j) \ud615\ud0dc\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1): # i = \ud0c0\uc77c \ubc88\ud638\n            curr_dist = sys.maxsize\n            for tile in tiles[i]: # tile\ub3c4 (i, j) \ud615\ud0dc\n                if tile in visited:\n                    continue\n                curr_dist = min(abs(start[0]-tile[0]) + abs(start[1]-tile[1]), curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"]