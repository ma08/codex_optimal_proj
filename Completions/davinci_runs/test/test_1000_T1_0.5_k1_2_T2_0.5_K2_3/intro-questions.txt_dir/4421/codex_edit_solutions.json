["\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\nif ((a == b) or (a == c) or (a == d) or (b == c) or (b == d) or (c == d)):\n    print(\"S\")\nelse:\n    print(\"N\")\n", "\n\nn,k = [int(x) for x in input().strip().split()]\nd = [int(x) for x in input().strip().split()]\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\n\ndef possible(a, b) -> bool:\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n", "\n\nn,k = [int(x) for x in input().split()] # n is number of cards, k is number of different cards\nd = [int(x) for x in input().split()] # d is list of all the card values\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n", "\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\ndef findMedian(arr):\n    arr.sort()\n    return arr[len(arr)//2]\n\n# Complete the activityNotifications function below.\ndef activityNotifications(expenditure, d):\n    notifications = 0\n\n    for i in range(len(expenditure)):\n        if i >= d:\n            median = findMedian(expenditure[i-d:i])\n            if expenditure[i] >= 2*median:\n                notifications += 1\n    return notifications\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    nd = input().split()\n\n    n = int(nd[0])\n\n    d = int(nd[1])\n\n    expenditure = list(map(int, input().rstrip().split()))\n\n    result = activityNotifications(expenditure, d)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n", "\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n\nnum_pairs = int(mods[max_mod_val]/2)\n\n\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "#!/usr/bin/python3\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(x, y):\n    return (x + y) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n    if possible(d[l], d[r]):\n        ans += 2\n        l += 1\n        r -= 1\n    else:\n        ans += 1\n        r -= 1\n\nif l == r:\n    ans += 1\n\nprint(ans)\n", "\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n", "n,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i % k] += 1\n\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val] / 2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k % 2 == 0:\n    if max_mod_val == int(k / 2):\n        num_pairs += int(mods[0] / 2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "#!/bin/python3\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n", "\n\nprint(\"test\")\n", "\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"]