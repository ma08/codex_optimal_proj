2022-04-12 20:30:09.199015 num operations 2
2022-04-12 20:30:09.199024 size on input set 1
2022-04-12 20:30:14.699990 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    },
    {
      "index": 1,
      "text": "\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    },
    {
      "index": 2,
      "text": "\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    }
  ],
  "created": 1649795409,
  "object": "edit"
}
2022-04-12 20:30:14.700234 fix spelling mistakes 3 ['\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n', '\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n', '\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n']
2022-04-12 20:30:14.700274 size on output set 3
2022-04-12 20:30:14.700280 size on input set 3
2022-04-12 20:30:24.940957 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\nif ((a == b) or (a == c) or (a == d) or (b == c) or (b == d) or (c == d)):\n    print(\"S\")\nelse:\n    print(\"N\")\n"
    },
    {
      "index": 1,
      "text": "#!/bin/python3\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    },
    {
      "index": 2,
      "text": "\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i % k] += 1\n\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val] / 2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k % 2 == 0:\n    if max_mod_val == int(k / 2):\n        num_pairs += int(mods[0] / 2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    }
  ],
  "created": 1649795414,
  "object": "edit"
}
2022-04-12 20:30:24.941164 fix syntax errors 3 ['\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\nif ((a == b) or (a == c) or (a == d) or (b == c) or (b == d) or (c == d)):\n    print("S")\nelse:\n    print("N")\n', '#!/bin/python3\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n', '\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mode value\nmods = [0] * k\nfor i in d:\n    mods[i % k] += 1\n\n# find the most common mode value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val] / 2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k % 2 == 0:\n    if max_mod_val == int(k / 2):\n        num_pairs += int(mods[0] / 2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n']
2022-04-12 20:30:36.953587 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\ndef findMedian(arr):\n    arr.sort()\n    return arr[len(arr)//2]\n\n# Complete the activityNotifications function below.\ndef activityNotifications(expenditure, d):\n    notifications = 0\n\n    for i in range(len(expenditure)):\n        if i >= d:\n            median = findMedian(expenditure[i-d:i])\n            if expenditure[i] >= 2*median:\n                notifications += 1\n    return notifications\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    nd = input().split()\n\n    n = int(nd[0])\n\n    d = int(nd[1])\n\n    expenditure = list(map(int, input().rstrip().split()))\n\n    result = activityNotifications(expenditure, d)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n"
    },
    {
      "index": 1,
      "text": "\n\nn,k = [int(x) for x in input().split()] # n is number of cards, k is number of different cards\nd = [int(x) for x in input().split()] # d is list of all the card values\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    },
    {
      "index": 2,
      "text": "\n\nn,k = [int(x) for x in input().strip().split()]\nd = [int(x) for x in input().strip().split()]\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    }
  ],
  "created": 1649795424,
  "object": "edit"
}
2022-04-12 20:30:36.953779 fix syntax errors 3 ["\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\ndef findMedian(arr):\n    arr.sort()\n    return arr[len(arr)//2]\n\n# Complete the activityNotifications function below.\ndef activityNotifications(expenditure, d):\n    notifications = 0\n\n    for i in range(len(expenditure)):\n        if i >= d:\n            median = findMedian(expenditure[i-d:i])\n            if expenditure[i] >= 2*median:\n                notifications += 1\n    return notifications\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    nd = input().split()\n\n    n = int(nd[0])\n\n    d = int(nd[1])\n\n    expenditure = list(map(int, input().rstrip().split()))\n\n    result = activityNotifications(expenditure, d)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n", '\n\nn,k = [int(x) for x in input().split()] # n is number of cards, k is number of different cards\nd = [int(x) for x in input().split()] # d is list of all the card values\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n', '\n\nn,k = [int(x) for x in input().strip().split()]\nd = [int(x) for x in input().strip().split()]\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mode value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mode value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n']
2022-04-12 20:30:43.857022 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "n,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    },
    {
      "index": 1,
      "text": "\n\nprint(\"test\")\n"
    },
    {
      "index": 2,
      "text": "\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n\nnum_pairs = int(mods[max_mod_val]/2)\n\n\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"
    }
  ],
  "created": 1649795436,
  "object": "edit"
}
2022-04-12 20:30:43.857203 fix syntax errors 3 ['n,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val]/2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n', '\n\nprint("test")\n', '\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\n\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\n\n\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n\nnum_pairs = int(mods[max_mod_val]/2)\n\n\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n']
2022-04-12 20:30:43.857314 size on output set 9
2022-04-12 20:30:43.857326 num operations 2
2022-04-12 20:30:43.857331 size on input set 1
2022-04-12 20:30:46.685493 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    }
  ],
  "created": 1649795443,
  "object": "edit"
}
2022-04-12 20:30:46.685676 fix spelling mistakes 3 ['\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n', '\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n', '\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n']
2022-04-12 20:30:46.685702 size on output set 2
2022-04-12 20:30:46.685708 size on input set 2
2022-04-12 20:30:51.064978 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/python3\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(x, y):\n    return (x + y) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n    if possible(d[l], d[r]):\n        ans += 2\n        l += 1\n        r -= 1\n    else:\n        ans += 1\n        r -= 1\n\nif l == r:\n    ans += 1\n\nprint(ans)\n"
    }
  ],
  "created": 1649795446,
  "object": "edit"
}
2022-04-12 20:30:51.065155 fix syntax errors 3 ['\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n', '\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n', '#!/usr/bin/python3\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(x, y):\n    return (x + y) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n    if possible(d[l], d[r]):\n        ans += 2\n        l += 1\n        r -= 1\n    else:\n        ans += 1\n        r -= 1\n\nif l == r:\n    ans += 1\n\nprint(ans)\n']
2022-04-12 20:30:53.223773 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\n\ndef possible(a, b) -> bool:\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n"
    }
  ],
  "created": 1649795451,
  "object": "edit"
}
2022-04-12 20:30:53.223971 fix syntax errors 3 ['\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n', '\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\n\ndef possible(a, b) -> bool:\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n', '\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(a[l], a[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n']
2022-04-12 20:30:53.223999 size on output set 5
