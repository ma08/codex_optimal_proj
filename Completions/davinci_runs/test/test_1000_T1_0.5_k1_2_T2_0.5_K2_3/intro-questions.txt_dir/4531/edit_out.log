2022-04-12 21:46:09.475390 num operations 2
2022-04-12 21:46:09.475401 size on input set 1
2022-04-12 21:46:12.144113 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799969,
  "object": "edit"
}
2022-04-12 21:46:12.144331 fix spelling mistakes 3 ['import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', '\nfrom collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:46:12.144377 size on output set 3
2022-04-12 21:46:12.144384 size on input set 3
2022-04-12 21:46:19.645190 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, parent, root):\n        return sum(self.dfs(root, child) + 1 for child in self.adj[root] if child != parent)\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(-1, i) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "def main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]  # 0\u756a\u76ee\u306f\u4f7f\u308f\u306a\u3044\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799972,
  "object": "edit"
}
2022-04-12 21:46:19.645435 fix syntax errors 3 ['import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, parent, root):\n        return sum(self.dfs(root, child) + 1 for child in self.adj[root] if child != parent)\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(-1, i) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'def main():\n    pass\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]  # 0番目は使わない\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:46:23.121745 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent, a):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root, a) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1, a) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        res += a[root]\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1)\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799979,
  "object": "edit"
}
2022-04-12 21:46:23.121928 fix syntax errors 3 ['import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent, a):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root, a) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1, a) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        res += a[root]\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1)\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:46:35.233467 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(n + 1):\n        res += tree.dfs(i, 0) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "from collections import defaultdict\n\n\nclass Tree:\n  def __init__(self, n):\n    self.n = n\n    self.adj = defaultdict(list)\n\n  def add_edge(self, u, v):\n    self.adj[u].append(v)\n    self.adj[v].append(u)\n\n  def dfs(self, root, parent):\n    children = self.adj[root]\n    res = 0\n    for child in children:\n      if child != parent:\n        res += self.dfs(child, root) + 1\n    return res\n\n\ndef solve(n, a, tree):\n  res = 0\n  for i in range(1, n + 1):\n    res += tree.dfs(i, -1) * a[i]\n  return res\n\n\ndef main():\n  n = int(input())\n  a = [0] + [int(x) for x in input().split()]\n  tree = Tree(n)\n  for _ in range(n - 1):\n    u, v = [int(x) for x in input().split()]\n    tree.add_edge(u, v)\n  print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n  main()\n"
    },
    {
      "index": 2,
      "text": "from collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649799983,
  "object": "edit"
}
2022-04-12 21:46:35.233734 fix syntax errors 3 ['\nfrom collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(n + 1):\n        res += tree.dfs(i, 0) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'from collections import defaultdict\n\n\nclass Tree:\n  def __init__(self, n):\n    self.n = n\n    self.adj = defaultdict(list)\n\n  def add_edge(self, u, v):\n    self.adj[u].append(v)\n    self.adj[v].append(u)\n\n  def dfs(self, root, parent):\n    children = self.adj[root]\n    res = 0\n    for child in children:\n      if child != parent:\n        res += self.dfs(child, root) + 1\n    return res\n\n\ndef solve(n, a, tree):\n  res = 0\n  for i in range(1, n + 1):\n    res += tree.dfs(i, -1) * a[i]\n  return res\n\n\ndef main():\n  n = int(input())\n  a = [0] + [int(x) for x in input().split()]\n  tree = Tree(n)\n  for _ in range(n - 1):\n    u, v = [int(x) for x in input().split()]\n    tree.add_edge(u, v)\n  print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n  main()\n', 'from collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 21:46:35.233778 size on output set 9
2022-04-12 21:46:35.233788 num operations 2
2022-04-12 21:46:35.233793 size on input set 1
2022-04-12 21:46:42.716322 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n#\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649799995,
  "object": "edit"
}
2022-04-12 21:46:42.716514 fix spelling mistakes 3 ['\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n#\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n']
2022-04-12 21:46:42.716622 size on output set 3
2022-04-12 21:46:42.716630 size on input set 3
2022-04-12 21:46:56.390164 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# @Date     : 2018-04-01 15:09:56\n# @Author   : Albert Shi\n# @Link     : http://blog.csdn.net/albertsh\n# @Github   : https://github.com/AlbertGithubHome\n__author__ = 'AlbertS'\n# @Subject  : level 1 of python challenge\n# \n# \u601d\u8def\uff1a\u5148\u7528Python\u7684\u8bed\u6cd5\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u5bf9\u5e94\u7684\u6570\u5b57\uff0c\u518d\u7528Python\u7684\u5185\u5efa\u51fd\u6570\u6c42\u548c\n#       \u518d\u7528Python\u7684\u8bed\u6cd5\u628a\u6570\u5b57\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u6253\u5370\u51fa\u6765\n#\n# \u5907\u6ce8\uff1a1. python challenge home page : http://www.pythonchallenge.com/\n#       2. current level url : http://www.pythonchallenge.com/pc/def/0.html\n#       3. next level url : http://www.pythonchallenge.com/pc/def/274877906944.html\n#\nimport re\n\n\ndef get_sum(num_str):\n    num_sum = 0\n    for i in range(len(num_str)):\n        num_sum += int(num_str[i])\n    return num_sum\n\ndef get_str_from_num(num):\n    return str(num)\n\ndef main():\n    num_str = '1234567890'\n    num_sum = get_sum(num_str)\n    print(num_sum)\n    num_str = get_str_from_num(num_sum)\n    print(num_str)\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n    return subtree_size_u, subtree_sum_u\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649800002,
  "object": "edit"
}
2022-04-12 21:46:56.390344 fix syntax errors 3 ['\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# @Date     : 2018-04-01 15:09:56\n# @Author   : Albert Shi\n# @Link     : http://blog.csdn.net/albertsh\n# @Github   : https://github.com/AlbertGithubHome\n__author__ = 'AlbertS'\n# @Subject  : level 1 of python challenge\n# \n# 思路：先用Python的语法把字符串转换成对应的数字，再用Python的内建函数求和\n#       再用Python的语法把数字转换成字符串，打印出来\n#\n# 备注：1. python challenge home page : http://www.pythonchallenge.com/\n#       2. current level url : http://www.pythonchallenge.com/pc/def/0.html\n#       3. next level url : http://www.pythonchallenge.com/pc/def/274877906944.html\n#\nimport re\n\n\ndef get_sum(num_str):\n    num_sum = 0\n    for i in range(len(num_str)):\n        num_sum += int(num_str[i])\n    return num_sum\n\ndef get_str_from_num(num):\n    return str(num)\n\ndef main():\n    num_str = '1234567890'\n    num_sum = get_sum(num_str)\n    print(num_sum)\n    num_str = get_str_from_num(num_sum)\n    print(num_str)\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    return subtree_size_u, subtree_sum_u\n    return subtree_size_u, subtree_sum_u\n\ndef solve(u, p):\n    subtree_size_u = 1\n    subtree_sum_u = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size_u += subtree_size_v\n            subtree_sum_u += subtree_sum_v\n    max_cost = subtree_sum_u\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum_u - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n']
2022-04-12 21:46:58.147566 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649800016,
  "object": "edit"
}
2022-04-12 21:46:58.147746 fix syntax errors 3 ['\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n']
2022-04-12 21:47:01.075070 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649800018,
  "object": "edit"
}
2022-04-12 21:47:01.075365 fix syntax errors 3 ['\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n']
2022-04-12 21:47:01.075418 size on output set 6
