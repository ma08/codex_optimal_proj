["\n\n# My solution\n\ns = input()\n\n# Create a dictionary of the number of occurrences of each letter in s\noccurrences = {}\nfor char in s:\n    if char in occurrences:\n        occurrences[char] += 1\n    else:\n        occurrences[char] = 1\n\n# Create a list of the number of occurrences of each letter in s\noccurrences_list = []\nfor key, value in occurrences.items():\n    occurrences_list.append(value)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1\noccurrences_list_gt1 = []\nfor num in occurrences_list:\n    if num > 1:\n        occurrences_list_gt1.append(num)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1 = []\nfor num in occurrences_list_gt1:\n    occurrences_list_gt1_sub1.append(num - 1)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number and multiply all the numbers in the list together\n# and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult = 1\nfor num in occurrences_list_gt1_sub1:\n    occurrences_list_gt1_sub1_mult *= num\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number,\n# and multiply all the numbers in the list together and multiply that number by the number of occurrences of each letter in s that are equal to 1\noccurrences_list_gt1_sub1_mult_mult1 = occurrences_list_gt1_sub1_mult * len(occurrences)\n\n# Print the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together and multiply that number by the number of occurrences of each letter in s that are equal to 1\nprint(occurrences_list_gt1_sub1_mult_mult1)\n", "\n\ndef get_input():\n    return list(input())\n\ndef get_num_good_itinerary(event_list):\n    start = None\n    end = None\n    for i in range(len(event_list)):\n        if i == 0:\n            start = event_list[i]\n        elif i == len(event_list) - 1:\n            end = event_list[i]\n    \n    if start == end:\n        return 0\n    else:\n        return 1\n\ndef main():\n    event_list = get_input()\n    good_itinerary = get_num_good_itinerary(event_list)\n    print(good_itinerary)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# My solution\n\ns = input()\n\n# Create a dictionary of the number of occurrences of each letter in s\noccurrences = {}\nfor char in s:\n    if char in occurrences:\n        occurrences[char] += 1\n    else:\n        occurrences[char] = 1\n\n# Create a list of the number of occurrences of each letter in s\noccurrences_list = []\nfor key, value in occurrences.items():\n    occurrences_list.append(value)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1\noccurrences_list_gt1 = []\nfor num in occurrences_list:\n    if num > 1:\n        occurrences_list_gt1.append(num)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1 = []\nfor num in occurrences_list_gt1:\n    occurrences_list_gt1_sub1.append(num - 1)\n\n# Multiply all the numbers in the list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult = 1\nfor num in occurrences_list_gt1_sub1:\n    occurrences_list_gt1_sub1_mult *= num\n\n# Multiply the number of the number of occurrences of each letter in s that are equal to 1 by the number of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult_mult1 = occurrences_list_gt1_sub1_mult * len(occurrences_list_gt1_sub1)\n\n# Print the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together and multiply that number by the number of occurrences of each letter in s that are equal to 1\nprint(occurrences_list_gt1_sub1_mult_mult1)\n", "\n\n# My solution\n\ns = input()\n\n# Create a dictionary of the number of occurrences of each letter in s\noccurrences = {}\nfor char in s:\n    if char in occurrences:\n        occurrences[char] += 1\n    else:\n        occurrences[char] = 1\n\n# Create a list of the number of occurrences of each letter in s\noccurrences_list = []\nfor key, value in occurrences.items():\n    occurrences_list.append(value)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1\noccurrences_list_gt1 = []\nfor num in occurrences_list:\n    if num > 1:\n        occurrences_list_gt1.append(num)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1 = []\nfor num in occurrences_list_gt1:\n    occurrences_list_gt1_sub1.append(num - 1)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult = 1\nfor num in occurrences_list_gt1_sub1:\n    occurrences_list_gt1_sub1_mult *= num\n\n# Multiply that number by the number of occurrences of each letter in s that are equal to 1\noccurrences_list_gt1_sub1_mult_mult1 = occurrences_list_gt1_sub1_mult * len(occurrences)\n\n# Print the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number and multiply that number by the number of occurrences of each letter in s that are equal to 1\nprint(occurrences_list_gt1_sub1_mult_mult1)\n", "\nimport sys\n\ndef main(input):\n    \"\"\"\n    >>> main('abbcccddddeeeeef')\n    10\n    >>> main('abbcccddddeeeeefffff')\n    12\n    >>> main('abbcccddddeeeeefffffa')\n    13\n    \"\"\"\n    count = 1\n    last = input[0]\n    for c in input[1:]:\n        if c != last:\n            count += 1\n        last = c\n    return count - 1\n\nif __name__ == '__main__':\n    input = sys.stdin.readline().strip()\n    print(main(input))\n", "\n\ndef get_input():\n    return input()\n\ndef get_num_good_itineraries(event_list, num_events):\n    start = None\n    end = None\n    for i in range(num_events):\n        if i == 0:\n            start = event_list[i]\n        elif i == num_events - 1:\n            end = event_list[i]\n    \n    if start == end:\n        return 0\n    else:\n        return 1\n\ndef main():\n    event_list = list(get_input())\n    good_itineraries = get_num_good_itineraries(event_list, len(event_list))\n    print(good_itineraries)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_input():\n    return input()\n\ndef get_num_good_itineraries(event_list, num_events):\n    start = None\n    end = None\n    for i in range(num_events):\n        if i == 0:\n            start = event_list[i]\n        elif i == num_events - 1:\n            end = event_list[i]\n    \n    if start == end:\n        return 0\n    else:\n        return 1\n\ndef main():\n    event_list = list(map(int, get_input().split()))\n    good_itineraries = get_num_good_itineraries(event_list, len(event_list))\n    print(good_itineraries)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# I/O\ninput_string = input()\n\n# Solution\ndef count_itineraries(input_string):\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events in the winter\n    season where the first and last events are of different types,\n    and they are both unique among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types\n    event_types = {}\n    # Initialize variable to store number of itineraries\n    itineraries = 0\n    # Iterate through the input string\n    for event in input_string:\n        # Check if event type is in the dictionary\n        if event in event_types:\n            # Increment value of event type by 1\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with value of 1\n            event_types[event] = 1\n        # Check if there are at least two different event types\n        if len(event_types) > 2:\n            # Iterate through event types in dictionary\n            for event_type in event_types:\n                # Check if event type is the first one in the input string\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number of\n                    # events of the current type\n                    itineraries += event_types[event_type]\n    # Return number of itineraries\n    return itineraries\n\n# Output\nprint(count_itineraries(input_string))\n", "import sys\n\ndef main(input_):\n    \"\"\"\n    >>> main(\"abbcccddddeeeee\") #doctest: +NORMALIZE_WHITESPACE\n    a1b2c3d4e5\n    \"\"\"\n    result = []\n    count = 0\n    for c in input_:\n        if len(result) == 0 or c == result[-1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(c)\n            count = 1\n    result.append(str(count))\n    return ''.join(result)\n\nif __name__ == '__main__':\n    input_ = sys.stdin.readline().strip()\n    print(main(input_))\n", "\n\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))  # 4\n\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))  # 0\n\ndef good_itineraries(string):\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # good itinerary ends with a unique letter \n    # good itinerary has at least 2 events \n    # good itinerary doesn't have duplicates of the same event type \n    # so we can start with the first unique letter, and the last unique letter \n    # and then count the number of ways to fill in the middle \n    \n    # first, find the first and the last unique letters \n    first = None \n    last = None \n    seen = set() \n    for i, char in enumerate(string): \n        if char not in seen: \n            first = i \n            seen.add(char) \n        if char not in string[i+1:]: \n            last = i \n            break \n    \n    # there are no good itinerary if there is only one event, \n    # or if there are no unique events \n    if first is None or last is None: \n        return 0 \n    \n    # now, count the number of ways to fill in the middle \n    # the middle can be filled with any characters, \n    # as long as they don't repeat the first or last character \n    # and as long as they don't repeat the same character \n    # there are n - 2 positions to fill in, \n    # and there are 26 - 2 characters to choose from \n    # so there are (n - 2) * (26 - 2) ways to fill in the middle \n    return (len(string) - 2) * (26 - 2) \n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    events = sys.stdin.readlines()\n    num_events = len(events[0].strip())\n\n    # Build a list of the number of occurrences of each event type\n    counts = [0 for i in xrange(26)]\n    for c in events[0].strip():\n        counts[ord(c) - ord('a')] += 1\n\n    # Compute the number of good itineraries\n    num_good = 0\n    for i in xrange(26):\n        num_good += counts[i] * (num_events - counts[i])\n\n    print (num_good)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# My solution\n\ns = input()\n\n# Create a dictionary of the number of occurrences of each letter in s\noccurrences = {}\nfor char in s:\n    if char in occurrences:\n        occurrences[char] += 1\n    else:\n        occurrences[char] = 1\n\n# Create a list of the number of occurrences of each letter in s\noccurrences_list = []\nfor key, value in occurrences.items():\n    occurrences_list.append(value)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1\noccurrences_list_gt1 = []\nfor num in occurrences_list:\n    if num > 1:\n        occurrences_list_gt1.append(num)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number in the list\noccurrences_list_gt1_sub1 = []\nfor num in occurrences_list_gt1:\n    occurrences_list_gt1_sub1.append(num - 1)\n\n# Multiply all the numbers in the list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult = 1\nfor num in occurrences_list_gt1_sub1:\n    occurrences_list_gt1_sub1_mult *= num\n\n# Multiply the number of the number of occurrences of each letter in s that are equal to 1 by the number of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1_mult_mult1 = occurrences_list_gt1_sub1_mult * len(occurrences)\n\n# Print the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together and multiply that number by the number of occurrences of each letter in s that are equal to 1\nprint(occurrences_list_gt1_sub1_mult_mult1)\n", "\nimport sys\n\ndef main(input):\n    \"\"\"\n    >>> main(\"abbcccddddeeeee\")\n    a1b2c3d4e5\n    \"\"\"\n    result = []\n    count = 0\n    for c in input:\n        if len(result) == 0 or c == result[-1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(c)\n            count = 1\n    result.append(str(count))\n    return ''.join(result)\n\nif __name__ == '__main__':\n    input = sys.stdin.readline().strip()\n    print(main(input))\n", "\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()  # read a line from stdin and remove the trailing new line character\n    count = 0\n    for i in range(len(s)):  # iterate over all characters in the string\n        for j in range(i + 1, len(s)):  # iterate over all characters following the first character\n            if s[i] != s[j]:  # check if the characters are different\n                if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:  # check if both characters do not appear between the two characters\n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n\n    main()\n", "\n\nimport sys, collections\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    print(good_itineraries(n))\n\ndef good_itineraries(n):\n    \"\"\"\n    :param n: number of events\n    :return: number of good itineraries\n    \"\"\"\n    # good itinerary starts with a unique letter\n    # good itinerary ends with a unique letter\n    # good itinerary has at least 2 events\n    # good itinerary doesn't have duplicates of the same event type\n    # so we can start with the first unique letter, and the last unique letter\n    # and then count the number of ways to fill in the middle\n\n    # first, find the first and the last unique letters\n    # first = None\n    # last = None\n    # seen = set()\n    # for i, char in enumerate(string):\n    #     if char not in seen:\n    #         first = i\n    #         seen.add(char)\n    #     if char not in string[i+1:]:\n    #         last = i\n    #         break\n\n    # there are no good itinerary if there is only one event,\n    # or if there are no unique events\n    # if first is None or last is None:\n    #     return 0\n\n    # now, count the number of ways to fill in the middle\n    # the middle can be filled with any characters,\n    # as long as they don't repeat the first or last character\n    # and as long as they don't repeat the same character\n    # there are n - 2 positions to fill in,\n    # and there are 26 - 2 characters to choose from\n    # so there are (n - 2) * (26 - 2) ways to fill in the middle\n    return (n - 2) * (26 - 2)\n\nif __name__ == '__main__':\n    main()\n", "\n# I/O\ninput_string = input()\n\ndef count_itineraries(input_string):\n    # Solution\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events in the winter\n    season where the first and last events are of different types,\n    and they are both unique among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types and counts\n    event_types = {}\n    # Initialize variable to store number of itineraries as 0\n    itineraries = 1\n    # Iterate through the input string, starting from the second event\n    for i in range(1, len(input_string)):\n        # Check if the current event type is in the dictionary\n        if input_string[i] in event_types:\n            # Increment the value of the current event type by 1\n            event_types[input_string[i]] += 1\n        else:\n            # Add the current event type to the dictionary with value of 1\n            event_types[input_string[i]] = 1\n        # Check if there are at least two different event types in the\n        # dictionary\n        if len(event_types) > 1:\n            # Iterate through event types in the dictionary\n            for key in event_types:\n                # Check if the current event type is the first one in the\n                # input string\n                if key == input_string[0]:\n                    # Increment the number of itineraries by the number of\n                    # events of the current type and the number of events of\n                    # the first type\n                    itineraries += event_types[key] * event_types[input_string[0]]\n                # Check if the current event type is not the first one in the\n                # input string\n                elif key != input_string[0]:\n                    # Increment the number of itineraries by the number of\n                    # events of the current type and the number of events of\n                    # the first type\n                    itineraries += event_types[key] * event_types[input_string[0]]\n    # Return the number of itineraries\n    return itineraries\n\n# Output\nprint(count_itineraries(input_string))\n", "\n\nimport sys\n\ndef main():\n    events = sys.stdin.readlines()[0].strip() #read the file\n    num_events = len(events) #count the number of events\n\n    # Build a list of the number of occurrences of each event type \n    counts = [0 for i in xrange(26)] #create a list of 26 zeros\n    for c in events: #for each character in the file\n        counts[ord(c) - ord('a')] += 1 #increment the count for each character\n\n    # Compute the number of good itineraries \n    num_good = 0\n    for i in xrange(26):\n        num_good += counts[i] * (num_events - counts[i]) #num_good = sum of counts * (num_events - counts)\n\n    print(num_good) #print the number of good itineraries\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# My solution\n\ns = input()\n\n# Create a dictionary of the number of occurrences of each letter in s\noccurrences = {}\nfor char in s:\n    if char in occurrences:\n        occurrences[char] += 1\n    else:\n        occurrences[char] = 1\n\n# Create a list of the number of occurrences of each letter in s\noccurrences_list = []\nfor key, value in occurrences.items():\n    occurrences_list.append(value)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1\noccurrences_list_gt1 = []\nfor num in occurrences_list:\n    if num > 1:\n        occurrences_list_gt1.append(num)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1 = []\nfor num in occurrences_list_gt1:\n    occurrences_list_gt1_sub1.append(num - 1)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number and multiply all the numbers in the list together\n# and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult = 1\nfor num in occurrences_list_gt1_sub1:\n    occurrences_list_gt1_sub1_mult *= num\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number and multiply all the numbers in the list together\n# and multiply that number by the number of occurrences of each letter in s that are equal to 1\noccurrences_list_gt1_sub1_mult_mult1 = occurrences_list_gt1_sub1_mult * len(occurrences)\n\n# Print the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together and multiply that number by the number of occurrences of each letter in s that are equal to 1\nprint(occurrences_list_gt1_sub1_mult_mult1)\n", "\n\n# My solution\n\ns = input()\n\n# Create a dictionary of the number of occurrences of each letter in s\noccurrences = {}\nfor char in s:\n    if char in occurrences:\n        occurrences[char] += 1\n    else:\n        occurrences[char] = 1\n\n# Create a list of the number of occurrences of each letter in s\noccurrences_list = []\nfor key, value in occurrences.items():\n    occurrences_list.append(value)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1\noccurrences_list_gt1 = []\nfor num in occurrences_list:\n    if num > 1:\n        occurrences_list_gt1.append(num)\n\n# Create a list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1 = []\nfor num in occurrences_list_gt1:\n    occurrences_list_gt1_sub1.append(num - 1)\n\n# Multiply all the numbers in the list of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together\noccurrences_list_gt1_sub1_mult = 1\nfor num in occurrences_list_gt1_sub1:\n    occurrences_list_gt1_sub1_mult *= num\n\n# Multiply the number of occurrences of each letter in s that are equal to 1 by the number of the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\noccurrences_list_gt1_sub1_mult_mult1 = occurrences_list_gt1_sub1_mult * len(occurrences)\n\n# Print the number of occurrences of each letter in s that are greater than 1 and subtract 1 from each number\n# and multiply all the numbers in the list together and multiply that number by the number of occurrences of each letter in s that are equal to 1\nprint(occurrences_list_gt1_sub1_mult_mult1)\n", "\n\n# I/O\ninput_string = input()\n\n# Solution\ndef count_itineraries(input_string):\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events in the summer\n    season where the first and last events are of different types,\n    and they are both unique among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types and their\n    # frequencies\n    event_types = {}\n    # Initialize variable to store number of itineraries\n    itineraries = 0\n    # Iterate through the input string\n    for event in input_string:\n        # Check if event type is in the dictionary\n        if event in event_types:\n            # Increment frequency of event type by 1\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with frequency of 1\n            event_types[event] = 1\n        # Check if there are at least two different event types\n        if len(event_types) >= 2:\n            # Iterate through event types in dictionary\n            for event_type in event_types:\n                # Check if event type is the first one in the\n                # input string\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number\n                    # of events of the current type\n                    itineraries += event_types[event_type]\n                else:\n                    # Increment number of itineraries by 1\n                    itineraries += 1\n    # Return number of itineraries\n    return itineraries\n\n# Output\nprint(count_itineraries(input_string))\n", "\n\nimport sys\n\ndef main():\n    events = sys.stdin.readlines()[0].strip() #read the input file\n    num_events = len(events) #count the number of events\n\n    # Build a list of the number of occurrences of each event type \n    counts = [0 for i in xrange(26)] #create a list of 26 zeros\n    for c in events: #for each character in the file\n        counts[ord(c) - ord('a')] += 1 #increment the count for each character\n\n    # Compute the number of good itineraries \n    num_good = 0\n    for i in xrange(26): #for each character in the alphabet\n        num_good += counts[i] * (num_events - counts[i]) #num_good = sum of counts * (num_events - counts)\n\n    print num_good #print the number of good itineraries\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_input():\n    return input().split()\n\ndef get_num_good_itineraries(events):\n    start = None\n    end = None\n    start = events[0]\n    end = events[len(events) - 1]\n    \n    if start == end:\n        return 0\n    else:\n        return 1\n\ndef main():\n    events = get_input()\n    good_itineraries = get_num_good_itineraries(events)\n    print(good_itineraries)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# I/O\ninput_string = input()\n\n# Solution\ndef count_itineraries(input_string):\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events in the summer\n    season where the first and last events are of different types,\n    and they are both unique among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types and their frequencies.\n    event_types = {}\n    # Initialize variable to store number of itineraries.\n    itineraries = 0\n    # Iterate through the input string.\n    for event in input_string:\n        # Check if event type is in the dictionary.\n        if event in event_types:\n            # Increment frequency of event type by 1.\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with frequency of 1.\n            event_types[event] = 1\n        # Check if there are at least two different event types.\n        if len(event_types) >= 2:\n            # Iterate through event types in dictionary.\n            for event_type in event_types:\n                # Check if event type is the first one in the input string.\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number of\n                    # events of the current type.\n                    itineraries += event_types[event_type]\n                else:\n                    # Increment number of itineraries by 1.\n                    itineraries += 1\n    # Return number of itineraries.\n    return itineraries\n\n# Output\nprint(count_itineraries(input_string))\n", "import sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] != s[j]:\n                if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:\n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))\n\ndef good_itineraries(string):\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # good itinerary:\n    #   starts with a unique letter\n    #   ends with a unique letter\n    #   has at least 2 events\n    #   doesn't have duplicates of the same event type\n    #\n    # so we can start with the first unique letter and the last unique letter,\n    # and then count the number of ways to fill in the middle\n\n    # first, find the first and the last unique letters\n    first = None\n    last = None\n    seen = set()\n    for i, char in enumerate(string):\n        if char not in seen:\n            first = i\n            seen.add(char)\n        if char not in string[i+1:]:\n            last = i\n            break\n\n    # there are no good itinerary if there is only one event,\n    # or if there are no unique events\n    if first is None or last is None:\n        return 0\n\n    # now, count the number of ways to fill in the middle\n    # the middle can be filled with any characters, as long as they don't\n    # repeat the first or last character, and as long as they don't repeat\n    # the same character; there are n - 2 positions to fill in, and there\n    # are 26 - 2 characters to choose from, so there are (n - 2) * (26 - 2)\n    # ways to fill in the middle\n    return (len(string) - 2) * (26 - 2)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    events = sys.stdin.readlines()\n    num_events = len(events[0])\n\n    # Build a list of the number of occurrences of each event type\n    counts = [0 for i in xrange(26)]\n    for c in events[0]:\n        counts[ord(c) - ord('a')] += 1\n\n    # Compute the number of good itineraries\n    num_good = 0\n    for i in xrange(26):\n        num_good += counts[i] * (num_events - counts[i])\n\n    print (num_good)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    events = sys.stdin.readline().strip() #read the file\n    num_events = len(events) #count the number of events\n\n    # Build a list of the number of occurrences of each event type \n    counts = [0 for i in range(26)] #create a list of 26 zeros\n    for c in events: #for each character in the file\n        counts[ord(c) - ord('a')] += 1 #increment the count for each character\n\n    # Compute the number of good itineraries \n    num_good = 0\n    for i in range(26):\n        num_good += counts[i] * (num_events - counts[i]) #num_good = sum of counts * (num_events - counts)\n\n    print num_good #print the number of good itineraries\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main(input):\n    # \"\"\"\n    # >>> main(\"abbcccddddeeeee\")\n    # 10\n    # \"\"\"\n    count = 1\n    last = input[0]\n    for c in input[1:]:\n        if c != last:\n            count += 1\n        last = c\n    return count - 1\n\nif __name__ == '__main__':\n    input = sys.stdin.readline().strip()\n    print(main(input))\n", "\n\n# I/O\ninput_string = input().strip()\n\n# Solution\ndef count_itineraries():\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events in the winter\n    season where the first and last events are of different types,\n    and they are both unique among all event types during the sequence.\n    global input_string\n    \"\"\"\n    # Initialize dictionary to store event types\n    event_types = {}\n    # Initialize variable to store number of itineraries\n    itineraries = 0\n    # Iterate through the input string\n    for event in input_string:\n        # Check if event type is in the dictionary\n        if event in event_types:\n            # Increment value of event type by 1\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with value of 1\n            event_types[event] = 1\n        # Check if there are at least two different event types\n        if len(event_types) >= 2:\n            # Iterate through event types in dictionary\n            for event_type in event_types:\n                # Check if event type is the first one in the input string\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number of\n                    # events of the current type\n                    itineraries += event_types[event_type]\n                else:\n                    # Increment number of itineraries by 1\n                    itineraries += 1\n    # Return number of itineraries\n    return itineraries\n\n# Output\nprint(count_itineraries())\n", "\n# I/O\ninput_string = input()\n\n# Solution\ndef count_itineraries(input_string):\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events in the summer\n    season where the first and last events are of different types,\n    and they are both unique among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types and their frequencies\n    event_types = {}\n    # Initialize variable to store number of itineraries\n    itineraries = 0\n    # Iterate through the input string\n    for event in input_string:\n        # Check if event type is in the dictionary\n        if event in event_types:\n            # Increment frequency of event type by 1\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with frequency of 1\n            event_types[event] = 1\n        # Check if there are at least two different event types\n        if len(event_types) >= 2:\n            # Iterate through event types in dictionary\n            for event_type in event_types:\n                # Check if event type is the first one in the input string\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number of\n                    # events of the current type\n                    itineraries += event_types[event_type]\n                else:\n                    # Increment number of itineraries by 1\n                    itineraries += 1\n    # Return number of itineraries\n    return itineraries\n\n# Output\nprint(count_itineraries(input_string))\n", "import sys\n\ndef main(input_):\n    \"\"\"\n    >>> main(\"abbcccddddeeeee\")\n    10\n    \"\"\"\n    count = 1\n    last = input_[0]\n    for c in input_[1:]:\n        if c != last:\n            count += 1\n        last = c\n    return count - 1\n\nif __name__ == '__main__':\n    input_ = sys.stdin.readline().strip()\n    print(main(input_))\n", "\n\ndef get_input():\n    return list(input().split())\n\ndef get_num_good_itinerary(event_list):\n    start = None\n    end = None\n    for i in range(len(event_list)):\n        if i == 0:\n            start = event_list[i]\n        elif i == len(event_list) - 1:\n            end = event_list[i]\n    \n    if start == end:\n        return 0\n    else:\n        return 1\n\ndef main():\n    event_list = get_input()\n    good_itinerary = get_num_good_itinerary(event_list)\n    print(good_itinerary)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] != s[j]:\n                if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:\n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "'''\nDescription\n\nGiven a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\n\nFor example:\n\nGiven \"aacecaaa\", return \"aaacecaaa\".\n\nGiven \"abcd\", return \"dcbabcd\".\n'''\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    s = s[::-1]\n    print(s)\n\nif __name__ == \"__main__\":\n    main()\n", "'''\nDescription\n\nGiven a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the\nshortest palindrome you can find by performing this transformation.\n\nFor example:\n\nGiven \"aacecaaa\", return \"aaacecaaa\".\n\nGiven \"abcd\", return \"dcbabcd\".\n'''\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] != s[j]:\n                if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:\n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main(input):\n    \"\"\"\n    >>> main(\"abbcccddddeeeeef\")\n    10\n    >>> main(\"abbcccddddeeeeefffff\")\n    12\n    >>> main(\"abbcccddddeeeeefffffa\")\n    13\n    \"\"\"\n    count = 0\n    last = input[0]\n    for c in input[1:]:\n        if c != last:\n            count += 1\n        last = c\n    return count\n\nif __name__ == '__main__':\n    input = sys.stdin.readline().strip()\n    print(main(input))\n", "\n\ndef get_input():\n    return int(input())\n\ndef get_num_good_itineraries(num_events):\n    return num_events - 1\n    \n\ndef main():\n    num_events = get_input()\n    good_itineraries = get_num_good_itineraries(num_events)\n    print(good_itineraries)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_input():\n\n    return input()\n\ndef get_num_good_itineraries(event_list, num_events):\n    start = None\n    end = None\n    for i in range(num_events):\n        if i == 0:\n            start = event_list[i]\n        elif i == num_events - 1:\n            end = event_list[i]\n    \n    if start == end:\n        return 0\n    else:\n        return 1\n\n\ndef main():\n    event_list = get_input()\n    good_itineraries = get_num_good_itineraries(event_list, len(event_list))\n    print(good_itineraries)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] != s[j]:\n                if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:\n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))\n\ndef good_itineraries(string):\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # good itineraries start with a unique character\n    # good itineraries end with a unique character\n    # good itineraries have at least 2 characters\n    # good itineraries don't have duplicates of the same character\n    # so we can start with the first unique character, and the last unique character\n    # and then count the number of ways to fill in the rest\n\n    # first, find the first and the last unique characters\n    first = None\n    last = None\n    seen = set()\n    for i, char in enumerate(string):\n        if char not in seen:\n            first = i\n            seen.add(char)\n        if char not in string[i+1:]:\n            last = i\n            break\n\n    # there are no good itineraries if there is only one event,\n    # or if there are no unique events\n    if first is None or last is None:\n        return 0\n\n    # now, count the number of ways to fill in the middle\n    # the middle can be filled with any characters,\n    # as long as they don't repeat the first or last character\n    # and as long as they don't repeat the same character\n    # there are n - 2 positions to fill in,\n    # and there are 26 - 2 characters to choose from\n    # so there are (n - 2) * (26 - 2) ways to fill in the middle\n    return (len(string) - 2) * (26 - 2)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n\n    print(good_itineraries(string))\n\ndef good_itineraries(string):\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # good itineraries start with a unique letter\n    # good itineraries end with a unique letter\n    # good itineraries have at least 2 events\n    # good itineraries don't have duplicates of the same event\n    # so we can start with the first unique letter, and the last unique letter\n    # and then count the number of ways to fill in the middle\n\n    # first, find the first and the last unique letters\n    first = None\n    last = None\n    seen = set()\n    for i, char in enumerate(string):\n        if char not in seen:\n            first = i\n            seen.add(char)\n        if char not in string[i + 1:]:\n            last = i\n            break\n\n    # there are no good itineraries if there is only one event,\n    # or if there are no unique events\n    if first is None or last is None:\n        return 0\n\n    # now, count the number of ways to fill in the middle\n    # the middle can be filled with any characters,\n    # as long as they don't repeat the first or last character\n    # and as long as they don't repeat the same character\n    # there are n - 2 positions to fill in,\n    # and there are 26 - 2 characters to choose from\n    # so there are (n - 2) * (26 - 2) ways to fill in the middle\n    return (len(string) - 2) * (26 - 2)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    events = sys.stdin.readlines()\n    num_events = len(events[0])\n\n    # Build a list of the number of occurrences of each event type\n    counts = [0 for i in xrange(26)]\n    for c in events[0]:\n        counts[ord(c) - ord('a')] += 1\n\n    # Compute the number of good itineraries\n    num_good = 0\n    for i in xrange(26):\n        num_good += counts[i] * (num_events - counts[i])\n\n    print num_good\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))\n\ndef good_itineraries(string):\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # good itineraries start with a unique letter\n    # good itineraries end with a unique letter\n    # good itineraries have at least 2 events\n    # good itineraries don't have duplicates of the same event\n    # so we can start with the first unique letter, and the last unique letter\n    # and then count the number of ways to fill in the middle\n\n    # first, find the first and the last unique letters\n    first = None\n    last = None\n    seen = set()\n    for i, char in enumerate(string):\n        if char not in seen:\n            first = i\n            seen.add(char)\n        if char not in string[i+1:]:\n            last = i\n            break\n\n    # there are no good itineraries if there is only one event,\n    # or if there are no unique events\n    if first is None or last is None:\n        return 0\n\n    # now, count the number of ways to fill in the middle\n    # the middle can be filled with any characters,\n    # as long as they don't repeat the first or last character\n    # and as long as they don't repeat the same character\n    # there are n - 2 positions to fill in,\n    # and there are 26 - 2 characters to choose from\n    # so there are (n - 2) * (26 - 2) ways to fill in the middle\n    return (len(string) - 2) * (26 - 2)\n\nif __name__ == '__main__':\n    main()\n", "\n#\n# I/O\ninput_string = input()\n#\n# Solution\ndef count_itineraries(input_string):\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events where the first\n    and last events are of different types, and they are both unique\n    among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types\n    event_types = {}\n    # Initialize variable to store number of itineraries\n    itineraries = 0\n    # Iterate through the input string\n    for event in input_string:\n        # Check if event type is in the dictionary\n        if event in event_types:\n            # Increment value of event type by 1\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with value of 1\n            event_types[event] = 1\n        # Check if there are at least two different event types\n        if len(event_types) >= 2:\n            # Iterate through event types in dictionary\n            for event_type in event_types:\n                # Check if event type is the first one in the input\n                # string\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number of\n                    # events of the current type\n                    itineraries += event_types[event_type]\n                else:\n                    # Increment number of itineraries by 1\n                    itineraries += 1\n    # Return number of itineraries\n    return itineraries\n#\n# Output\nprint(count_itineraries(input_string))\n", "\n\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))\n\ndef good_itineraries(string):\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # good itineraries start with a unique character\n    # good itineraries end with a unique character\n    # good itineraries have at least 2 characters\n    # good itineraries don't have duplicates of the same character\n    # so we can start with the first unique character, and the last unique character\n    # and then count the number of ways to fill in the rest\n\n    # first, find the first and the last unique characters\n    first = None\n    last = None\n    seen = set()\n    for i, char in enumerate(string):\n        if char not in seen:\n            first = i\n            seen.add(char)\n        if char not in string[i+1:]:\n            last = i\n            break\n\n    # there are no good itineraries if there is only one event,\n    # or if there are no unique events\n    if first is None or last is None:\n        return 0\n\n    # now, count the number of ways to fill in the middle\n    # the middle can be filled with any characters,\n    # as long as they don't repeat the first or last character\n    # and as long as they don't repeat the same character\n    # there are n - 2 positions to fill in,\n    # and there are 26 - 2 characters to choose from\n    # so there are (n - 2) * (26 - 2) ways to fill in the middle\n    return (len(string) - 2) * (26 - 2)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    string = sys.stdin.readline().strip()\n    print(good_itineraries(string))\n\ndef good_itineraries(string):\n    https://www.hackerrank.com/challenges/good-itineraries/problem\n    \"\"\"\n    :param string: string of lowercase letters\n    :return: number of good itineraries\n    \"\"\"\n    # Good itineraries start with a unique letter\n    # Good itineraries end with a unique letter\n    # Good itineraries have at least 2 events\n    # Good itineraries don't have duplicates of the same event\n    # So we can start with the first unique letter, and the last unique letter\n    # And then count the number of ways to fill in the middle\n\n    # First, find the first and the last unique letters\n    first = None\n    last = None\n    seen = set()\n    for i, char in enumerate(string):\n        if char not in seen:\n            first = i\n            seen.add(char)\n        if char not in string[i+1:]:\n            last = i\n            break\n\n    # There are no good itineraries if there is only one event,\n    # Or if there are no unique events\n    if first is None or last is None:\n        return 0\n\n    # Now, count the number of ways to fill in the middle\n    # The middle can be filled with any characters,\n    # As long as they don't repeat the first or last character\n    # And as long as they don't repeat the same character\n    # There are n - 2 positions to fill in,\n    # And there are 26 - 2 characters to choose from\n    # So there are (n - 2) * (26 - 2) ways to fill in the middle\n    return (len(string) - 2) * (26 - 2)\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    for i in range(n):\n        s = sys.stdin.readline().strip()\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i] != s[j]:\n                    if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:\n                        count += 1\n        print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_input():\n    return input()\n    \ndef get_num_good_itineraries(events):\n    start = None\n    end = None\n    for i in range(len(events)):\n        if events[i][1] == \"S\":\n            start = events[i]\n        elif events[i][1] == \"E\":\n            end = events[i]\n    \n    if start[0] == end[0]:\n        return 0\n    else:\n        return 1\n\ndef main():\n    events = get_input()\n    good_itineraries = get_num_good_itineraries(events)\n    print(good_itineraries)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_input():\n    return input()\n\n\ndef get_num_good_itinerary(event_list):\n    start = event_list[0]\n    end = event_list[len(event_list) - 1]\n    for i in range(len(event_list)):\n        pass\n\n    if start == end:\n        return 0\n    else:\n        return 1\n\n\ndef main():\n    event_list = get_input()\n    good_itinerary = get_num_good_itinerary(event_list)\n    print(good_itinerary)\n\n\nif __name__ == \"__main__\":\n    main()\n", "'''\nDescription\n\nGiven a string S, you are allowed to convert it to a palindrome by adding characters\nin front of it. Find and return the shortest palindrome you can find by performing this transformation.\n\nFor example:\n\nGiven \"aacecaaa\", return \"aaacecaaa\".\n\nGiven \"abcd\", return \"dcbabcd\".\n'''\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] != s[j]:\n                if s[i] not in s[i+1:j] and s[j] not in s[i+1:j]:\n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "\n# I/O\ninput_string = input()\n\n# Solution\ndef count_itineraries(input_string):\n    \"\"\"\n    Returns the number of itineraries for a given input string.\n    An itinerary is a sequence of at least two events where the first\n    and last events are of different types, and they are both unique\n    among all event types during the sequence.\n    \"\"\"\n    # Initialize dictionary to store event types\n    event_types = {}\n    # Initialize variable to store number of itineraries\n    itineraries = 0\n    # Iterate through the input string\n    for event in input_string:\n        # Check if event type is in the dictionary\n        if event in event_types:\n            # Increment value of event type by 1\n            event_types[event] += 1\n        else:\n            # Add event type to dictionary with value of 1\n            event_types[event] = 1\n        # Check if there are at least two different event types\n        if len(event_types) >= 2:\n            # Iterate through event types in dictionary\n            for event_type in event_types:\n                # Check if event type is the first one in the input\n                # string\n                if event_type == input_string[0]:\n                    # Increment number of itineraries by the number of\n                    # events of the current type\n                    itineraries += event_types[event_type]\n                else:\n                    # Increment number of itineraries by 1\n                    itineraries += 1\n    # Return number of itineraries\n    return itineraries\n\n# Output\nprint(count_itineraries(input_string))\n"]