["# coding: utf-8\n\nN = int(input())\n\ndays = [None] * N\nfor i in range(N):\n    s, t = map(int, input().split())\n    days[i] = (s, t)\n\ndays.sort(key=lambda x: x[0])\ntotal_days = 0\n\nfor i in range(N):\n    if i == 0:\n        total_days += days[i][1] - days[i][0] + 1\n    else:\n        if days[i][0] <= days[i-1][1]:\n            if days[i][1] > days[i-1][1]:\n                total_days += days[i][1] - days[i-1][1]\n        else:\n            total_days += days[i][1] - days[i][0] + 1\n\nprint(total_days)\n", "\nN = int(input())\nevents = []\n\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n# initialize the last event to be the first event\nlast_event = events[0]\n# initialize the number of days with free food to the duration of the first event.\ndays_with_free_food = last_event[1] - last_event[0] + 1\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\nprint(days_with_free_food)\n", "\nN = int(input())\n\nstart_dates = []  # list to store starting dates\nend_dates = []  # list to store ending dates\n# iterate over N\n\n    # store start and end dates in start_dates and end_dates\nfor i in range(N):\n    start, end = map(int, input().split())\n    start_dates.append(start)\n    end_dates.append(end)\n# sort start_dates and end_dates\n\nstart_dates.sort()\nend_dates.sort()\n# counter to store number of rooms needed\n\ncount = 0\n# index for start_dates and end_dates\n\ncurr_start = 0\ncurr_end = 0\n\n# iterate over start_dates and end_dates\nwhile curr_start < len(start_dates) and curr_end < len(end_dates):\n    # if starting date is less than ending date, increment count\n    if start_dates[curr_start] <= end_dates[curr_end]:\n        count += 1\n        curr_start += 1\n    # else decrement count\n    else:\n        count -= 1\n        curr_end += 1\n\n# print count\nprint(count)\n", "\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, s, t, days[365] = {0}, maxDays = 0;\n    cin >> N;\n    while (N--)\n    {\n        cin >> s >> t;\n        for (int i = s - 1; i < t; i++)\n        {\n            days[i]++;\n            maxDays = max(maxDays, days[i]);\n        }\n    }\n    cout << maxDays << endl;\n}\n", "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, s, t, days[365] = {0}, max_days = 0;\n    cin >> N;\n    while (N--)\n    {\n        cin >> s >> t;\n        for (int i = s - 1; i < t; i++)\n        {\n            days[i]++;\n            max_days = max(max_days, days[i]);\n        }\n    }\n    cout << max_days << endl;\n}\n", "\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, s, t, days[365] = {0}, max_days = 0;\n    cin >> N;\n    while (N--)\n    {\n        cin >> s >> t;\n        for (int i = s - 1; i < t; i++)\n        {\n            days[i]++;\n            max_days = max(max_days, days[i]);\n        }\n    }\n    cout << max_days << endl;\n    return 0;\n}\n", "#!/usr/bin/python3\n\nimport sys\n\nif __name__ == \"__main__\":\n    N = int(input())\n\n    days = [0 for i in range(365)]\n\n    for i in range(N):\n        start, end = map(int, input().split())\n        for j in range(start - 1, end):\n            days[j] += 1\n\n    print(sum(days))\n", "# coding: utf-8\nN = int(input())\ndays = []\nfor i in range(N):\n    s, t = map(int, input().split())\n    days.append((s, t))\ndays.sort(key=lambda x: x[0])\ntotal_days = 0\nfor i in range(N):\n    if i == 0:\n        total_days += days[i][1] - days[i][0] + 1\n    else:\n        if days[i][0] <= days[i-1][1]:\n            if days[i][1] > days[i-1][1]:\n                total_days += days[i][1] - days[i-1][1]\n        else:\n            total_days += days[i][1] - days[i][0] + 1\n\nprint(total_days)\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = set()\n    for i in range(n):\n        s, t = map(int, sys.stdin.readline().split())\n        for j in range(s, t+1):\n            days.add(j)\n    print(len(days))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nn = int(input())\n\ndays = [0 for i in range(365)]\n\nfor i in range(n):\n    start, end = map(int, input().split())\n    for j in range(start - 1, end):\n        days[j] += 1\n\nprint(sum(days))\n", "\n\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n#%%\ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j] + 1\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n", "\nN = int(input())\nevents = []\n\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n# initialize the last event to be the first event\nlast_event = events[0]\n# initialize the number of days with free food to the duration of the last event\ndays_with_free_food = last_event[1] - last_event[0] + 1\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\n\nprint(days_with_free_food)\n", "\n\nimport sys\n\ndef main():\n    events = int(sys.stdin.readline().strip())\n    days = [] # list of days\n    for i in range(events):\n        days.append(list(map(int, sys.stdin.readline().strip().split())))\n    days.sort()\n    intervals = [] # list of intervals\n    for start, end in days:\n        if len(intervals) == 0:\n            intervals.append([start, end])\n        else:\n            if intervals[-1][1] >= start:\n                intervals[-1][1] = max(intervals[-1][1], end)\n            else:\n                intervals.append([start, end])\n    days_served = 0 # number of days served\n    for start, end in intervals:\n        days_served += end - start + 1\n    print(days_served)\n\nif __name__ == \"__main__\":\n    main()\n", "#include <algorithm>\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int N, s, t, days[365] = {0}, maxDays = 0;\n    cin >> N;\n    while (N--)\n    {\n        cin >> s >> t;\n        for (int i = s - 1; i < t; i++)\n        {\n            days[i]++;\n            maxDays = max(maxDays, days[i]);\n        }\n    }\n    cout << maxDays << endl;\n}\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = []\n    for i in range(n):\n        s, t = map(int, sys.stdin.readline().split())\n        for j in range(s, t+1):\n            days.append(j)\n    print(len(set(days)))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    events = int(sys.stdin.readline().strip())\n    days = []\n    for i in range(events):\n        days.append(list(map(int, sys.stdin.readline().strip().split())))\n    days.sort()\n    intervals = [] # list of intervals\n    for start, end in days:\n        if len(intervals) == 0:\n            intervals.append([start, end])\n        else:\n            if intervals[-1][1] >= start: # if the interval overlaps with the previous interval\n                intervals[-1][1] = max(intervals[-1][1], end) # extend the previous interval\n            else:\n                intervals.append([start, end]) # add a new interval\n    days_served = 0\n    for start, end in intervals:\n        days_served += end - start + 1\n    print(days_served)\n\nif __name__ == \"__main__\":\n    main()\n", "\nN = int(input())\n\ndays = [0 for i in range(365)]\n\nfor i in range(N):\n    start, end = map(int, input().split())\n    for j in range(start - 1, end):\n        days[j] += 1\n\nprint(sum(days))\n\n\n\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = []\n    for i in range(n):\n        s, t = map(int, sys.stdin.readline().split())\n        for j in range(s, t + 1):\n            days.append(j)\n    days = set(days)\n    print(len(days))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nN = int(input(\"\"))\n\ndays = [0 for i in range(365)]\n\nfor i in range(N):\n    start, end = map(int, input(\"\").split())\n    for j in range(start - 1, end):\n        days[j] += 1\n\nprint(sum(days))\n", "\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n, s, t, days[365] = {0}, maxDays = 0;\n    cin >> n;\n    while (n--)\n    {\n        cin >> s >> t;\n        for (int i = s - 1; i < t; i++)\n        {\n            days[i]++;\n            if (maxDays < days[i])\n            {\n                maxDays = days[i];\n            }\n        }\n    }\n    cout << maxDays << endl;\n}\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = []\n    for i in range(n):\n        s, t = map(int, sys.stdin.readline().split())\n        for j in range(s, t + 1):\n            days.append(j)\n    days = set(days)\n    print(len(days))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = []\n    for i in range(n):\n        s, t = map(int, sys.stdin.readline().split())\n        for j in range(s, t + 1):\n            days.append(j)\n    print(len(set(days)))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# %%\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n# %%\ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j] + 1\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n\n# %%\n", "\nN = int(input())\n\nevents = []\n\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n\n# initialize the last event to the first event\nlast_event = events[0]\n\n# initialize the number of days with free food to the duration of the first event\ndays_with_free_food = last_event[1] - last_event[0] + 1\n\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\n\nprint(days_with_free_food)\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = []\n    for i in range(n):\n        s, t = map(int, sys.stdin.readline().split())\n        for j in range(s, t + 1):\n            days.append(j)\n    days = set(days)\n    print(len(days))\n\nif __name__ == '__main__':\n    main()\n", "\n#%%\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n#%%\ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j]\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n", "\nN = int(input())\n\nstart_dates = []\nend_dates = []\n\nfor i in range(N):\n    start, end = map(int, input().split())\n    start_dates.append(start)\n    end_dates.append(end)\n\nstart_dates.sort()\nend_dates.sort()\n\ncount = 0\n\ncurr_start = 0\ncurr_end = 0\n\nwhile curr_start < len(start_dates) and curr_end < len(end_dates):\n    if start_dates[curr_start] <= end_dates[curr_end]:\n        count += 1\n        curr_start += 1\n    else:\n        count -= 1\n        curr_end += 1\n\nprint(count)\n", "\nN = int(input())\n\ndays = []\nfor i in range(N):\n    s, t = map(int, input().split())\n    days.append((s, t))\n\ndays.sort(key=lambda x: x[0])  # \u30bd\u30fc\u30c8\u3059\u308b\ntotal_days = 0\n\nfor i in range(N):\n    if i == 0:\n        total_days += days[i][1] - days[i][0] + 1  # \u521d\u65e5\u306f\u5fc5\u305a\u8a2a\u308c\u308b\n    else:\n        if days[i][0] <= days[i-1][1]:\n            if days[i][1] > days[i-1][1]:\n                total_days += days[i][1] - days[i-1][1]\n        else:\n            total_days += days[i][1] - days[i][0] + 1\n\nprint(total_days)\n", "\nN = int(input())\n\nevents = []\n\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n\n# initialize the last event to be the first event\nlast_event = events[0]\n\n# initialize the number of days with free food to the duration of the last event\ndays_with_free_food = last_event[1] - last_event[0] + 1\n\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\n\nprint(days_with_free_food)\n", "\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n#%%\ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j] + 1\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n", "\nN = int(input())\n\nstart_dates = []\nend_dates = []\nfor i in range(N):\n    start, end = map(int, input().split())\n    start_dates.append(start)\n    end_dates.append(end)\nstart_dates.sort()\nend_dates.sort()\ncount = 0\ncurr_start = 0\ncurr_end = 0\nwhile curr_start < len(start_dates) and curr_end < len(end_dates):\n    if start_dates[curr_start] <= end_dates[curr_end]:\n        count += 1\n        curr_start += 1\n    else:\n        count -= 1\n        curr_end += 1\nprint(count)\n", "\n\n\n#%%\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n#%%\ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j] + 1\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n", "\nprint(str(input())[::-1])\n", "import sys\n\n\n\ndef main():\n    events = int(sys.stdin.readline().strip())\n    days = [] # list of days\n    for i in range(events):\n        days.append(list(map(int, sys.stdin.readline().strip().split())))\n    days.sort()\n    intervals = []\n    for start, end in days:\n        if len(intervals) == 0:\n            intervals.append([start, end])\n        else:\n            if intervals[-1][1] >= start:\n                intervals[-1][1] = max(intervals[-1][1], end)\n            else:\n                intervals.append([start, end])\n    days_served = 0\n    for start, end in intervals:\n        days_served += end - start + 1\n    print(days_served)\n\nif __name__ == \"__main__\":\n    main()\n", "\nN = int(input()) \nevents = []\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n# initialize the last event to be the first event\nlast_event = events[0]\n# initialize the number of days with free food to the duration of the first event.\ndays_with_free_food = last_event[1] - last_event[0] + 1\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\nprint(days_with_free_food)\n", "\nN = int(input())\nevents = []\n\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n\n# initialize the last event to be the first event\nlast_event = events[0]\n\n# initialize the number of days with free food to the duration of the first event.\ndays_with_free_food = last_event[1] - last_event[0] + 1\n\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\n\nprint(days_with_free_food)\n", "\n\n#%%\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n#%% \ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j] + 1\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n", "\n#%%\nN = int(input())\n\nstart = []\nend = []\n\nfor i in range(N):\n    s, t = map(int, input().split())\n    start.append(s)\n    end.append(t)\n\nstart.sort()\nend.sort()\n\n#%%\ntotal = 0\ni = 0\nj = 0\nwhile i < N:\n    if start[i] <= end[j]:\n        total += start[i] - end[j] + 1\n        i += 1\n    else:\n        j += 1\n\nprint(total)\n", "\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, s, t, days[366] = {0}, max_days = 0;\n    cin >> N;\n    while (N--)\n    {\n        cin >> s >> t;\n        for (int i = s - 1; i < t; i++)\n        {\n            days[i]++;\n            max_days = max(max_days, days[i]);\n        }\n    }\n    cout << max_days << endl;\n}\n", "\n\nN, M = map(int, input().split())\n\nfile_size = []\nfor i in range(M):\n    file_size.append(int(input()))\n\nfile_size.sort(reverse=True)\n\nfor i in range(M):\n    if N > file_size[i]:\n        N -= file_size[i]\n        print(i + 1)\n        break\n", "N = int(input())\n\ndays = []\nfor i in range(N):\n    s, t = map(int, input().split())\n    days.append((s, t))\n\ndays.sort(key=lambda x: x[0])\ntotal_days = 0\n\nfor i in range(N):\n    if i == 0:\n        total_days += days[i][1] - days[i][0] + 1\n    else:\n        if days[i][0] <= days[i-1][1]:\n            if days[i][1] > days[i-1][1]:\n                total_days += days[i][1] - days[i-1][1]\n        else:\n            total_days += days[i][1] - days[i][0] + 1\n\nprint(total_days)\n", "\n\nimport sys\n\ndef main():\n    events = int(sys.stdin.readline().strip())\n    days = []\n    for i in range(events):\n        days.append(list(map(int, sys.stdin.readline().strip().split())))\n    days.sort()\n    intervals = []\n    for start, end in days:\n        if len(intervals) == 0:\n            intervals.append([start, end])\n        else:\n            if intervals[-1][1] >= start:\n                intervals[-1][1] = max(intervals[-1][1], end)\n            else:\n                intervals.append([start, end])\n    days_served = 0\n    for start, end in intervals:\n        days_served += end - start + 1\n    print(days_served)\n\nif __name__ == \"__main__\":\n    main()\n", "\nN = int(input())\ndays = [0 for i in range(365)]\nfor i in range(N):\n    start, end = map(int, input().split())\n    for j in range(start - 1, end):\n        days[j] += 1\nprint(sum(days))\n", "\n\nN = int(input())\n\nevents = []\n\nfor i in range(N):\n    event = tuple(map(int, input().split()))\n    events.append(event)\n\n# sort events by start time\nevents = sorted(events, key=lambda e: e[0])\n\n# initialize the last event to the first event\nlast_event = events[0]\n\n# initialize the number of days with free food to the duration of the first event \ndays_with_free_food = last_event[1] - last_event[0] + 1\n\nfor event in events:\n    if event[0] <= last_event[1]:\n        # if the current event starts before the last event ends\n        # then the current event overlaps the last event\n        # if the current event ends after the last event ends, then we need to add the difference to days_with_free_food\n        if event[1] > last_event[1]:\n            days_with_free_food += event[1] - last_event[1]\n    else:\n        # if the current event doesn't overlap the last event, then we need to add the duration of the current event to days_with_free_food\n        days_with_free_food += event[1] - event[0] + 1\n    last_event = event\n\nprint(days_with_free_food)\n", "# coding: utf-8\n\nN = int(input()) # \u65e5\u6570\n\ndays = []\nfor i in range(N):\n    s, t = map(int, input().split())\n    days.append((s, t))\n\ndays.sort(key=lambda x: x[0])\ntotal_days = 0\n\nfor i in range(N):\n    if i == 0:\n        total_days += days[i][1] - days[i][0] + 1\n    else:\n        if days[i][0] <= days[i-1][1]:\n            if days[i][1] > days[i-1][1]:\n                total_days += days[i][1] - days[i-1][1]\n        else:\n            total_days += days[i][1] - days[i][0] + 1\n\nprint(total_days)\n", "N = int(input())\ndays = [0 for i in range(365)]\nfor i in range(N):\n    start, end = map(int, input().split())\n    for j in range(start - 1, end):\n        days[j] += 1\nprint(sum(days))\n"]