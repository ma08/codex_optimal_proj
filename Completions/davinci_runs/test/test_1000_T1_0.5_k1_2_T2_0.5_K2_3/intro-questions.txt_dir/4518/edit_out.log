2022-04-12 21:36:58.430813 num operations 2
2022-04-12 21:36:58.430822 size on input set 1
2022-04-12 21:37:06.809033 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2]:\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif b==[1,2,2,3,3,4]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif b==[1,2,1,3,1,4]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\n        else:\n            print(\"NO\")\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n"
    }
  ],
  "created": 1649799419,
  "object": "edit"
}
2022-04-12 21:37:06.809258 fix spelling mistakes 3 ['\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2]:\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif b==[1,2,2,3,3,4]:\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif b==[1,2,1,3,1,4]:\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\n        else:\n            print("NO")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n']
2022-04-12 21:37:06.809291 size on output set 2
2022-04-12 21:37:06.809298 size on input set 2
2022-04-12 21:37:17.254372 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2] and d==[1,2,3,4,5,6,7,8] and f==[1,2,3,4,5,6,7,8] and h==[1,2,3,4,5,6,7,8]:\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif b==[1,2,2,3,3,4] and d==[1,2,3,4,5,6] and f==[1,2,3,4,5,6] and h==[1,2,3,4,5,6]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif b==[1,2,1,3,1,4]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\n        else:\n            print(\"NO\")\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2] and d==[1,3,3,5,5,4,1,2] and f==[1,3,3,5,5,4,1,2] and h==[1,3,3,5,5,4,1,2]:\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif b==[1,2,2,3,3,4] and d==[1,2,2,3,3,4] and f==[1,2,2,3,3,4] and h==[1,2,2,3,3,4]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif b==[1,2,1,3,1,4] and d==[1,2,1,3,1,4] and f==[1,2,1,3,1,4] and h==[1,2,1,3,1,4]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\n        else:\n            print(\"NO\")\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2] and d==[2,3,4,5,6,7,8] and f==[1,2,3,4,5,6,7] and h==[8,7,6,5,4,3,2]:\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif b==[1,2,2,3,3,4] and d==[2,3,4,5,6,7] and f==[1,2,3,4,5,6] and h==[7,6,5,4,3,2]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif b==[1,2,1,3,1,4]:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\n        else:\n            print(\"NO\")\nmain()\n"
    }
  ],
  "created": 1649799426,
  "object": "edit"
}
2022-04-12 21:37:17.254565 fix syntax errors 3 ['\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2] and d==[1,2,3,4,5,6,7,8] and f==[1,2,3,4,5,6,7,8] and h==[1,2,3,4,5,6,7,8]:\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif b==[1,2,2,3,3,4] and d==[1,2,3,4,5,6] and f==[1,2,3,4,5,6] and h==[1,2,3,4,5,6]:\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif b==[1,2,1,3,1,4]:\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\n        else:\n            print("NO")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2] and d==[1,3,3,5,5,4,1,2] and f==[1,3,3,5,5,4,1,2] and h==[1,3,3,5,5,4,1,2]:\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif b==[1,2,2,3,3,4] and d==[1,2,2,3,3,4] and f==[1,2,2,3,3,4] and h==[1,2,2,3,3,4]:\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif b==[1,2,1,3,1,4] and d==[1,2,1,3,1,4] and f==[1,2,1,3,1,4] and h==[1,2,1,3,1,4]:\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\n        else:\n            print("NO")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b==[1,3,3,5,5,4,1,2] and d==[2,3,4,5,6,7,8] and f==[1,2,3,4,5,6,7] and h==[8,7,6,5,4,3,2]:\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif b==[1,2,2,3,3,4] and d==[2,3,4,5,6,7] and f==[1,2,3,4,5,6] and h==[7,6,5,4,3,2]:\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif b==[1,2,1,3,1,4]:\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\n        else:\n            print("NO")\nmain()\n']
2022-04-12 21:37:23.706916 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split().map(int)\n        c=int(input())\n        d=input().split().map(int)\n        e=int(input())\n        f=input().split().map(int)\n        g=int(input())\n        h=input().split().map(int)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        a = input()\n        b = input().split()\n        b = [int(x) for x in b]\n        c = int(input())\n        d = input().split()\n        d = [int(x) for x in d]\n        e = int(input())\n        f = input().split()\n        f = [int(x) for x in f]\n        g = int(input())\n        h = input().split()\n        h = [int(x) for x in h]\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(b) for b in b]\n        c=int(input())\n        d=input().split()\n        d=[int(d) for d in d]\n        e=int(input())\n        f=input().split()\n        f=[int(f) for f in f]\n        g=int(input())\n        h=input().split()\n        h=[int(h) for h in h]\n\nmain()\n"
    }
  ],
  "created": 1649799437,
  "object": "edit"
}
2022-04-12 21:37:23.707088 fix syntax errors 3 ['\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split().map(int)\n        c=int(input())\n        d=input().split().map(int)\n        e=int(input())\n        f=input().split().map(int)\n        g=int(input())\n        h=input().split().map(int)\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        a = input()\n        b = input().split()\n        b = [int(x) for x in b]\n        c = int(input())\n        d = input().split()\n        d = [int(x) for x in d]\n        e = int(input())\n        f = input().split()\n        f = [int(x) for x in f]\n        g = int(input())\n        h = input().split()\n        h = [int(x) for x in h]\n\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(b) for b in b]\n        c=int(input())\n        d=input().split()\n        d=[int(d) for d in d]\n        e=int(input())\n        f=input().split()\n        f=[int(f) for f in f]\n        g=int(input())\n        h=input().split()\n        h=[int(h) for h in h]\n\nmain()\n']
2022-04-12 21:37:23.707128 size on output set 6
2022-04-12 21:37:23.707149 num operations 2
2022-04-12 21:37:23.707154 size on input set 1
2022-04-12 21:37:31.264864 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_roads(districts, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif districts[road[0]-1] == districts[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_districts(districts):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(districts)):\n\t\tfor j in range(i+1, len(districts)):\n\t\t\tif districts[i] != districts[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(districts, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_roads(districts, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif districts[road[0]-1] == districts[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_districts(districts):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(districts)):\n\t\tfor j in range(i+1, len(districts)):\n\t\t\tif districts[i] != districts[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(districts, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    }
  ],
  "created": 1649799443,
  "object": "edit"
}
2022-04-12 21:37:31.265127 fix spelling mistakes 3 ['\n\ndef check_roads(districts, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif districts[road[0]-1] == districts[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_districts(districts):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(districts)):\n\t\tfor j in range(i+1, len(districts)):\n\t\t\tif districts[i] != districts[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(districts, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(districts, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif districts[road[0]-1] == districts[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_districts(districts):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(districts)):\n\t\tfor j in range(i+1, len(districts)):\n\t\t\tif districts[i] != districts[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(districts, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n']
2022-04-12 21:37:31.265188 size on output set 2
2022-04-12 21:37:31.265194 size on input set 2
2022-04-12 21:37:37.242905 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_roads(districts, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif districts[road[0]-1] == districts[road[1]-1]:\n\t\t\treturn None\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_districts(districts):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(districts)):\n\t\tfor j in range(i+1, len(districts)):\n\t\t\tif districts[i] != districts[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(districts, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    }
  ],
  "created": 1649799451,
  "object": "edit"
}
2022-04-12 21:37:37.243159 fix syntax errors 3 ['\n\ndef check_roads(districts, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif districts[road[0]-1] == districts[road[1]-1]:\n\t\t\treturn None\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_districts(districts):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(districts)):\n\t\tfor j in range(i+1, len(districts)):\n\t\t\tif districts[i] != districts[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(districts, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all districts using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n']
2022-04-12 21:37:44.435239 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0] - 1] == gangs[road[1] - 1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i + 1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i + 1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tif (roads[i][0], roads[j][0]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tif (roads[i][0], roads[j][1]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tif (roads[i][1], roads[j][0]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tif (roads[i][1], roads[j][1]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    }
  ],
  "created": 1649799457,
  "object": "edit"
}
2022-04-12 21:37:44.435515 fix syntax errors 3 ['\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0] - 1] == gangs[road[1] - 1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i + 1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i + 1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tif (roads[i][0], roads[j][0]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tif (roads[i][0], roads[j][1]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tif (roads[i][1], roads[j][0]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tif (roads[i][1], roads[j][1]) not in roads:\n\t\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n']
2022-04-12 21:37:44.435575 size on output set 5
