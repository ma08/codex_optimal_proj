["\n\ndef find_max_team_size(skill):\n    unique_skill = list(set(skill))\n    same_skill = {}\n    for sk in skill:\n        if sk in same_skill:\n            same_skill[sk] += 1\n        else:\n            same_skill[sk] = 1\n\n    if len(unique_skill) == 1:\n        return 0\n    elif len(unique_skill) == 2:\n        return min(same_skill.values())\n    else:\n        return min(same_skill.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skill = list(map(int, input().split()))\n        print(find_max_team_size(skill))\n", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. \n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\n    if len(skills) == 0:\n        return 0\n    \ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n", "\n\ndef find_max_team_size(skill_sets):\n    uniq_skill_sets = set(skill_sets)\n    same_skill_sets = {}\n    for skill in skill_sets:\n        same_skill_sets[skill] = same_skill_sets.get(skill, 0) + 1\n    \n    if len(uniq_skill_sets) == 1:\n        return 0\n    elif len(uniq_skill_sets) == 2:\n        return min(same_skill_sets.values())\n    else:\n        return min(same_skill_sets.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skill_sets = list(map(int, input().split()))\n        print(find_max_team_size(skill_sets))\n", "\n\ndef find_max_team_size(skill):\n    unique_skill = set(skill)\n    same_skill = {}\n    for sk in skill:\n        if sk in same_skill:\n            same_skill[sk] += 1\n        else:\n            same_skill[sk] = 1\n\n    if len(unique_skill) == 1:\n        return 0\n    elif len(unique_skill) == 2:\n        return min(same_skill.values())\n    else:\n        return min(same_skill.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skill = list(map(int, input().split()))\n        print(find_max_team_size(skill))\n", "\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n", "\n\ndef find_max_team_size(skill_set):\n    uniq_skill_set = set(skill_set)\n    same_skill_set = {}\n    for skill in skill_set:\n        same_skill_set[skill] = same_skill_set.get(skill, 0) + 1\n    \n    if len(uniq_skill_set) == 1:\n        return 0\n    elif len(uniq_skill_set) == 2:\n        return len(uniq_skill_set) - 1\n    else:\n        return min(same_skill_set.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skill_set = list(map(int, input().split()))\n        print(find_max_team_size(skill_set))\n", "\n\ndef find_max_team_size(skill_set):\n    uniq_skill_set = set(skill_set)\n    same_skill_set = {}\n    for skill in skill_set:\n        same_skill_set[skill] = same_skill_set.get(skill, 0) + 1\n\n    if len(uniq_skill_set) == 1:\n        return 0\n    elif len(uniq_skill_set) == 2:\n        return min(same_skill_set.values())\n    else:\n        return min(same_skill_set.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skill_set = list(map(int, input().split()))\n        print(find_max_team_size(skill_set))\n", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\n\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n", "\n", "\n\ndef find_max_team_size(skill):\n    unique_skill = set(skill)\n    same_skill = {}\n    for sk in skill:\n        if sk in same_skill:\n            same_skill[sk] += 1\n        else:\n            same_skill[sk] = 1\n    \n    if len(unique_skill) == 1:\n        return 0\n    elif len(unique_skill) == 2:\n        return min(same_skill.values()) - 1\n    else:\n        return min(same_skill.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skill = list(map(int, input().split()))\n        print(find_max_team_size(skill))\n"]