["s = input()\n\n\ndef is_palinedrome(st):\n    for i in range(len(st)//2):\n        if st[i] != st[-(i+1)]:\n            return False\n    return True\n\n\ns_pali = is_palinedrome(s)\nsub_pali_left = is_palinedrome(s[:len(s)//2])\nsub_pali_right = is_palinedrome(s[len(s)//2+1:])\n\nif s_pali and sub_pali_left and sub_pali_right:\n    print('Yes')\nelse:\n    print('No')\n", "S = input()\nN = len(S)\nS1 = S[0:(N-1)//2]\nS2 = S[(N+3)//2-1:N+1]\nprint(\"Yes\" if S == S[::-1] and S1 == S1[::-1] and S2 == S2[::-1] else \"No\")", "s = input()\nn = len(s)\na = len(s) // 4\nif s[:n // 2] == s[n // 2 + 1:]:\n    print('Yes')\n        \nelse:\n    print('No')\n", "s = input()\ns1 = s[:len(s)//2]\ns2 = s[len(s)//2+1:]\nprint(\"Yes\" if s==s[::-1] and s1==s1[::-1] and s2==s2[::-1] else \"No\")", "import os, sys, re, math\n\nS = input()\n\ns1 = S[:(len(S) - 1) // 2]\ns2 = S[(len(S) + 3) // 2 - 1:]\nif S[::-1] == S and s1[::-1] == s1 and s2[::-1] == s2:\n    print('Yes')\nelse:\n    print('No')\n", "s = input()\nn = len(s)\n\ndef judge_palindrome(s):\n    if s == s[::-1]:\n        return True\n    else:\n        return False\n\nif judge_palindrome(s) and judge_palindrome(s[:(n - 1) // 2]) and judge_palindrome(s[(n + 3) // 2 - 1:]):\n    ans = 'Yes'\nelse:\n    ans = 'No'\nprint(ans)", "import sys\ns=list(input())\nr=list(reversed(s))\nn=len(s)\n\nfor i in range(n):\n    if s[i]!=r[i]:\n        print('No')\n        return\n\ns1=s[:]\n\ndel s1[(n-1)//2:]\nr1=list(reversed(s1))\n\nfor i in range(len(s1)):\n    if s1[i]!=r1[i]:\n        print('No')\n        return\n\ns2=s[:]\n\ndel s2[:(n+3)//2-1]\nr2=list(reversed(s2))\n\nfor i in range(len(s2)):\n    if s2[i]!=r2[i]:\n        print('No')\n        return\nprint('Yes')", "s = input()\n\nif s == s[::-1]:\n    f = s[:len(s)//2]\n    b = s[len(s)//2 + 1:]\n    if f == f[::-1] and b == b[::-1]:\n        print('Yes')\n        return\n\nprint('No')", "S=input()\nsize=len(S)\ndef palin(S,size):\n    for i  in range (size//2):\n        if S[i]!=S[-1-i]:\n            return False\n    return True\nif palin(S,size) == True:\n    L=S[:size//2]\n    R=S[size//2+2:]\n    if palin(L,size//2) & palin(L,size//2):\n        print('Yes')\n    else:\n        print('No')\nelse:\n    print('No')\n\n", "import math\ns = list(input())\nn = len(s)\ns1 = s[ : (n-1) // 2]\ns2 = s[(n+3) // 2 - 1 : n]\nflag = 1\n\nfor i in range(len(s) // 2):\n    if s[i] != s[- i - 1]:\n        flag = 0\n\nfor i in range(len(s1) // 2):\n    if s1[i] != s1[- i - 1]:\n        flag = 0\n\nfor i in range(len(s2) // 2):\n    if s2[i] != s2[- i - 1]:\n        flag = 0\n\nprint(('Yes' if flag == 1  else 'No'))\n", "s = list(input())\ns_front = s[:(len(s)//2)]\ns_back = s[::-1][:(len(s)//2)]\n\nresult = 'Yes'\n\nfor f, f_r, b, b_r in zip(s_front, s_front[::-1], s_back, s_back[::-1]):\n    if f != f_r or b != b_r or f != b:\n        result = 'No'\n\nprint(result)", "S = input()\nN = len(S)\n\ndef palindrome(string):\n  return 0 if string==string[::-1] else 1\n\nls1 = S[0:int((N-1)/2)]\nls2 = S[int((N+3)/2-1):N]\n\n#print(ls1)\n#print(ls2)\n\n\nif palindrome(S) == palindrome(ls1) == palindrome(ls2) == 0:\n  print('Yes')\nelse:\n  print('No')", "s = input()\ns1 = s[:len(s) // 2]\ns2 = s[:len(s) // 2:-1]\ns3 = s[len(s) // 2 + 1:]\n\nif s1 == s2 == s3:\n    print('Yes')\nelse:\n    print('No')\n", "s = input()\nn = len(s)\nif s != s[::-1]:\n  print(\"No\")\nelif s[0:(n-1)//2] != s[(n-1)//2-1::-1]:\n  print(\"No\")\nelif s[(n+3)//2-1:n] != s[n-1:(n+3)//2-2:-1]:\n  print(\"No\")\nelse:\n  print(\"Yes\")", "s = input()\nn = len(s)\ns1 = s[0:(n - 1) // 2]\ns2 = s[(n + 3) // 2 - 1:]\nif s == s[::-1] and s1 == s1[::-1] and s2 == s2[::-1]:\n    print('Yes')\nelse:\n    print('No')\n", "s = input()\n\nans = True\n\nif s != s[::-1]:\n    print('No')\n    return\n\nn = len(s)\nm = int((n-1)/2)\ns_2 = s[0:m]\n\nif s_2 != s_2[::-1]:\n    print('No')\n    return\n\nl = int((n+3)/2) - 1\ns_3 = s[l:]\n\nif s_3 != s_3[::-1]:\n    print('No')\n    return\n\nprint('Yes')\n", "S = input()\n\ndef isKaibun(s1) :\n    s2 = \"\"\n    i = len(s1)\n    \n    while(i > 0) :\n        i -= 1\n        s2 += s1[i]\n    if(s1 == s2) :\n        return True\n    return False\n\ncon1 = isKaibun(S)\ncon2 = isKaibun(S[:(len(S)-1)//2])\ncon3 = isKaibun(S[(len(S)+3)//2-1:])\nif(con1 and con2 and con3) :\n    print(\"Yes\")\nelse :\n    print(\"No\")", "def main():\n    S = input()\n    def first(s):\n        return s == s[::-1]\n    def second(s):\n        n = len(s)\n        return s[:(n-1)//2] == s[:(n-1)//2:-1]\n    def third(s):\n        n = len(s)\n        temp = s[(n+3)//2-1:]\n        return temp == temp[::-1]\n\n    return \"Yes\" if  first(S) and second(S) and third(S) else \"No\"\n\n\ndef __starting_point():\n    print(main())\n__starting_point()", "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\n\ndef answer(s: str) -> str:\n    if not is_palindrome(s):\n        return 'No'\n\n    strings = [s[:(len(s) - 1) // 2], s[(len(s) + 3) // 2 - 1:]]\n    for i in strings:\n        if not is_palindrome(i):\n            return 'No'\n\n    return 'Yes'\n\n\ndef main():\n    s = input()\n    print((answer(s)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# ABC159\n\ndef is_kaibun(string):\n\n    for i in range((len(string)//2)+1):\n        if string[i] != string[len(string)-i-1]:\n            return False\n    else:\n        return True\n\n\nS = input()\nif is_kaibun(S) and is_kaibun(S[0:(len(S)-1)//2]) and is_kaibun(S[((len(S)+3)//2)-1:len(S)]):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s=input()\nn=len(s)\ncheck=True\nfor i in range(n):\n  if s[i]!=s[n-i-1]:\n    check=False\nfor i in range((n-1)//2):\n  if s[i]!=s[(n-1)//2-i-1]:\n    check=False\n  if s[i+(n+1)//2]!=s[n-i-1]:\n    check=False\nprint(\"Yes\" if check else \"No\")", "S=input()\nN=len(S)\nSS=S[0:(N-1)//2]\nSSS=S[(N+1)//2:N+1]\n\nfor i in range((N-1)//2):\n  if S[i]!=S[-1-i]:print('No');return\n  if SS[i]!=SS[-1-i]:print('No');return\n  if SSS[i]!=SSS[-1-i]:print('No');return\nprint('Yes')", "S = list(input())\nS1 = S[:(len(S)-1)//2]\nS1 = S[(len(S)+1)//2:]\nif S == list(reversed(S)):\n    if S1 == list(reversed(S1)):\n        print('Yes')\n    else:\n        print('No')\nelse:\n    print('No')", "S=input();l=len(S)//2;print(\"YNeos\"[any(map(lambda s:any(c!=d for c,d in zip(s,s[::-1])),[S,S[:l],S[-l:]]))::2])", "S = input()\nl = len(S) // 2\nformer = S[:l]\nlatter = S[l+1:]\nprint(\"Yes\" if S == S[::-1] and former == former[::-1] and latter == latter[::-1] else \"No\")", "s = input()\nl = len(s)\nokey = 1\nll = l//2\n\nfor i in range(0,l//2):\n    if s[i] != s[l-i-1]:\n        okey = 0\n        break\n\nif okey == 1: \n    for i in range(0,ll//2):\n        if s[i] != s[ll-i-1]:\n            okey = 0\n            break\n\nif okey == 1:\n    for i in range(ll+1, ll+ll//2):\n        if s[i] != s[l-i-1]:\n            okey = 0\n            break\n\nif okey == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s=input();n=len(s)//2;print('YNeos'[s[:n]!=s[n+1:]::2])", "def resolve():\n    s = input()\n    if s == s[::-1]:\n        s_1 = s[:len(s)//2]\n        s_2 = s[(len(s)+1)//2:]\n        if (s_1 == s_1[::-1]) and (s_2 == s_2[::-1]):\n            print('Yes')\n        else:\n            print('No')\n    else:\n        print('No')\nresolve()", "S = input()\nN = len(S)\n\nret = 'Yes'\nfor s1, s2 in list(zip(S, reversed(S)))[:N//2]:\n    if s1 != s2:\n        ret = 'No'\n        break\ns = S[:N//2]\nfor s3, s4 in list(zip(s, reversed(s)))[:N//4]:\n    if s3 != s4:\n        ret = 'No'\n        break\n\nprint(ret)\n\n", "s=input()\n\nn = len(s)\nfor i in range(n//2):\n  if s[i] != s[n-1-i]:\n    print('No')\n    return\n\nn_left = int((n-1)/2)\nfor i in range(n//4):\n  if s[i] != s[n_left-1-i]:\n    print('No')\n    return\n\nn_right = int((n+3) / 2)-1\nfor i in range(n//4):\n  if s[i+n_right] != s[n-1-i]:\n    print('No')\n    return\n\nprint('Yes')", "s = input()\n\nn = len(s)\n\ns1 = s[:(n-1) //2]\n\ns2 = s[(n+3)// 2-1:n]\n\n\n\nif s != s[::-1] or s1 != s1[::-1] or s2 != s2[::-1]:\n    print('No')\nelse :\n    print('Yes')", "S=input()\nclass Palindrome:\n    def __init__(self,string):\n        self.string=string\n    def jugde_paindrome(self):\n        if self.string==self.string[::-1]:\n            return True\n        else:\n            return False\n\nbefore=S[:int((len(S)-1)/2)]\nafter=S[int((len(S)-1)/2)+1:]\nS_judge=Palindrome(S)\nbefore_judge=Palindrome(before)\nafter_judge=Palindrome(after)\n\nif S_judge.jugde_paindrome()==True and after_judge.jugde_paindrome()==True and before_judge.jugde_paindrome()==True:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "S=input()\nN=len(S)\ndef isPalindrome(s):\n  n = len(s)\n  flag=True\n  slist=list(s)\n  for i, c in enumerate(slist):\n    if c!=slist[n-1-i]:\n      flag=False\n    if i > n-i:\n      break\n  return flag\n\nSlist=list(S)\n\nif isPalindrome(S) and \\\n   isPalindrome(Slist[0:int((N-1)/2)]) and \\\n   isPalindrome(Slist[int((N+3)/2)-1:N]):\n  print('Yes')\nelse:\n  print('No')", "s = input()\nn = len(s) // 2\n\nif s[:n] == s[n+1:]:\n    print('Yes')\nelse:\n    print('No')\n", "kaibunkai = input()\nn = len(kaibunkai)\nzenhan = kaibunkai[:(n-1)//2]\nkouhan = kaibunkai[(n+3)//2-1:]\n\n\ndef kaibun_desuka(bun):\n  s = len(bun)\n  for x in range(s//2):\n    if bun[x] != bun[-x-1]:\n      return False\n  return True\n\nif kaibun_desuka(kaibunkai) and kaibun_desuka(zenhan) and kaibun_desuka(kouhan):\n  print(\"Yes\")\n\n  \nelse:\n  print(\"No\")\n    \n", "n=input()\nleng=len(n)\na=n[0:leng//2]\nb=n[(leng+3)//2-1:]\nif n==n[::-1] and a==a[::-1] and b==b[::-1]:\n   print(\"Yes\")\nelse:\n   print(\"No\")", "S = input()\nans = 'Yes'\ndef kaibun(Str):\n    N = len(Str)//2\n    re = True\n    for i in range(N):\n        if Str[i] == Str[-i-1]:\n            continue\n        else:\n            re = False\n    return re\n\nN = len(S)\nif not kaibun(S):\n    ans = ('No')\nif not kaibun(S[:(N-1)//2]):\n    ans = ('No')\nif not kaibun(S[(N+3)//2-1:]):\n    ans = ('No')\n\nprint(ans)", "s = input()\n\na = s[:len(s)//2]\nb = s[len(s)//2+1:]\nprint('Yes' if s == s[::-1] and a == a[::-1] and b == b[::-1] else 'No')", "# coding=utf-8\n\ndef tk(s):\n    s1 = s[0:len(s)//2+1]\n    s2 = s[len(s)//2:len(s)]\n\n    #print(s1, s2)\n\n    if s1 == s2[::-1]:\n        return True\n    else:\n        return False\n\ndef Kaibun(s):\n    if s == s[::-1]:\n        return True\n    else:\n        return False\n\ndef __starting_point():\n    S = input()\n    #print(len(S)//2)\n    #print(S[0:len(S)//2])\n\n    if tk(S) and Kaibun(S[0:len(S)//2]) and Kaibun(S[len(S)//2+1:len(S)]):\n        print('Yes')\n\n    else:\n        print('No')\n__starting_point()", "s = input()\nn = len(s)\na = len(s) // 4\nif s[:n // 2] == s[n // 2 + 1:]:\n    print('Yes')\n        \nelse:\n    print('No')\n", "S = str(input())\nforward = ''\nback = ''\nfor i in range(0, ((len(S)-1)//2)):\n  forward += S[i]\nfor j in range(((len(S)+3)//2)-1, len(S)):\n  back += S[j]\nif forward == back:\n  print('Yes')\nelse:\n  print('No')", "s = input()\nn = len(s)\n\nif s == s[::-1]:\n    check = s[0:(n-1)//2]\n    if check == check[::-1]:\n        check = s[(n+3)//2-1:]\n        if check == check[::-1]:\n            print(\"Yes\")\n            return\nprint(\"No\")", "s = input()\nn = len(s)\n\ndef f(s):\n    return s == s[::-1]\n\nif f(s) and f(s[:(n-1)//2]) and f(s[(n+3)//2-1:]):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "string=input()\npalindrome=False\npalin1=False\n\ndef palin(string):\n    palindrome=False\n    if string==string[::-1]:\n        palindrome=True\n    return palindrome\n\npalindrome=palin(string)\n\nif palin(string[int((len(string)-1)/2)])==True and palindrome==True:\n    palin1=True\nif palin(string[int((len(string)+3)/2)-1:len(string)])==True and palin1==True:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "def main():\n    S = input()\n\n    N = len(S)\n    for i in range(N):\n        if S[i] != S[N-i-1]:\n            print(\"No\")\n            return\n\n    M = (N-1)//2\n    for i in range(M):\n        if S[i] != S[N-i-1]:\n            print(\"No\")\n            return\n\n    L = (N+3)//2 - 1\n    for i in range(L, N):\n        if S[i] != S[N+L-i-1]:\n            print(\"No\")\n            return\n\n    print(\"Yes\")\n\n\nmain()\n", "import math\nS=input()\nr=len(S)\nz=0\nstr_list=[]\nwhile z<r:\n    str_list.append(S[z])\n    z=z+1\n\nN=len(str_list)\nx=math.floor((N-1)/2)\ny=math.floor((N+3)/2)\n\ns=0\n\nlist1=str_list[::-1]\n\nif list1==str_list:\n    s=s+1\n\nlist2=[]\nlist3=[]\n\nt=0\nwhile t<x:\n    list2.append(str_list[t])\n    t=t+1\n\nlist4=list2[::-1]\nif list2==list4:\n    s=s+1\n\nu=y-1\nwhile u<N:\n    list3.append(str_list[u])\n    u=u+1\n\nlist5=list3[::-1]\nif list3==list5:\n    s=s+1\n\n\n\nif s==3:\n    print('Yes')\nelse:\n    print('No')\n", "S = input()\n\n#print ((len(S)-1)//2)\n#print ((len(S)+3)//2)\n#print (S[0:(len(S)-1)//2])\n#print (S[((len(S)+3)//2)-1:len(S)])\n#print (S[::-1])\n\nSkai1 = S[0:(len(S)-1)//2]\nSkai1 = Skai1[::-1]\nSkai2 = S[((len(S)+3)//2)-1:len(S)]\nSkai2 = Skai2[::-1]\n\nif S==S[::-1] and S[0:(len(S)-1)//2] ==Skai1 and S[((len(S)+3)//2)-1:len(S)] == Skai2: \n  print('Yes')\nelse:\n  print(\"No\")", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\n#from heapq import heappush, heappop\n#import numpy as np\n#from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\ndef judge(S):\n    for i in range(len(S) // 2):\n        if S[i] != S[-(i+1)]:\n            return False\n    return True\n\nS = ns()\nN = len(S)\np = S[:(N-1)//2]\nl = S[(N+3)//2 - 1:]\nif judge(S) and judge(p) and judge(l):\n    print('Yes')\nelse:\n    print('No')\n\n", "s = input()\nsf = s[:int((len(s)-1)/2)]\nsl = s[int((len(s)+3)/2)-1:]\nif s == s[::-1] and sf == sf[::-1] and sl == sl[::-1]:\n    print('Yes')\nelse:\n    print('No')", "def readinput():\n    s=input()\n    return s\n\ndef isKaibun(s):\n    i=0\n    j=len(s)-1\n    while i<=j:\n        if s[i] != s[j]:\n            return False\n        else:\n            i+=1\n            j-=1\n    return True\n\ndef main(s):\n    if not isKaibun(s):\n        return 'No'\n    n=len(s)\n    m=(n-1)//2\n    l=(n+3)//2\n    if not isKaibun(s[:m]):\n        return 'No'\n    if not isKaibun(s[l-1:]):\n        return 'No'\n    return 'Yes'\n\ndef __starting_point():\n    s=readinput()\n    ans=main(s)\n    print(ans)\n\n__starting_point()", "# 159 B\nS = input()\nN = len(S)\nSf = S[0:(N-1)//2]\nNSf = len(Sf)\nSb = S[(N+3)//2 -1:N+1]\nNSb = len(Sb)\nans = 0\n\nfor i in range(N//2):\n    if S[i:i+1] != S[N-1-i:N-i]:\n        ans = 1\n\nfor i in range(NSf//2):\n    if Sf[i:i+1] != Sf[NSf-1-i:NSf-i]:\n        ans = 1\n        \nfor i in range(NSb//2):\n    if Sb[i:i+1] != Sb[NSb-1-i:NSb-i]:\n        ans = 1\n        \nprint('Yes') if ans == 0 else print('No')", "import sys\n\ndef isKaibun(S):\n    for i in range(len(S)//2):\n        if not S[i] == S[len(S)-1-i]:\n            return False\n            return\n    return True\n\nS = input()\nN = len(S)\n\nS1 = S[0:(N-1)//2]\nS2 = S[(N+3)//2-1:N]\n\nif isKaibun(S) and isKaibun(S1) and isKaibun(S2):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self,Nodes,is_directed=False):\n        self.nodes=Nodes\n        self.adj_list={}\n        self.is_directed=is_directed\n \n        for node in self.nodes:\n            self.adj_list[node]=[]\n            \n    def add_edge(self,u,v):\n        self.adj_list[u].append(v)\n        if self.is_directed==False:\n            self.adj_list[v].append(u)\n \n    def print_graph(self):\n        for node in self.nodes:\n            print((node,\"->\",self.adj_list[node]))\n \n    def degree_node(self,node):\n        return len(self.adj_list[node])\n \n    def dfsUTIL(self,v,visited,parents=[]):\n        #print(v,end=\" \")\n        visited[v]=True\n        for i in self.adj_list[v]:\n            if visited[i]==False:\n                self.dfsUTIL(i,visited,parents)\n                parents.append(i)        \n    \n    def dfs(self,v):\n        visited=[False]*(max(self.adj_list)+1)\n        parents=[v]\n        self.dfsUTIL(v,visited,parents)\n        return len(parents)\n        \n#####sorting a dictionary by the values#####\ndef dict_sort(ans):\n    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))\n    \n##### naive method for testing prime or not O(n^.5)#####\ndef is_prime(n):\n    if n==1:\n        return 0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\n\n#####swap function#####\ndef swap(a,b):\n    temp=a\n    a=b\n    b=temp\n    return a,b\n\n#####Primes till Nth O(n)#####\ndef seive_primes(n):\n    flag=[0]*(n+10)\n    flag[1]=flag[0]=1\n    i=2\n    while i*i<=n+1:\n        if flag[i]==0:\n            j=i*i\n            while j<=n+1:\n                flag[j]=1\n                j+=i\n        i+=1\n    return flag\n\n#####all the prime factors of a number#####\ndef factors(n):\n    d={}\n    while(n%2==0):\n        if 2 in d:\n            d[2]+=1\n        else:\n            d[2]=1\n        n/=2\n    for i in range(3,int(n**0.5)+1,2):\n        while(n%i==0):\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n            n/=i\n    n=int(n)\n    if n>1:\n        d[n]=1\n    return d\n\n#####greatest common divisor of two numbers#####\ndef gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\n#####least common multiplyer of two numbers#####\ndef lcm(a,b):\n    return (a*b)//gcd(a,b)\n\n#####function that return all the letters#####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n#####binary search O(logN)#####\ndef binary_search(ls,n,flag):\n    low=0\n    hi=n-1\n    while(low<=hi):\n        mid=(low+hi)//2\n        if ls[mid]==flag:\n            return mid\n        elif ls[mid]>flag:\n            hi=mid-1\n        else:\n            low=mid+1\n    return -1\n\n#####quadratic roots#####\ndef qdrt(a,b,c):\n    chk=b*b-4*a*c\n    if chk>=0:\n        ans1=(-b+chk**0.5)/(2*a)\n        ans2=(-b-chk**0.5)/(2*a)\n        return [int(ans1),int(ans2)]\n    return -1\n#####permutations#####\ndef permutation(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(n-r+1,n+1):\n        ans*=i\n    return ans\n\n#####combinations#####\ndef combination(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(r):\n        ans*=(n-i)\n    div=1\n    for i in range(2,r+1):\n        div*=i\n    return ans//div\n        \n#####taking an array/list as input#####\ndef arinp():\n    ls=list(map(int,input().split()))\n    return ls\n\n#####taking multiple inputs#####\ndef mult_inp():\n    return list(map(int,input().split()))\n\n#####Main function starts from here#####\ndef main():\n    s=input()\n    n=len(s)\n    if s==s[::-1] and s[:n//2]==s[n//2+1:]:\n        print('Yes')\n    else:\n        print('No')\ndef __starting_point():\n    main()\n    \n\n    \n    \n    \n            \n    \n    \n\n__starting_point()", "s = list(input())\nn = len(s)\nflag = 0\nfor i in range(n//2):\n    if s[i] != s[n-i-1]:\n        flag = 1\nif flag == 0:\n    s2 = s[:(n-1)//2]\n    n2 = len(s2)\n    for i in range(n2//2):\n        if s2[i] != s2[n2-i-1]:\n            flag = 1\n#print(n, n2, s, s2)\nif flag == 0:\n    if flag == 0:\n        s2 = s[(n+3)//2-1:]\n        n2 = len(s2)\n    for i in range(n2//2):\n        if s2[i] != s2[n2-i-1]:\n            flag = 1\n#print(s2)\nif flag == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "N = str(input())\nlenN = len(N)\n\nfN =N[0:(lenN - 1)//2]\nlN =N[(lenN + 3)//2-1:]\nprint(((\"No\",\"Yes\")[(0,1)[fN == fN[-1::-1]]*(0,1)[lN == lN[-1::-1]]*(0,1)[lN == fN]]))\n\n", "s = input()\nn = len(s)\n\ns_ = s[:(n-1)//2]\n\nif s == s[::-1] and s_ == s_[::-1]:\n  print('Yes')\nelse:\n  print('No')", "s = input()\nl = len(s)\n\ndef check(a):\n  n = len(a)\n  if n % 2 == 0:\n    for i in range(n//2):\n      if a[i] != a[n-i-1]:\n        return False\n    return True\n  else:\n    for i in range((n-1)//2):\n      if a[i] != a[n-i-1]:\n        return False\n    return True\n\nres = \"No\"\nif check(s):\n  #print(s)\n  if check(s[:(l-1)//2]):\n    if check(s[(l+3)//2 - 1:]):\n      res = \"Yes\"\n\nprint(res)", "S = input()\nans=\"No\"\nif S==S[::-1] and \\\nS[:int((len(S)-1)/2)]==S[:int((len(S)-1)/2)][::-1] and \\\nS[int((len(S)+3)/2)-1:]==S[int((len(S)+3)/2)-1:][::-1]:ans=\"Yes\"\nprint(ans)", "s = list(input())\ns_front = s[:(len(s)//2)]\ns_back = s[::-1][:(len(s)//2)]\n\nresult = 'Yes'\n\nfor f, f_r, b, b_r in zip(s_front, s_front[::-1], s_back, s_back[::-1]):\n    if f != f_r or b != b_r or f != b:\n        result = 'No'\n\nprint(result)", "def check(string):\n    if string == string[::-1]:\n        return True\n    else:\n        return False\n\n\nS = input()\nn = len(S)\n\nS1 = S[:(n-1)//2]\nS2 = S[(n+1)//2:]\n\nif check(S) and check(S1) and check(S2):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "S1 = input()\nN = len(S1)\n\nS2 = S1[::-1]\n\na = S1 == S2\n\nS3 = S1[:int((N - 1) / 2)]\nS4 = S3[::-1]\n\nb = S3 == S4\n\nS5 = S1[int((N + 3) / 2) - 1:]\nS6 = S5[::-1]\n\nc = S5 == S6\n\nif a and b and c:\n    print('Yes')\n\nelse:\n    print('No')", "S = input()\nT = \"\"\nU = \"\"\nN = len(S)\nfor i in range((N-1)//2):\n    T += S[i]\nfor i in range(((N-1)//2)-1,-1,-1):\n    U += T[i]\nif(T==U):\n    if(S == T+S[(N-1)//2]+T):\n        print(\"Yes\")\n        return\nprint(\"No\")", "s = input()\nd = len(s)\nn = int((d-1)/2)\nfor i in range(n):\n  x = int((d-3)/2 -i)\n  if s[i] == s[d-i-1] ==s[x]:\n    continue\n  else:\n    print('No')\n    return\nprint('Yes')", "def judge_kaibun(S):\n    return S == S[::-1]\n\n\nS = input()\n\n# \u56de\u6587\u304b\u3069\u3046\u304b\nif judge_kaibun(S):\n    # \u5f37\u3044\u56de\u6587\u304b\u3069\u3046\u304b\n    S_part1 = S[(len(S) + 1) // 2:]\n    S_part2 = S[:(len(S) - 1) // 2]\n    if judge_kaibun(S_part1) and judge_kaibun(S_part2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")\n", "s = list(input())\nn = len(s)\ns1 = s[0:(n-1)//2]\ns2 = s[(n-1)//2+1:n]\nsr = list(reversed(s))\ns1r = list(reversed(s1))\ns2r = list(reversed(s2))\n\nif s == sr and s1 == s1r and s2 == s2r:\n    print(\"Yes\")\n    return\n\nprint(\"No\")", "import sys\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\ndef is_pal(s):\n    return s[::-1] == s\n\n\ndef solve():\n    S = ins()\n    n = len(S)\n    return is_pal(S) and is_pal(S[: n // 2]) and is_pal(S[n // 2 + 1 :])\n\n\nprint(\"Yes\" if solve() else \"No\")\n", "S=input()\nrS=S[::-1]\n\nle=len(S)\ncent=int((le+1)/2)\n\nS1=S[0:cent-1]\nS2=S[cent:]\nrS1=S1[::-1]\nrS2=S2[::-1]\n\nif S==rS and S1==rS1 and S2==rS2:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n", "S = input()\nN = len(S)\nS1 = S[0:(N-1)//2]\nS2 = S[(N+3)//2-1:]\n\nprint('Yes' if S == S[::-1] and S1 == S1[::-1] and S2 == S2[::-1] else 'No')", "s = input()\nn = len(s)\n\ns1 = s[0:(n-1)//2]\ns2 = s[(n+1)//2:n]\n\ns_reverse = s[::-1]\ns1_reverse = s1[::-1]\ns2_reverse = s2[::-1]\n\nif s == s_reverse and s1 == s1_reverse and s2 == s2_reverse:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "s=input()\nn=(len(s)-1)//2\nprint('Yes' if s[:n]==s[n+1:] else 'No')", "Ss = input().rstrip()\n\nN = len(Ss)\nS1s = Ss[:N//2]\nS2s = Ss[(N+1)//2:]\n#print('# S1s:', S1s)\n#print('# S2s:', S2s)\n\nif Ss == Ss[::-1] and S1s == S1s[::-1] and S2s == S2s[::-1]:\n    print('Yes')\nelse:\n    print('No')\n", "S=input()\nN=len(S)\ns=''.join(list(reversed(S)))\n\nT=S[0:int((N-1)/2)]\nNT=len(T)\nt=''.join(list(reversed(T)))\n\nU=S[int((N+1)/2):N]\nNU=len(U)\nu=''.join(list(reversed(U)))\n\nif S[0:int((N-1)/2)] == s[0:int((N-1)/2)] and T == t and U == u:\n    print('Yes')\nelse:\n    print('No')", "def check(s):\n  return s == s[::-1]\n\ns=input()\nn=len(s)\n\nif check(s) and check(s[:(n-1)//2]) and check(s[(n+3)//2-1:n]):\n  print(\"Yes\")\nelse:\n  print(\"No\")", "def main():\n    S = input()\n    N = len(S)\n    S1 = S[0:(N - 1) // 2]\n    S2 = S[(N + 3) // 2 - 1:]\n    \n    if S == S[::-1] and S1 == S1[::-1] and S2 == S2[::-1]:\n        print('Yes')\n    else:\n        print('No')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "s = input()\nn = len(s)\nl1 = int((n-1)/2)\nl2 = int((n+3)/2)\nif s == s[::-1] and s[:l1] == s[l2-1:n] :   \n    print('Yes')\nelse :\n    print('No')", "s = input()\nstr2 = s[0: (len(s) - 1) // 2]\nstr3 = s[(len(s) + 3) // 2: len(s) - 1]\nif s == ''.join(list(reversed(s))) \\\n\tand str2 == ''.join(list(reversed(str2))) \\\n\tand str3 == ''.join(list(reversed(str3))):\n\tprint('Yes')\nelse:\n\tprint('No')", "s = input()\nif 4 < len(s) < 6:\n  print('No')\n  return\n\nif s[::-1] != s:\n  print('No')\n  return\ns = s[:len(s)//2]\nif s[::-1] != s:\n  print('No')\n  return\nprint('Yes')", "s = input()\nN = len(s)\na = s[:N//2]\nif N % 2 == 0:\n    b = s[N//2:]\nelse:\n    b = s[N//2+1:]\n\nif a == a[::-1] and b == b[::-1] and a == b:\n    print(\"Yes\")\n    return\nprint(\"No\")", "s = input()\nn = len(s)\nflag = False\n \n \ndef palind(S):\n    size = len(S)\n    for i in range(size//2):\n        if S[i] != S[-1-i]:\n            return False\n    return True\n \n \n \nif palind(s):\n    m = (n-1)//2\n    sb = s[:m]\n    if palind(sb):\n        sa = s[m+1:]\n        flag = palind(sa)\n \nprint((\"Yes\" if flag else \"No\"))\n", "s = input()\nnum = len(s)\nn1 = s[0:(num-1) // 2]\nn2 = s[(len(s)+3) // 2-1:]\n\nif s == s[::-1] and n1 == n1[::-1] and n2 == n2[::-1]:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n", "s=input()\nn=len(s)\n\nif s[0:(n-1)//2]==s[(n+3)//2-1:n]:\n    print('Yes')\nelse:\n    print('No')", "\ndef main():\n    s = input()\n    n = len(s)\n    for i in range(n//2):\n        if s[i] != s[n-1-i]:\n            print(\"No\")\n            return\n    s1 = s[:(n-1)//2]\n    s2 = s[(n+3)//2-1:]\n    n1 = len(s1)\n    for i in range(n//4):\n        if s1[i] != s[n1-1-i]:\n            print(\"No\")\n            return\n        if s2[i] != s[n1-1-i]:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\ndef __starting_point():\n    main()\n__starting_point()", "S = str(input())\ns = list(map(str, S))\nN = len(s)\nt = 0\nfor i in range(int((N-1)/2)):\n    if s[i] != s[N-i-1]:\n        t += 1\n        break\nfor i in range(int((N-1)/4)):\n    if s[i] != s[int((N-1)/2) - i - 1]:\n        t += 1\n        break\n\nif t == 0:\n    print('Yes')\nelse:\n    print('No')", "s = input()\n\nans = 'No'\nn = len(s)\nif s == s[::-1]:\n  tmp = s[0:(n-1)//2]\n  if tmp == tmp[::-1]:\n    tmp = s[(n+3)//2-1:]\n    if tmp == tmp[::-1]:\n      ans = 'Yes'\nprint(ans)", "s=input()\nif s[:]==s[::-1]:\n    a=s[:((len(s)-1)//2)]\n    if a[:]==a[::-1]:\n        b=s[((len(s)+2)//2):]\n        if b[:]==b[::-1]:\n            print(\"Yes\")\n            return\nprint(\"No\")", "S=input()\nN=len(S)\nS_1=S[:int((N-1)//2)]\nS_2=S[int((N+2)//2):]\n\nif S==S[::-1] and S_1==S_1[::-1] and S_2==S_2[::-1]:\n  print(\"Yes\")\nelse:\n  print(\"No\")", "s = list(input())\nn = len(s)\n\na = int((n-1)/2)\nb = int((n+3)/2)\n\nfor i in range(a):\n  if s[i] != s[n-1-i]:\n    print(\"No\")\n    return\n    \nfor i in range(a):\n  if s[i] != s[a-1-i]:\n    print(\"No\")\n    return\n    \nfor i in range(a):\n  if s[b+i-1] != s[n-1-i]:\n    print(\"No\")\n    return\n    \nprint(\"Yes\")", "s = input()\nn = len(s)\nflag = False\n\n\ndef palind(S):\n    size = len(S)\n    for i in range(size//2):\n        if S[i] != S[-1-i]:\n            return False\n    return True\n\n\n\nif palind(s):\n    m = (n-1)//2\n    sb = s[:m]\n    if palind(sb):\n        sa = s[m+1:]\n        flag = palind(sa)\n\nprint((\"Yes\" if flag else \"No\"))\n", "S=input()\nS2=S[:(len(S)-1)//2]\nS3=S[(len(S)+3)//2-1:]\nif S==S[::-1] and S2==S2[::-1] and S3==S3[::-1]:\n  print(\"Yes\")\nelse:\n  print(\"No\")", "from fractions import Fraction\n\ns = input()\n\ntmp_1 = Fraction(len(s) - 1, 2)\ntmp_2 = Fraction(len(s) + 3, 2)\n\na = s[0: int(tmp_1)]\nb = s[int(tmp_2) - 1: int(len(s))]\n\nprint('Yes' if a == b else 'No')", "#ABC159B\ns = input()\nn = len(s)\nf = s[:(n-1)//2]\nl = s[1+((n-1)//2):]\nprint(\"Yes\" if s==s[::-1] and f==f[::-1] and l==l[::-1] else \"No\")", "def isParindrome(s):\n    return s == s[::-1]\n\nstring = input()\n\nans = True\nif not isParindrome(string):\n    ans = False\nif not isParindrome(string[(len(string)+1)//2:]):\n    ans = False\nif ans:\n    print('Yes')\nelse:\n    print('No')", "S = input()\nN = len(S)\ndef is_palindrome(s):\n    return s == ''.join(list(reversed(s)))\n\nans = 'Yes' if is_palindrome(S) and is_palindrome(S[:(N-1)//2]) and is_palindrome(S[(N+1)//2:]) else 'No'\nprint(ans)", "s = list(input())\nb = 0\nif len(s)%2==1:\n    for a in range(int((len(s)-1)/2)):\n        if s[a]!=s[len(s)-a-1] and b==0:\n            b = 1\nelse:\n    b = 1\nif b == 0:\n    for c in range(int((len(s)-1)/4+1)):\n        if s[c]==s[int((len(s)-1)/2-c-1)]==s[int((len(s)+1)/2+c)]==s[len(s)-c-1] and b==0:\n            b = 0\n        else:\n            b = 1\nif b == 0:\n    print(\"Yes\")\nelif b == 1:\n    print(\"No\")", "kai = input()\nnum = len(kai)\n\nans = 0\n\nn1 = int((num-1) / 2)\n\nfor i in range(n1):\n    if kai[i] != kai[-1*(i+1)]:\n        ans += 1\n\nl1 = kai[0:n1]\n\nfor i in range(len(l1)):\n    if l1[i] != l1[-1*(i+1)]:\n        ans += 1\n\nl2 = kai[n1+1:]\n\nfor i in range(len(l2)):\n    if l2[i] != l2[-1*(i+1)]:\n        ans += 1\n\nif ans == 0:\n    print(\"Yes\")\n\nelse:\n    print(\"No\")", "S = str(input())\nN = len(S)\nsList = [str(s) for s in S]\nisPalindrome = 1\nstr1 = ''\nstr2 = ''\nstr3 = ''\nstr4 = ''\n\nfor i in range(N):\n  if (sList[i] != sList[N - 1 - i]):\n    isPalindrome = 0\nif isPalindrome == 1:\n  for i in range(int((N - 1) / 2)):\n    str1 += sList[i]\n    str2 += sList[int((N - 1) / 2 - 1 - i)]\n    str3 += sList[int((N + 3) / 2 - 1 + i)]\n    str4 += sList[N - 1 - i]\n    \n    if str1 != str2:\n      isPalindrome = 0\n    if str3 != str4:\n      isPalindrome = 0\nif isPalindrome == 0:\n  print('No')\nelse:\n  print('Yes')", "S=input()\nN=len(S)\nif S==S[::-1] and S[0:(N-1)//2]==S[(N-1)//2-1::-1] and S[(N+3)//2-1:]==S[-1:(N+3)//2-2:-1]:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "s=input()\ns1=s[:len(s)//2]\ns2=s[len(s)//2+1:]\nprint('Yes' if s==s[::-1] and s1==s1[::-1] and s2==s2[::-1] else 'No')", "S = input()\nN = len(S)\n\nif S != S[::-1]:\n    print('No')\nelif S[:(N - 1) // 2] != (S[:(N - 1) // 2])[::-1]:\n    print('No')\nelif S[(N + 3) // 2 - 1:] != (S[(N + 3) // 2 - 1:])[::-1]:\n    print('No')\nelse:\n    print('Yes')\n", "S = input()\nN = len(S)\nS_f = S[:int((N-1)/2)]\nS_b = S[int((N+1)/2):]\na = []\nfor i in range(int(len(S)/2)):\n    if S[i] == S[len(S)-i-1]:\n        a.append(0)\n    else:\n        a.append(1)\nfor i in range (int(len(S_f)/2)):\n    if S_f[i] == S_f[len(S_f)-i-1]:\n        a.append(0)\n    else:\n        a.append(1)\nfor i in range (int(len(S_b)/2)):\n    if S_b[i] == S_b[len(S_b)-i-1]:\n        a.append(0)\n    else:\n        a.append(1)\nif sum(a) == 0:\n    print('Yes')\nelse:\n    print('No')"]