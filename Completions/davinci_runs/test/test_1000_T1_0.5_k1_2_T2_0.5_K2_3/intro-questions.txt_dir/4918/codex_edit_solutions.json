["import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in xrange(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # get input (this is a test)\n    # n, q = map(int, input().split())\n    # queries = []\n    # for i in range(q):\n    #     queries.append(input().split())\n\n    # initialize\n    # group_sizes = [1]*n\n    # group_leader = [i for i in range(n)]\n\n    # process queries\n    # for query in queries:\n    #     # merge groups of two students\n    #     if query[0] == 't':\n    #         a = int(query[1])-1\n    #         b = int(query[2])-1\n    #         leader_a = find_leader(a, group_leader)\n    #         leader_b = find_leader(b, group_leader)\n    #         if leader_a != leader_b:\n    #             group_sizes[leader_b] += group_sizes[leader_a]\n    #             group_leader[leader_a] = leader_b\n    #     # print size of group of a student\n    #     else:\n    #         a = int(query[1])-1\n    #         leader_a = find_leader(a, group_leader)\n    #         print(group_sizes[leader_a])\n\n# def find_leader(a, group_leader):\n#     while group_leader[a] != a:\n#         a = group_leader[a]\n#     return a\n\nmain()\n", "import sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 'c':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\nimport sys\nfrom collections import defaultdict\n\ndef find(a, parent):\n    # find root of a\n    while parent[a] != a:\n        a = parent[a]\n    return a\n\ndef union(a, b, parent):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef find(n, parent):\n    if n != parent[n]:\n        parent[n] = find(parent[n], parent)\n    return parent[n]\n\ndef merge(n1, n2, parent, size):\n    root1 = find(n1, parent)\n    root2 = find(n2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "class DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    # global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    # size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(find(int(line[1])))\n            # print(size[find(int(line[1]))])\n            # size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1])-1)))\n\nif __name__ == '__main__':\n    main()\n", "\ndef find(n, p):\n    if n != p[n-1]:\n        p[n-1] = find(p[n-1], p)\n    return p[n-1]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)-1])\n\nif __name__ == \"__main__\":\n    main()\n", "#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.size = 1\n        self.parent = self\n\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val]).val\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.size >= parent2.size:\n            parent1.size += parent2.size\n            parent2.size += parent1.size\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])))\n", "\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n + 1)]\n        self.size = [1 for i in range(n + 1)]\n\n    def find(self, i):\n        if self.sets[i] != i: self.sets[i] = self.find(self.sets[i])\n        return self.sets[i] \n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j) \n        if i == j: return\n        if self.size[i] < self.size[j]: i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2])) \n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n", "\n\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(find(int(line[1])))\n\nif __name__ == '__main__':\n    main()\n", "\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "#union find (with path compression)\n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "import sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\n\n#union find - linked list (O(n) for find)\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array (O(n) for find)\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n)]\n    size = [1] * (n)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(10**6)\n        self.ranks = [0]*10**6\n        self.size = [1]*10**6\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p[find(x)] = find(y)\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).val)\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)] # this is the parent array\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "\ndef find(n, p):\n    if n != p[n]:\n        p[n] = find(p[n], p)\n    return p[n]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)])\n\nif __name__ == \"__main__\":\n    main()\n", "\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "#union find \n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\nfrom sys import stdin\n\ndef find(a):\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n", "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input \nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n        \nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\"\"\"\nDisjoint set implementation\n\"\"\"\nimport sys\n\n\"\"\"\n    Node class of the disjoint set\n    \"\"\"\n\n\"\"\"\n        Initialize a node\n\"\"\"\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\n\"\"\"\n    Disjoint set class\n    \"\"\"\nclass DisjointSet:\n    \"\"\"\n        Initialize a disjoint set\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Create a set with value val\n    \"\"\"\n        self.map = {}\n\n    def make_set(self, val):\n    \"\"\"\n        Get the parent node of the value val\n        \"\"\"\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n    \"\"\"\n        Get the parent node of the node\n    \"\"\"\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    \"\"\"\n        Union two sets with value val1 and val2\n    \"\"\"\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "\n\ndef main():\n    # get inputs\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\nimport sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n", "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 'u':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # get input \n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "import sys\n\nsys.stdin = open(\"input.txt\", \"r\")\nsys.stdout = open(\"output.txt\", \"w\")\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(int(input())):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1] * n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1]) - 1\n            b = int(query[2]) - 1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1]) - 1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\n\nmain()\n", "\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size, count):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    count[0] -= 1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    count = [n]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size, count)\n        else:\n            print(count[0])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "import sys\n\nclass Node:\n  def __init__(self, val):\n    self.val = val\n    self.rank = 0\n    self.parent = self\n\nclass DisjointSet:\n  def __init__(self):\n    self.map = {}\n\n  def make_set(self, val):\n    node = Node(val)\n    self.map[val] = node\n\n  def find_set(self, val):\n    return self.find_set_node(self.map[val])\n\n  def find_set_node(self, node):\n    parent = node.parent\n    if parent == node:\n      return parent\n    node.parent = self.find_set_node(node.parent)\n    return node.parent\n\n  def union(self, val1, val2):\n    node1 = self.map[val1]\n    node2 = self.map[val2]\n\n    parent1 = self.find_set_node(node1)\n    parent2 = self.find_set_node(node2)\n\n    if parent1.rank >= parent2.rank:\n      parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n      parent2.parent = parent1\n    else:\n      parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n  n, q = [int(x) for x in sys.stdin.readline().split()]\n  ds = DisjointSet()\n  for i in range(1, n+1):\n    ds.make_set(i)\n\n  for _ in range(q):\n    line = sys.stdin.readline().split()\n    if line[0] == 't':\n      ds.union(int(line[1]), int(line[2]))\n    else:\n      print(ds.find_set(int(line[1])).rank + 1)\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 'union':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 'size':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import numpy as np\n\nprint np.prod(map(int, raw_input().split()))\n", "\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1] #add size of node1 to node2\n        sizes[node1] = 0 #set size of node1 to 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "import sys\n\ndef find(x):\n    while x != parent[x]:\n        x = parent[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        parent[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global parent\n    parent = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(parent.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]