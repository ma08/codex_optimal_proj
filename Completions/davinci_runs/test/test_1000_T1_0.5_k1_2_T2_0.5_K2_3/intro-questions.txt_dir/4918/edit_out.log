2022-04-13 07:11:02.332276 num operations 2
2022-04-13 07:11:02.332292 size on input set 1
2022-04-13 07:11:07.463945 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n#\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 2,
      "text": "\n\"\"\"\nDisjoint set implementation\n\"\"\"\nimport sys\n    \"\"\"\n    Node class of the disjoint set\n    \"\"\"\n\n        \"\"\"\n        Initialize a node\n        \"\"\"\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\n    \"\"\"\n    Disjoint set class\n    \"\"\"\nclass DisjointSet:\n        \"\"\"\n        Initialize a disjoint set\n        \"\"\"\n    def __init__(self):\n        \"\"\"\n        Create a set with value val\n        \"\"\"\n        self.map = {}\n\n    def make_set(self, val):\n        \"\"\"\n        Get the parent node of the value val\n        \"\"\"\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        \"\"\"\n        Get the parent node of the node\n        \"\"\"\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n        \"\"\"\n        Union two sets with value val1 and val2\n        \"\"\"\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649833862,
  "object": "edit"
}
2022-04-13 07:11:07.464170 fix spelling mistakes 3 ['\n#\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n', '\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n', '\n"""\nDisjoint set implementation\n"""\nimport sys\n    """\n    Node class of the disjoint set\n    """\n\n        """\n        Initialize a node\n        """\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\n    """\n    Disjoint set class\n    """\nclass DisjointSet:\n        """\n        Initialize a disjoint set\n        """\n    def __init__(self):\n        """\n        Create a set with value val\n        """\n        self.map = {}\n\n    def make_set(self, val):\n        """\n        Get the parent node of the value val\n        """\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        """\n        Get the parent node of the node\n        """\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n        """\n        Union two sets with value val1 and val2\n        """\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-13 07:11:07.464305 size on output set 3
2022-04-13 07:11:07.464314 size on input set 3
2022-04-13 07:11:15.566261 fix syntax errors {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 1
    },
    {
      "index": 2,
      "text": "\n\"\"\"\nDisjoint set implementation\n\"\"\"\nimport sys\n\n\"\"\"\n    Node class of the disjoint set\n    \"\"\"\n\n\"\"\"\n        Initialize a node\n\"\"\"\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\n\"\"\"\n    Disjoint set class\n    \"\"\"\nclass DisjointSet:\n    \"\"\"\n        Initialize a disjoint set\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Create a set with value val\n    \"\"\"\n        self.map = {}\n\n    def make_set(self, val):\n    \"\"\"\n        Get the parent node of the value val\n        \"\"\"\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n    \"\"\"\n        Get the parent node of the node\n    \"\"\"\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    \"\"\"\n        Union two sets with value val1 and val2\n    \"\"\"\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649833867,
  "object": "edit"
}
2022-04-13 07:11:15.566456 NO RESULT
2022-04-13 07:11:15.566463 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-13 07:11:15.566490 NO RESULT
2022-04-13 07:11:15.566495 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 1
}
2022-04-13 07:11:15.566587 fix syntax errors 1 ['\n"""\nDisjoint set implementation\n"""\nimport sys\n\n"""\n    Node class of the disjoint set\n    """\n\n"""\n        Initialize a node\n"""\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\n"""\n    Disjoint set class\n    """\nclass DisjointSet:\n    """\n        Initialize a disjoint set\n    """\n    def __init__(self):\n        """\n        Create a set with value val\n    """\n        self.map = {}\n\n    def make_set(self, val):\n    """\n        Get the parent node of the value val\n        """\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n    """\n        Get the parent node of the node\n    """\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    """\n        Union two sets with value val1 and val2\n    """\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-13 07:11:21.538984 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.size = 1\n        self.parent = self\n\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val]).val\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.size >= parent2.size:\n            parent1.size += parent2.size\n            parent2.size += parent1.size\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649833875,
  "object": "edit"
}
2022-04-13 07:11:21.539285 fix syntax errors 3 ['\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n', '\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.size = 1\n        self.parent = self\n\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val]).val\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.size >= parent2.size:\n            parent1.size += parent2.size\n            parent2.size += parent1.size\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])))\n', '\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-13 07:11:42.421827 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nclass Node:\n  def __init__(self, val):\n    self.val = val\n    self.rank = 0\n    self.parent = self\n\nclass DisjointSet:\n  def __init__(self):\n    self.map = {}\n\n  def make_set(self, val):\n    node = Node(val)\n    self.map[val] = node\n\n  def find_set(self, val):\n    return self.find_set_node(self.map[val])\n\n  def find_set_node(self, node):\n    parent = node.parent\n    if parent == node:\n      return parent\n    node.parent = self.find_set_node(node.parent)\n    return node.parent\n\n  def union(self, val1, val2):\n    node1 = self.map[val1]\n    node2 = self.map[val2]\n\n    parent1 = self.find_set_node(node1)\n    parent2 = self.find_set_node(node2)\n\n    if parent1.rank >= parent2.rank:\n      parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n      parent2.parent = parent1\n    else:\n      parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n  n, q = [int(x) for x in sys.stdin.readline().split()]\n  ds = DisjointSet()\n  for i in range(1, n+1):\n    ds.make_set(i)\n\n  for _ in range(q):\n    line = sys.stdin.readline().split()\n    if line[0] == 't':\n      ds.union(int(line[1]), int(line[2]))\n    else:\n      print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).val)\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 'c':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649833881,
  "object": "edit"
}
2022-04-13 07:11:42.422080 fix syntax errors 3 ['import sys\n\nclass Node:\n  def __init__(self, val):\n    self.val = val\n    self.rank = 0\n    self.parent = self\n\nclass DisjointSet:\n  def __init__(self):\n    self.map = {}\n\n  def make_set(self, val):\n    node = Node(val)\n    self.map[val] = node\n\n  def find_set(self, val):\n    return self.find_set_node(self.map[val])\n\n  def find_set_node(self, node):\n    parent = node.parent\n    if parent == node:\n      return parent\n    node.parent = self.find_set_node(node.parent)\n    return node.parent\n\n  def union(self, val1, val2):\n    node1 = self.map[val1]\n    node2 = self.map[val2]\n\n    parent1 = self.find_set_node(node1)\n    parent2 = self.find_set_node(node2)\n\n    if parent1.rank >= parent2.rank:\n      parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n      parent2.parent = parent1\n    else:\n      parent1.parent = parent2\n\n\nif __name__ == "__main__":\n  n, q = [int(x) for x in sys.stdin.readline().split()]\n  ds = DisjointSet()\n  for i in range(1, n+1):\n    ds.make_set(i)\n\n  for _ in range(q):\n    line = sys.stdin.readline().split()\n    if line[0] == \'t\':\n      ds.union(int(line[1]), int(line[2]))\n    else:\n      print(ds.find_set(int(line[1])).rank + 1)\n', '\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).val)\n', 'import sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'c\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-13 07:11:42.422137 size on output set 6
2022-04-13 07:11:42.422154 num operations 2
2022-04-13 07:11:42.422160 size on input set 1
2022-04-13 07:11:44.238354 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649833902,
  "object": "edit"
}
2022-04-13 07:11:44.238521 fix spelling mistakes 3 ["import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:11:44.238551 size on output set 2
2022-04-13 07:11:44.238557 size on input set 2
2022-04-13 07:11:48.634653 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p[find(x)] = find(y)\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef find(x):\n    while x != parent[x]:\n        x = parent[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        parent[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global parent\n    parent = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(parent.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649833904,
  "object": "edit"
}
2022-04-13 07:11:48.634924 fix syntax errors 3 ["\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p[find(x)] = find(y)\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != parent[x]:\n        x = parent[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        parent[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global parent\n    parent = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(parent.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:11:51.434416 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)] # this is the parent array\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1])-1)))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in xrange(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649833908,
  "object": "edit"
}
2022-04-13 07:11:51.434595 fix syntax errors 3 ["import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)] # this is the parent array\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1])-1)))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in xrange(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:11:51.434631 size on output set 6
2022-04-13 07:11:51.434642 num operations 2
2022-04-13 07:11:51.434647 size on input set 1
2022-04-13 07:11:58.550428 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find(n, p):\n    if n != p[n]:\n        p[n] = find(p[n], p)\n    return p[n]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649833911,
  "object": "edit"
}
2022-04-13 07:11:58.550603 fix spelling mistakes 3 ['\n\ndef find(n, p):\n    if n != p[n]:\n        p[n] = find(p[n], p)\n    return p[n]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)])\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 07:11:58.550704 size on output set 3
2022-04-13 07:11:58.550711 size on input set 3
2022-04-13 07:12:05.825141 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find(n, parent):\n    if n != parent[n]:\n        parent[n] = find(parent[n], parent)\n    return parent[n]\n\ndef merge(n1, n2, parent, size):\n    root1 = find(n1, parent)\n    root2 = find(n2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef find(n, p):\n    if n != p[n]:\n        p[n] = find(p[n], p)\n    return p[n]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef find(n, p):\n    if n != p[n-1]:\n        p[n-1] = find(p[n-1], p)\n    return p[n-1]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)-1])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649833918,
  "object": "edit"
}
2022-04-13 07:12:05.825319 fix syntax errors 3 ['\n\ndef find(n, parent):\n    if n != parent[n]:\n        parent[n] = find(parent[n], parent)\n    return parent[n]\n\ndef merge(n1, n2, parent, size):\n    root1 = find(n1, parent)\n    root2 = find(n2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n', '\ndef find(n, p):\n    if n != p[n]:\n        p[n] = find(p[n], p)\n    return p[n]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)])\n\nif __name__ == "__main__":\n    main()\n', '\ndef find(n, p):\n    if n != p[n-1]:\n        p[n-1] = find(p[n-1], p)\n    return p[n-1]\n\ndef merge(n1, n2, p, size):\n    root1 = find(n1, p)\n    root2 = find(n2, p)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    p[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    p = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), p, size)\n        else:\n            print(size[find(int(query[1]), p)-1])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 07:12:08.213588 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 'u':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649833925,
  "object": "edit"
}
2022-04-13 07:12:08.213763 fix syntax errors 3 ['\n\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n)]\n    size = [1 for i in range(n)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == "__main__":\n    main()\n', '\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == "__main__":\n    main()\n', '\ndef find(parent, node):\n    if node != parent[node]:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(parent, node1)\n    root2 = find(parent, node2)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'u\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(parent, int(query[1]))])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 07:12:11.922747 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size, count):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    count[0] -= 1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    count = [n]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size, count)\n        else:\n            print(count[0])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649833928,
  "object": "edit"
}
2022-04-13 07:12:11.922924 fix syntax errors 3 ['\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size, count):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    count[0] -= 1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    count = [n]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            union(int(query[1]), int(query[2]), parent, size, count)\n        else:\n            print(count[0])\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python3\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef union(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            union(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 07:12:11.922967 size on output set 9
2022-04-13 07:12:11.922994 num operations 2
2022-04-13 07:12:11.922999 size on input set 1
2022-04-13 07:12:14.286189 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 1
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    }
  ],
  "created": 1649833931,
  "object": "edit"
}
2022-04-13 07:12:14.286364 NO RESULT
2022-04-13 07:12:14.286371 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 1
}
2022-04-13 07:12:14.286405 fix spelling mistakes 2 ["\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"]
2022-04-13 07:12:14.286533 size on output set 2
2022-04-13 07:12:14.286541 size on input set 2
2022-04-13 07:12:27.652422 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # get input \n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # get input (this is a test)\n    # n, q = map(int, input().split())\n    # queries = []\n    # for i in range(q):\n    #     queries.append(input().split())\n\n    # initialize\n    # group_sizes = [1]*n\n    # group_leader = [i for i in range(n)]\n\n    # process queries\n    # for query in queries:\n    #     # merge groups of two students\n    #     if query[0] == 't':\n    #         a = int(query[1])-1\n    #         b = int(query[2])-1\n    #         leader_a = find_leader(a, group_leader)\n    #         leader_b = find_leader(b, group_leader)\n    #         if leader_a != leader_b:\n    #             group_sizes[leader_b] += group_sizes[leader_a]\n    #             group_leader[leader_a] = leader_b\n    #     # print size of group of a student\n    #     else:\n    #         a = int(query[1])-1\n    #         leader_a = find_leader(a, group_leader)\n    #         print(group_sizes[leader_a])\n\n# def find_leader(a, group_leader):\n#     while group_leader[a] != a:\n#         a = group_leader[a]\n#     return a\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    }
  ],
  "created": 1649833934,
  "object": "edit"
}
2022-04-13 07:12:27.652623 fix syntax errors 3 ["\n\ndef main():\n    # get input \n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\n\ndef main():\n    # get input (this is a test)\n    # n, q = map(int, input().split())\n    # queries = []\n    # for i in range(q):\n    #     queries.append(input().split())\n\n    # initialize\n    # group_sizes = [1]*n\n    # group_leader = [i for i in range(n)]\n\n    # process queries\n    # for query in queries:\n    #     # merge groups of two students\n    #     if query[0] == 't':\n    #         a = int(query[1])-1\n    #         b = int(query[2])-1\n    #         leader_a = find_leader(a, group_leader)\n    #         leader_b = find_leader(b, group_leader)\n    #         if leader_a != leader_b:\n    #             group_sizes[leader_b] += group_sizes[leader_a]\n    #             group_leader[leader_a] = leader_b\n    #     # print size of group of a student\n    #     else:\n    #         a = int(query[1])-1\n    #         leader_a = find_leader(a, group_leader)\n    #         print(group_sizes[leader_a])\n\n# def find_leader(a, group_leader):\n#     while group_leader[a] != a:\n#         a = group_leader[a]\n#     return a\n\nmain()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups of two students\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group of a student\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"]
2022-04-13 07:12:32.061764 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1] * n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1]) - 1\n            b = int(query[2]) - 1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1]) - 1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # get inputs\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    }
  ],
  "created": 1649833947,
  "object": "edit"
}
2022-04-13 07:12:32.062006 fix syntax errors 3 ["\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1] * n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1]) - 1\n            b = int(query[2]) - 1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1]) - 1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\n\nmain()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\n\ndef main():\n    # get inputs\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of the group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"]
2022-04-13 07:12:32.062052 size on output set 6
2022-04-13 07:12:32.062063 num operations 2
2022-04-13 07:12:32.062068 size on input set 1
2022-04-13 07:12:46.950951 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint dsu.size[dsu.find(int(line[1]))]\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 2,
      "text": "import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649833952,
  "object": "edit"
}
2022-04-13 07:12:46.951159 fix spelling mistakes 3 ['\nimport sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == "s":\n\t\tprint dsu.size[dsu.find(int(line[1]))]\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n', '\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', 'import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n']
2022-04-13 07:12:46.951287 size on output set 3
2022-04-13 07:12:46.951296 size on input set 3
2022-04-13 07:12:51.131077 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nsys.stdin = open(\"input.txt\", \"r\")\nsys.stdout = open(\"output.txt\", \"w\")\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(int(input())):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == \"s\":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649833967,
  "object": "edit"
}
2022-04-13 07:12:51.131274 fix syntax errors 3 ['import sys\n\nsys.stdin = open("input.txt", "r")\nsys.stdout = open("output.txt", "w")\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(int(input())):\n\tline = sys.stdin.readline().split()\n\tif line[0] == "s":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n', '\nimport sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == "s":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n', 'import sys\n\nclass DSU:\n\tdef __init__(self):\n\t\tself.parent = range(100001)\n\t\tself.ranks = [0]*100001\n\t\tself.size = [1]*100001\n\n\tdef find(self, x):\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x, y):\n\t\txr, yr = self.find(x), self.find(y)\n\t\tif xr == yr: return\n\t\telif self.ranks[xr] < self.ranks[yr]:\n\t\t\tself.parent[xr] = yr\n\t\t\tself.size[yr] += self.size[xr]\n\t\telif self.ranks[xr] > self.ranks[yr]:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.size[xr] += self.size[yr]\n\t\telse:\n\t\t\tself.parent[yr] = xr\n\t\t\tself.ranks[xr] += 1\n\t\t\tself.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n\tline = sys.stdin.readline().split()\n\tif line[0] == "s":\n\t\tprint(dsu.size[dsu.find(int(line[1]))])\n\telse:\n\t\tdsu.union(int(line[1]), int(line[2]))\n']
2022-04-13 07:12:55.364369 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(10**6)\n        self.ranks = [0]*10**6\n        self.size = [1]*10**6\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649833971,
  "object": "edit"
}
2022-04-13 07:12:55.364602 fix syntax errors 3 ['\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', '\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', 'import sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(10**6)\n        self.ranks = [0]*10**6\n        self.size = [1]*10**6\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n']
2022-04-13 07:13:04.586795 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import numpy as np\n\nprint np.prod(map(int, raw_input().split()))\n"
    },
    {
      "index": 1,
      "text": "import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 2,
      "text": "import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649833975,
  "object": "edit"
}
2022-04-13 07:13:04.586961 fix syntax errors 3 ['import numpy as np\n\nprint np.prod(map(int, raw_input().split()))\n', 'import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', 'import sys\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n']
2022-04-13 07:13:04.586996 size on output set 7
2022-04-13 07:13:04.587007 num operations 2
2022-04-13 07:13:04.587011 size on input set 1
2022-04-13 07:13:06.084218 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n        \nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 1,
      "text": "\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    }
  ],
  "created": 1649833984,
  "object": "edit"
}
2022-04-13 07:13:06.084510 fix spelling mistakes 3 ["\n\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n        \nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"]
2022-04-13 07:13:06.084568 size on output set 3
2022-04-13 07:13:06.084577 size on input set 3
2022-04-13 07:13:08.621946 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "class DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 1,
      "text": "class DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 'union':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 'size':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    }
  ],
  "created": 1649833986,
  "object": "edit"
}
2022-04-13 07:13:08.622140 fix syntax errors 3 ["class DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "class DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 'union':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 'size':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"]
2022-04-13 07:13:10.536625 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 1,
      "text": "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n        \nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    }
  ],
  "created": 1649833988,
  "object": "edit"
}
2022-04-13 07:13:10.536858 fix syntax errors 3 ["\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n        \nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"]
2022-04-13 07:13:18.785714 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 1,
      "text": "\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n + 1)]\n        self.size = [1 for i in range(n + 1)]\n\n    def find(self, i):\n        if self.sets[i] != i: self.sets[i] = self.find(self.sets[i])\n        return self.sets[i] \n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j) \n        if i == j: return\n        if self.size[i] < self.size[j]: i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2])) \n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 2,
      "text": "\n\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    }
  ],
  "created": 1649833990,
  "object": "edit"
}
2022-04-13 07:13:18.785904 fix syntax errors 3 ["\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n + 1)]\n        self.size = [1 for i in range(n + 1)]\n\n    def find(self, i):\n        if self.sets[i] != i: self.sets[i] = self.find(self.sets[i])\n        return self.sets[i] \n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j) \n        if i == j: return\n        if self.size[i] < self.size[j]: i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2])) \n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"]
2022-04-13 07:13:18.786005 size on output set 8
2022-04-13 07:13:18.786023 num operations 2
2022-04-13 07:13:18.786028 size on input set 1
2022-04-13 07:13:21.763356 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649833998,
  "object": "edit"
}
2022-04-13 07:13:21.763539 fix spelling mistakes 3 ["\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:13:21.763599 size on output set 3
2022-04-13 07:13:21.763606 size on input set 3
2022-04-13 07:13:25.744942 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    # global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    # size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(find(int(line[1])))\n            # print(size[find(int(line[1]))])\n            # size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n)]\n    size = [1] * (n)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(find(int(line[1])))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649834001,
  "object": "edit"
}
2022-04-13 07:13:25.745111 fix syntax errors 3 ["#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    # global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    # size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(find(int(line[1])))\n            # print(size[find(int(line[1]))])\n            # size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n)]\n    size = [1] * (n)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(find(int(line[1])))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:13:29.697173 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649834005,
  "object": "edit"
}
2022-04-13 07:13:29.697356 fix syntax errors 3 ["import sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:13:38.208847 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\n\ndef find(a):\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\n\ndef find(a, parent):\n    # find root of a\n    while parent[a] != a:\n        a = parent[a]\n    return a\n\ndef union(a, b, parent):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649834009,
  "object": "edit"
}
2022-04-13 07:13:38.209015 fix syntax errors 3 ["\n\nfrom sys import stdin\n\ndef find(a):\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\ndef find(a, parent):\n    # find root of a\n    while parent[a] != a:\n        a = parent[a]\n    return a\n\ndef union(a, b, parent):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent[find(int(line[1]))])\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 07:13:38.209112 size on output set 8
2022-04-13 07:13:38.209123 num operations 2
2022-04-13 07:13:38.209128 size on input set 1
2022-04-13 07:13:44.938940 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#union find - linked list\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 1,
      "text": "#union find\n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 2,
      "text": "\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input \nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    }
  ],
  "created": 1649834018,
  "object": "edit"
}
2022-04-13 07:13:44.939124 fix spelling mistakes 3 ["\n\n#union find - linked list\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "#union find\n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input \nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"]
2022-04-13 07:13:44.939171 size on output set 3
2022-04-13 07:13:44.939178 size on input set 3
2022-04-13 07:13:48.831772 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n"
    },
    {
      "index": 1,
      "text": "#union find \n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 2,
      "text": "#union find (with path compression)\n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    }
  ],
  "created": 1649834024,
  "object": "edit"
}
2022-04-13 07:13:48.832038 fix syntax errors 3 ['#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n', "#union find \n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "#union find (with path compression)\n\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"]
2022-04-13 07:13:51.154383 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 1,
      "text": "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 2,
      "text": "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input \nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    }
  ],
  "created": 1649834028,
  "object": "edit"
}
2022-04-13 07:13:51.154561 fix syntax errors 3 ["\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input \nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"]
2022-04-13 07:13:57.608228 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1] #add size of node1 to node2\n        sizes[node1] = 0 #set size of node1 to 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 1,
      "text": "\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 2,
      "text": "\n\n#union find - linked list (O(n) for find)\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array (O(n) for find)\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    }
  ],
  "created": 1649834031,
  "object": "edit"
}
2022-04-13 07:13:57.608491 fix syntax errors 3 ["\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1] #add size of node1 to node2\n        sizes[node1] = 0 #set size of node1 to 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\n#union find - array\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\n#union find - linked list (O(n) for find)\n\n#find root of node - O(n)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n\n#union find - array (O(n) for find)\n\n#find root of node - O(n)\ndef find(node):\n    if parents[node] == node:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes - O(1)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"]
2022-04-13 07:13:57.608539 size on output set 9
