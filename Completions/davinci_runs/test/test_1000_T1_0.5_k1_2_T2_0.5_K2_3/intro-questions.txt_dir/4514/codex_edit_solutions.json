["import sys\nsys.setrecursionlimit(10**6)\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n    # Read the input.\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n    # Build the tree.\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n    # DFS.\n\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# BFS\ndef bfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = bfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = bfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, query\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# BFS\ndef bfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = bfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = bfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\n\n# Read the input.\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree.\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS.\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    s = input()\n    n = len(s)\n\n    res = 0\n    for i in range(n):\n        if s[i] == 'U':\n            res += n - i - 1 + 2 * i\n        else:\n            res += 2 * (n - i - 1) + i\n\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# Read the input.\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree.\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS.\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k+1:\n            return u\n        for v in tree[u]:\n            res = dfs(tree, v, k, visited)\n            if res:\n                return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n# BFS\ndef bfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = bfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = bfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\nif __name__ == \"__main__\":\n    main()\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k - 1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"]