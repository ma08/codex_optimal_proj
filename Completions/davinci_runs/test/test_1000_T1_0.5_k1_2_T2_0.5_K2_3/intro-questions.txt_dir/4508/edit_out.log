2022-04-12 21:30:01.063069 num operations 2
2022-04-12 21:30:01.063078 size on input set 1
2022-04-12 21:30:09.232116 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649799001,
  "object": "edit"
}
2022-04-12 21:30:09.232354 fix spelling mistakes 3 ["\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 21:30:09.232401 size on output set 3
2022-04-12 21:30:09.232409 size on input set 3
2022-04-12 21:30:10.868258 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649799009,
  "object": "edit"
}
2022-04-12 21:30:10.868523 fix syntax errors 3 ["\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, parent):\n    for v in adj[u]:\n        if v != parent:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 21:30:15.232738 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par, visited):\n    visited[u] = True\n    count = 1\n    for v in adj[u]: \n        if visited[v] == False: \n            count += dfs(adj, v, u, visited) \n    return count\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par, visited):\n    visited[u] = True\n    for v in adj[u]: \n        if visited[v] == False: \n            dfs(adj, v, u, visited)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/3)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649799010,
  "object": "edit"
}
2022-04-12 21:30:15.232931 fix syntax errors 3 ["\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par, visited):\n    visited[u] = True\n    count = 1\n    for v in adj[u]: \n        if visited[v] == False: \n            count += dfs(adj, v, u, visited) \n    return count\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par, visited):\n    visited[u] = True\n    for v in adj[u]: \n        if visited[v] == False: \n            dfs(adj, v, u, visited)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/3)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 21:30:18.758496 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649799015,
  "object": "edit"
}
2022-04-12 21:30:18.758670 fix syntax errors 3 ["\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef read_list():\n    return [int(i) for i in input().split()]\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef add_edge(adj, u, v, w):\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndef dfs(adj, u, par):\n    for v in adj[u]:\n        if v != par:\n            dfs(adj, v, u)\n\ndef solve(adj, n):\n    dfs(adj, 1, 0)\n    count = 0\n    for u in adj:\n        if len(adj[u]) == 1:\n            count += 1\n    if count == 2:\n        return 0\n    else:\n        return math.ceil((count - 2)/2)\n\ndef main():\n    n = read_single_int()\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_list()\n        add_edge(adj, u, v)\n    print(solve(adj, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 21:30:18.758710 size on output set 7
2022-04-12 21:30:18.758730 num operations 2
2022-04-12 21:30:18.758735 size on input set 1
2022-04-12 21:30:20.492723 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# solution\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    },
    {
      "index": 1,
      "text": "\n\n# python3\n# solution:\n\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    },
    {
      "index": 2,
      "text": "\n\n# solution\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    }
  ],
  "created": 1649799018,
  "object": "edit"
}
2022-04-12 21:30:20.492986 fix spelling mistakes 3 ['\n\n# solution\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n', '\n\n# python3\n# solution:\n\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n', '\n\n# solution\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n']
2022-04-12 21:30:20.493027 size on output set 2
2022-04-12 21:30:20.493033 size on input set 2
2022-04-12 21:30:27.924244 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# python3 solution:\n\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    },
    {
      "index": 1,
      "text": "\n\n# python3\n# solution: https://codility.com/demo/results/trainingQQ6Q3W-KXU/\n"
    },
    {
      "index": 2,
      "text": "\n\n# python3\n# solution:\n\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    }
  ],
  "created": 1649799020,
  "object": "edit"
}
2022-04-12 21:30:27.924421 fix syntax errors 3 ['\n\n# python3 solution:\n\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n', '\n\n# python3\n# solution: https://codility.com/demo/results/trainingQQ6Q3W-KXU/\n', '\n\n# python3\n# solution:\n\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n']
2022-04-12 21:30:34.272356 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# solution 1\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n\n\n# solution 2\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def Read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n\n    def compute_height(self):\n        maxHeight = 0\n        for vertex in range(self.n):\n            height = 0\n            i = vertex\n            while i != -1:\n                height += 1\n                i = self.parent[i]\n            maxHeight = max(maxHeight, height);\n        return maxHeight;\n\n\ndef main():\n    tree = TreeHeight()\n    tree.Read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    },
    {
      "index": 1,
      "text": "\n# solution\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    },
    {
      "index": 2,
      "text": "\n# solution\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n"
    }
  ],
  "created": 1649799027,
  "object": "edit"
}
2022-04-12 21:30:34.272640 fix syntax errors 3 ['\n\n# solution 1\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n\n\n# solution 2\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def Read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n\n    def compute_height(self):\n        maxHeight = 0\n        for vertex in range(self.n):\n            height = 0\n            i = vertex\n            while i != -1:\n                height += 1\n                i = self.parent[i]\n            maxHeight = max(maxHeight, height);\n        return maxHeight;\n\n\ndef main():\n    tree = TreeHeight()\n    tree.Read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n', '\n# solution\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n', '\n# solution\n\n# python3\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10 ** 7)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\n\n\nclass TreeHeight:\n    def __init__(self):\n        self.n = 0\n        self.parent = []\n        self.depth = []\n\n    def read(self):\n        self.n = int(sys.stdin.readline())\n        self.parent = list(map(int, sys.stdin.readline().split()))\n        self.depth = [0] * self.n\n\n    def compute_height(self):\n        for vertex in range(self.n):\n            i = vertex\n            while i != -1:\n                if self.depth[i] != 0:\n                    break\n                self.depth[i] = self.depth[self.parent[i]] + 1\n                i = self.parent[i]\n        return max(self.depth)\n\n\ndef main():\n    tree = TreeHeight()\n    tree.read()\n    print(tree.compute_height())\n\nthreading.Thread(target=main).start()\n']
2022-04-12 21:30:34.272692 size on output set 6
