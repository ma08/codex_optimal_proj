2022-04-13 00:24:43.872807 num operations 2
2022-04-13 00:24:43.872817 size on input set 1
2022-04-13 00:24:48.482668 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second \n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809484,
  "object": "edit"
}
2022-04-13 00:24:48.482909 fix spelling mistakes 3 ['\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second \n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 00:24:48.483045 size on output set 3
2022-04-13 00:24:48.483054 size on input set 3
2022-04-13 00:24:54.382723 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    if p == 0:\n        _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\nimport fileinput\n\ndef main():\n    lines = sys.stdin.readlines()\n    N, p = map(int, lines[0].split())  # number of problems, number of perfect problems\n    estimations = list(map(int, lines[1].split()))  # number of minutes to solve each problem\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nimport fileinput\n\ndef main():\n    lines = sys.stdin.readlines()\n    N, p = map(int, lines[0].strip().split())\n    estimations = list(map(int, lines[1].strip().split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    num_ac, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809488,
  "object": "edit"
}
2022-04-13 00:24:54.382913 fix syntax errors 3 ['\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    if p == 0:\n        _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', 'import sys\n\nimport fileinput\n\ndef main():\n    lines = sys.stdin.readlines()\n    N, p = map(int, lines[0].split())  # number of problems, number of perfect problems\n    estimations = list(map(int, lines[1].split()))  # number of minutes to solve each problem\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', 'import sys\n\nimport fileinput\n\ndef main():\n    lines = sys.stdin.readlines()\n    N, p = map(int, lines[0].strip().split())\n    estimations = list(map(int, lines[1].strip().split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    num_ac, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 00:24:57.328984 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second \n    # problem, etc. Any other order will be worse.\n    num_ac, penalty = solve(estimations, 0)\n    if p == 0:\n        print(num_ac, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809494,
  "object": "edit"
}
2022-04-13 00:24:57.329169 fix syntax errors 3 ['\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second \n    # problem, etc. Any other order will be worse.\n    num_ac, penalty = solve(estimations, 0)\n    if p == 0:\n        print(num_ac, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 00:24:59.417076 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 1:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809497,
  "object": "edit"
}
2022-04-13 00:24:59.417263 fix syntax errors 3 ['\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 1:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    """\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    """\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 00:24:59.418391 size on output set 7
2022-04-13 00:24:59.418450 num operations 2
2022-04-13 00:24:59.418456 size on input set 1
2022-04-13 00:25:03.429520 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans]))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans]))\n\nmain()\n"
    }
  ],
  "created": 1649809499,
  "object": "edit"
}
2022-04-13 00:25:03.429688 fix spelling mistakes 3 ['\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans]))\n\nmain()\n', '\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n\nmain()\n', '\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans]))\n\nmain()\n']
2022-04-13 00:25:03.429716 size on output set 2
2022-04-13 00:25:03.429722 size on input set 2
2022-04-13 00:25:05.338385 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:p]))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans])) \n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:p]))\n\nmain()\n"
    }
  ],
  "created": 1649809503,
  "object": "edit"
}
2022-04-13 00:25:05.338564 fix syntax errors 3 ['\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:p]))\n\nmain()\n', '\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans])) \n\nmain()\n', '\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:p]))\n\nmain()\n']
2022-04-13 00:25:08.040012 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:p]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300 or time[0] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n\nmain()\n"
    }
  ],
  "created": 1649809505,
  "object": "edit"
}
2022-04-13 00:25:08.040190 fix syntax errors 3 ['\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n', '\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:p]))\n\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p - 1] > 300 or time[0] > 300:\n        print("0 0")\n        return\n    ans = 0\n    for i in range(p - 1, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n\nmain()\n']
2022-04-13 00:25:08.040221 size on output set 5
2022-04-13 00:25:08.040232 num operations 2
2022-04-13 00:25:08.040237 size on input set 1
2022-04-13 00:25:12.776909 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split())) # estimated time for each problem\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems.\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nestimates = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif estimates[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: estimates[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + estimates[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += estimates[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split())) #estimated time\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    }
  ],
  "created": 1649809508,
  "object": "edit"
}
2022-04-13 00:25:12.777176 fix spelling mistakes 3 ["\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split())) # estimated time for each problem\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems.\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nestimates = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif estimates[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: estimates[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + estimates[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += estimates[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split())) #estimated time\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"]
2022-04-13 00:25:12.777234 size on output set 3
2022-04-13 00:25:12.777240 size on input set 3
2022-04-13 00:25:18.899634 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))  # estimated time\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first,\n        # then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem.\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    }
  ],
  "created": 1649809512,
  "object": "edit"
}
2022-04-13 00:25:18.899891 fix syntax errors 3 ["\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))  # estimated time\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first,\n        # then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem.\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"]
2022-04-13 00:25:26.382209 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\nif est[p] > 300:\n    print(0, 0)\nelse:\n    perms = permutations(range(N))\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        if perm[0] == p:\n            time = 0\n            ac = 0\n            for problem in perm:\n                if time + est[problem] > 300:\n                    break\n                else:\n                    ac += 1\n                    time += est[problem]\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 1,
      "text": "\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split())) # estimated time for each problem\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems.\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\nif est[p] > 300:\n    print(0, 0)\nelse:\n    perms = permutations(range(N))\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        if perm[0] == p:\n            time = 0\n            ac = 0\n            for problem in perm:\n                if time + est[problem] > 300:\n                    break\n                else:\n                    ac += 1\n                    time += est[problem]\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    }
  ],
  "created": 1649809518,
  "object": "edit"
}
2022-04-13 00:25:26.382400 fix syntax errors 3 ['\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\nif est[p] > 300:\n    print(0, 0)\nelse:\n    perms = permutations(range(N))\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        if perm[0] == p:\n            time = 0\n            ac = 0\n            for problem in perm:\n                if time + est[problem] > 300:\n                    break\n                else:\n                    ac += 1\n                    time += est[problem]\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n', "\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split())) # estimated time for each problem\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems.\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", '\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\nif est[p] > 300:\n    print(0, 0)\nelse:\n    perms = permutations(range(N))\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        if perm[0] == p:\n            time = 0\n            ac = 0\n            for problem in perm:\n                if time + est[problem] > 300:\n                    break\n                else:\n                    ac += 1\n                    time += est[problem]\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n']
2022-04-13 00:25:34.562242 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nestimates = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif estimates[p] > 300:\n    print(0)\n    print(0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: estimates[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + estimates[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += estimates[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac)\n    print(min_time)\n"
    },
    {
      "index": 1,
      "text": "\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nestimates = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif estimates[p] > 300: # 300 is the time limit\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N)) # N is the number of problems\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: estimates[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + estimates[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += estimates[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\nfrom itertools import permutations\n"
    }
  ],
  "created": 1649809526,
  "object": "edit"
}
2022-04-13 00:25:34.562426 fix syntax errors 3 ["\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nestimates = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif estimates[p] > 300:\n    print(0)\n    print(0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: estimates[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + estimates[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += estimates[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac)\n    print(min_time)\n", "\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nestimates = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif estimates[p] > 300: # 300 is the time limit\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N)) # N is the number of problems\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: estimates[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + estimates[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += estimates[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", '\n\nfrom sys import stdin\nfrom itertools import permutations\n']
2022-04-13 00:25:34.562480 size on output set 8
2022-04-13 00:25:34.562493 num operations 2
2022-04-13 00:25:34.562499 size on input set 1
2022-04-13 00:25:37.300298 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    _, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "# coding: utf-8\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalties = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalties += t\n        else:\n            break\n    print(max_solved, min_penalties)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809534,
  "object": "edit"
}
2022-04-13 00:25:37.300580 fix spelling mistakes 3 ['\n\ndef main():\n    _, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == "__main__":\n    main()\n', '# coding: utf-8\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalties = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalties += t\n        else:\n            break\n    print(max_solved, min_penalties)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:25:37.300616 size on output set 3
2022-04-13 00:25:37.300623 size on input set 3
2022-04-13 00:25:40.866363 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    _, p = map(int, input().split())\n    times = list(map(int, input().split()))[p:] + list(map(int, input().split()))[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    _, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p] # rotate\n    max_solved = 0\n    total_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            total_penalty += t\n        else:\n            break\n    print(max_solved, total_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809537,
  "object": "edit"
}
2022-04-13 00:25:40.866558 fix syntax errors 3 ['\n\ndef main():\n    _, p = map(int, input().split())\n    times = list(map(int, input().split()))[p:] + list(map(int, input().split()))[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    _, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p] # rotate\n    max_solved = 0\n    total_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            total_penalty += t\n        else:\n            break\n    print(max_solved, total_penalty)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:25:51.738127 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# coding: utf-8\n\ndef main():\n    n, p = map(int, input().split())  # \u9078\u624b\u6570, \u5148\u982d\u306e\u9078\u624b\u756a\u53f7\n    times = list(map(int, input().split()))  # \u6642\u9593\n    times = times[p:] + times[:p]  # \u5148\u982d\u306e\u9078\u624b\u3092\u5148\u982d\u306b\u79fb\u52d5\n    max_solved = 0  # \u89e3\u3044\u305f\u554f\u984c\u6570\n    min_penalty = 0  # \u30da\u30ca\u30eb\u30c6\u30a3\n    remaining = 300  # \u6b8b\u308a\u6642\u9593\n    for t in times:  # \u5404\u9078\u624b\u306e\u6642\u9593\n        if remaining >= t:  # \u6b8b\u308a\u6642\u9593\u304c\u5341\u5206\u3042\u308b\u5834\u5408\n            remaining -= t  # \u6b8b\u308a\u6642\u9593\u304b\u3089\u89e3\u3044\u305f\u6642\u9593\u3092\u5f15\u304f\n            max_solved += 1  # \u89e3\u3044\u305f\u554f\u984c\u6570\u30921\u5897\u3084\u3059\n            min_penalty += t  # \u30da\u30ca\u30eb\u30c6\u30a3\u306b\u89e3\u3044\u305f\u6642\u9593\u3092\u52a0\u3048\u308b\n        else:  # \u6b8b\u308a\u6642\u9593\u304c\u8db3\u308a\u306a\u3044\u5834\u5408\n            break  # \u7d42\u4e86\n    print(max_solved, min_penalty)  # \u6700\u5927\u89e3\u3044\u305f\u554f\u984c\u6570\u3068\u30da\u30ca\u30eb\u30c6\u30a3\u3092\u51fa\u529b\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "# coding: utf-8\n\ndef main():\n    n, p = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    print(a)\n    print(b)\n    print(c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "# coding: utf-8\n\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809540,
  "object": "edit"
}
2022-04-13 00:25:51.738299 fix syntax errors 3 ['# coding: utf-8\n\ndef main():\n    n, p = map(int, input().split())  # 選手数, 先頭の選手番号\n    times = list(map(int, input().split()))  # 時間\n    times = times[p:] + times[:p]  # 先頭の選手を先頭に移動\n    max_solved = 0  # 解いた問題数\n    min_penalty = 0  # ペナルティ\n    remaining = 300  # 残り時間\n    for t in times:  # 各選手の時間\n        if remaining >= t:  # 残り時間が十分ある場合\n            remaining -= t  # 残り時間から解いた時間を引く\n            max_solved += 1  # 解いた問題数を1増やす\n            min_penalty += t  # ペナルティに解いた時間を加える\n        else:  # 残り時間が足りない場合\n            break  # 終了\n    print(max_solved, min_penalty)  # 最大解いた問題数とペナルティを出力\n\nif __name__ == "__main__":\n    main()\n', '# coding: utf-8\n\ndef main():\n    n, p = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    print(a)\n    print(b)\n    print(c)\n\nif __name__ == "__main__":\n    main()\n', '# coding: utf-8\n\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:25:59.359320 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n#\n# def main():\n#     n, p = map(int, input().split())\n#     times = list(map(int, input().split()))\n#     times = times[p:] + times[:p]\n#     max_solved = 0\n#     min_penalties = 0\n#     remaining = 300\n#     for t in times:\n#         if remaining >= t:\n#             remaining -= t\n#             max_solved += 1\n#             min_penalties += t\n#         else:\n#             break\n#     print(max_solved, min_penalties)\n#\n# if __name__ == \"__main__\":\n#     main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))[p:] + list(map(int, input().split()))[:p]\n    max_solved = 0\n    penalties = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            penalties += t\n        else:\n            break\n    print(max_solved, penalties)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809551,
  "object": "edit"
}
2022-04-13 00:25:59.359499 fix syntax errors 3 ['\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == "__main__":\n    main()\n', '\n#\n# def main():\n#     n, p = map(int, input().split())\n#     times = list(map(int, input().split()))\n#     times = times[p:] + times[:p]\n#     max_solved = 0\n#     min_penalties = 0\n#     remaining = 300\n#     for t in times:\n#         if remaining >= t:\n#             remaining -= t\n#             max_solved += 1\n#             min_penalties += t\n#         else:\n#             break\n#     print(max_solved, min_penalties)\n#\n# if __name__ == "__main__":\n#     main()\n', '\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))[p:] + list(map(int, input().split()))[:p]\n    max_solved = 0\n    penalties = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            penalties += t\n        else:\n            break\n    print(max_solved, penalties)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:25:59.359533 size on output set 8
2022-04-13 00:25:59.359545 num operations 2
2022-04-13 00:25:59.359549 size on input set 1
2022-04-13 00:26:05.184537 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        #print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809559,
  "object": "edit"
}
2022-04-13 00:26:05.184709 fix spelling mistakes 3 ["\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        #print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 00:26:05.184817 size on output set 3
2022-04-13 00:26:05.184824 size on input set 3
2022-04-13 00:26:10.699368 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom itertools import permutations\n\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809565,
  "object": "edit"
}
2022-04-13 00:26:10.699580 fix syntax errors 3 ["\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom itertools import permutations\n\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        ac_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            ac_count += 1\n        #print(ac_count)\n        if ac_count > num_AC:\n            num_AC = ac_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif ac_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 00:26:17.778616 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom itertools import permutations\n\n    problem_list = problem_list[:]\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "def solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = permutations(problem_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809570,
  "object": "edit"
}
2022-04-13 00:26:17.779925 fix syntax errors 3 ["\n\nfrom itertools import permutations\n\n    problem_list = problem_list[:]\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "def solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = permutations(problem_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 00:26:23.248756 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    # print(problem_list)\n    # print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    # print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        # print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    # print(problem_list)\n    # print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    # print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        # print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            # print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        # print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            # print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        #print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, first_problem = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, first_problem)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649809577,
  "object": "edit"
}
2022-04-13 00:26:23.249023 fix syntax errors 3 ["\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    # print(problem_list)\n    # print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    # print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        # print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    # print(problem_list)\n    # print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    # print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        # print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            # print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        # print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            # print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem)\n        #print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, first_problem = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, first_problem)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 00:26:23.249097 size on output set 9
2022-04-13 00:26:23.249116 num operations 2
2022-04-13 00:26:23.249122 size on input set 1
2022-04-13 00:26:29.102234 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"
    }
  ],
  "created": 1649809583,
  "object": "edit"
}
2022-04-13 00:26:29.102407 fix spelling mistakes 3 ['\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n', "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"]
2022-04-13 00:26:29.102509 size on output set 3
2022-04-13 00:26:29.102516 size on input set 3
2022-04-13 00:26:36.153234 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    N, p = map(int, input().split())\n    times = map(int, input().split())\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0 or times[i] + times[p] < best[1]:\n                best = [2, times[i] + times[p]]\n        else:\n            if best[0] == 0 or times[p] < best[1]:\n                best = [1, times[p]]\n\n    print(*best)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n"
    }
  ],
  "created": 1649809589,
  "object": "edit"
}
2022-04-13 00:26:36.153474 fix syntax errors 3 ['\nimport sys\n\ndef main():\n    N, p = map(int, input().split())\n    times = map(int, input().split())\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0 or times[i] + times[p] < best[1]:\n                best = [2, times[i] + times[p]]\n        else:\n            if best[0] == 0 or times[p] < best[1]:\n                best = [1, times[p]]\n\n    print(*best)\n\nmain()\n', 'import sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n\n        if times[i] + times[p] < 300:\n\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n']
2022-04-13 00:26:43.276454 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    N, M, K = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(N):\n        grid.append(list(map(int, sys.stdin.readline().split())))\n    print(grid)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n"
    }
  ],
  "created": 1649809596,
  "object": "edit"
}
2022-04-13 00:26:43.276624 fix syntax errors 3 ['\n\nimport sys\n\ndef main():\n    N, M, K = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(N):\n        grid.append(list(map(int, sys.stdin.readline().split())))\n    print(grid)\n\nmain()\n', '\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n', '#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n']
2022-04-13 00:26:45.491756 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"
    }
  ],
  "created": 1649809603,
  "object": "edit"
}
2022-04-13 00:26:45.492141 fix syntax errors 3 ["\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n", "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n", "\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n"]
2022-04-13 00:26:45.492193 size on output set 7
2022-04-13 00:26:45.492206 num operations 2
2022-04-13 00:26:45.492212 size on input set 1
2022-04-13 00:26:52.082745 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_estimates):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809605,
  "object": "edit"
}
2022-04-13 00:26:52.082958 fix spelling mistakes 3 ['\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_estimates):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:26:52.083098 size on output set 3
2022-04-13 00:26:52.083107 size on input set 3
2022-04-13 00:26:54.957996 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809612,
  "object": "edit"
}
2022-04-13 00:26:54.958196 fix syntax errors 3 ['\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time initially\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:26:58.339517 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809615,
  "object": "edit"
}
2022-04-13 00:26:58.339703 fix syntax errors 3 ['\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems in the problem set\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:27:01.059024 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_estimates):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_estimates):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_estimates):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809618,
  "object": "edit"
}
2022-04-13 00:27:01.059220 fix syntax errors 3 ['\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_estimates):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_estimates):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    """\n    This function is the main entry point of the program.\n    """\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_estimates = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_estimates)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_estimates):\n    """\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    """\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_estimates[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_estimates[problem]\n                penalty_time += time_estimates[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_estimates[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_estimates[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:27:01.059345 size on output set 6
2022-04-13 00:27:01.059371 num operations 2
2022-04-13 00:27:01.059377 size on input set 1
2022-04-13 00:27:19.223043 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_right = times[:p] + times[p+1:]\n        times_right.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    first_problem_time = times[p]\n    times = times[:p] + times[p+1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809621,
  "object": "edit"
}
2022-04-13 00:27:19.223239 fix spelling mistakes 3 ['\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_right = times[:p] + times[p+1:]\n        times_right.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    first_problem_time = times[p]\n    times = times[:p] + times[p+1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:27:19.223374 size on output set 3
2022-04-13 00:27:19.223381 size on input set 3
2022-04-13 00:27:23.968967 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809639,
  "object": "edit"
}
2022-04-13 00:27:23.969184 fix syntax errors 3 ['\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:27:36.457872 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p-1] + times[p:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    max_num_ac, max_penalty_time = 0, 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        times_left = times[:p] + times[p+1:] # Exclude time of the first problem\n        times_left.sort() # Sort times from small to large\n        for j in range(n-1): # Exclude time of the first problem\n            if i & (1 << j): # If j-th bit of i is 1\n                penalty_time += times_left[j] # Add the time to the penalty time\n                times_left[j] = 0 # Set the time to 0\n        for time in times_left: # Check if the remaining problems can be solved\n            if time <= 300 - penalty_time: # If the problem can be solved\n                penalty_time += time # Add the time to the penalty time\n                num_ac += 1 # The number of solved problems increases by one\n        penalty_time += times[p] # Add the time of the first problem to the penalty time\n        if num_ac > max_num_ac or (num_ac == max_num_ac and penalty_time < max_penalty_time):\n            max_num_ac = num_ac\n            max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2 ** (n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n - 1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809644,
  "object": "edit"
}
2022-04-13 00:27:36.458086 fix syntax errors 3 ['\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p-1] + times[p:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    max_num_ac, max_penalty_time = 0, 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        times_left = times[:p] + times[p+1:] # Exclude time of the first problem\n        times_left.sort() # Sort times from small to large\n        for j in range(n-1): # Exclude time of the first problem\n            if i & (1 << j): # If j-th bit of i is 1\n                penalty_time += times_left[j] # Add the time to the penalty time\n                times_left[j] = 0 # Set the time to 0\n        for time in times_left: # Check if the remaining problems can be solved\n            if time <= 300 - penalty_time: # If the problem can be solved\n                penalty_time += time # Add the time to the penalty time\n                num_ac += 1 # The number of solved problems increases by one\n        penalty_time += times[p] # Add the time of the first problem to the penalty time\n        if num_ac > max_num_ac or (num_ac == max_num_ac and penalty_time < max_penalty_time):\n            max_num_ac = num_ac\n            max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2 ** (n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n - 1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:27:43.612769 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    first_problem_time = times[p]\n    times = times[:p] + times[p + 1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(float, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    first_problem_time = times[p]\n    times = times[:p] + times[p + 1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    if first_problem_time < 300:\n        num_ac += 1\n        penalty_time += first_problem_time\n        while times:\n            num_ac += 1\n            penalty_time += times[0]\n            times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times_left = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times_left)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times_left):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    first_problem_time = times_left[p]\n    times_left = times_left[:p] + times_left[p+1:]\n    times_left.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times_left:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649809656,
  "object": "edit"
}
2022-04-13 00:27:43.612953 fix syntax errors 3 ['\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    first_problem_time = times[p]\n    times = times[:p] + times[p + 1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times = list(map(float, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    """\n    Solve problem\n    """\n    first_problem_time = times[p]\n    times = times[:p] + times[p + 1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    if first_problem_time < 300:\n        num_ac += 1\n        penalty_time += first_problem_time\n        while times:\n            num_ac += 1\n            penalty_time += times[0]\n            times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    """\n    1. Read input\n    2. Solve problem\n    3. Output result\n    """\n    n, p = map(int, input().split())\n    times_left = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times_left)\n    print("{} {}".format(num_ac, penalty_time))\n\ndef solve(n, p, times_left):\n    """\n    Solve problem\n    """\n    first_problem_time = times_left[p]\n    times_left = times_left[:p] + times_left[p+1:]\n    times_left.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times_left:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 00:27:43.613078 size on output set 8
