["\n\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second\n    # problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, p = [int(x) for x in input().split()]\n    time = [int(x) for x in input().split()]\n    time.sort()\n    if time[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if time[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(time[:ans]))\n\nmain()", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)", "\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved = 0\n    min_penalty = 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    #print(problem_list)\n    #print(first_problem_index)\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    #print(permutations_list)\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        #print(permutation)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            #print(time_elapsed)\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        #print(AC_count)\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    # print(N, p)\n    # print(times)\n    # print('')\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        # print('i:', i)\n        # print('times[i]:', times[i])\n        # print('times[p]:', times[p])\n        # print('times[i] + times[p]:', times[i] + times[p])\n        # print('times[i] + times[p] < 300:', times[i] + times[p] < 300)\n        if times[i] + times[p] < 300:\n            # print('best[0]:', best[0])\n            # print('best[1]:', best[1])\n            # print('times[i]:', times[i])\n            # print('times[p]:', times[p])\n            # print('times[i] + times[p]:', times[i] + times[p])\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print num_ac, penalty_time\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time\n    remaining_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    # first_problem_time = times[p]\n    # times = times[:p] + times[p+1:]\n    # times.sort()\n    # num_ac = 0\n    # penalty_time = 0\n    # while times:\n    #     num_ac += 1\n    #     penalty_time += times[0]\n    #     times = times[1:]\n    # return num_ac, penalty_time + first_problem_time\n\n    max_time = 300\n    max_num_ac = 0\n    max_penalty_time = 0\n    for i in range(2**(n-1)):\n        num_ac = 0\n        penalty_time = 0\n        first_problem_time = times[p]\n        times_left = times[:p] + times[p+1:]\n        times_left.sort()\n        for j in range(n-1):\n            if i & (1 << j):\n                penalty_time += times_left[j]\n                times_left[j] = 0\n        for time in times_left:\n            if time <= max_time - penalty_time:\n                max_time -= penalty_time\n                penalty_time += time\n                num_ac += 1\n        penalty_time += first_problem_time\n        if penalty_time <= max_time:\n            if num_ac > max_num_ac:\n                max_num_ac = num_ac\n                max_penalty_time = penalty_time\n            elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n                max_penalty_time = penalty_time\n    return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()"]