["\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at the earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time (in ascending order)\n    heapq.heapify(trees, reverse=True)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized\n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    num_sticks = int(sys.stdin.readline().strip())\n    stick_lengths = [int(x) for x in sys.stdin.readline().strip().split()]\n    stick_lengths.sort()\n    max_time = stick_lengths[-1]\n    for i in range(len(stick_lengths)-2,-1,-1):\n        max_time += 1 + stick_lengths[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\"\"\"\nThis is a test file\n\"\"\"\nimport sys\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    trees = [int(x) for x in sys.stdin.readline().strip().split()]\n    count = 0\n    while n > 0:\n        n -= 1\n        count += trees[n]\n\n    print(count)\n", "\nimport sys\n\ndef main():\n    num_soldiers = int(sys.stdin.readline().strip())\n    soldier_growth_times = [int(x) for x in sys.stdin.readline().strip().split()]\n    soldier_growth_times.sort()\n    max_time = soldier_growth_times[-1]\n    for i in range(len(soldier_growth_times) - 2, -1, -1):\n        max_time += 1 + soldier_growth_times[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport math\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline())\n    while n > 0:\n        n -= 1\n        x = int(sys.stdin.readline())\n        if x > 0:\n            print(math.floor(math.log(x, 2)) + 1)\n        else:\n            print(0)\n", "\n\nimport sys\n\n\ndef main(n):\n    trees = [int(x) for x in sys.stdin.readline().split()]\n    trees.sort()\n    if n == 1:\n        print(trees[0])\n    else:\n        max_days = 0\n        for i in range(n):\n            max_days = max(max_days, trees[i] + n - i)\n        print(max_days)\n\n\ndef main2(n):\n    trees = [int(x) for x in sys.stdin.readline().split()]\n    trees.sort()\n    max_days = 0\n    for i in range(n):\n        max_days = max(max_days, trees[i] + n - i)\n    print(max_days)\n\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    main2(n)\n", "\n\nimport sys\n\nif __name__ == \"__main__\":\n    print(\"Hello World\")\n", "\n\nn = int(input())\ns = list(map(int, input().split()))\n\n# sort sticks by length\ns.sort()\n\n# find the shortest stick\nshortest = s[0]\nfor i in range(n):\n    if s[i] < shortest:\n        shortest = s[i]\n\n# print the number of sticks that are longer than the shortest stick\nprint(len([x for x in s if x > shortest]))\n", "import sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  trees = [int(x) for x in sys.stdin.readline().split()]\n  trees.sort()\n  if n == 1:\n    print(trees[0])\n  else:\n    max_days = 0\n    for i in range(n):\n      max_days = max(max_days, trees[i] + n - i - 1)\n    print(max_days)\n\nif __name__ == '__main__':\n  main()\n", "import sys\n\ndef main():\n    num_segments = int(sys.stdin.readline().strip())\n    segment_lengths = [int(x) for x in sys.stdin.readline().strip().split()]\n    segment_lengths.sort()\n    max_time = segment_lengths[-1]\n    for i in range(len(segment_lengths)-2,-1,-1):\n        max_time += 1 + segment_lengths[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    t.sort()\n    print(sum(t[i]*(n-i) for i in range(n))) \n\nmain()\n", "\nimport sys\n# Solution \n\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nmax = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] = max + t[i]\n\n\n# Solution 2\n\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nmax = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] = max + t[i]\n\nprint(t[-1] + 1)\nprint(t[-1] + 1)\n", "\nn = int(input())\nt = list(map(int, input().split()))\nt.sort()\nmax = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] = max + t[i]\nprint(t[-1] + 1)\n", "\nn = int(input())\nt = list(map(int, input().split()))\n\n# sort trees by time required for them to grow (ascending)\nt.sort()\n\n# find the earliest day when the party can be organized\nday = 0\nfor i in range(n):\n    if t[i] < day:\n        day += 1\n    else:\n        day += t[i]\n\nprint(day)\n", "\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at the earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized\n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each\n     tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time (min heap)\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the\n    # last tree has grown so we need to keep track of the last day that a tree\n    # will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized \n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport heapq\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = map(int, sys.stdin.readline().split())\n    heap = []\n    for i in days:\n        heapq.heappush(heap, i)\n    time = 0\n    while heap:\n        time += heapq.heappop(heap)\n        if heap:\n            time += 1\n    print(time)\n\nif __name__ == \"__main__\":\n    main()\n", "#\n# import sys\n#\n# def main():\n#     n = int(sys.stdin.readline())\n#     t = list(map(int, sys.stdin.readline().split()))\n#     t.sort()\n#     print(sum(t[i]*(n-i) for i in range(n))) # t[i]*(n-i) is the waiting time for the ith customer\n#\n# main()\n\n\nimport math\n\ndef is_prime(x):\n    if x < 2:\n        return False\n    else:\n        for i in range(2, int(math.sqrt(x))+1):\n            if x % i == 0:\n                return False\n        return True\n\nprint(is_prime(1))\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport getopt\nimport re\nimport codecs\n\n\ndef main(argv):\n    inputfile = ''\n    outputfile = ''\n    try:\n        opts, args = getopt.getopt(argv, \"hi:o:\", [\"ifile=\", \"ofile=\"])\n    except getopt.GetoptError:\n        print('test.py -i <inputfile> -o <outputfile>')\n        sys.exit(2)\n    for opt, arg in opts:\n        if opt == '-h':\n            print('test.py -i <inputfile> -o <outputfile>')\n            sys.exit()\n        elif opt in (\"-i\", \"--ifile\"):\n            inputfile = arg\n        elif opt in (\"-o\", \"--ofile\"):\n            outputfile = arg\n    print('Input file is ', inputfile)\n    print('Output file is ', outputfile)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n", "\n\n# Solution\n\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nmaximum = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] = max + t[i]\n\nprint(t[-1] + 1)\n", "\n\nn = int(input())\nt = list(map(int, input().split()))\n\n# sort trees by time required for them to grow\nt.sort()\n\n# find the earliest day when the party can be organized\nday = 0\nfor i in range(n):\n    if t[i] < day:\n        day += 1\n    else:\n        day += t[i]\n\nprint(day)\n", "\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nday = 0\nfor i in range(n):\n    if t[i] < day:\n        day += 1\n    else:\n        day += t[i]\n\nprint(day)\n", "\nn = int(input())\nt = list(map(int, input().split()))\n\n# sort trees by time required for them to grow\nt.sort()\n\n# find the earliest day when the party can be organized\nday = 0\nfor i in range(n):\n    if t[i] < day:\n        day += 1\n    else:\n        day += t[i]\n\nprint(day)\n", "\n\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time (min heap)\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized \n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day + 1\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    with open('in.txt', 'r') as f:\n        n = int(f.readline())\n        if n == 1:\n            print(int(f.readline()))\n        else:\n            trees = [int(x) for x in f.readline().split()]\n            trees.sort()\n            max_days = 0\n            for i in range(n):\n                max_days = max(max_days, trees[i] + n - i)\n            print(max_days)\n\n\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nn = int(input())\nt = list(map(int, input().split()))\n\n# sort trees by time required for them to grow\nt.sort()\n\n# find the earliest day when the party can be organized\nday = 0\nfor i in range(n):\n    day += max(t[i], day)\n\nprint(day)\n", "\nimport sys\n\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at the earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized\n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    t.sort()\n    print(sum(t[i] * (n - i) for i in range(n)))\n\nmain()\n", "# Solution\n\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nmax = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] = max + t[i]\n\nprint(t[-1] + 1)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys, getopt\nimport re\nimport codecs\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport heapq\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = map(int, sys.stdin.readline().split())\n    heap = []\n    for i in days:\n        heapq.heappush(heap, i)\n    time = 0\n    while heap:\n        time += heapq.heappop(heap)\n        if heap:\n            time += 1\n    print time\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time (min heap)\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized \n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    num_soldiers = int(sys.stdin.readline().strip()) # read the number of soldiers\n    soldier_growth_times = [int(x) for x in sys.stdin.readline().strip().split()] # read the time it takes for each soldier to grow\n    soldier_growth_times.sort() # sort the soldier growth times\n    max_time = soldier_growth_times[-1] # the maximum time will be the time of the last soldier\n    for i in range(len(soldier_growth_times)-2,-1,-1): # for each soldier before the last one\n        max_time += 1 + soldier_growth_times[i] # add one to the maximum time and then add the time it takes for that soldier to grow\n    print(max_time) # print the maximum time\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    trees = [int(x) for x in sys.stdin.readline().split()]\n    trees.sort()\n    if n == 1:\n        print(trees[0])\n    else:\n        max_days = 0\n        for i in range(n):\n            max_days = max(max_days, trees[i] + n - i)\n        print(max_days)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    trees = [int(x) for x in sys.stdin.readline().strip().split(' ')]\n    count = 0\n    while n > 0:\n        n -= 1\n        count += trees[n]\n    print(count)\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    t.sort()\n    print(sum(t[i]*(n-i) for i in range(n)))\n\nmain()\n", "\nimport sys\nimport heapq\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = list(map(int, sys.stdin.readline().split()))\n    heap = []\n    for i in days:\n        heapq.heappush(heap, i)\n    time = 0\n    while heap:\n        time += heapq.heappop(heap)\n        if heap:\n            time += 1\n    print(time)\n\nif __name__ == \"__main__\":\n    main()\n", "\n# TODO: fix algorithm - it doesn't work for some inputs.\n\nn = int(input())\nt = list(map(int, input().split()))\n\n# find the earliest day when the party can be organized\nday = 0\nfor i in range(n):\n    if t[i] < day:\n        day += 1\n    else:\n        day += t[i]\n\nprint(day)\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    trees = [int(x) for x in sys.stdin.readline().split()]\n    trees.sort()\n    if n == 1:\n        print(trees[0])\n    else:\n        max_days = 0\n        for i in range(n):\n            max_days = max(max_days, trees[i] + n - i - 1)\n        print(max_days)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    num_sticks = int(sys.stdin.readline().strip())\n    stick_lengths = [int(x) for x in sys.stdin.readline().strip().split()]\n    stick_lengths.sort()\n    max_time = stick_lengths[-1]\n    for i in range(len(stick_lengths)-2, -1, -1):\n        max_time += stick_lengths[i] + 1\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    trees = [int(x) for x in sys.stdin.readline().strip().split()]\n    count = 0.0\n    while n > 0:\n        n -= 1\n        count += trees[n]\n\n    print(count)\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    t.sort()\n    print(sum(t[i]*(n-i) for i in range(n))\n\nmain()\n", "#!/usr/bin/python\n\nimport sys\n\ndef main():\n    num_segments = int(sys.stdin.readline().strip())\n    segment_lengths = [int(x) for x in sys.stdin.readline().strip().split()]\n    segment_lengths.sort()\n    max_time = segment_lengths[-1]\n    for i in range(len(segment_lengths)-2,-1,-1):\n        max_time += 1 + segment_lengths[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    t.sort()\n    print(sum(t[i]*(n-i) for i in range(n))) \n\nmain()\n", "\nimport sys\nimport heapq\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = map(int, sys.stdin.readline().split())\n    heap = []\n    for i in days:\n        heapq.heappush(heap, i)\n    time = 0\n    while heap:\n        time += heapq.heappop(heap)\n        if heap:\n            time += 1\n    print(time)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    num_cases = int(sys.stdin.readline().strip())\n    for case in range(num_cases):\n        num_sticks = int(sys.stdin.readline().strip())\n        stick_lengths = [int(x) for x in sys.stdin.readline().strip().split()]\n        stick_lengths.sort()\n        max_time = stick_lengths[-1]\n        for i in range(len(stick_lengths)-2,-1,-1):\n            max_time += 1 + stick_lengths[i]\n        print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "\ntrees = int(input())\ndays = list(map(int, input().split()))\ndays.sort()\ntime = 0\nfor i in range(trees):\n    if days[i] < time:\n        time += 1\n    else:\n        time += days[i]\nprint(time)\n", "\nimport sys\n\ndef main():\n    num_segments = int(sys.stdin.readline().strip())\n    segment_lengths = [int(x) for x in sys.stdin.readline().strip().split()]\n    segment_lengths.sort()\n    max_time = segment_lengths[-1]\n    for i in range(len(segment_lengths) - 2, -1, -1):\n        max_time += 1 + segment_lengths[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python\n\nimport sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  trees = [int(x) for x in sys.stdin.readline().split()]\n  trees.sort()\n  if n == 1:\n    print(trees[0])\n  else:\n    max_days = 0\n    for i in range(n):\n      max_days = max(max_days, trees[i] + n - i - 1)\n    print(max_days)\n\nif __name__ == '__main__':\n  main()\n", "\nimport sys\n\n\ndef main(n):\n    trees = [int(x) for x in input().split()]\n    trees.sort()\n    if n == 1:\n        print(trees[0])\n    else:\n        max_days = 0\n        for i in range(n):\n            max_days = max(max_days, trees[i] + n - i)\n        print(max_days)\n\n\ndef main2(n):\n    trees = [int(x) for x in input().split()]\n    trees.sort()\n    max_days = 0\n    for i in range(n):\n        max_days = max(max_days, trees[i] + n - i)\n    print(max_days)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    main(n)\n", "\nimport os\nimport sys, getopt\nimport re\nimport codecs\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\nif __name__ == \"__main__\":\n    pass\n", "import sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  trees = [int(x) for x in sys.stdin.readline().split()] # list comprehension\n  trees.sort()\n  if n == 1:\n    print(trees[0])\n  else:\n    max_days = 0\n    for i in range(n):\n      max_days = max(max_days, trees[i] + n - i) # max(max_days, trees[i] + n - i)\n    print(max_days)\n\nif __name__ == '__main__':\n  main()\n", "\nimport sys\n\ndef main():\n    num_soldiers = int(sys.stdin.readline().strip())\n    soldier_growth_times = [int(x) for x in sys.stdin.readline().strip().split()]\n    soldier_growth_times.sort()\n    max_time = soldier_growth_times[-1]\n    for i in range(len(soldier_growth_times)-2, -1, -1):\n        max_time += 1 + soldier_growth_times[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()\n", "\n#\n# Solution\n\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nmax = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] += max\n\nprint(t[-1] + 1)\n", "\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time in ascending order\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant and 0 days to grow\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized\n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()\n"]