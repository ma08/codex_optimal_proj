["\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles in the\n# permutation. The cycle length is the number of days it takes for a book to\n# return to its owner. We can use the union-find structure to quickly find the\n# cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations and\n# each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\ndef check_cycle(index, permutation, visited):\n    \"\"\"\n    Checks if there is a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    if visited[index] == 1:\n        return 0\n    visited[index] = 1\n    return check_cycle(permutation[index] - 1, permutation, visited)\n\ndef find_cycle_length(index, permutation, visited):\n    \"\"\"\n    Finds the length of a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    return 1 + find_cycle_length(permutation[index] - 1, permutation, visited)\n\ndef solve_cycle(index, permutation, visited):\n    \"\"\"\n    Solves a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    return solve_cycle(permutation[index] - 1, permutation, visited)\n\ndef solve_query(n, permutation):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    visited = [0] * n\n    for i in range(n):\n        if permutation[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, permutation, visited))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        permutation = list(map(int, input().split()))\n        res = solve_query(n, permutation)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(index, permutation):\n    \"\"\"\n    Checks if there is a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    if permutation[index] < 0:\n        return 0\n    permutation[index] = -2\n    return check_cycle(permutation[index] - 1, permutation)\n\ndef find_cycle_length(index, permutation):\n    \"\"\"\n    Finds the length of a cycle starting from index index.\n    \"\"\"\n    if permutation[index] == index + 1:\n        return 1\n    return 1 + find_cycle_length(permutation[index] - 1, permutation)\n\ndef solve_cycle(index, permutation):\n    \"\"\"\n    Solves a cycle starting from index index.\n    \"\"\"\n    if permutation[index] == index + 1:\n        return 1\n    return solve_cycle(permutation[index] - 1, permutation)\n\ndef solve_query(n, permutation):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if permutation[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, permutation))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        permutation = list(map(int, input().split()))\n        res = solve_query(n, permutation)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] < 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    length = 1\n    while i != p[i] - 1:\n        length += 1\n        i = p[i] - 1\n    return length\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    length = find_cycle_length(i, p)\n    if length % 2 == 0:\n        return 0\n    return 1\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query. \n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p) + 1\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query. \n    \"\"\"\n    res = [0] * n\n    for i in range(n): res[i] = solve_cycle(i, p)\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve():\n    pass\n\n\nif __name__ == \"__main__\":\n    solve()\n", "#!/usr/bin/env python3\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles in the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations and\n# each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\n# SOLUTION\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\ndef check_cycle(i, p, visited):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if visited[i]:\n        return 0\n    visited[i] = True\n    return check_cycle(p[i] - 1, p, visited)\n\ndef find_cycle_length(i, p, visited, length):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if visited[i]:\n        return length[i]\n    visited[i] = True\n    length[i] = 1 + find_cycle_length(p[i] - 1, p, visited, length)\n    return length[i]\n\ndef solve_cycle(i, p, visited, length):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if visited[i]:\n        return length[i]\n    visited[i] = True\n    length[i] = 1 + solve_cycle(p[i] - 1, p, visited, length)\n    return length[i]\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    visited = [False] * n\n    length = [0] * n\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p, visited, length))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    with open('file.in', 'r') as fin:\n        with open('file.out', 'w') as fout:\n            q = int(fin.readline())\n            for _ in range(q):\n                n = int(fin.readline())\n                p = list(map(int, fin.readline().split()))\n                res = solve_query(n, p)\n                fout.write(' '.join(map(str, res)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1: # base case\n        return 1\n    if p[i] > 0: # already visited\n        return 0\n    p[i] = -2 # mark as visited\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1: # base case\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1: # base case\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1: # base case\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input()) # number of queries\n    for _ in range(q):\n        n = int(input()) # number of elements\n        p = list(map(int, input().split())) # permutation\n        res = solve_query(n, p) # solve query\n        print(*res) # print result\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# SOLUTION 1\n# The idea is to use a union-find structure to keep track of the cycles of the permutations.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id  # swap\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = (self.size[i_id] * self.cycle[j_id] + self.size[j_id] * self.cycle[i_id]) // (self.size[i_id] + self.size[j_id])\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print(\"\")\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "#!/usr/bin/env python3\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutations.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))  # list of parents\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\ndef check_cycle(index, permutation):\n    \"\"\"\n    Checks if there is a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    if permutation[index] < 0:\n        return 0\n    permutation[index] = -permutation[index]\n    return check_cycle(permutation[index] - 1, permutation)\n\ndef find_cycle_length(index, permutation):\n    \"\"\"\n    Finds the length of a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    return 1 + find_cycle_length(permutation[index] - 1, permutation)\n\ndef solve_cycle(index, permutation):\n    \"\"\"\n    Solves a cycle starting from index index.\n    \"\"\"\n    if index == permutation[index] - 1:\n        return 1\n    return solve_cycle(permutation[index] - 1, permutation)\n\ndef solve_query(n, permutation):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if permutation[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, permutation))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        permutation = list(map(int, input().split()))\n        res = solve_query(n, permutation)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n"]