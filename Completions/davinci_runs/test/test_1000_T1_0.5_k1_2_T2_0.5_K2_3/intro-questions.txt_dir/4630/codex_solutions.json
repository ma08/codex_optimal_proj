["\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()"]