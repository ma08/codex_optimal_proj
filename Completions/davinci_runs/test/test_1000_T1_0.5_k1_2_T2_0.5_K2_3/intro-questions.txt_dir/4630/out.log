2022-04-09 21:12:12.638527 """
The only difference between easy and hard versions is constraints.

There are $n$ kids, each of them is reading a unique book. At the end of any day, the $i$-th kid will give his book to the $p_i$-th kid (in case of $i = p_i$ the kid will give his book to himself). It is guaranteed that all values of $p_i$ are distinct integers from $1$ to $n$ (i.e. $p$ is a permutation). The sequence $p$ doesn't change from day to day, it is fixed.

For example, if $n=6$ and $p=[4, 6, 1, 3, 5, 2]$ then at the end of the first day the book of the $1$-st kid will belong to the $4$-th kid, the $2$-nd kid will belong to the $6$-th kid and so on. At the end of the second day the book of the $1$-st kid will belong to the $3$-th kid, the $2$-nd kid will belong to the $2$-th kid and so on.

Your task is to determine the number of the day the book of the $i$-th child is returned back to him for the first time for every $i$ from $1$ to $n$.

Consider the following example: $p = [5, 1, 2, 4, 3]$. The book of the $1$-st kid will be passed to the following kids:  after the $1$-st day it will belong to the $5$-th kid,  after the $2$-nd day it will belong to the $3$-rd kid,  after the $3$-rd day it will belong to the $2$-nd kid,  after the $4$-th day it will belong to the $1$-st kid. 

So after the fourth day, the book of the first kid will return to its owner. The book of the fourth kid will return to him for the first time after exactly one day.

You have to answer $q$ independent queries.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 1000$) — the number of queries. Then $q$ queries follow.

The first line of the query contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of kids in the query. The second line of the query contains $n$ integers $p_1, p_2, \dots, p_n$ ($1 \le p_i \le n$, all $p_i$ are distinct, i.e. $p$ is a permutation), where $p_i$ is the kid which will get the book of the $i$-th kid.

It is guaranteed that $\sum n \le 2 \cdot 10^5$ (sum of $n$ over all queries does not exceed $2 \cdot 10^5$).


-----Output-----

For each query, print the answer on it: $n$ integers $a_1, a_2, \dots, a_n$, where $a_i$ is the number of the day the book of the $i$-th child is returned back to him for the first time in this query.


-----Example-----
Input
6
5
1 2 3 4 5
3
2 3 1
6
4 6 2 1 5 3
1
1
4
3 4 1 2
5
5 1 2 4 3

Output
1 1 1 1 1 
3 3 3 
2 3 3 2 1 3 
1 
2 2 2 2 
4 4 4 1 4
"""
2022-04-09 21:12:12.638575 --------------------------
2022-04-09 21:12:42.713923 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()"
    }
  ],
  "created": 1649553133,
  "id": "cmpl-4vGPdclqx38IadRk4pNFuAs3tLaRy",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 21:12:42.714193 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 21:12:42.714243 REASON stop
2022-04-09 21:12:42.715504 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()"
}
2022-04-09 21:12:42.715652 REASON stop
