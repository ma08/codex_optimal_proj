["n=int(input())\nF = [int(input().replace(\" \",\"\"),2) for _ in range(n)]\nP = [list(map(int,input().split())) for _ in range(n)]\n\ntotal = -10**9\nfor i in range(1,2**10):\n    pgain = 0\n    for f,p in zip(F,P):\n        pgain += p[bin(f&i).count(\"1\")]\n    if total < pgain:\n        total = pgain\n        k = i\nprint(total)", "n = int(input())\nf = []\nans = -10**9\n\nfor i in range(n):\n    a = input().split()\n    f.append(a)\n\np = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(1, 2**10):\n    ref = 0\n    i = str(bin(i))[2:].zfill(10)\n    for j in range(n):\n        cnt = 0\n        for k in range(10):\n            if i[k] == f[j][k] == \"1\":\n                cnt += 1\n        ref += p[j][cnt]\n    else:\n        ans = max(ans, ref)\n\nprint(ans)", "N = int(input())\n\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\nans = -float('inf')\nfor i in range(1,1 << 10):\n    g = [0] * N\n    for j in range(10):\n        if i >> j & 1:\n            for k in range(N):\n                g[k] += F[k][j]\n    sub = 0\n    for i in range(N):\n        sub += P[i][g[i]]\n    ans = max(ans, sub)\nprint(ans)", "import numpy as np\nimport heapq as hq\nN = int(input())\nF = np.array([[int(x) for x in input().split()] for _ in range(N)])\nP = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nProfit = []\nfor i in range(1,2**10): #bit\u5168\u63a2\u7d22\n    Open = np.array([int(x) for x in format(i, '010b')]) #2\u9032\u6570\u3092\u30d9\u30af\u30c8\u30eb\u306b\u5909\u63db\n    prf = 0\n    for f, p in zip(F, P):\n        cnt = np.dot(Open, f)\n        prf += p[cnt]\n    hq.heappush(Profit, -prf)\nprint((-Profit[0]))\n", "N = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\nans = -10**10\n\nfor a in range(2**10):\n    t = [(a>>b)&1 for b in range(10)]\n    if 1 not in t:\n        continue\n    \n    p = 0\n    for i in range(N):\n        p += P[i][sum(t[j] and F[i][j] for j in range(10))]\n\n    ans = max(p, ans)\n\nprint(ans)", "n = int(input())\nf = [list(map(int, input().split())) for i in range(n)]\np = [list(map(int, input().split())) for i in range(n)]\nans = -float(\"inf\")\nfor i in range(1, 2**10):\n    tf = [False]*10\n    for j in range(10):\n        if (i>>j)&1:\n            tf[j] = True\n    cnt1 = 0\n    for j in range(n):\n        cnt2 = 0\n        for k in range(10):\n            if tf[k] and f[j][k]:\n                cnt2 += 1\n        cnt1 += p[j][cnt2]\n    ans = max(ans, cnt1)\nprint(ans)", "import sys\nmod=10**9+7 ; inf=float(\"inf\")\nfrom math import sqrt, ceil\nfrom collections import deque, Counter, defaultdict #\u3059\u3079\u3066\u306ekey\u304c\u7528\u610f\u3055\u308c\u3066\u308b defaultdict(int)\u3067\u521d\u671f\u5316\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright\n#\u30e1\u30e2\u5316\u518d\u5e30def\u306e\u5192\u982d\u306b\u6bce\u56de @lru_cache(maxsize=10**10)\n#\u5f15\u6570\u306blist\u306f\u3060\u3081\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\n\nn=int(input());ans=-inf\nF=[] ;P=[]\nfor i in range(n):\n    F.append(list(map(int,input().split())))\nfor i in range(n):\n    P.append(list(map(int,input().split())))\n\nfor bit in range(1,1<<10):\n    L=[(bit>>i)&1 for i in range(10)]\n    now=0\n    for i in range(n):\n        cnt=0\n        for cc in range(10):\n            if (F[i][cc]==1 and L[cc]==1) : cnt+=1\n        now+=P[i][cnt]\n    ans=max(ans,now)\nprint(ans)\n", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nn = INT()\nf = []\nfor i in range(n):\n    f.append(LIST())\np = []\nfor i in range(n):\n    p.append(LIST())\n\nans = -inf\nfor x in product([0, 1], repeat=10):\n    if sum(x) != 0:\n        tmp = 0\n        for j in range(n):\n            count = 0\n            for k in range(10):\n                count += f[j][k]*x[k]\n            tmp += p[j][count]\n        ans = max(ans, tmp)\nprint(ans)", "def dfs(s,N):\n    if len(s)==10:\n        if \"1\" in s:\n            cal(s,N)\n        return\n    dfs(s+\"0\",N)\n    dfs(s+\"1\",N)\n\ndef cal(s,N):\n    p = 0\n    for i in range(N):\n        c=0\n        for j in range(10):\n            c+=F[i][j]*int(s[j])\n        p+=P[i][c]\n    profit.append(p)\n    return\n\nN = int(input())\nF=[list(map(int,input().split())) for _ in range(N)]\nP=[list(map(int,input().split())) for _ in range(N)]\nprofit=[]\n\ndfs(\"\",N)\nprint(max(profit))", "n = int(input())\n\nL,score = [],[]\nfor i in range(n):\n    L.append(list(map(int,input().split())))\n    \nfor i in range(n):\n    score.append(list(map(int,input().split())))\n\nans = -10**32\n \nfor k in range(1,1<<10):\n    sc = 0\n    \n    for i in range(n):\n        cnt = 0\n        for j in range(10):\n            if L[i][j] and k>>j&1:\n                cnt +=1\n        #print(L[i],v,cnt,i,score,score[i][cnt])\n        sc += score[i][cnt]\n            #print(L[i],v,cnt,i,score,score[i][cnt])\n    ans = max(ans,sc)\n\nprint(ans)", "#coding: utf-8\nfrom collections import deque\n\nN = int(input())\nF = []\nfor i in range(N):\n    F.append([int(x) for x in input().split()])\n\nP = []\nfor i in range(N):\n    P.append([int(x) for x in input().split()])\n\nret = None\nfor bit in range(1, 2**10):\n    nWork = [0] * N\n    for i in range(10):\n        if (bit >> i) & 1:\n            for shop in range(N):\n                if F[shop][i] == 1:\n                    nWork[shop] += 1\n\n    cand = 0\n    for i in range(N):\n        cand += P[i][nWork[i]]\n    if ret == None or cand > ret:\n        ret = cand\nprint(ret)\n\n", "N=int(input())\nF=[list(map(int,input().split()))for _ in range(N)]\nP=[list(map(int,input().split()))for _ in range(N)]\n\nans=-10**9\nfor i in range(2**10-1):\n    Bit=[1]*10\n    for j in range(10):\n        if (i>>j)&1:\n            Bit[j]=0\n    count=0\n    for k in range(N):\n        op=sum(b&f for b,f in zip(Bit,F[k]))\n        count+=P[k][op]\n    ans=max(ans,count)\nprint(ans)", "n=int(input())\nf=[list(map(int, input().split())) for _ in range(n)]\np=[list(map(int, input().split())) for _ in range(n)]\n\nfrom itertools import product\nbits_l=list(product([0,1], repeat=10))\nbits_l.remove((0,0,0,0,0,0,0,0,0,0))\n\nans=-float(\"inf\")\nfor bits in bits_l:\n    tmp_ans=0\n    for shop in range(n):\n        tmp_cnt=0\n        for i, bit in enumerate(bits):\n            if bit==1 and f[shop][i]==1:\n                tmp_cnt+=1\n        tmp_ans+=p[shop][tmp_cnt]\n    ans=max(ans, tmp_ans)\n\nprint(ans)", "n = int(input())\nF = [int(\"\".join(input().split()), 2) for _ in range(n)]\nP = [list(map(int, input().split())) for _ in range(n)]\nnum = 1 << 10\nans = -(10 ** 10)\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0F0F0F0F0F0F0F0F) + ((c >> 4) & 0x0F0F0F0F0F0F0F0F)\n    c = (c & 0x00FF00FF00FF00FF) + ((c >> 8) & 0x00FF00FF00FF00FF)\n    c = (c & 0x0000FFFF0000FFFF) + ((c >> 16) & 0x0000FFFF0000FFFF)\n    c = (c & 0x00000000FFFFFFFF) + ((c >> 32) & 0x00000000FFFFFFFF)\n    return c\n\n\n# print(F)\n\nfor i in range(1, num):\n    temp = 0\n    for j in range(n):\n        temp += P[j][popcnt(i & F[j])]\n    ans = max(temp, ans)\nprint(ans)\n", "n=int(input())\nf=[]\nfor i in range(n):\n    fn=[int(x) for x in input().rstrip().split()]\n    f.append(fn)\n\np=[]\nfor i in range(n):\n    pn=[int(x) for x in input().rstrip().split()]\n    p.append(pn)\n\nans=-float('inf')\nfor i in range(1,2**10):\n    now=0\n    for s in range(n):\n        cnt=0\n        for j in range(10):\n            if ((i>>j) & 1) and f[s][j]==1:\n                cnt+=1\n        now+=p[s][cnt]\n    ans=max(ans,now)\nprint(ans)", "n = int(input())\nf = [list(map(int, input().split())) for i in range(n)]\np = [list(map(int, input().split())) for i in range(n)]\nans = -(1 << 30)\nfor bit in range(1, 1 << 10):\n    cnt = 0\n    for i in range(n):\n        cnt2 = 0\n        for j in range(10):\n            if (bit >> j & 1) and f[i][j]:\n                cnt2 += 1\n        cnt += p[i][cnt2]\n    if ans < cnt:\n        ans = cnt\nprint(ans)", "N = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\nans = -9999999999\nfor i in range(1, 2 ** 10):\n    s = 0\n    for j in range(N):\n        cnt = 0\n        for k in range(10):\n            if i >> k & 1 and F[j][k] == 1:\n                cnt += 1\n        s += P[j][cnt]\n    ans = max(ans, s)\nprint(ans)", "import sys, math\nfrom functools import lru_cache\nfrom collections import defaultdict\nfrom decimal import Decimal\nsys.setrecursionlimit(10**9)\nMOD = 10**9+7\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef mi():\n    return list(map(int, input().split()))\n\ndef ii():\n    return int(input())\n\ndef i2(n):\n    tmp = [list(mi()) for i in range(n)]\n    return [list(i) for i in zip(*tmp)]\n\ndef main():\n    N = ii()\n    F = [list(mi()) for i in range(N)]\n    P = [list(mi()) for i in range(N)]\n\n    m = -math.inf\n\n    for ptn in range(1, 2**10):\n        r = 0\n        for i in range(N):\n            cnt = 0\n            for j in range(10):\n                if F[i][j] and (ptn>>j)&1:\n                    cnt += 1\n            r += P[i][cnt]\n        m = max(m, r)\n\n    print(m)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nF = [list(map(int,input().split())) for i in range(N)]\nP = [list(map(int,input().split())) for i in range(N)]\n \nans = -10**9\nfor i in range(2**10-1):\n  Bit = [1]*10\n  for j in range(10):\n    if (i>>j)&1:\n      Bit[j]=0\n  count = 0\n  for k in range(N):\n    op = sum(b&f for b,f in zip(Bit,F[k]))\n    count+=P[k][op]\n  ans = max(ans,count)\nprint(ans)", "import itertools\nN = int(input())\nF =[ list(input().split()) for i in range(N)]\nP =[ list(input().split()) for i in range(N)]\nset01 = list(itertools.product('01',repeat = 10))\ncounter = []\nans = -10**9\nfor s01 in set01:\n    if s01 != (\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"):\n        prof = 0\n        for i in range(N):\n            counter = 0\n            for j in range(10):\n                if s01[j] ==\"1\" and F[i][j] == \"1\":\n                    counter += 1\n            prof += int(P[i][counter])\n        ans = max(ans,prof)\nprint(ans)", "def solve():\n    import numpy as np\n    n = int(input())\n    oc = [[] for _ in range(n)]\n    prof = [[] for _ in range(n)]\n\n    for i in range(n):\n        oc[i] = list(map(int, input().split()))\n    for i in range(n):\n        prof[i] = list(map(int, input().split()))\n\n    oc = np.array(oc)\n    prof = np.array(prof)\n\n    ans = -9999999999\n\n    for a in range(1, 1 << 10):\n        res = np.zeros(n, dtype=np.int64)\n        for b in range(10):\n            if a >> b & 1:\n                res += oc[:, b]\n        #print(res)\n        tmp = 0\n        for i, x in enumerate(res):\n            tmp += prof[i, x]\n        #print(tmp)\n        ans = max(ans, tmp)\n    print(ans)\n\n\nsolve()\n", "n = int(input())\narr = [list(map(int, input().split())) for i in range(n)]\narm = [list(map(int, input().split())) for j in range(n)]\n\nans = -9999999999\nfor item in range(1, 1024):\n    fund = 0\n    for i in range(n):\n        cou = 0\n        for x in range(10):\n            if (item >> x) % 2 == 1 and arr[i][x] == 1:\n                cou += 1\n        fund += arm[i][cou]\n    ans = max(ans, fund)\n\nprint(ans)", "import numpy as np\nN = int(input())\nschedules = [list(map(int, input().split())) for _ in range(N)]\nprices = [list(map(int, input().split())) for _ in range(N)]\n# print(schedules)\n# print(prices)\nans = -1 * float('inf')\nfor i in range(1, 1 << 10):\n    my_schedule = list(map(int, bin(i)[2:].zfill(10)))\n    score = 0\n    for j, schedule in enumerate(schedules):\n        count = 0\n        for k in range(10):\n            if my_schedule[k] == schedule[k] and schedule[k] == 1:\n                count += 1\n        score += prices[j][count]\n    ans = max(ans, score)\nprint(ans)\n", "def solve():\n    import numpy as np\n    n = int(input())\n    oc = [list(map(int, input().split())) for _ in range(n)]\n    prof = [list(map(int, input().split())) for _ in range(n)]\n\n    oc = np.array(oc)\n    prof = np.array(prof)\n\n    inf = 10 ** 10\n    ans = - inf\n\n    for a in range(1, 1 << 10):\n        res = np.zeros(n, dtype=np.int64)\n        for b in range(10):\n            if a >> b & 1:\n                res += oc[:, b]\n        tmp = 0\n        for i, x in enumerate(res):\n            tmp += prof[i, x]\n        ans = max(ans, tmp)\n    print(ans)\n\n\nsolve()\n\n", "N = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\nres = - 10 ** 18\nfor i in range(1, 2 ** 10):\n    tmp = [0] * N\n    for j in range(10):\n        if i >> j & 1:\n            for k in range(N):\n                tmp[k] += F[k][j]\n    res_tmp = 0\n    for j in range(N):\n        res_tmp += P[j][tmp[j]]\n    res = max(res, res_tmp)\n\nprint(res)\n", "n = int(input())\n\nf = []\nfor i in range(n):\n    f.append(list(map(int, input().split())))\np = []\nfor i in range(n):\n    p.append(list(map(int, input().split())))\n\nans = -10**18\nfor ci in range(1, 2**10):\n    score = 0\n    for cn in range(n):\n        cnt = 0\n        for cj in range(10):\n            x = ci >> cj & 1\n            if x and f[cn][cj]:\n                cnt += 1\n        score += p[cn][cnt]\n    ans = max(ans, score)\nprint(ans)\n", "import sys\nfrom itertools import product\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    F = [None] * N\n    for i in range(N):\n        F[i] = tuple(map(int, input().split()))\n    P = [None] * N\n    for i in range(N):\n        P[i] = tuple(map(int, input().split()))\n\n    ans = -float(\"inf\")\n    for comb in product(list(range(2)), repeat=10):\n        if sum(comb) == 0:\n            continue\n        c = [0] * N\n        for j, is_open in enumerate(comb):\n            if is_open:\n                for i in range(N):\n                    c[i] += F[i][j]\n        profit = sum(P[i][c[i]] for i in range(N))\n        ans = max(ans, profit)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\n# bit\u5168\u63a2\u7d22\ninf = float(\"inf\")\nans = -inf\nfor i in range(1, 2**10):\n    op = []\n    for j in range(10):\n        if (i >> j) & 1:\n            op.append(1)\n        else:\n            op.append(0)\n\n    res = 0\n    for k in range(N):\n        temp = 0\n        for l in range(10):\n            if op[l] == 1 and F[k][l] == 1:\n                temp += 1\n        res += P[k][temp]\n    ans = max(ans, res)\n\nprint(ans)", "N = int(input())\nF = [list(map(int,input().split())) for i in range(N)]\nP = [list(map(int,input().split())) for i in range(N)]\nans = - 10**9\nfor i in range(1,2**10):\n    s = i\n    b = [0]*10\n    for j in range(10):\n        if s >= (2**(10-j-1)):\n            s -= 2**(10-j-1)\n            b[j] = 1\n    a = 0\n    for j in range(N):\n        c = 0\n        for k in range(10):\n            if b[k] == 1 and F[j][k] == 1:\n                c += 1\n        a += P[j][c]\n    ans = max(ans,a)\nprint(ans)", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[2]:\n\n\nimport itertools\n\n\n# In[47]:\n\n\nN = int(input())\nF = []\nfor _ in range(N):\n    F.append(list(map(int, input().split())))\nP = []\nfor _ in range(N):\n    P.append(list(map(int, input().split())))\n\n\n# In[48]:\n\n\nans = sum([min(a) for a in P])\nfor b in range(1,1024):\n    b = list(map(int, format(b,\"010b\")))\n    tmp = 0\n    for i in range(N):\n        cnt = 0\n        for j,x in enumerate(b):\n            cnt += F[i][j]*x\n        tmp += P[i][cnt]\n    ans = max(ans, tmp)\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "from itertools import product\nn=int(input())\nfs=[list(map(int,input().split())) for _ in range(n)]\nps=[list(map(int,input().split())) for _ in range(n)]\nans=-float('inf')\nfor b in product((0,1),repeat=10):\n    if sum(b)==0:\n        continue\n    v=0\n    for f,p in zip(fs,ps):\n        cnt=sum([a&b for a,b in zip(b,f)])\n        v+=p[cnt]\n    ans=max(ans,v)\nprint(ans)\n", "N = int(input())\narr = [list(map(int,input().split())) for i in range(N)]\narm = [list(map(int,input().split())) for j in range(N)]\n\nans = -9999999999\nfor item in range(1,2**10):#joisino\u304a\u59c9\u3061\u3083\u3093\u304c\u55b6\u696d\u3059\u308b\u3057\u306a\u3044\u306e\u7d44\u307f\u5408\u308f\u305b1024\u901a\u308a\n  fund = 0\n  for i in range(N):#\u5e97\u306e\u6570\n    cou = 0\n    for x in range(10):#\u55b6\u696d\u30bf\u30a4\u30df\u30f3\u30b0\uff08\u6708~\u91d1\u305d\u308c\u305e\u308c\u5348\u524d\u3001\u5348\u5f8c\uff09\n      if (item >> x) % 2 == 1 and arr[i][x] == 1:#joisino\u59c9\u306e\u958b\u5e97\u3068\u5e97i\u306e\u958b\u5e97\u304c\u4e00\u81f4\n        cou += 1\n    fund += arm[i][cou]\n  ans = max(ans, fund)\n\nprint(ans)", "N=int(input())\nF=[list(map(int,input().split())) for _ in range(N)]\nP=[list(map(int,input().split())) for _ in range(N)]\nans=-1000000000\nfor i in range(1,1<<10):\n    cnt=[0 for _ in range(N)]\n    for j in range(10):\n        if (i>>j)%2==1:\n            for k in range(N):\n                cnt[k]+=F[k][j]\n    A=[P[j][cnt[j]] for j in range(N)]\n    ans=max(ans,sum(A))\nprint(ans)\n", "from itertools import product\nn = int(input())\nf = []\nfor i in range(n):\n    f.append(list(map(int, input().split())))\np = []\nfor _ in range(n):\n    p.append(list(map(int, input().split())))\n\nschejule_list = set(product([0, 1], repeat=10))\nans = - float(\"inf\")\nfor schedule in schejule_list:\n    if schedule == (0, 0, 0, 0, 0, 0, 0, 0, 0, 0):\n        continue\n    res = 0\n    for i in range(n):\n        kaburi = 0\n        for j in range(10):\n            kaburi += f[i][j] * schedule[j]\n        res += p[i][kaburi]\n    ans = max(ans, res)\nprint(ans)\n\n\n", "n = int(input())\nl = []\nm = []\nans = -10**9\n\nfor i in range(n):\n    f = \"\".join(input().split())\n    f = int(f, 2)\n    l.append(f)\n\nfor i in range(n):\n    p = list(map(int, input().split()))\n    m.append(p)\n\nfor i in range(1, 2**10):\n    ref = 0\n    for j in range(n):\n        cnt = bin(i & l[j]).count(\"1\")\n        ref += m[j][cnt]\n    else:\n        ans = max(ans, ref)\n\nprint(ans)", "import numpy as np\nN = int(input())\nF = np.array([list(map(int, input().split())) for i in range(N)])\nP = np.array([list(map(int, input().split())) for i in range(N)])\nans = -10**18\nfor i in range(2**10):\n    box = []\n    for k in range(10):\n        if ((i>>k)&1):\n            box = [1]+ box\n        else:\n            box = [0]+ box\n    if all(i == 0 for i in box):\n        continue\n    # box \u306f\u958b\u696d\u3059\u308b0~9\u306e\u5019\u88dc\u30ea\u30b9\u30c8\n    # G \u306f F(0\u304b1\u306e\u5404\u5e97\u958b\u696d\u72b6\u6cc1)\n    G = np.sum(F*box, axis=1)\n    a = 0\n    for x,y in zip(G,P):\n        a += y[x]\n    ans = max(ans, a)\n    \nprint(ans)", "import sys\nfrom itertools import product\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    F = [list(map(int, input().split())) for _ in range(n)]\n    P = [list(map(int, input().split())) for _ in range(n)]\n\n    res = -f_inf\n    for pattern in product([0, 1], repeat=10):\n        if sum(pattern) == 0:\n            continue\n        tmp = 0\n        for i in range(n):\n            cnt = 0\n            for p, f in zip(pattern, F[i]):\n                if p == 1 and f == 1:\n                    cnt += 1\n            tmp += P[i][cnt]\n        res = max(res, tmp)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def pad_zero(s, n):\n\ts = str(s)\n\treturn (\"0\" * n + s)[-n:]\n\ndef main():\n\tN = int(input())\n\tF = [[int(f) for f in input().split(\" \")] for i in range(N)]\n\tP = [[int(p) for p in input().split(\" \")] for i in range(N)]\n\n\ttotal_profit = []\n\tfor b in range(1, 2 ** 10):\n\t\tsale_bit = list(pad_zero(format(b, 'b'), 10))\n\t\tprofit = 0\n\t\tfor i in range(len(F)):\n\t\t\tf = F[i]\n\t\t\tp = P[i]\n\t\t\tprofit += p[sum([fjk * int(s) for (fjk, s) in zip(f, sale_bit)])]\n\t\ttotal_profit.append(profit)\n\tprint(max(total_profit))\n\n\nmain()", "import itertools\nN=int(input())\nF=[list(map(int,input().split())) for _ in range(N)]\nP=[list(map(int,input().split())) for _ in range(N)]\nans=-10**9\nfor i in list(itertools.product(range(2),repeat=10)):\n  if sum(i)==0:\n    continue\n  bns=0\n  for j in range(N):\n    b=0\n    for k in range(10):\n      if i[k]*F[j][k]==1:\n        b+=1\n    bns+=P[j][b]\n  ans=max(ans,bns)\nprint(ans)", "from itertools import product\ndef main():\n    N = int(input())\n    F = []\n    for _ in range(N):\n        f = list(map(int, input().split()))\n        F.append(f)\n    P = []\n    for _ in range(N):\n        p = list(map(int, input().split()))\n        P.append(p)\n    m = -10**21\n    for i in product(list(range(2)), repeat=10):\n        if sum(i) == 0:\n            continue\n        r = 0\n        for j in range(N):\n            r += P[j][sum(ii&jj for ii, jj in zip(i, F[j]))]\n        m = max(r, m)\n    return m\nprint((main()))\n", "n = int(input())\nfl = [list(map(int, input().split())) for _ in range(n)]\npl = [list(map(int, input().split())) for _ in range(n)]\n\nans = -1001001001\nfor i in range(1, 2**10):\n    profit = 0\n    cnt = [0]*n\n    for j in range(10):\n        if (i >> j) & 1 == 1:\n            for k in range(n):\n                if fl[k][j] == 1:\n                    cnt[k] += 1\n    for k in range(n):\n        profit += pl[k][cnt[k]]\n    ans = max(ans, profit)\n\nprint(ans)\n", "#coding: utf-8\nfrom itertools import product\n\nN = int(input())\nF = [[int(x) for x in input().split()] for _ in range(N)]\nP = [[int(x) for x in input().split()] for _ in range(N)]\n\nret = -10 ** 18\n\n# skip (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\nitr = product([0, 1], repeat=10)\nitr.__next__()\nfor bit in itr:\n    cand = sum((P[i][sum((f*b for f, b in zip(F[i], bit)))] for i in range(N)))\n    ret = max(ret, cand)\n\nprint(ret)\n", "from itertools import combinations\n\nn = int(input())\nf = [list(map(int, input().split())) for _ in range(n)]\np = [list(map(int, input().split())) for _ in range(n)]\n\nans = - 10 ** 18\nfor i in range(1, 11):\n    for pat in combinations(list(range(10)), i):\n        cnt = [0] * n\n        for e in pat:\n            for j in range(n):\n                cnt[j] += f[j][e]\n\n        score = 0\n        for i, e in enumerate(cnt):\n            score += p[i][e]\n\n        ans = max(ans, score)\n\nprint(ans)\n", "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    F = []\n    for _ in range(N):\n        F.append(list(map(int, input().split())))\n    P = []\n    for _ in range(N):\n        P.append(list(map(int, input().split())))\n\n    # A: choosen list\n    A = list(range(10))\n    n = len(A)\n    ans = -float('inf')\n    for i in range(2 ** n):\n        select = []\n        score = 0\n        for j in range(n):\n            if (i >> j) & 1:\n                select.append(A[j])\n        if len(select) == 0:\n            continue\n        \n        for j in range(N):\n            cnt = 0\n            for k in select:\n                if F[j][k] == 1:\n                    cnt += 1\n            score += P[j][cnt]\n        \n        ans = max(ans, score)\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom heapq import heappush, heappop\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\n\ndef main():\n    n = ii()\n    F = []\n    P = []\n    for _ in range(n):\n        F.append(li())\n    for _ in range(n):\n        P.append(li())\n    \n    inf = 10 ** 18\n    ans = -inf\n    for i in range(1, 1<<10):\n        c = [0]*(n)\n        tmp = 0\n        for j in range(10):\n            if (i>>j)&1:\n                for k in range(n):\n                    c[k] += F[k][j]\n        for k in range(n):\n            tmp += P[k][c[k]]\n        ans = max(ans, tmp)\n    print(ans)\n            \n            \n        \n    \n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python3\nimport numpy as np\nfrom itertools import product\nimport sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\n\ndata = np.zeros((10, n), dtype=int)\nfor i in range(n):\n    f = np.array(list(map(int, input().split())))\n    data[:, i] = f\n\n# print(data)\n\np = [list(map(int, input().split())) for i in range(n)]\n# print(p)\n\nans = -10**10\n\nfor j, i in enumerate(product([0, 1], repeat=10)):\n    if j == 0:\n        continue\n\n    indices = [x for x, y in enumerate(i) if y == 1]\n    # print(indices)\n\n    data_tmp = data[indices]\n    data_tmp = np.sum(data_tmp, axis=0)\n    ans_tmp = sum([p[a][b] for a, b in enumerate(data_tmp)])\n    ans = max(ans, ans_tmp)\nprint(ans)\n", "from itertools import product\n\nN=int(input())\nF=[list(map(int,input().split())) for _ in range(N)]\nP=[list(map(int,input().split())) for _ in range(N)]\n\nMAX=-10**12\nfor p in product(range(2),repeat=10):\n  if p==(0,)*10:continue\n  SUM=0\n  for i in range(N):\n    count=0\n    for j in range(10):\n      if p[j]==1 and F[i][j]==1:\n        count+=1\n    SUM += P[i][count]\n  MAX = max(MAX,SUM)\nprint(MAX)", "N = int(input())\nF = [0] * N\nfor i in range(N):\n    F[i] = list(map(int, input().split()))\n\nP = [0] * N\nfor i in range(N):\n    P[i] = list(map(int, input().split()))\n\nans = -float(\"inf\")\n\nfor j in range(1, 1024):\n    ss = 0\n    for i in range(N):\n        b = format(j, \"010b\")\n        bb = [0] * 10\n        for k in range(10):\n            bb[k] = F[i][k] * int(b[k])\n        ss += P[i][sum(bb)]\n    ans = max(ans, ss)\n\nprint(ans)", "def solve():\n    n = int(input())\n    oc = [list(map(int, input().split())) for _ in range(n)]\n    prof = [list(map(int, input().split())) for _ in range(n)]\n\n    ans = -9999999999\n\n    for a in range(1, 1 << 10):\n        res = 0\n        for i in range(n):\n            cnt = 0\n            for x in range(10):\n                if (a >> x) % 2 == 1 and oc[i][x] == 1:\n                    cnt += 1\n            res += prof[i][cnt]\n        ans = max(ans, res)\n    print(ans)\n\n\nsolve()\n", "import numpy as np\n \nN = int(input())\nF = np.array([list(map(int, input().split(' '))) for _ in range(N)])\nP = np.array([list(map(int, input().split(' '))) for _ in range(N)])\n \nans = - (10 ** 11)\n \nfor n in range(1, 1024):\n    bits = np.array(list(map(int, list('{:010b}'.format(n)))))\n    dup = np.sum(F * bits, axis=1)\n    ans = max(ans, np.sum(P[range(N), dup]))\n\nprint(ans)", "n = int(input())\nf = [list(map(int,input().split())) for _ in range(n)]\np = [list(map(int,input().split())) for _ in range(n)]\n\nli = []\n\nfor i in range(2**10):\n    if i == 0:\n        continue\n    ans = 0\n    co = [0]*n\n    for j in range(10):\n        if (i>>j &1)==1:\n            for k in range(n):\n                if f[k][j]==1:\n                    co[k] +=1\n    #print(i,bin(i),co)\n    for l in range(n):\n        ans += p[l][co[l]]\n    li += [ans]\nprint(max(li))", "N = int(input())\nF = [ list(map(int, input().split())) for _ in range(N)]\nP = [ list(map(int, input().split())) for _ in range(N)]\n\nres = -(1<<30)\n\nfor b in range(1,1<<10):\n  cc = 0\n  for i in range(N):\n    c = 0\n    for j in range(10):\n      if (b>>j&1) & F[i][j]:\n        c+=1\n    cc += P[i][c]\n  if res<cc:\n    res = cc\n    \nprint(res)\n", "import numpy as np\nimport heapq as hq\nN = int(input())\nF = np.array([[int(x) for x in input().split()] for _ in range(N)])\nP = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nProfit = []\nfor i in range(1,2**10):\n    Open = np.array([int(x) for x in format(i, '010b')])\n    prf = 0\n    for f, p in zip(F, P):\n        cnt = np.dot(Open, f)\n        prf += p[cnt]\n    hq.heappush(Profit, -prf)\nprint((-Profit[0]))\n", "from itertools import product\nn = int(input())\nf = []\nfor i in range(n):\n    f.append(list(map(int, input().split())))\np = []\nfor _ in range(n):\n    p.append(list(map(int, input().split())))\n\nschejule_list = list(product([0, 1], repeat=10))\nans = - float(\"inf\")\nfor schedule in schejule_list:\n    if schedule == (0,0,0,0,0,0,0,0,0,0):\n        continue\n    res = 0\n    for i in range(n):\n        kaburi = 0\n        for j in range(10):\n            kaburi += f[i][j] * schedule[j]\n        res += p[i][kaburi]\n    ans = max(ans, res)\nprint(ans)\n\n\n", "import numpy as np\n\ndef main():\n    with open(0) as f:\n        N = int(f.readline())\n        F = np.array([list(map(int, f.readline().split())) for _ in range(N)])\n        P = [list(map(int, f.readline().split())) for _ in range(N)]\n\n    max_profit = -np.inf\n    for i in range(1,2**10):\n        Open = np.array([(i>>j)&1 for j in range(10)])\n        conflict = np.dot(F, Open.T)\n        profit = sum(P[i][v] for i,v in enumerate(conflict))\n        max_profit = max(max_profit, profit)\n    print(max_profit)\n\nmain()", "N = int(input())\nF = []\nfor i in range(N):\n    A = list(map(int, input().split()))\n    F.append(A[::-1])\n\nP = []\nfor i in range(N):\n    A = list(map(int, input().split()))\n    P.append(A)\n\nresult = float(\"inf\")*(-1)\nfor i in range(1, 2**10):\n    ans = 0\n    for l in range(N):\n        c = 0\n        for j in range(10):\n            if ((i>>j) & 1):\n                if F[l][j] == 1:\n                    c += 1\n        ans += P[l][c]\n    result = max(ans, result)\nprint(result)\n", "n = int(input())\ndata1 = [list(map(int,input().split())) for _ in range(n)]\ndata2 = [list(map(int,input().split())) for _ in range(n)]\nans = []\ntrans = -1\nfor i in range(2**10):\n    S = [0]*n\n    l = 0\n    for j in range(10):\n        for k in range(n):\n            S[k] += data1[k][j]*((i>>j)&1)\n    for j in range(n):\n        l += data2[j][S[j]]\n    ans.append(l)\n    if not i:\n        trans = l\nans.sort()\nprint(ans[-1] if ans[-1] != trans else ans[-2])", "N = int(input())\nF, P = [], []\nfor i in range(N):\n  F.append(list(map(int, input().split())))\nfor i in range(N):\n  P.append(list(map(int, input().split())))\n  \nans = -(10**9)\nfor i in range(1, 2**10):\n  l = [0] * N\n  for j in range(10):\n    if (i>>j) & 1:\n      for k in range(N):\n        if F[k][j] == 1:\n          l[k] += 1\n  tmp = 0\n  for m in range(N):\n    n = l[m]\n    tmp += P[m][n]\n  ans = max(tmp, ans)\nprint(ans)", "# \u30d3\u30c3\u30c8\u5168\u63a2\u7d22\nfrom itertools import product\n\nN = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\nresult = -float('inf')\nfor i in product([True, False], repeat=10):\n    if i.count(False) == 10:\n        continue\n    t = 0\n    for j in range(N):\n        t += P[j][sum(1 & F[j][k] for k in range(10) if i[k])]\n    result = max(result, t)\nprint(result)\n", "n = int(input())\n\nF = []\nP = []\nfor i in range(n):\n    F.append(list(map(int, input().split())))\nfor i in range(n):\n    P.append(list(map(int, input().split())))\nans = -10**9\nfor i in range(1, 1 << (10)):\n    C = [0]*n\n    for j in range(10):\n        if i & 2**j:\n            for k in range(n):\n                if F[k][j]:\n                    C[k] += 1\n    current = 0\n    for k in range(n):\n        current += P[k][C[k]]\n    ans = max(current, ans)\nprint (ans)", "n=int(input())\nf=[list(map(int,input().split())) for i in range(n)]\np=[list(map(int,input().split())) for i in range(n)]\nans=-(10**10)\nfor i in range(1,1024):\n    bit=bin(i)[2:].zfill(10)\n    a=0\n    for j in range(n):\n        b=0\n        for k in range(10):\n            if int(bit[k]) and f[j][k]:\n                b+=1\n        a+=p[j][b]\n    ans=max(ans,a)\nprint(ans)", "n=int(input())\nf=[list(map(int,input().split())) for _ in range(n)]\np=[list(map(int,input().split())) for _ in range(n)]\nmaxp=-float(\"inf\")\nfor i in range(1,2**10):\n  pt=0\n  for j in range(n):\n    cnt=0\n    for k in range(10):\n      if (i>>k)&1 and f[j][k]==1:\n        cnt+=1\n    pt+=p[j][cnt]\n  maxp=max(maxp,pt)\nprint(maxp)", "n = int(input())\nF = [0]*n\nP = [0]*n\nfor i in range(n):\n    F[i] = list(map(int,input().split()))\nfor i in range(n):\n    P[i] = list(map(int,input().split()))\n \nans = -float(\"Inf\")\nfor i in range(1,2**10):\n    L = []\n    b = 0\n    for j in range(10):\n        if (i>>j)&1:\n            L.append(j)\n    for j in range(n):\n        c = 0\n        for x in L:\n            if F[j][x] == 1:\n                c += 1\n        b += P[j][c]\n        \n    ans = max(ans, b)\n \n \nprint(ans)", "n = int(input())\nf = []\nans = -10**9\n\nfor i in range(n):\n    a = \"\".join(input().split())\n    a = int(a, 2)\n    f.append(a)\n\np = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(1, 2**10):\n    ref = 0\n    for j in range(n):\n        cnt = bin(i&f[j]).count(\"1\")\n        ref += p[j][cnt]\n    else:\n        ans = max(ans, ref)\n\nprint(ans)", "from itertools import product\nN = int(input())\nlsF = [[]]\nfor i in range(N):\n    lsF.append(list(map(int,input().split())))\nlsP = [[]]\nfor i in range(N):\n    lsP.append(list(map(int,input().split())))\nbita = list(product(range(2),repeat=10))\nbita.pop(0)\nans = -10**10\nfor bit in bita:\n    count = [0 for i in range(N+1)]\n    for i in range(10):\n        for j in range(1,N+1):\n            count[j] += bit[i]*lsF[j][i]\n    benifit = 0\n    for i in range(1,N+1):\n        benifit += lsP[i][count[i]]\n    ans = max(ans,benifit)\nprint(ans)", "A=int(input())\nshop_l=[list(map(int,input().split())) for i in range(A)]\nshop_count_l=[list(map(int,input().split())) for i in range(A)]\nans=-1*10**10\nfor i in range(1,1024):\n   tmp=0\n   l=[0]*A\n   for j in range(10):\n      if (i>>j)&1:\n         for k in range(A):\n            if shop_l[k][j] == 1:\n               l[k]+=1\n   for i in range(A):\n      tmp+=shop_count_l[i][l[i]]\n   ans=max(ans,tmp)\nprint(ans)", "def solve():\n    n = int(input())\n    oc = [list(map(int, input().split())) for _ in range(n)]\n    prof = [list(map(int, input().split())) for _ in range(n)]\n\n    inf = 10 ** 16\n    ans = - inf\n\n    for a in range(1, 1 << 10):\n        res = 0\n        for i in range(n):\n            cnt = 0\n            for x in range(10):\n                if a >> x & 1 and oc[i][x] == 1:\n                    cnt += 1\n            res += prof[i][cnt]\n        ans = max(ans, res)\n    print(ans)\n\n\nsolve()\n", "import sys\nn = int(input())\nF = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\nP = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\nans = -pow(10,9)-7\nfor i in range(1,pow(2,10)):\n    b = bin(i)[2:].zfill(10)\n    t = 0\n    for j in range(n):\n        c = 0\n        for k in range(10):\n            if int(b[k]) and F[j][k]:\n                c += 1\n        t += P[j][c]\n    ans = max(ans, t)\nprint(ans)", "n = int(input())\nf = []\nfor i in range(n):\n    line = list(map(int, input().split()))\n    f.append(line)\n\np = []\nfor i in range(n):\n    line = [int(j) for j in input().split()]\n    p.append(line)\n\nres = - 10 ** 11\nfor i in range(1, 1 << 10):\n    tmp_res = 0\n    for j in range(n):\n        counter = 0\n        for k in range(10):\n            if i >> k & f[j][k]:\n                counter += 1\n        tmp_res += p[j][counter]\n    res = max(res, tmp_res)\n\nprint(res)\n", "import itertools\nn=int(input())\nf=[list(map(int,input().split())) for _ in range(n)]\np=[list(map(int,input().split())) for _ in range(n)]\nans=-(10**12)\nfor i in range(1,11):\n    num=list(itertools.combinations(list(range(10)),i))\n    for j in range(len(num)):\n        cnt=[0]*n\n        cnt2=0\n        for k in range(i):\n            for l in range(n):\n                if f[l][num[j][k]]==1:\n                    cnt[l]+=1\n        for k in range(n):\n            cnt2+=p[k][cnt[k]]\n        ans=max(cnt2,ans)\nprint(ans)\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N = I()\n    F = [LI() for _ in range(N)]\n    P = [LI() for _ in range(N)]\n\n    ans = -INF\n    for i in range(1, 2 ** 10):\n        tmp = 0\n        for j in range(N):\n            cnt = 0\n            for k in range(10):\n                if i >> k & 1:\n                    cnt += F[j][k]\n            tmp += P[j][cnt]\n        ans = max(tmp, ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n = int(input())\nf = []\nans = -10**9\n\nfor i in range(n):\n    a = \"\".join(input().split())\n    a = int(a, 2)\n    f.append(a)\n\np = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(1, 2**10):\n    ref = 0\n    for j in range(n):\n        cnt = bin(i & f[j]).count(\"1\")\n        ref += p[j][cnt]\n    else:\n        ans = max(ans, ref)\n\nprint(ans)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n    F = [list(map(int, readline().split())) for _ in range(N)]\n    P = [list(map(int, readline().split())) for _ in range(N)]\n\n    ans = -INF\n    for bits in range(1, 1 << 10):\n        res = 0\n        for i in range(N):\n            c = 0\n            for j in range(10):\n                if F[i][j] and (bits & (1 << j)):\n                    c += 1\n            res += P[i][c]\n        if ans < res:\n            ans = res\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nF = [0]*n\nP = [0]*n\nfor i in range(n):\n    F[i] = list(map(int,input().split()))\nfor i in range(n):\n    P[i] = list(map(int,input().split()))\n\nans = -float(\"Inf\")\nfor i in range(1,2**10):\n    L = []\n    b = 0\n    for j in range(10):\n        if (i>>j)&1:\n            L.append(j)\n    for j in range(n):\n        c = 0\n        for x in L:\n            if F[j][x] == 1:\n                c += 1\n        b += P[j][c]\n        \n    ans = max(ans, b)\n\n\nprint(ans)", "def count_set_bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\n\nN = int(input())\nF = [int(\"\".join(input().split()), 2) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\nans = -float(\"inf\")\nfor i in range(1, 1 << 10):\n    tmp = 0\n    for j in range(N):\n        tmp += P[j][count_set_bits(i & F[j])]\n    ans = max(ans, tmp)\nprint(ans)\n", "N = int(input())\nF = [int(''.join(list(input().split())), 2) for i in range(N)]\nP = [list(map(int, input().split())) for i in range(N)]\n\nans = -float('inf')\n\nfor i in range(1, 2**10):\n    res = 0\n    for k in range(N):\n        p = i & F[k]\n        cnt = 0\n        for j in range(10):\n            if (p >> j) & 1:\n                cnt += 1\n        res += P[k][cnt]\n    ans = max(ans, res)\n\nprint(ans)", "n = int(input())\n\nf = [list(map(int, input().split())) for _ in range(n)]\n# f = zip(*f)\n\np = [list(map(int, input().split())) for _ in range(n)]\n# p = zip(*p)\n\nans = -10**10\nfor i in range(1,1<<10):\n    c = [0] * n # \u540c\u6642\u306b\u5e97\u3092\u958b\u3044\u3066\u3044\u308b\u6642\u9593\u5e2f\u6570\n    for j in range(10):\n        if i & (1<<j):\n            for k,F in enumerate(f):\n                if F[j]:\n                    c[k] += 1\n    profit = 0\n    for j in range(n):\n        profit += p[j][c[j]]\n    ans = max(ans, profit)\n\nprint(ans)", "N = int(input())\nF = [list(map(int,input().split())) for n in range(N)]\nP = [list(map(int,input().split())) for n in range(N)]\nans = []\n\nfor i in range(1,1024):\n  p = 0\n  for j in range(N):\n    c = 0\n    for k in range(10):\n      if (i>>k&1) & F[j][k]:\n        c+=1\n    p+=P[j][c]\n  ans+=[p]\n    \nprint(max(ans))", "n = int(input())\nf = [int(input().replace(\" \", \"\"), 2) for i in range(n)]\np = [list(map(int, input().split())) for i in range(n)]\nans = -float('inf')\nfor i in range(1, 2 ** 10):\n  sum = 0\n  for j in range(n):\n    sum += p[j][bin(i & f[j]).count('1')]\n  ans = max(ans, sum)\nprint(ans)", "N = int(input())\nF = [0] * N\nfor i in range(N):\n  F[i] = list(map(int, input().split()))\n  \nP = [0] * N   \nfor i in range(N):\n  P[i] = list(map(int, input().split()))\n\n#print(F, P)\n#print(4 >> 1)\nans = - 10 ** 10\n#print(ans)\nfor i in range(1, 2 ** 10):#bit\u5168\u63a2\u7d22 #0\u306f\u7a7a\u3044\u3066\u308b\u6642\u9593\u5e2f\u304c\u306a\u3044\u306e\u3067\u30ab\u30c3\u30c8\n  open_n = [0] * N\n  profit = 0\n  for j in range(10):#10240\u901a\u308a\n    if ((i >> j) & 1):#j\u306e\u6642\u9593\u5e2f\u306b\u7a7a\u3044\u3066\u308b\n      for k in range(N):#100\n        if F[k][j] == 1:\n          open_n[k] += 1\n  for l in range(N):\n    profit += P[l][open_n[l]]\n  if ans < profit:\n    ans = profit\n          \nprint(ans) \n", "import numpy as np\nimport heapq as hq\nN = int(input())\nF = np.array([[int(x) for x in input().split()] for _ in range(N)])\nP = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nProfit = []\nfor i in range(1,2**10): #\u55b6\u696d\u6642\u9593\u5e2f\u306b\u3064\u3044\u3066bit\u5168\u63a2\u7d22\n    Open = np.array([int(x) for x in format(i, '010b')]).T #2\u9032\u6570\u3092\u7e26\u30d9\u30af\u30c8\u30eb\u306b\u5909\u63db\n    c = np.dot(F, Open) #\u5e97\u5225\u306b\u88ab\u308b\u6642\u9593\u5e2f\u306e\u500b\u6570\u3092\u30d9\u30af\u30c8\u30eb\u3068\u3057\u3066\u7b97\u51fa\n    hq.heappush(Profit, -sum(P[i, c[i]] for i in range(N))) #-1\u500d\u3057\u305f\u5229\u76ca\u3092Profit\u306bpush\u3002\nprint((-Profit[0])) #heap\u304b\u3089\u6700\u5c0f\u5024\u3092\u53d6\u5f97\n", "n=int(input())\nf=[list(map(int,input().split())) for _ in range(n)]\np=[list(map(int,input().split())) for _ in range(n)]\n\nbh=[0]*n\nc=[0]*n\nfor i,s in enumerate(f):\n  for j,h in enumerate(s):\n    bh[i]|=h<<j\n\nmaxp=-float('inf')\nfor mbh in range(1,2**10):\n  for i in range(n):\n    intsect=mbh&bh[i]\n    c[i]=sum(intsect>>k&1 for k in range(10))\n  maxp=max(maxp,sum(p[i][c[i]] for i in range(n)))\nprint(maxp)", "#\n# abc080 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"1\n1 1 0 1 0 0 0 1 0 1\n3 4 5 6 7 8 9 -2 -3 4 -2\"\"\"\n        output = \"\"\"8\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"2\n1 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 1 1 1 1 1\n0 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1\n0 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1\"\"\"\n        output = \"\"\"-2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"3\n1 1 1 1 1 1 0 0 1 1\n0 1 0 1 1 1 1 0 1 0\n1 0 1 1 0 1 0 1 0 1\n-8 6 -2 -8 -8 4 8 7 -6 2 2\n-9 2 0 1 7 -5 0 -2 -6 5 5\n6 -6 7 -9 6 -5 8 0 -9 -7 -7\"\"\"\n        output = \"\"\"23\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N = int(input())\n    F = [list(map(int, input().split())) for _ in range(N)]\n    P = [list(map(int, input().split())) for _ in range(N)]\n\n    ans = sum([min(p) for p in P])\n    for bit in range(1, 1 << 10):\n        lbit = list(map(int, format(bit, \"b\").zfill(10)))\n        p = 0\n        for i, f in enumerate(F):\n            n = 0\n            for j in range(10):\n                if lbit[j] == f[j] == 1:\n                    n += 1\n            p += P[i][n]\n        ans = max(ans, p)\n\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "import numpy as np\nN = int(input())\n\nF = np.empty((N,10))\nP = np.empty((N,11))\nfor i in range(N):\n  Flist = np.array(list(map(int, input().split())), dtype = int)\n  F[i] = Flist\nfor i in range(N):\n  Plist = np.array(list(map(int, input().split())), dtype = int)\n  P[i] = Plist\nBenefitMax = 0\n\nfor i in range(1,1024):\n  A = np.zeros(10)\n  iForBin = i\n  for j in range(10):\n    if iForBin %2 == 1:\n      A[j] = 1\n    iForBin = iForBin // 2\n  ADotF = np.tensordot(A,F,((0),(1)))\n  Benefit = 0\n  for j in range(N):\n    Benefit += P[j,int(ADotF[j])]\n  if i == 1:\n    BenefitMax = Benefit\n  else:\n    if BenefitMax < Benefit:\n      BenefitMax = Benefit\n\nprint(int(BenefitMax))", "n=int(input())\nimport numpy as np\nf=[]\nfor i in range(n):\n    f.append(list(map(int,input().split())))\np=[]\nfor i in range(n):\n    p.append(list(map(int,input().split())))\nx=np.asarray(f)\nmx=-10**9\nfor i in range(1,2**10):\n    y=np.asarray([int(x) for x in list(format(i,'010b'))])\n    z=x*y\n    can=np.sum(z,axis=1)\n    c=0\n    for j in range(n):\n        c += p[j][can[j]]\n    mx=max(c,mx)\nprint(mx)", "def bitcount(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f #8bit\u3054\u3068\n    x = x + (x >> 8) #16bit\u3054\u3068\n    x = x + (x >> 16) #32bit\u3054\u3068\n    x = x + (x >> 32) #64bit\u3054\u3068 = \u5168\u90e8\u306e\u5408\u8a08\n    return x & 0x0000007f\n\ndef binary_to_int(x):\n    temp = 0\n    for i in range(len(str(x))):\n        temp += 2**(len(str(x))-i-1) * int(str(x[i]))\n    return temp\n\nn = int(input())\nshops = []\nfor i in range(n):\n    shops.append(binary_to_int(\"\".join(input().split())))\np = []\nfor i in range(n):\n    p.append(list(map(int, input().split())))\n\nfor i in range(1, 2**10):\n    temp = 0\n    for j in range(n):\n        temp += p[j-1][bitcount(i & shops[j-1])]\n    if i == 1:\n        ans = temp\n    elif temp > ans:\n        ans = temp\n\nprint(ans)", "N = int(input())\nF = [int(\"\".join(input().split()),2) for n in range(N)]\nP = [list(map(int,input().split())) for n in range(N)]\nprint(max(sum(p[bin(n&f).count(\"1\")]for f,p in zip(F,P)) for n in range(1,1024)))", "def ForBaseConvert(Roop,MaxD,Base):\n    if all(type(TT) is int for TT in [Roop,MaxD,Base]):\n        if Base>=2 and MaxD>=1:\n            ConvertN = []\n            while Roop>0:\n                ConvertN.append(Roop%Base)\n                Roop = Roop//Base\n\n            BaseConv = [0]*(MaxD-len(ConvertN))+ConvertN[::-1]\n            BaseSInd = [[] for TB in range(0,Base)]\n            for TB in range(0,Base):\n                BaseSInd[TB] = [SInd for SInd,SNum in enumerate(BaseConv) if SNum==TB]\n            return BaseConv,BaseSInd\n        else:\n            return []\n    else:\n        return []\n      \nN = int(input())\nF = [[] for TF in range(0,N)]\nfor TF in range(0,N):\n    F[TF] = [int(T) for T in input().split()]\nP = [[] for TP in range(0,N)]\nfor TP in range(0,N):\n    P[TP] = [int(T) for T in input().split()]\n    \nMAXB = -10**9\nfor TB in range(1,2**10):\n    BaseConv,BaseSInd = ForBaseConvert(TB,10,2)\n    Benefit = 0\n    for TN in range(0,N):        \n        Count = sum(1 if F[TN][TT]==1 else 0 for TT in BaseSInd[1])\n        Benefit += P[TN][Count]\n    if MAXB<Benefit:\n        MAXB = Benefit\nprint(MAXB)", "import itertools\nn=int(input())\nf=[list(map(int,input().split())) for _ in range(n)]\np=[list(map(int,input().split())) for _ in range(n)]\nans=-(10**12)\nfor i in range(1,11):\n    num=list(itertools.combinations(list(range(10)),i))\n    for j in range(len(num)):\n        cnt=[0]*n\n        cnt2=0\n        for k in range(i):\n            for l in range(n):\n                if f[l][num[j][k]]==1:\n                    cnt[l]+=1\n        for k in range(n):\n            cnt2+=p[k][cnt[k]]\n        ans=max(cnt2,ans)\nprint(ans)\n", "N = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\nmax_prof = -float('inf')\n\nfor s in range(1, 1 << 10):\n\n    sum_prof = 0\n    for store_no in range(N):\n        state = s\n\n        time_zone = 0\n        both_open_cnt = 0\n        while state > 0:\n            if (state & 1) and F[store_no][time_zone]:\n                both_open_cnt += 1\n\n            state >>= 1\n            time_zone += 1\n\n        sum_prof += P[store_no][both_open_cnt]\n\n    max_prof = max(max_prof, sum_prof)\n\n\nprint(max_prof)\n", "from math import inf\n\nn = int(input())\nf = [list(map(int, input().split())) for _ in range(n)]\np = [list(map(int, input().split())) for _ in range(n)]\n\nans = -inf\nfor bit in range(1,1024):\n    res = 0\n    for j in range(n):\n        c = 0\n        for k in range(10):\n            mask = 1 << k\n            if f[j][k] and bit&mask:\n                c+=1\n        res += p[j][c]\n    ans = max(ans, res)\nprint(ans)\n\n\n", "from itertools import product\nN = int(input())\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\nA = [0, 1]\nM = -10**18\nPr = list(product(A, repeat=10))\nPr.remove((0,0,0,0,0,0,0,0,0,0))\nfor I in Pr:\n  s = 0\n  for i in range(N):\n    s += P[i][sum(i*f for i, f in zip(I, F[i]))]\n  M = max(M, s)\nprint(M)", "N = int(input())\n\nF = [list(map(int, input().split())) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\n\nans = -float(\"inf\")\n\nfor i in range(1, 2**10):\n    score = 0\n    jonson = [0 for _ in range(10)]\n\n    #jonson\u304c\u304a\u5e97\u3092\u958b\u304f\u6642\u9593\u3092\u6c7a\u3081\u308b\n    for j in range(10):\n        if ((i >> j)&1):\n            jonson[j] = 1\n    #\u4ed6\u306e\u304a\u5e97\u3068\u30aa\u30fc\u30d7\u30f3\u304c\u304b\u3076\u3063\u3066\u3044\u308b\u6642\u9593\u3092\u8abf\u3079\u308b\n    for k in range(N):\n        cnt = 0\n        for l in range(10):\n            if F[k][l] == jonson[l] == 1:\n                cnt += 1\n        score += P[k][cnt]\n\n    ans = max(score, ans)\n\nprint(ans)", "N = int(input())\nF = [int(input().replace(' ', ''), 2) for _ in range(N)]\nP = [list(map(int, input().split())) for _ in range(N)]\nans = float('-inf')\n\nfor i in range(1, 2**10):\n    ans = max(ans, sum(p[bin(i & f).count('1')] for f, p in zip(F, P)))\nprint(ans)\n", "import itertools\n\nN = int(input())\nM = 10\nF = [list(map(int, input().split())) for i in range(N)]\nP = [list(map(int, input().split())) for i in range(N)]\n\nans = -10 ** 10\nfor s in itertools.product([0, 1], repeat=M):\n    if max(s) == 0:\n        continue\n    score = 0\n    for i in range(N):\n        cnt = 0\n        for j in range(M):\n            if s[j] and F[i][j]:\n                cnt += 1\n        score += P[i][cnt]\n    ans = max(ans, score)\nprint(ans)\n", "from itertools import product\n\nans = -10**9 - 1\n\nN = int(input())\nF = []\nfor _ in range(N):\n  F.append(list(map(int, input().split())))\n\nP = []\nfor _ in range(N):\n  P.append(list(map(int, input().split())))\n\nall_x = True\nfor ox in product((0, 1), repeat=10):\n  if all_x:\n    all_x = False\n  else:\n    temp = 0\n    for n in range(N):\n      cnt = 0\n      for i, j in zip(F[n], ox):\n        cnt += i*j\n      temp += P[n][cnt]\n    ans = max(ans, temp)\n\nprint(ans)"]