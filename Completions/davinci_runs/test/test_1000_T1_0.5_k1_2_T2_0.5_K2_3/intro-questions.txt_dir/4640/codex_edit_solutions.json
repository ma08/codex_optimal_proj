["\n\n# The idea is to sort the points by x-coordinate, and then process them in that order.\nfrom itertools import accumulate\nimport sys\n\n# When processing a point, we maintain a set of all the platforms that have already been placed.\n\n# We can do this in O(log n) time by keeping the platforms sorted by y-coordinate.\n# For each platform, we check if the point is above or below it.\n# If it's above, we can safely ignore it.\n\n# If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it.\n# If we remove it, we also check if the point is close enough to the next platform that we should remove it too.\n# This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform.\n# If it is, then we remove the next platform as well.\n\n# Otherwise, we keep the platform.\n\n# We then insert the new platform into the set.\n\n# We repeat this process for all the points, and then we're done.\n# This runs in O(n log n) time, which is fast enough for the time limit.\n\ndef main():\n    t = int(sys.stdin.readline()) \n    for _ in range(t):\n        n = int(sys.stdin.readline())\n        xs = list(map(int, sys.stdin.readline().split())) \n        xs.sort()\n        k = int(sys.stdin.readline())\n        ds = list(map(int, sys.stdin.readline().split()))\n        ds.sort()\n        ds.append(0)\n        ds.append(0)\n        ds = list(accumulate(ds))\n        print(xs)\n        print(ds)\n        for i in range(len(xs)):\n            xs[i] += ds[i]\n        print(xs)\n        xs.sort()\n        print(xs)\n        print(xs[k])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n# The idea is to sort the points by x-coordinate and then process them in that\n# order. When processing a point, we maintain a set of all the platforms that\n# have already been placed. We can do this in O(log n) time by keeping the\n# platforms sorted by y-coordinate. For each platform, we check if the point is\n# above or below it. If it's above, we can safely ignore it. If it's below, we\n# can add it to a count and then check if the point is close enough to the\n# platform that we should remove it. If we remove it, we also check if the\n# point is close enough to the next platform that we should remove it as well.\n# This can be done by checking if the y-coordinate of the point plus the length\n# of the platform is greater than the y-coordinate of the next platform. If it\n# is, then we remove the next platform as well. Otherwise, we keep the\n# platform. We then insert the new platform into the set. We repeat this\n# process for all the points, and then we're done. This runs in O(n log n) time,\n# which is fast enough for the time limit.\n\n\ndef main():\n  t = int(sys.stdin.readline())\n  for _ in range(t):\n    n, k = map(int, sys.stdin.readline().split())\n    xs = list(map(int, sys.stdin.readline().split()))\n    ys = list(map(int, sys.stdin.readline().split()))\n    points = [(x, y) for x, y in zip(xs, ys)]\n    points.sort()\n    platforms = []\n    count = 0\n    for x, y in points:\n      while platforms and y > platforms[0][1]:\n        platforms.pop(0)\n      if not platforms:\n        platforms.append((x, y))\n        continue\n      if y - platforms[0][1] <= k:\n        count += 1\n        if len(platforms) > 1 and y + k > platforms[1][1]:\n          platforms.pop(0)\n          continue\n      platforms.append((x, y))\n    print(count)\n\n\nif __name__ == '__main__':\n  main()\n", "\n\nimport sys\n\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n, k = map(int, sys.stdin.readline().split())\n    xs = list(map(int, sys.stdin.readline().split()))\n    ys = list(map(int, sys.stdin.readline().split()))\n    points = [(x, y) for x, y in zip(xs, ys)]\n    points.sort()\n    platforms = []\n    count = 0\n    for x, y in points:\n        while platforms and y > platforms[0][1]:\n            platforms.pop(0)\n        if not platforms:\n            platforms.append((x, y))\n            continue\n        if y - platforms[0][1] <= k:\n            count += 1\n            if len(platforms) > 1 and y + k > platforms[1][1]:\n                platforms.pop(0)\n                continue\n        platforms.append((x, y))\n    print(count)\n", "\nimport sys\n\n# The idea is to sort the points by x-coordinate, and then process them in that\n# order. When processing a point, we maintain a list of all the platforms that\n# have already been placed. We can do this in O(log n) time by keeping the\n# platforms sorted by y-coordinate. For each platform, we check if the point is\n# above or below it. If it's above, we can safely ignore it. If it's below,\n# we can add it to a count, and then check if the point is close enough to the\n# platform that we should remove it. If we remove it, we also check if the\n# point is close enough to the next platform that we should remove it too.\n# This can be done by checking if the y-coordinate of the point plus the length\n# of the platform is greater than the y-coordinate of the next platform. If it\n# is, then we remove the next platform as well. Otherwise, we keep the platform.\n# We then insert the new platform into the list. We repeat this process for all\n# the points, and then we're done. This runs in O(n log n) time, which is fast\n# enough for the time limit.\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n \ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n = int(sys.stdin.readline())\n        for i in range(n):\n            print(i)\n \nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        points = list(zip(x, y))\n        points.sort()\n        left = [x for x, y in points]\n        right = [y for x, y in points]\n        left.sort(reverse=True)\n        right.sort()\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] > right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        points = list(zip(x, y))\n        points.sort()\n        left = [x for x, _ in points]\n        right = [x for x, _ in points]\n        left = sorted(left)\n        right = sorted(right)\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        left = list(zip(x, y))\n        right = list(zip(x, y))\n        left = sorted(left)\n        right = sorted(right)\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport numpy as np\n\n\ndef read_ints(): return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = np.array(read_ints())\n        y = np.array(read_ints())\n        x_sorted = np.sort(x)\n        y_sorted = np.sort(y)\n        print(x_sorted)\n        print(y_sorted)\n        # points = list(zip(x, y))\n        # points.sort()\n        # left = [y for x, y in points]\n        # right = [y for x, y in points]\n        # left.sort()\n        # right.sort()\n        # i = 0\n        # j = 0\n        # ans = 0\n        # while i < n and j < n:\n        #     if left[i] <= right[j]:\n        #         i += 1\n        #         ans += 1\n        #     else:\n        #         j += 1\n        # print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# The idea is to sort the points by x-coordinate and then process them in that order.\nimport sys\n\n# When processing a point, we maintain a list of all the platforms that have already been placed.\n\n# We can do this in O(log n) time by keeping the platforms sorted by y-coordinate and using binary search.\n# For each platform, we check if the point is above or below it.\n# If it's above, we can safely ignore it.\n\n# If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it.\n# If we remove it, we also check if the point is close enough to the next platform that we should remove it too.\n# This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform.\n# If it is, then we remove the next platform as well.\n\n# Otherwise, we keep the platform.\n\n# We then insert the new platform into the list.\n\n# We repeat this process for all the points, and then we're done.\n# This runs in O(n log n) time, which is fast enough for the time limit.\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# The idea is to sort the points by x-coordinate,\n# and then process them in that order.\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        xs = list(map(int, input().split()))\n        ys = list(map(int, input().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k >= platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n'''\nThe idea is to sort the points by x-coordinate and then process them in that order.\nWhen processing a point, we maintain a set of all the platforms that have already been placed.\nWe can do this in O(log n) time by keeping the platforms sorted by y-coordinate.\nFor each platform, we check if the point is above or below it.\nIf it's above, we can safely ignore it.\nIf it's below, we can add it to a count and then check if the point is close enough to the platform that we should remove it.\nIf we remove it, we also check if the point is close enough to the next platform that we should remove it as well.\nThis can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform.\nIf it is, then we remove the next platform as well.\nOtherwise, we keep the platform.\nWe then insert the new platform into the set.\nWe repeat this process for all the points, and then we're done.\nThis runs in O(n log n) time, which is fast enough for the time limit.\n'''\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        left = list(zip(x, y))\n        right = list(zip(x, y))\n        left.sort()\n        right.sort()\n        left = [x for x, y in left]\n        right = [x for x, y in right]\n        left = sorted(left)\n        right = sorted(right)\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"]