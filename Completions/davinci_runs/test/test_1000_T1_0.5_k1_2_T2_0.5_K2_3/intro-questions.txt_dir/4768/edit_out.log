2022-04-13 01:43:29.560253 num operations 2
2022-04-13 01:43:29.560264 size on input set 1
2022-04-13 01:43:32.816253 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): # O(n^2 * k)\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n): # O(n)\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    }
  ],
  "created": 1649814209,
  "object": "edit"
}
2022-04-13 01:43:32.816509 fix spelling mistakes 3 ['\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): # O(n^2 * k)\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n): # O(n)\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n']
2022-04-13 01:43:32.816665 size on output set 3
2022-04-13 01:43:32.816673 size on input set 3
2022-04-13 01:43:36.098568 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): # O(n^2 * k)\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n): # O(n)\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): # O(n^2 * k)\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n): # O(n)\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\n\ndef min_unlikeliness(n, k, dna):  # O(n^2 * k)\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\n\ndef print_tree(n):  # O(n)\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    }
  ],
  "created": 1649814212,
  "object": "edit"
}
2022-04-13 01:43:36.098785 fix syntax errors 3 ['\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): # O(n^2 * k)\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n): # O(n)\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): # O(n^2 * k)\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n): # O(n)\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\n\ndef min_unlikeliness(n, k, dna):  # O(n^2 * k)\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\n\ndef print_tree(n):  # O(n)\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n']
2022-04-13 01:43:37.712235 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    }
  ],
  "created": 1649814216,
  "object": "edit"
}
2022-04-13 01:43:37.712443 fix syntax errors 3 ['\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n']
2022-04-13 01:43:40.165473 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1], 'r')\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1], \"r\")\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n"
    }
  ],
  "created": 1649814217,
  "object": "edit"
}
2022-04-13 01:43:40.165690 fix syntax errors 3 ['\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '#!/usr/bin/env python3\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1], \'r\')\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n', '\n\nimport sys\n\ndef get_input(f):\n    """\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    """\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print("Invalid Input")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    """\n    Compute the minimal unlikeliness of the phylogenetic tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the phylogenetic tree\n    """\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    """\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    """\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == "__main__":\n    # Get the input\n    f = open(sys.argv[1], "r")\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n']
2022-04-13 01:43:40.165829 size on output set 6
2022-04-13 01:43:40.165848 num operations 2
2022-04-13 01:43:40.165854 size on input set 1
2022-04-13 01:43:42.649185 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 1
    },
    {
      "index": 2,
      "text": "\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649814220,
  "object": "edit"
}
2022-04-13 01:43:42.649445 NO RESULT
2022-04-13 01:43:42.649455 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 1
}
2022-04-13 01:43:42.649497 fix spelling mistakes 2 ["\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 01:43:42.649525 size on output set 2
2022-04-13 01:43:42.649532 size on input set 2
2022-04-13 01:44:19.731821 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "n = int(input())\ns = input()\ni = 0\nj = 1\ncount = 0\nwhile i < n-1:\n    while j < n:\n        if s[i] == s[j]:\n            count += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n            j += 1\n    i += 1\n    j += 1\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "def main():\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main2():\n\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main3():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main4():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main5():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main6():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main7():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main8():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main9():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main10():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649814222,
  "object": "edit"
}
2022-04-13 01:44:19.732158 fix syntax errors 3 ['n = int(input())\ns = input()\ni = 0\nj = 1\ncount = 0\nwhile i < n-1:\n    while j < n:\n        if s[i] == s[j]:\n            count += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n            j += 1\n    i += 1\n    j += 1\nprint(count)\n', "def main():\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main2():\n\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main3():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main4():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main5():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main6():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main7():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main8():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main9():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\ndef main10():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 01:44:33.692784 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(key[0] + 1, key[1] + 1)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            dna_dict[(i, j)] = hamming_distance(dna[i], dna[j])\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\ndef hamming_distance(a, b):\n    count = 0\n    for i, j in zip(a, b):\n        if i != j:\n            count += 1\n    return count\n\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n\n    n, k = map(int, input().split())  # n - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u043d\u0435\u0439, k - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432\n    dna = [input() for i in range(n)]  # \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043d\u0435\u0439\n    dna_dict = {}  # \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u0434\u043d\u0435\u0439\n\n    for i in range(n):  # \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0434\u043d\u0435\u0439\n        for j in range(i+1, n):  # \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0434\u043d\u0435\u0439\n            count = 0\n            for x in range(k):  # \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432\n                if dna[i][x] != dna[j][x]:  # \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432\n                    count += 1\n            dna_dict[(i+1, j+1)] = count  # \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0434\u043d\u0435\u0439 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044c\n\n    print(min(dna_dict.values()))  # \u0432\u044b\u0432\u043e\u0434 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u043d\u0435\u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439\n\n    for key, value in dna_dict.items():  # \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0434\u043d\u0435\u0439 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u0435\n        if value == min(dna_dict.values()):  # \u043f\u043e\u0438\u0441\u043a \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u043d\u0435\u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439\n            print(*key)  # \u0432\u044b\u0432\u043e\u0434 \u043d\u043e\u043c\u0435\u0440\u043e\u0432 \u0434\u043d\u0435\u0439\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649814259,
  "object": "edit"
}
2022-04-13 01:44:33.693062 fix syntax errors 3 ["\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = []\n    for i in range(n):\n        dna.append(input())\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(key[0] + 1, key[1] + 1)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            dna_dict[(i, j)] = hamming_distance(dna[i], dna[j])\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\ndef hamming_distance(a, b):\n    count = 0\n    for i, j in zip(a, b):\n        if i != j:\n            count += 1\n    return count\n\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n\n    n, k = map(int, input().split())  # n - количество дней, k - количество клиентов\n    dna = [input() for i in range(n)]  # список дней\n    dna_dict = {}  # словарь дней\n\n    for i in range(n):  # перебор дней\n        for j in range(i+1, n):  # перебор дней\n            count = 0\n            for x in range(k):  # перебор клиентов\n                if dna[i][x] != dna[j][x]:  # сравнение клиентов\n                    count += 1\n            dna_dict[(i+1, j+1)] = count  # добавление дней в словарь\n\n    print(min(dna_dict.values()))  # вывод минимального числа несовпадений\n\n    for key, value in dna_dict.items():  # перебор дней в словаре\n        if value == min(dna_dict.values()):  # поиск минимального числа несовпадений\n            print(*key)  # вывод номеров дней\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 01:44:33.693117 size on output set 6
2022-04-13 01:44:33.693130 num operations 2
2022-04-13 01:44:33.693136 size on input set 1
2022-04-13 01:44:39.723463 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSets:\n    \"\"\"\n    Class for representing disjoint sets.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649814273,
  "object": "edit"
}
2022-04-13 01:44:39.723788 fix spelling mistakes 3 ['\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint sets.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSets:\n    """\n    Class for representing disjoint sets.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint sets.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 01:44:39.723925 size on output set 2
2022-04-13 01:44:39.723933 size on input set 2
2022-04-13 01:44:51.445241 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna, k))\n\ndef kruskal(dna, k):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight)[:k]:\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return sum(edge.weight for edge in mst)\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1))) / 2\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(e.weight for e in mst))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649814279,
  "object": "edit"
}
2022-04-13 01:44:51.445605 fix syntax errors 3 ['\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna, k))\n\ndef kruskal(dna, k):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight)[:k]:\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return sum(edge.weight for edge in mst)\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1))) / 2\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint sets.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(e.weight for e in mst))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint sets.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    """\n    Class for representing a disjoint set.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint sets.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 01:44:58.457389 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSets:\n    \"\"\"\n    Class for representing disjoint sets.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(edge.weight for edge in mst) // 2)\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSets:\n    \"\"\"\n    Class for representing disjoint sets.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(mst)\n    print(sum(edge.weight for edge in mst))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2]), len(dna[vertex1])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1))) / len(dna1)\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight, length):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n        self.length = length\n\nclass DisjointSets:\n    \"\"\"\n    Class for representing disjoint sets.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649814291,
  "object": "edit"
}
2022-04-13 01:44:58.457676 fix syntax errors 3 ['\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSets:\n    """\n    Class for representing disjoint sets.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(edge.weight for edge in mst) // 2)\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSets:\n    """\n    Class for representing disjoint sets.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(mst)\n    print(sum(edge.weight for edge in mst))\n\ndef kruskal(dna):\n    """\n    Kruskal\'s algorithm for finding the minimum spanning tree of a graph.\n    """\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSets(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    """\n    Class for representing a graph.\n    """\n    def __init__(self, dna):\n        """\n        Initialize the graph.\n        """\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2]), len(dna[vertex1])))\n    \n    def weight(self, dna1, dna2):\n        """\n        Compute the weight of an edge between two vertices.\n        """\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1))) / len(dna1)\n\nclass Edge:\n    """\n    Class for representing an edge.\n    """\n    def __init__(self, vertex1, vertex2, weight, length):\n        """\n        Initialize the edge.\n        """\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n        self.length = length\n\nclass DisjointSets:\n    """\n    Class for representing disjoint sets.\n    """\n    def __init__(self, size):\n        """\n        Initialize the disjoint set.\n        """\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        """\n        Find the root of a given vertex.\n        """\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        """\n        Merge the sets containing two given vertices.\n        """\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        """\n        Check if two given vertices are in the same set.\n        """\n        return self.find(x) == self.find(y)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 01:44:58.457785 size on output set 6
2022-04-13 01:44:58.457798 num operations 2
2022-04-13 01:44:58.457803 size on input set 1
2022-04-13 01:45:21.769267 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[inf for i in range(n)] for j in range(n)] # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n"
    },
    {
      "index": 2,
      "text": "\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[inf for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    }
  ],
  "created": 1649814298,
  "object": "edit"
}
2022-04-13 01:45:21.769590 fix spelling mistakes 3 ['\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[inf for i in range(n)] for j in range(n)] # матрица расстояний\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # матрица расстояний\n\n# def mst(n): # алгоритм построения минимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # минимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n): # алгоритм построения максимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # максимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # алгоритм построения максимального остовного дерева\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # максимальное остовное дерево\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n', '\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[inf for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n']
2022-04-13 01:45:21.769732 size on output set 3
2022-04-13 01:45:21.769740 size on input set 3
2022-04-13 01:45:46.583741 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[inf for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    }
  ],
  "created": 1649814321,
  "object": "edit"
}
2022-04-13 01:45:46.584033 fix syntax errors 3 ['\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open("input.txt", "r")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\n# d = [[inf for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open("input.txt", "r")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n']
2022-04-13 01:45:58.928492 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)] # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)] # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)] # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # \u043c\u0430\u0442\u0440\u0438\u0446\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439\n\n# def mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u0441\u0442\u043e\u0432\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n"
    }
  ],
  "created": 1649814346,
  "object": "edit"
}
2022-04-13 01:45:58.928782 fix syntax errors 3 ['\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)] # матрица расстояний\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # матрица расстояний\n\n# def mst(n): # алгоритм построения минимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # минимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n): # алгоритм построения максимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # максимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # алгоритм построения максимального остовного дерева\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # максимальное остовное дерево\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)] # матрица расстояний\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # матрица расстояний\n\n# def mst(n): # алгоритм построения минимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # минимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n): # алгоритм построения максимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # максимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # алгоритм построения максимального остовного дерева\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # максимальное остовное дерево\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)] # матрица расстояний\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d) # матрица расстояний\n\n# def mst(n): # алгоритм построения минимального остовного дерева\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n) # минимальное остовное дерево\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n): # алгоритм построения максимального остовного дерева\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n) # максимальное остовное дерево\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n']
2022-04-13 01:46:15.549471 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)] # read by line\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n"
    },
    {
      "index": 1,
      "text": "\nfrom math import inf, sqrt\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\nprint(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        # d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\nprint(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\n# print(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# # print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# # print(sum(e for e, v in edges))\n# # for e, v in edges:\n# #     print(v, e)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n"
    }
  ],
  "created": 1649814358,
  "object": "edit"
}
2022-04-13 01:46:15.549760 fix syntax errors 3 ['\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open("input.txt", "r")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)] # read by line\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n', '\nfrom math import inf, sqrt\nfrom sys import stdin, stdout\n\nf = open("input.txt", "r")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\nprint(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        # d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\nprint(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\n# print(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# # print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# # print(sum(e for e, v in edges))\n# # for e, v in edges:\n# #     print(v, e)\n', '\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open("input.txt", "r")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n']
2022-04-13 01:46:15.549825 size on output set 8
2022-04-13 01:46:15.549838 num operations 2
2022-04-13 01:46:15.549843 size on input set 1
2022-04-13 01:46:17.683614 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649814375,
  "object": "edit"
}
2022-04-13 01:46:17.683875 fix spelling mistakes 3 ["\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 01:46:17.683929 size on output set 1
2022-04-13 01:46:17.683936 size on input set 1
2022-04-13 01:46:32.403185 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from math import sqrt\nfrom collections import defaultdict\n\n\ndef parse_data():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        edges.append((a, b, c))\n    return n, edges\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(i), find(j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, dist in tree:\n        print(i, j, dist)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649814377,
  "object": "edit"
}
2022-04-13 01:46:32.403386 fix syntax errors 3 ["from math import sqrt\nfrom collections import defaultdict\n\n\ndef parse_data():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        edges.append((a, b, c))\n    return n, edges\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(i), find(j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, dist in tree:\n        print(i, j, dist)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 01:46:32.403542 size on output set 3
2022-04-13 01:46:32.403567 num operations 2
2022-04-13 01:46:32.403576 size on input set 1
2022-04-13 01:46:44.287911 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\nimport sys\n\ndef main(n, k, dna):\n    components = {i: i for i in range(1, n + 1)}\n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if components[i] != components[j]:\n                d = hamming(dna[i - 1], dna[j - 1])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(1, n + 1):\n                        if components[k] == c2:\n                            components[k] = c1\n    return total_distance\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    }
  ],
  "created": 1649814392,
  "object": "edit"
}
2022-04-13 01:46:44.288111 fix spelling mistakes 3 ['\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n', "\n\nimport math\nimport sys\n\ndef main(n, k, dna):\n    components = {i: i for i in range(1, n + 1)}\n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if components[i] != components[j]:\n                d = hamming(dna[i - 1], dna[j - 1])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(1, n + 1):\n                        if components[k] == c2:\n                            components[k] = c1\n    return total_distance\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", '\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n']
2022-04-13 01:46:44.288155 size on output set 3
2022-04-13 01:46:44.288161 size on input set 3
2022-04-13 01:46:45.827640 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    }
  ],
  "created": 1649814404,
  "object": "edit"
}
2022-04-13 01:46:45.827876 fix syntax errors 3 ['\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n', '\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n', '\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n']
2022-04-13 01:46:52.781095 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import math\nimport sys\n\ndef main(n, k, dna):\n    components = {i: i for i in range(1, n + 1)}\n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if components[i] != components[j]:\n                d = hamming(dna[i - 1], dna[j - 1])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(1, n + 1):\n                        if components[k] == c2:\n                            components[k] = c1\n    return total_distance\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    components = {i: i for i in range(1, n + 1)}\n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if components[i] != components[j]:\n                d = hamming(dna[i - 1], dna[j - 1])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(1, n + 1):\n                        if components[k] == c2:\n                            components[k] = c1\n    print(total_distance)\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main(n, k, dna):\n    components = {i: i for i in range(n)}\n    total_distance = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if components[i] != components[j]:\n                d = hamming(dna[i], dna[j])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(n):\n                        if components[k] == c2:\n                            components[k] = c1\n    return total_distance\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain(6, 5, [\"CCTAA\", \"CTAAA\", \"TAAAA\", \"AAATT\", \"AATTT\", \"TTTTT\"])\n"
    }
  ],
  "created": 1649814405,
  "object": "edit"
}
2022-04-13 01:46:52.781286 fix syntax errors 3 ["import math\nimport sys\n\ndef main(n, k, dna):\n    components = {i: i for i in range(1, n + 1)}\n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if components[i] != components[j]:\n                d = hamming(dna[i - 1], dna[j - 1])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(1, n + 1):\n                        if components[k] == c2:\n                            components[k] = c1\n    return total_distance\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\n\nimport math\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    components = {i: i for i in range(1, n + 1)}\n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if components[i] != components[j]:\n                d = hamming(dna[i - 1], dna[j - 1])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(1, n + 1):\n                        if components[k] == c2:\n                            components[k] = c1\n    print(total_distance)\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", '\n\ndef main(n, k, dna):\n    components = {i: i for i in range(n)}\n    total_distance = float(\'inf\')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if components[i] != components[j]:\n                d = hamming(dna[i], dna[j])\n                if d < total_distance:\n                    total_distance = d\n                    c1 = components[i]\n                    c2 = components[j]\n                    for k in range(n):\n                        if components[k] == c2:\n                            components[k] = c1\n    return total_distance\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain(6, 5, ["CCTAA", "CTAAA", "TAAAA", "AAATT", "AATTT", "TTTTT"])\n']
2022-04-13 01:46:57.199694 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n - 1):\n        for j in range(i + 1, n - 1):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n - 1)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n - 1):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n - 1):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n)\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n"
    }
  ],
  "created": 1649814412,
  "object": "edit"
}
2022-04-13 01:46:57.199939 fix syntax errors 3 ['\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n - 1):\n        for j in range(i + 1, n - 1):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n - 1)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n - 1):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n - 1):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n)\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n']
2022-04-13 01:46:57.199982 size on output set 7
2022-04-13 01:46:57.200010 num operations 2
2022-04-13 01:46:57.200015 size on input set 1
2022-04-13 01:47:02.173414 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    # for i in range(n):\n    #     for j in range(n):\n    #         if mst[i][j] != math.inf:\n    #             print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n+1)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649814417,
  "object": "edit"
}
2022-04-13 01:47:02.173620 fix spelling mistakes 3 ['\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    # for i in range(n):\n    #     for j in range(n):\n    #         if mst[i][j] != math.inf:\n    #             print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n+1)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 01:47:02.173751 size on output set 3
2022-04-13 01:47:02.173762 size on input set 3
2022-04-13 01:47:05.535406 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[float('inf') for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float('inf'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "#coding=utf-8\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[float('inf') for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float('inf'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[sys.maxsize for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != sys.maxsize:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649814422,
  "object": "edit"
}
2022-04-13 01:47:05.535704 fix syntax errors 3 ['\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[float(\'inf\') for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float(\'inf\'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '#coding=utf-8\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[float(\'inf\') for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float(\'inf\'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edges)\n    mst = [[sys.maxsize for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != sys.maxsize:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 01:47:17.338354 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\n\nimport sys\nimport math\n\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for _ in range(n)] for _ in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    # for i in range(n):\n    #     for j in range(n):\n    #         if mst[i][j] != math.inf:\n    #             print(i, j)\n\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nl = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nfor i in range(1, len(l)):\n    print(l[i], l[i-1], l[i] % l[i-1])\n"
    }
  ],
  "created": 1649814425,
  "object": "edit"
}
2022-04-13 01:47:17.338620 fix syntax errors 3 ['#!/usr/bin/env python3\n\nimport sys\nimport math\n\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for _ in range(n)] for _ in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    # for i in range(n):\n    #     for j in range(n):\n    #         if mst[i][j] != math.inf:\n    #             print(i, j)\n\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\nl = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nfor i in range(1, len(l)):\n    print(l[i], l[i-1], l[i] % l[i-1])\n']
2022-04-13 01:47:23.607136 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n+1)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[i][j] < mst[i][v]):\n                v = j\n        used[v] = True\n        ans += mst[i][v]\n        for j in range(n):\n            if mst[i+1][j] > edge[v][j]:\n                mst[i+1][j] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[n][i] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n+1)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i-1]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j] and not used[j]:\n                mst[j][i+1] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[float('inf') for i in range(n)] for j in range(n+1)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float('inf'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649814437,
  "object": "edit"
}
2022-04-13 01:47:23.607336 fix syntax errors 3 ['\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n+1)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[i][j] < mst[i][v]):\n                v = j\n        used[v] = True\n        ans += mst[i][v]\n        for j in range(n):\n            if mst[i+1][j] > edge[v][j]:\n                mst[i+1][j] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[n][i] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n+1)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i-1]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j] and not used[j]:\n                mst[j][i+1] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[float(\'inf\') for i in range(n)] for j in range(n+1)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n+1):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float(\'inf\'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 01:47:23.607452 size on output set 9
2022-04-13 01:47:23.607466 num operations 2
2022-04-13 01:47:23.607471 size on input set 1
2022-04-13 01:47:25.385394 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm \nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport heapq\nimport sys\n\n# Read input and build graphs\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm \nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    }
  ],
  "created": 1649814443,
  "object": "edit"
}
2022-04-13 01:47:25.385587 fix spelling mistakes 3 ["\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm \nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\nimport heapq\nimport sys\n\n# Read input and build graphs\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm \nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"]
2022-04-13 01:47:25.385647 size on output set 2
2022-04-13 01:47:25.385654 size on input set 2
2022-04-13 01:47:27.898598 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    },
    {
      "index": 1,
      "text": "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n"
    }
  ],
  "created": 1649814445,
  "object": "edit"
}
2022-04-13 01:47:27.898833 fix syntax errors 3 ["\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n"]
2022-04-13 01:47:37.644756 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport heapq\nimport sys\n\n# Read input and build graphs\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport heapq\nimport sys\n\n# Read input and build graphs\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]  # adjacency list\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"
    }
  ],
  "created": 1649814447,
  "object": "edit"
}
2022-04-13 01:47:37.644941 fix syntax errors 3 ["\nimport heapq\nimport sys\n\n# Read input and build graphs\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n", "\nimport heapq\nimport sys\n\n# Read input and build graphs\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n", "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]  # adjacency list\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"]
2022-04-13 01:47:37.645048 size on output set 4
