2022-04-12 17:19:47.100489 num operations 2
2022-04-12 17:19:47.100498 size on input set 1
2022-04-12 17:19:50.053765 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:  # \u5207\u65ad\n            diff.append(i)\n\n        graph[a - 1] = tmp1  # \u5143\u306b\u623b\u3059\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    }
  ],
  "created": 1649783987,
  "object": "edit"
}
2022-04-12 17:19:50.054000 fix spelling mistakes 3 ["\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:  # 切断\n            diff.append(i)\n\n        graph[a - 1] = tmp1  # 元に戻す\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"]
2022-04-12 17:19:50.054145 size on output set 3
2022-04-12 17:19:50.054152 size on input set 3
2022-04-12 17:19:55.676247 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0, flush=True)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff), flush=True)\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1), flush=True)\n    else:\n        print(k, flush=True)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1), flush=True)\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\ndef inp(): return int(sys.stdin.readline())\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    }
  ],
  "created": 1649783990,
  "object": "edit"
}
2022-04-12 17:19:55.676446 fix syntax errors 3 ["\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0, flush=True)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff), flush=True)\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1), flush=True)\n    else:\n        print(k, flush=True)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1), flush=True)\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\ndef inp(): return int(sys.stdin.readline())\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]  # copy\n        tmp2 = graph[b - 1][:]  # copy\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"]
2022-04-12 17:20:01.449952 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):  # n:\u9802\u70b9\u6570,m:\u8fba\u306e\u6570,k:\u5207\u308a\u96e2\u3059\u8fba\u306e\u6570\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in range(len(diff)):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1), end='')\n        print()\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    }
  ],
  "created": 1649783995,
  "object": "edit"
}
2022-04-12 17:20:01.450147 fix syntax errors 3 ["\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):  # n:頂点数,m:辺の数,k:切り離す辺の数\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in range(len(diff)):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1), end='')\n        print()\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"]
2022-04-12 17:20:23.399279 fix syntax errors {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n#\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:  # \u5207\u65ad\n            diff.append(i)\n\n        graph[a - 1] = tmp1  # \u5143\u306b\u623b\u3059\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\n# def func(n, m, k):\n#     def dfs(u):\n#         if visited[u]:\n#             return\n#         visited[u] = True\n#         for v in graph[u]:\n#             dfs(v)\n#\n#     graph = [[] for i in range(n)]\n#     for i in range(m):\n#         a, b = inp_list()\n#         graph[a - 1].append(b - 1)\n#         graph[b - 1].append(a - 1)\n#\n#     visited = [False] * n\n#     dfs(0)\n#     if False in visited:\n#         print(0)\n#         return\n#\n#     diff = []\n#     for i in range(m):\n#         a, b = inp_list()\n#         tmp1 = graph[a - 1][:]\n#         tmp2 = graph[b - 1][:]\n#         graph[a - 1].remove(b - 1)\n#         graph[b - 1].remove(a - 1)\n#\n#         visited = [False] * n\n#         dfs(0)\n#         if False in visited:  # \u5207\u65ad\n#             diff.append(i)\n#\n#         graph[a - 1] = tmp1  # \u5143\u306b\u623b\u3059\n#         graph[b - 1] = tmp2\n#\n#     if len(diff) < k:\n#         print(len(diff))\n#         for i in diff:\n#             print('1' * (i + 1) + '0' * (m - i - 1))\n#     else:\n#         print(k)\n#         for i in range(k):\n#             print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n#\n#\n# func(inp(), inp(), inp())\n"
    }
  ],
  "created": 1649784001,
  "object": "edit"
}
2022-04-12 17:20:23.399500 NO RESULT
2022-04-12 17:20:23.399509 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-12 17:20:23.399551 fix syntax errors 2 ["\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n#\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:  # 切断\n            diff.append(i)\n\n        graph[a - 1] = tmp1  # 元に戻す\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\n# def func(n, m, k):\n#     def dfs(u):\n#         if visited[u]:\n#             return\n#         visited[u] = True\n#         for v in graph[u]:\n#             dfs(v)\n#\n#     graph = [[] for i in range(n)]\n#     for i in range(m):\n#         a, b = inp_list()\n#         graph[a - 1].append(b - 1)\n#         graph[b - 1].append(a - 1)\n#\n#     visited = [False] * n\n#     dfs(0)\n#     if False in visited:\n#         print(0)\n#         return\n#\n#     diff = []\n#     for i in range(m):\n#         a, b = inp_list()\n#         tmp1 = graph[a - 1][:]\n#         tmp2 = graph[b - 1][:]\n#         graph[a - 1].remove(b - 1)\n#         graph[b - 1].remove(a - 1)\n#\n#         visited = [False] * n\n#         dfs(0)\n#         if False in visited:  # 切断\n#             diff.append(i)\n#\n#         graph[a - 1] = tmp1  # 元に戻す\n#         graph[b - 1] = tmp2\n#\n#     if len(diff) < k:\n#         print(len(diff))\n#         for i in diff:\n#             print('1' * (i + 1) + '0' * (m - i - 1))\n#     else:\n#         print(k)\n#         for i in range(k):\n#             print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n#\n#\n# func(inp(), inp(), inp())\n"]
2022-04-12 17:20:23.399614 size on output set 8
2022-04-12 17:20:23.399625 num operations 2
2022-04-12 17:20:23.399630 size on input set 1
2022-04-12 17:20:38.445762 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n"
    },
    {
      "index": 1,
      "text": "\n\n# Reference:\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n"
    }
  ],
  "created": 1649784023,
  "object": "edit"
}
2022-04-12 17:20:38.445954 fix spelling mistakes 3 ["\n\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n", '\n\n# Reference:\n', "\n\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n"]
2022-04-12 17:20:38.446007 size on output set 2
2022-04-12 17:20:38.446013 size on input set 2
2022-04-12 17:21:15.986644 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/bin/bash\necho \"hello world\"\n\n# Reference:\n"
    },
    {
      "index": 1,
      "text": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Reference:\n"
    },
    {
      "index": 2,
      "text": "\n\n# Reference: \nhttps://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files\n"
    }
  ],
  "created": 1649784038,
  "object": "edit"
}
2022-04-12 17:21:15.986917 fix syntax errors 3 ['#!/bin/bash\necho "hello world"\n\n# Reference:\n', '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Reference:\n', '\n\n# Reference: \nhttps://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files\n']
2022-04-12 17:21:26.835373 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution\n\n#!/usr/bin/python\n\nfrom copy import deepcopy\n\nn, m, k = map(int, raw_input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, raw_input().split())\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if not used[g[v][i]]:\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if not used[i]:\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while len(q) > 0:\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if not used[g[cur][i]]:\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if bin(i).count('1') == n - 1:\n            cur = deepcopy(g)\n            for j in range(m):\n                if (i >> j) % 2 == 1:\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if is_connected(cur):\n                cur_dist = get_dist(cur)\n                if cur_dist < best:\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif cur_dist == best:\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution\n\n#!/usr/bin/python\n\nfrom copy import deepcopy\n\nn, m, k = map(int, raw_input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, raw_input().split())\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if not used[g[v][i]]:\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if not used[i]:\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while len(q) > 0:\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if not used[g[cur][i]]:\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if bin(i).count('1') == n - 1:\n            cur = deepcopy(g)\n            for j in range(m):\n                if (i >> j) % 2 == 1:\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if is_connected(cur):\n                cur_dist = get_dist(cur)\n                if cur_dist < best:\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif cur_dist == best:\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint len(ans)\nfor i in range(len(ans)):\n    print bin(ans[i])[2:].zfill(m)\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n"
    }
  ],
  "created": 1649784076,
  "object": "edit"
}
2022-04-12 17:21:26.835562 fix syntax errors 3 ["\n\n# Solution\n\n#!/usr/bin/python\n\nfrom copy import deepcopy\n\nn, m, k = map(int, raw_input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, raw_input().split())\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if not used[g[v][i]]:\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if not used[i]:\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while len(q) > 0:\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if not used[g[cur][i]]:\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if bin(i).count('1') == n - 1:\n            cur = deepcopy(g)\n            for j in range(m):\n                if (i >> j) % 2 == 1:\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if is_connected(cur):\n                cur_dist = get_dist(cur)\n                if cur_dist < best:\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif cur_dist == best:\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n", "\n\n# Solution\n\n#!/usr/bin/python\n\nfrom copy import deepcopy\n\nn, m, k = map(int, raw_input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, raw_input().split())\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if not used[g[v][i]]:\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if not used[i]:\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while len(q) > 0:\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if not used[g[cur][i]]:\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if bin(i).count('1') == n - 1:\n            cur = deepcopy(g)\n            for j in range(m):\n                if (i >> j) % 2 == 1:\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if is_connected(cur):\n                cur_dist = get_dist(cur)\n                if cur_dist < best:\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif cur_dist == best:\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint len(ans)\nfor i in range(len(ans)):\n    print bin(ans[i])[2:].zfill(m)\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp \n", "\n\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n"]
2022-04-12 17:21:26.835708 size on output set 6
