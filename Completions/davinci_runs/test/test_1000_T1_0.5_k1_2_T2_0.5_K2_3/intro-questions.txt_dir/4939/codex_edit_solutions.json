["\n\nn, k = map(int, input().split())\ncommands = input().split()\n\negg = 0\n\nfor i in range(len(commands)):\n    if \"undo\" in commands[i]:\n        for j in range(int(commands[i][5:])):\n            if i - j - 1 >= 0:\n                egg -= int(commands[i-j-1])\n            elif i - j - 1 < 0:\n                egg -= int(commands[0])\n    else:\n        egg += int(commands[i])\n\nprint(egg % n)\n", "\"\"\"\nIn this problem you will be given a list of commands that can be executed on a circular list.\nEach command is either an integer or an undo command. An undo command will undo the previous command\nif it was an integer command.\nIf the command was an undo command, nothing happens.\nThe integer command will move the current position of the list the specified amount of positions.\nThe list is circular, so if the current position is 5 and the command is -2, the new position will be 3.\nIf the current position is 5 and the command is 3, the new position will be 1.\nAfter the list of commands, on the last line, there will be a single integer, the index that should be printed.\nThe list starts at position 0.\n\"\"\"\n\nimport sys\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        newNode = Node(data)\n        if self.head is None:\n            self.head = newNode\n            return\n\n        lastNode = self.head\n        while lastNode.next is not None:\n            lastNode = lastNode.next\n        lastNode.next = newNode\n\n    def printList(self):\n        currNode = self.head\n        while currNode is not None:\n            print(currNode.data)\n            currNode = currNode.next\n\n    def delete(self, index):\n        currNode = self.head\n        if index == 0:\n            self.head = currNode.next\n            currNode = None\n            return\n\n        prevNode = None\n        count = 0\n        while currNode is not None and count != index:\n            prevNode = currNode\n            currNode = currNode.next\n            count += 1\n\n        if currNode is None:\n            return\n\n        prevNode.next = currNode.next\n        currNode = None\n\n    def length(self):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            count += 1\n            currNode = currNode.next\n        return count\n\n    def get(self, index):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            if count == index:\n                return currNode.data\n            count += 1\n            currNode = currNode.next\n        return -1\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, k = lines[0].split()\n    n, k = int(n), int(k)\n    commands = lines[1].split()\n\n    ll = LinkedList()\n    for i in range(n):\n        ll.insert(i)\n\n    curr_index = 0\n    i = 0\n    while i < k:\n        command = commands[i]\n        if command == \"undo\":\n            if i == k:\n                break\n            m = int(commands[i+1])\n        elif command == \"undo undo\":\n            m = int(commands[i+2])\n            for j in range(m):\n                ll.delete(curr_index)\n            i += 2\n            continue\n\n            for j in range(m):\n                ll.delete(curr_index)\n            i += 1\n            continue\n        else:\n            t = int(command)\n            if t < 0:\n                t = n + t\n            curr_index = (curr_index + t) % ll.length()\n    print(ll.get(curr_index))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        newNode = Node(data)\n        if self.head is None:\n            self.head = newNode\n            return\n\n        lastNode = self.head\n        while lastNode.next is not None:\n            lastNode = lastNode.next\n        lastNode.next = newNode\n\n    def printList(self):\n        currNode = self.head\n        while currNode is not None:\n            print(currNode.data)\n            currNode = currNode.next\n\n    def delete(self, index):\n        currNode = self.head\n        if index == 0:\n            self.head = currNode.next\n            currNode = None\n            return\n\n        prevNode = None\n        count = 0\n        while currNode is not None and count != index:\n            prevNode = currNode\n            currNode = currNode.next\n            count += 1\n\n        if currNode is None:\n            return\n\n        prevNode.next = currNode.next\n        currNode = None\n\n    def length(self):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            count += 1\n            currNode = currNode.next\n        return count\n\n    def get(self, index):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            if count == index:\n                return currNode.data\n            count += 1\n            currNode = currNode.next\n        return -1\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, k = lines[0].split(' ')\n    n, k = int(n), int(k)\n    commands = lines[1].split(' ')\n\n    ll = LinkedList()\n    for i in range(n):\n        ll.insert(i)\n\n    curr_index = 0\n    for i in range(k):\n        command = commands[i]\n        if command == \"undo\":\n            m = int(commands[i+1])\n            for j in range(m):\n                ll.delete(curr_index)\n            i += 1\n            continue\n        else:\n            t = int(command)\n            if t < 0:\n                t = n + t + 1\n            curr_index = (curr_index + t) % ll.length()\n    print(ll.get(curr_index))\n\nif __name__ == '__main__':\n    main()\n", "# https://www.codechef.com/problems/CRDGAME3\n\nn, k = map(int, input().split())\nthrows = input().split()\n\nposition = 0\n\nfor i in range(k):\n    if throws[i] == 'undo':\n        position += int(throws[i+1])\n    else:\n        position += int(throws[i])\n        if position > n-1:\n            position -= n\n        elif position < 0:\n            position += n\n\nprint(position)\n", "\nimport sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = sys.stdin.readline().split()\n    current_child = 0\n    for command in commands:\n        if command == 'undo':\n            undo_command = int(commands[commands.index(command)+1])\n            undo_index = commands.index('undo')\n            undo_commands_to_remove = []\n            for i in range(undo_command):\n                undo_index -= 1\n                if commands[undo_index] == 'undo':\n                    undo_commands_to_remove.append(undo_index)\n                else:\n                    current_child -= int(commands[undo_index])\n            for i in undo_commands_to_remove:\n                commands.pop(i)\n        elif command == '0' or command == '-0':\n            pass\n        else:\n            current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop()\n        undo_index = commands.index('undo')\n        undo_commands_to_remove = []\n        for i in range(undo_command):\n            undo_index -= 1\n            if commands[undo_index] == 'undo':\n                undo_commands_to_remove.append(undo_index)\n            else:\n                current_child -= int(commands[undo_index])\n        for i in undo_commands_to_remove:\n            commands.pop(i)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "\nn, k = map(int, input().split())\ncommands = input().split()\n\negg = 0\n\nfor i in range(len(commands)):\n    if \"undo\" in commands[i]:\n        for j in range(int(commands[i][5:])):\n            if i - j - 1 >= 0:\n                egg -= int(commands[i-j-1])\n            elif i - j - 1 < 0:\n                egg -= int(commands[0])\n    else:\n        egg += int(commands[i])\n\nprint(egg % n)\n", "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    data = [int(x) for x in sys.stdin.readline().split()]\n    data.sort()\n    print(data)\n\nmain()\n", "\nn, k = map(int, input().split())\nthrows = input().split()\n\ncurrent_student = 0\ncurrent_throw = 0\n\nwhile current_throw < k:\n    if throws[current_throw].isdigit():\n        current_student = (current_student + int(throws[current_throw])) % n\n        current_throw += 1\n    else:\n        m = int(throws[current_throw][5:])\n        for _ in range(m):\n            current_throw -= 1\n            if throws[current_throw].isdigit():\n                current_student = (current_student - int(throws[current_throw])) % n\n            else:\n                m = int(throws[current_throw][5:])\n                for _ in range(m):\n                    current_throw -= 1\n                    current_student = (current_student + int(throws[current_throw])) % n\n\nprint(current_student)\n", "\n\n# Program starts here \nn, k = map(int, input().split())\ncommands = input().split()\n\negg = 0\n\nfor i in range(len(commands)):\n    if \"undo\" in commands[i]:\n        for j in range(int(commands[i][5:])):\n            if i - j - 1 >= 0:\n                egg -= int(commands[i-j-1])\n            elif i - j - 1 < 0:\n                egg -= int(commands[0])\n    else:\n        egg += int(commands[i])\n\nprint(egg % n)\n", "\n\n# Program for circular linked list\nn, k = map(int, input().split())\n\nchildren = [0] * n\n\nchildren[0] = 1\n\nfor i in range(k):\n    command = input()\n    if command[0:4] == \"undo\":\n        command = command.split()\n        for j in range(int(command[1])):\n            children[j] = 0\n    else:\n        command = int(command)\n        if command < 0:\n            children[(command % n) + n] = 1\n        else:\n            children[command % n] = 1\n\nfor i in range(n):\n    if children[i] == 1:\n        print(i)\n        break\n", "import math\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(math.gcd(a,b))\n", "#!/usr/bin/python\nimport sys\n\ndef main():\n    print \"Hello World\"\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = sys.stdin.readline().split()\n    current_child = 0\n    undo_commands = []\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command)+1]))\n        elif command == '0' or command == '-0':\n            pass\n        else:\n            current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop()\n        undo_index = commands.index('undo')\n        undo_commands_to_remove = []\n        for i in range(undo_command):\n            undo_index -= 1\n            if commands[undo_index] == 'undo':\n                undo_commands_to_remove.append(undo_index)\n            else:\n                current_child -= int(commands[undo_index])\n        for i in undo_commands_to_remove:\n            commands.pop(i)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    commands = sys.stdin.readline().split()\n    student = 0\n    undo = []\n    for command in commands:\n        if command == \"undo\":\n            student = undo.pop()\n        else:\n            student = (student + int(command)) % n\n            undo.append(student)\n    print(student)\n\nmain()\n", "\n\n#Program\nn, k = map(int, input().split())\n\nchildren = [0] * n\n\nchildren[0] = 1\n\nfor i in range(k):\n    command = input()\n    if command[0:4] == \"undo\":\n        command = command.split()\n        for j in range(int(command[1])):\n            children[j] = 0\n    else:\n        command = int(command)\n        if command < 0:\n            children[(command % n) + n] = 1\n        else:\n            children[command % n] = 1\n\nfor i in range(n):\n    if children[i] == 1:\n        print(i)\n        break\n", "\n# Program starts here\nn, k = map(int, input().split())\ncommands = input().split()\negg = 0\nfor i in range(len(commands)):\n    if \"undo\" in commands[i]:\n        for j in range(int(commands[i][5:])):\n            if i - j - 1 >= 0:\n                egg -= int(commands[i-j-1])\n            elif i - j - 1 < 0:\n                egg -= int(commands[0])\n    else:\n        egg += int(commands[i])\nprint(egg % n)\n", "\n\n", "\n\n\n# Program starts here\nn = int(input())\n\nfor i in range(1, 11):\n    print(n, \"x\", i, \"=\", n * i)\n", "\nimport sys\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        newNode = Node(data)\n        if self.head is None:\n            self.head = newNode\n            return\n\n        lastNode = self.head\n        while lastNode.next is not None:\n            lastNode = lastNode.next\n        lastNode.next = newNode\n\n    def printList(self):\n        currNode = self.head\n        while currNode is not None:\n            print(currNode.data)\n            currNode = currNode.next\n\n    def delete(self, index):\n        currNode = self.head\n        if index == 0:\n            self.head = currNode.next\n            currNode = None\n            return\n\n        prevNode = None\n        count = 0\n        while currNode is not None and count != index:\n            prevNode = currNode\n            currNode = currNode.next\n            count += 1\n\n        if currNode is None:\n            return\n\n        prevNode.next = currNode.next\n        currNode = None\n\n    def length(self):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            count += 1\n            currNode = currNode.next\n        return count\n\n    def get(self, index):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            if count == index:\n                return currNode.data\n            count += 1\n            currNode = currNode.next\n        return -1\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, k = lines[0].split()\n    n, k = int(n), int(k)\n    commands = lines[1].split()\n\n    ll = LinkedList()\n    for i in range(n):\n        ll.insert(i)\n\n    curr_index = 0\n    for i in range(k):\n        command = commands[i]\n        if command == \"undo\":\n            m = int(commands[i+1])\n            for j in range(m):\n                curr_index = (curr_index - 1) % ll.length()\n                ll.delete(curr_index)\n            i += 1\n            continue\n        else:\n            t = int(command)\n            if t < 0:\n                t = n + t\n            curr_index = (curr_index + t) % ll.length()\n    print(ll.get(curr_index))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split()) # n is the number of students, k is the number of commands\n    commands = sys.stdin.readline().split()\n    student = 0 # current student\n    undo = [] # list of previous students\n    for command in commands:\n        # if the command is undo, the current student is the previous student\n        if command == \"undo\":\n            student = undo.pop()\n        else: # if the command is a number, add that number to the current student and mod by the number of students\n            student = (student + int(command)) % n\n            undo.append(student) # add the current student to the undo list\n    print(student)\n\nmain()\n", "\n#\nimport sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = sys.stdin.readline().split()\n    current_child = 0\n    undo_commands = []\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command)+1]))\n        elif command == '0' or command == '-0' or command == 'undo':\n            pass\n        else:\n            current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop()\n        undo_index = commands.index('undo')\n        undo_commands_to_remove = []\n        for i in range(undo_command):\n            undo_index -= 1\n            if commands[undo_index] == 'undo':\n                undo_commands_to_remove.append(undo_index)\n            else:\n                current_child -= int(commands[undo_index])\n        for i in undo_commands_to_remove:\n            commands.pop(i)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    commands = sys.stdin.readline().strip().split()\n    student = 0\n    undo = []\n    for command in commands:\n        if command == \"undo\":\n            student = undo.pop() % n\n        else:\n            student = (student + int(command)) % n\n            undo.append(student)\n    print(student)\n\nmain()\n", "\n# https://open.kattis.com/problems/simonsays\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    for i in range(n):\n        if sys.stdin.readline()[:10] == 'Simon says':\n            print(sys.stdin.readline()[11:])\n\nif __name__ == '__main__':\n    main()\n", "\n\nn, k = map(int, input().split())\ncommands = input().split()\n\negg = 0\n\nfor i in range(len(commands)):\n    if \"undo\" in commands[i]:\n        for j in range(int(commands[i][5:])):\n            if i - j - 1 >= 0:\n                egg -= int(commands[i - j - 1])\n            elif i - j - 1 < 0:\n                egg -= int(commands[0])\n    else:\n        egg += int(commands[i])\n\nprint(egg % n)\n", "import math\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(math.gcd(a, b))\n", "\nimport math\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(math.gcd(a,b))\n\n#fix syntax errors\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    commands = sys.stdin.readline().split()[:-1]\n    student = 0\n    undo = []\n    for command in commands:\n        if command == \"undo\":\n            student = undo.pop() % n\n        else:\n            student = (student + int(command)) % n\n            undo.append(student)\n    print(student)\n\nmain()\n", "\n\nn, k = map(int, input().split())  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0447\u0435\u043d\u0438\u043a\u043e\u0432, \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043e\u043c\u0430\u043d\u0434\nthrows = input().split()  # \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043c\u0430\u043d\u0434\n\ncurrent_student = 0  # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0443\u0447\u0435\u043d\u0438\u043a\u0430\ncurrent_throw = 0  # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u043a\u043e\u043c\u0430\u043d\u0434\u044b\n\nwhile current_throw < k:  # \u043f\u043e\u043a\u0430 \u043d\u0435 \u043f\u0435\u0440\u0435\u043f\u0440\u044b\u0433\u043d\u0443\u043b\u0438 \u043d\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044e\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443\n    if throws[current_throw].isdigit():  # \u0435\u0441\u043b\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u0447\u0438\u0441\u043b\u043e\u043c\n        current_student = (current_student + int(throws[current_throw]) % n) % n  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u043d\u043e\u043c\u0435\u0440\u0443 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0443\n        current_throw += 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u0432\u043f\u0435\u0440\u0451\u0434\n    else:\n        m = int(throws[current_throw][5:])  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043e\u043c\u0430\u043d\u0434 \u043d\u0430\u0437\u0430\u0434\n        for _ in range(m):  # \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043d\u0430\u0437\u0430\u0434\n            current_throw -= 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u043d\u0430\u0437\u0430\u0434\n            if throws[current_throw].isdigit():  # \u0435\u0441\u043b\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u0447\u0438\u0441\u043b\u043e\u043c\n                current_student = (current_student - int(throws[current_throw]) % n) % n  # \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u0437 \u043d\u043e\u043c\u0435\u0440\u0430 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0443\n            else:\n                m = int(throws[current_throw][5:])  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043e\u043c\u0430\u043d\u0434 \u043d\u0430\u0437\u0430\u0434\n                for _ in range(m):  # \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043d\u0430\u0437\u0430\u0434\n                    current_throw -= 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u043d\u0430\u0437\u0430\u0434\n                    current_student = (current_student + int(throws[current_throw]) % n) % n  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u043d\u043e\u043c\u0435\u0440\u0443 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0443\n\nprint(current_student)\n", "The following is a list of media in the city of Winnipeg, Manitoba, Canada.\nRadio\n\nAM\n\n* CBW (990 kHz) CBC Radio One\n* CFRW (1290 kHz) Sports Radio 1290\n* CBWK-FM-1 (1350 kHz) CBC Radio One\n* CKJS (810 kHz) CKJS\n* CKLQ (840 kHz) 840 CKLQ\n* CJOB (680 kHz) CJOB\n* CKDM (770 kHz) Country 7\n* CKCL (1010 kHz) Radio Humsafar\n* CJGV (1570 kHz) The Spirit\n\nFM\n\n* CBW-FM (89.3 MHz) CBC Radio 2\n* CBW-FM-1 (93.1 MHz) CBC Radio 2\n* CBW-FM-2 (97.1 MHz) CBC Radio 2\n* CBW-FM-3 (102.3 MHz) CBC Radio 2\n* CBW-FM-4 (106.1 MHz) CBC Radio 2\n* CBW-FM-5 (107.9 MHz) CBC Radio 2\n* CBW-FM-6 (99.9 MHz) CBC Radio 2\n* CBW-FM-7 (94.3 MHz) CBC Radio 2\n* CBW-FM-8 (103.9 MHz) CBC Radio 2\n* CBW-FM-9 (91.5 MHz) CBC Radio 2\n* CBW-FM-10 (96.7 MHz) CBC Radio 2\n* CBW-FM-11 (100.7 MHz) CBC Radio 2\n* CBW-FM-12 (105.5 MHz) CBC Radio 2\n* CBW-FM-13 (98.3 MHz) CBC Radio 2\n* CBW-FM-14 (104.7 MHz) CBC Radio 2\n* CBW-FM-15 (99.1 MHz) CBC Radio 2\n* CBW-FM-16 (101.5 MHz) CBC Radio 2\n* CBW-FM-17 (103.1 MHz) CBC Radio 2\n* CBW-FM-18 (97.9 MHz) CBC Radio 2\n* CBW-FM-19 (92.1 MHz) CBC Radio 2\n* CBW-FM-20 (95.3 MHz) CBC Radio 2\n* CBW-FM-21 (90.5 MHz) CBC Radio 2\n* CBW-FM-22 (94.9 MHz) CBC Radio 2\n* CBW-FM-23 (107.3 MHz) CBC Radio 2\n* CBW-FM-24 (105.9 MHz) CBC Radio 2\n* CBW-FM-25 (102.7 MHz) CBC Radio 2\n* CBW-FM-26 (100.3 MHz) CBC Radio 2\n* CBW-FM-27 (92.7 MHz) CBC Radio 2\n* CBW-FM-28 (106.7 MHz) CBC Radio 2\n* CBW-FM-29 (101.1 MHz) CBC Radio 2\n* CBW-FM-30 (93.9 MHz) CBC Radio 2\n* CBW-FM-31 (95.9 MHz) CBC Radio 2\n* CBW-FM-32 (104.3 MHz) CBC Radio 2\n* CBW-FM-33 (94.5 MHz) CBC Radio 2\n* CBW-FM-34 (98.9 MHz) CBC Radio 2\n* CBW-FM-35 (103.5 MHz) CBC Radio 2\n* CBW-FM-36 (95.5 MHz) CBC Radio 2\n* CBW-FM-37 (99.5 MHz) CBC Radio 2\n* CBW-FM-38 (100.9 MHz) CBC Radio 2\n* CBW-FM-39 (97.5 MHz) CBC Radio 2\n* CBW-FM-40 (105.1 MHz) CBC Radio 2\n* CBW-FM-41 (104.1 MHz) CBC Radio 2\n* CBW-FM-42 (107.5 MHz) CBC Radio 2\n* CBW-FM-43 (103.7 MHz) CBC Radio 2\n* CBW-FM-44 (107.7 MHz) CBC Radio 2\n* CBW-FM-45 (102.9 MHz) CBC Radio 2\n* CBW-FM-46 (105.3 MHz) CBC Radio 2\n* CBW-FM-47 (97.7 MHz) CBC Radio 2\n* CBW-FM-48 (94.1 MHz) CBC Radio 2\n* CBW-FM-49 (101.7 MHz) CBC Radio 2\n* CBW-FM-50 (106.5 MHz) CBC Radio 2\n* CBW-FM-51 (93.7 MHz) CBC Radio 2\n* CBW-FM-52 (96.5 MHz) CBC Radio 2\n* CBW-FM-53 (92.9 MHz) CBC Radio 2\n* CBW-FM-54 (99.7 MHz) CBC Radio 2\n* CBW-FM-55 (101.3 MHz) CBC Radio 2\n* CBW-FM-56 (91.1 MHz) CBC Radio 2\n* CBW-FM-57 (90.9 MHz) CBC Radio 2\n* CBW-FM-58 (91.3 MHz) CBC Radio 2\n* CBW-FM-59 (91.7 MHz) CBC Radio 2\n* CBW-FM-60 (104.9 MHz) CBC Radio 2\n* CBW-FM-61 (107.1 MHz) CBC Radio 2\n* CBW-FM-62 (107.11 MHz) CBC Radio 2\n* CBW-FM-63 (105.7 MHz) CBC Radio 2\n* CBW-FM-64 (95.7 MHz) CBC Radio 2\n* CBW-FM-65 (99.3 MHz) CBC Radio 2\n* CBW-FM-66 (101.9 MHz) CBC Radio 2\n* CBW-FM-67 (103.3 MHz) CBC Radio 2\n* CBW-FM-68 (96.3 MHz) CBC Radio 2\n* CBW-FM-69 (92.5 MHz) CBC Radio 2\n* CBW-FM-70 (107.13 MHz) CBC Radio 2\n* CBW-FM-71 (107.15 MHz) CBC Radio 2\n* CBW-FM-72 (107.17 MHz) CBC Radio 2\n* CBW-FM-73 (107.19 MHz) CBC Radio 2\n* CBW-FM-74 (107.21 MHz) CBC Radio 2\n* CBW-FM-75 (107.23 MHz) CBC Radio 2\n* CBW-FM-76 (107.25 MHz) CBC Radio 2\n* CBW-FM-77 (107.27 MHz) CBC Radio 2\n* CBW-FM-78 (107.29 MHz) CBC Radio 2\n* CBW-FM-79 (107.31 MHz) CBC Radio 2\n* CBW-FM-80 (107.33 MHz) CBC Radio 2\n* CBW-FM-81 (107.35 MHz) CBC Radio 2\n* CBW-FM-82 (107.37 MHz) CBC Radio 2\n* CBW-FM-83 (107.39 MHz) CBC Radio 2\n* CBW-FM-84 (107.41 MHz) CBC Radio 2\n* CBW-FM-85 (107.43 MHz) CBC Radio 2\n* CBW-FM-86 (107.45 MHz) CBC Radio 2\n* CBW-FM-87 (107.47 MHz) CBC Radio 2\n* CBW-FM-88 (107.49 MHz) CBC Radio 2\n* CBW-FM-89 (107.51 MHz) CBC Radio 2\n* CBW-FM-90 (107.53 MHz) CBC Radio 2\n* CBW-FM-91 (107.55 MHz) CBC Radio 2\n* CBW-FM-92 (107.57 MHz) CBC Radio 2\n* CBW-FM-93 (107.59 MHz) CBC Radio 2\n* CBW-FM-94 (107.61 MHz) CBC Radio 2\n* CBW-FM-95 (107.63 MHz) CBC Radio 2\n* CBW-FM-96 (107.65 MHz) CBC Radio 2\n* CBW-FM-97 (107.67 MHz) CBC Radio 2\n* CBW-FM-98 (107.69 MHz) CBC Radio 2\n* CBW-FM-99 (107.71 MHz) CBC Radio 2\n* CBW-FM-100 (107.73 MHz) CBC Radio 2\n* CBW-FM-101 (107.75 MHz) CBC Radio 2\n* CBW-FM-102 (107.77 MHz) CBC Radio 2\n* CBW-FM-103 (107.79 MHz) CBC Radio 2\n* CBW-FM-104 (107.81 MHz) CBC Radio 2\n", "\n\n# program starts\nn, k = map(int, input().split())\ncommands = input().split()\n\negg = 0\n\nfor i in range(len(commands)):\n    if \"undo\" in commands[i]:\n        for j in range(int(commands[i][5:])):\n            if i - j - 1 >= 0:\n                egg -= int(commands[i-j-1])\n            elif i - j - 1 < 0:\n                egg -= int(commands[0])\n    else:\n        egg += int(commands[i])\n\nprint(egg % n)\n", "\nimport sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = sys.stdin.readline().split()\n    current_child = 0\n    undo_commands = []\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command)+1]))\n        elif command == '0' or command == '-0':\n            pass\n        else:\n            current_child += int(command)\n    if len(undo_commands) > 0:\n        while undo_commands:\n            undo_command = undo_commands.pop()\n            undo_index = commands.index('undo')\n            undo_commands_to_remove = []\n            for i in range(undo_command):\n                undo_index -= 1\n                if commands[undo_index] == 'undo':\n                    undo_commands_to_remove.append(undo_index)\n                else:\n                    current_child -= int(commands[undo_index])\n            for i in undo_commands_to_remove:\n                commands.pop(i)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# #Program for circular linked list\n# n, k = map(int, input().split())\n#\n# children = [0] * n\n#\n# children[0] = 1\n#\n# for i in range(k):\n#     command = input()\n#     if command[0:4] == \"undo\":\n#         command = command.split()\n#         for j in range(int(command[1])):\n#             children[j] = 0\n#     else:\n#         command = int(command)\n#         if command < 0:\n#             children[(command % n) + n] = 1\n#         else:\n#             children[command % n] = 1\n#\n# for i in range(n):\n#     if children[i] == 1:\n#         print(i)\n#         break\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    commands = sys.stdin.readline().split()\n    student = 0\n    undo = []\n    for command in commands:\n        if command == \"undo\":\n            student = undo.pop(0)\n        else:\n            undo.append(student)\n            student = (student + int(command)) % n\n    print(student)\n\nmain()\n", "n, k = map(int, input().split())\nthrows = input().split()\ncurrent_student = 0\ncurrent_throw = 0\nwhile current_throw < k:\n    if throws[current_throw].isdigit():\n        current_student = (current_student + int(throws[current_throw]) % n) % n\n        current_throw += 1\n    else:\n        m = int(throws[current_throw][5:])\n        for _ in range(m):\n            current_throw -= 1\n            if throws[current_throw].isdigit():\n                current_student = (current_student - int(throws[current_throw]) % n) % n\n            else:\n                m = int(throws[current_throw][5:])\n                for _ in range(m):\n                    current_throw -= 1\n                    current_student = (current_student + int(throws[current_throw]) % n) % n\nprint(current_student)\n", "\nn, k = map(int, input().split())  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0447\u0435\u043d\u0438\u043a\u043e\u0432, \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432\nthrows = input().split()  # \u0441\u043f\u0438\u0441\u043e\u043a \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432\n\ncurrent_student = 0  # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0443\u0447\u0435\u043d\u0438\u043a\u0430\ncurrent_throw = 0  # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u0430\n\nwhile current_throw < k:  # \u043f\u043e\u043a\u0430 \u043d\u0435 \u043f\u0435\u0440\u0435\u043f\u0440\u044b\u0433\u043d\u0443\u043b\u0438 \u043d\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n    if throws[current_throw].isdigit():  # \u0435\u0441\u043b\u0438 \u0440\u0430\u0437\u0431\u0440\u043e\u0441 \u0447\u0438\u0441\u043b\u043e\u043c\n        current_student = (current_student + int(throws[current_throw]) % n) % n  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u043d\u043e\u043c\u0435\u0440\u0443 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n        current_throw += 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u0432\u043f\u0435\u0440\u0451\u0434\n    else:\n        m = int(throws[current_throw][5:])  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432 \u043d\u0430\u0437\u0430\u0434\n        for _ in range(m):  # \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u044b \u043d\u0430\u0437\u0430\u0434\n            current_throw -= 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u043d\u0430\u0437\u0430\u0434\n            if throws[current_throw].isdigit():  # \u0435\u0441\u043b\u0438 \u0440\u0430\u0437\u0431\u0440\u043e\u0441 \u0447\u0438\u0441\u043b\u043e\u043c\n                current_student = (current_student - int(throws[current_throw]) % n) % n  # \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u0437 \u043d\u043e\u043c\u0435\u0440\u0430 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n            else:\n                m = int(throws[current_throw][5:])  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432 \u043d\u0430\u0437\u0430\u0434\n                for _ in range(m):  # \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u044b \u043d\u0430\u0437\u0430\u0434\n                    current_throw -= 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u043d\u0430\u0437\u0430\u0434\n                    current_student = (current_student + int(throws[current_throw]) % n) % n  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u043d\u043e\u043c\u0435\u0440\u0443 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n\nprint(current_student)\n", "\n\n# Program \nn, k = map(int, input().split())\n\nchildren = [0] * n\n\nchildren[0] = 1\n\nfor i in range(k):\n    command = input()\n    if command[0:4] == \"undo\":\n        command = command.split()\n        for j in range(int(command[1])):\n            children[j] = 0\n    else:\n        command = int(command)\n        if command < 0:\n            children[(command % n) + n] = 1\n        else:\n            children[command % n] = 1\n\nfor i in range(n):\n    if children[i] == 1:\n        print(i)\n        break\n", "\n\nimport math\n\nprint(math.factorial(3))\n", "\n#!/usr/bin/python\nimport sys\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        newNode = Node(data)\n        if self.head is None:\n            self.head = newNode\n            return\n\n        lastNode = self.head\n        while lastNode.next is not None:\n            lastNode = lastNode.next\n        lastNode.next = newNode\n\n    def printList(self):\n        currNode = self.head\n        while currNode is not None:\n            print currNode.data\n            currNode = currNode.next\n\n    def delete(self, index):\n        currNode = self.head\n        if index == 0:\n            self.head = currNode.next\n            currNode = None\n            return\n\n        prevNode = None\n        count = 0\n        while currNode is not None and count != index:\n            prevNode = currNode\n            currNode = currNode.next\n            count += 1\n\n        if currNode is None:\n            return\n\n        prevNode.next = currNode.next\n        currNode = None\n\n    def length(self):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            count += 1\n            currNode = currNode.next\n        return count\n\n    def get(self, index):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            if count == index:\n                return currNode.data\n            count += 1\n            currNode = currNode.next\n        return -1\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, k = lines[0].split()\n    n, k = int(n), int(k)\n    commands = lines[1].split()\n\n    ll = LinkedList()\n    for i in range(n):\n        ll.insert(i)\n\n    curr_index = 0\n    for i in range(k):\n        command = commands[i]\n        if command == \"undo\":\n            m = int(commands[i+1])\n            for j in range(m):\n                ll.delete(curr_index)\n            i += 1\n            continue\n        else:\n            t = int(command)\n            if t < 0:\n                t = n + t\n            curr_index = (curr_index + t) % ll.length()\n    print ll.get(curr_index)\n\nif __name__ == '__main__':\n    main()\n", "\nn, k = map(int, input().split())\nthrows = input().split()\n\ncurrent_student = 1\ncurrent_throw = 0\n\n\nwhile current_throw < k:\n    if throws[current_throw].isdigit():\n        current_student = (current_student + int(throws[current_throw])) % n\n        current_throw += 1\n    else:\n        m = int(throws[current_throw][5:])\n        for _ in range(m):\n            current_throw -= 1\n            if throws[current_throw].isdigit():\n                current_student = (current_student - int(throws[current_throw])) % n\n            else:\n                m = int(throws[current_throw][5:])\n                for _ in range(m):\n                    current_throw -= 1\n                    current_student = (current_student + int(throws[current_throw])) % n\n\nprint(current_student)\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    commands = [i for i in sys.stdin.readline().split()]\n    current_child = 0\n    undo_commands = []\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command) + 1]))\n        elif command == '0' or command == '-0':\n            pass\n        else:\n            current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop()\n        undo_index = commands.index('undo')\n        undo_commands_to_remove = [commands.index('undo')]\n        for i in range(undo_command):\n            undo_index -= 1\n            if commands[undo_index] == 'undo':\n                undo_commands_to_remove.append(undo_index)\n            else:\n                current_child -= int(commands[undo_index])\n        for i in undo_commands_to_remove:\n            commands.pop(i)\n    if current_child < 0:\n        current_child += n\n    if current_child > n:\n        current_child %= n\n    if current_child == 0:\n        current_child = n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = [i for i in sys.stdin.readline().split()]\n    current_child = 0\n    undo_commands = []\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command) + 1]))\n        else:\n            if command == '0' or command == '-0':\n                pass\n            else:\n                current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop()\n        undo_index = commands.index('undo')\n        undo_commands_to_remove = [commands.index('undo')]\n        for i in range(undo_command):\n            undo_index -= 1\n            if commands[undo_index] == 'undo':\n                undo_commands_to_remove.append(undo_index)\n            else:\n                current_child -= int(commands[undo_index])\n        for i in undo_commands_to_remove:\n            commands.pop(i)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    elif current_child == 0:\n        current_child = n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef find_missing(lst):\n    lst = sorted(lst)\n    for i in range(len(lst)):\n        if lst[i] != i:\n            return i\n\nprint(find_missing([0, 1, 2, 4, 5, 6, 7]))\nprint(find_missing([1, 2, 3, 4, 6, 7, 8]))\nprint(find_missing([0, 1, 2, 3, 4, 5, 6, 7, 9]))\n", "import sys\n\ndef main():\n    n, k = map(int, input().split())\n    commands = input().split()\n    egg = 0\n    for command in commands:\n        if command == 'undo':\n            k -= 1\n            if k == 0:\n                break\n            continue\n        command = int(command)\n        egg = (egg + command) % n\n        if egg < 0:\n            egg += n\n    print(egg)\n\nmain()\n", "\n# Program\nn, k = map(int, input().split())\n\nchildren = [0] * n\n\nchildren[0] = 1\n\nfor i in range(k):\n    command = input()\n    if command[0:4] == \"undo\":\n        command = command.split()\n        for j in range(int(command[1])):\n            children[j] = 0\n    else:\n        command = int(command)\n        if command < 0:\n            children[(command % n) + n] = 1\n        else:\n            children[command % n] = 1\n\nfor i in range(n):\n    if children[i] == 1:\n        print(i)\n        break\n", "\n\nn, k = map(int, input().split())  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0447\u0435\u043d\u0438\u043a\u043e\u0432, \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432\nthrows = input().split()  # \u0441\u043f\u0438\u0441\u043e\u043a \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432\n\ncurrent_student = 0  # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0443\u0447\u0435\u043d\u0438\u043a\u0430\ncurrent_throw = 0  # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u0430\n\nwhile current_throw < k:  # \u043f\u043e\u043a\u0430 \u043d\u0435 \u043f\u0435\u0440\u0435\u043f\u0440\u044b\u0433\u043d\u0443\u043b\u0438 \u043d\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n    if throws[current_throw].isdigit():  # \u0435\u0441\u043b\u0438 \u0440\u0430\u0437\u0431\u0440\u043e\u0441 \u0447\u0438\u0441\u043b\u043e\u043c\n        current_student = (current_student + int(throws[current_throw]) % n) % n  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u043d\u043e\u043c\u0435\u0440\u0443 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n        current_throw += 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u0432\u043f\u0435\u0440\u0451\u0434\n    else:\n        m = int(throws[current_throw][5:])  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432 \u043d\u0430\u0437\u0430\u0434\n        for _ in range(m):  # \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u044b \u043d\u0430\u0437\u0430\u0434\n            current_throw -= 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u043d\u0430\u0437\u0430\u0434\n            if throws[current_throw].isdigit():  # \u0435\u0441\u043b\u0438 \u0440\u0430\u0437\u0431\u0440\u043e\u0441 \u0447\u0438\u0441\u043b\u043e\u043c\n                current_student = (current_student - int(throws[current_throw]) % n) % n  # \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u0437 \u043d\u043e\u043c\u0435\u0440\u0430 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n            else:\n                m = int(throws[current_throw][5:])  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u043e\u0432 \u043d\u0430\u0437\u0430\u0434\n                for _ in range(m):  # \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u044b \u043d\u0430\u0437\u0430\u0434\n                    current_throw -= 1  # \u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c\u0441\u044f \u043d\u0430\u0437\u0430\u0434\n                    current_student = (current_student + int(throws[current_throw]) % n) % n  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a \u043d\u043e\u043c\u0435\u0440\u0443 \u0443\u0447\u0435\u043d\u0438\u043a\u0430 \u0440\u0430\u0437\u0431\u0440\u043e\u0441\n\nprint(current_student)\n", "\nimport sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = sys.stdin.readline().split()\n    current_child = 0\n    undo_commands = [0]\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command) + 1]))\n        elif command == '0' or command == '-0':\n            pass\n        else:\n            current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop(0)\n        undo_index = commands.index('undo') + 1\n        undo_commands_to_remove = []\n        for i in range(undo_command):\n            try:\n                if commands[undo_index] == 'undo':\n                    undo_commands_to_remove.append(undo_index)\n                else:\n                    current_child -= int(commands[undo_index])\n            except IndexError:\n                undo_commands_to_remove.append(undo_index)\n            undo_index += 1\n        for i in undo_commands_to_remove:\n            commands.pop(i - 1)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "#! /usr/bin/env python3\n\nn, k = map(int, input().split())\nthrows = input().split()\n\nposition = 0\n\nfor i in range(k):\n    if throws[i] == 'undo':\n        position -= int(throws[i+1])\n    else:\n        position = int(throws[i])\n        if position > n-1:\n            position -= n\n        elif position < 0:\n            position += n\n\nprint(position)\n", "\nn, k = map(int, input().split())\n\nchildren = [0] * n\n\nchildren[0] = 1\n\nfor i in range(k):\n    command = input()\n    if command[0:4] == \"undo\":\n        command = command.split()\n        for j in range(int(command[1])):\n            children[j] = 0\n    else:\n        command = int(command)\n        if command < 0:\n            children[(command % n) + n] = 0\n        else:\n            children[command % n] = 1\n\nfor i in range(n):\n    if children[i] == 1:\n        print(i)\n        break\n", "\n\nimport sys\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    commands = [i for i in sys.stdin.readline().split()]\n    current_child = 0\n    undo_commands = []\n    for command in commands:\n        if command == 'undo':\n            undo_commands.append(int(commands[commands.index(command) + 1]))\n        elif command == '0' or command == '-0':\n            pass\n        else:\n            current_child += int(command)\n    while undo_commands:\n        undo_command = undo_commands.pop()\n        undo_index = commands.index('undo')\n        undo_commands_to_remove = [undo_index]\n        for i in range(undo_command):\n            undo_index -= 1\n            if commands[undo_index] == 'undo':\n                undo_commands_to_remove.append(undo_index)\n            else:\n                current_child -= int(commands[undo_index])\n        for i in undo_commands_to_remove:\n            commands.pop(i, None)\n    if current_child < 0:\n        current_child += n\n    elif current_child > n:\n        current_child %= n\n    elif current_child == 0:\n        current_child = n\n    print(current_child)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    pass\n\nmain()\n", "# https://www.codechef.com/problems/CRDGAME3\n\nn, k = map(int, input().split())\nthrows = input().split()\n\nposition = 0\n\nfor i in range(k):\n    if throws[i] == 'undo':\n        position += int(throws[i + 1])\n    else:\n        position += int(throws[i])\n        if position > n - 1:\n            position -= n\n        elif position < 0:\n            position += n\n\nprint(position)\n", "\n\n# Programm\nn, k = map(int, input().split())\n\nchildren = [0] * n\n\nchildren[0] = 1\n\nfor i in range(k):\n    command = input()\n    if command[0:4] == \"undo\":\n        command = command.split()\n        for j in range(int(command[1])):\n            children[j] = 0\n    else:\n        command = int(command)\n        if command < 0:\n            children[(command % n) + n] = 1\n        else:\n            children[command % n] = 1\n\nfor i in range(n):\n    if children[i] == 1:\n        print(i)\n        break\n", "import sys\n\ndef read_file(filepath):\n    file = open(filepath, 'r')\n    lines = file.readlines()\n    file.close()\n    return lines\n\ndef write_file(filepath, lines):\n    file = open(filepath, 'w')\n    file.writelines(lines)\n    file.close()\n\ndef main():\n    lines = read_file(sys.argv[1])\n    write_file(sys.argv[2], lines)\n\nif __name__ == '__main__':\n    main()\n", "#! /usr/bin/env python3\n\nn, k = map(int, input().split())  # n = number of cards, k = number of throws\nthrows = input().split()\n\nposition = 0\n\nfor i in range(k):\n    if throws[i] == 'undo':  # undo the last throw\n        position += int(throws[i+1])\n    else:  # add the value of the throw to the current position\n        position += int(throws[i])\n        if position > n-1:  # if the position is out of bounds, bring it back\n            position -= n  # can be done with modulo, but this is faster\n        elif position < 0:  # if the position is out of bounds, bring it back\n            position += n  # can be done with modulo, but this is faster\n\nprint(position)\n", "import sys\nsys.stdin = open('input.txt', 'r')\n\ndef check(i, j, k):\n    global cnt\n    if k == 7:\n        cnt += 1\n        return\n    if i + 1 < N and j + 1 < N:\n        if board[i][j] == board[i + 1][j + 1]:\n            check(i + 1, j + 1, k + 1)\n    if i + 1 < N:\n        if board[i][j] == board[i + 1][j]:\n            check(i + 1, j, k + 1)\n    if j + 1 < N:\n        if board[i][j] == board[i][j + 1]:\n            check(i, j + 1, k + 1)\n\n\nT = int(input())\nfor tc in range(1, T + 1):\n    N = int(input())\n    board = [list(map(int, input().split())) for _ in range(N)]\n    cnt = 0\n    for i in range(N):\n        for j in range(N):\n            check(i, j, 1)\n    print('#{} {}'.format(tc, cnt))\n", "\"\"\"\nIn this problem you will be given a list of commands that can be executed on a circular list.\nEach command is either an integer or an undo command. An undo command will undo the previous command\nif it was an integer command.\nIf the command was an undo command, nothing happens.\nThe integer command will move the current position of the list the specified amount of positions.\nThe list is circular, so if the current position is 5 and the command is -2, the new position will be 3.\nIf the current position is 5 and the command is 3, the new position will be 1.\nAfter the list of commands, on the last line, there will be a single integer, the index that should be printed.\nThe list starts at position 0.\n\"\"\"\n\nimport sys\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        newNode = Node(data)\n        if self.head is None:\n            self.head = newNode\n            return\n\n        lastNode = self.head\n        while lastNode.next is not None:\n            lastNode = lastNode.next\n        lastNode.next = newNode\n\n    def printList(self):\n        currNode = self.head\n        while currNode is not None:\n            print(currNode.data)\n            currNode = currNode.next\n\n    def delete(self, index):\n        currNode = self.head\n        if index == 0:\n            self.head = currNode.next\n            currNode = None\n            return\n\n        prevNode = None\n        count = 0\n        while currNode is not None and count != index:\n            prevNode = currNode\n            currNode = currNode.next\n            count += 1\n\n        if currNode is None:\n            return\n\n        prevNode.next = currNode.next\n        currNode = None\n\n    def length(self):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            count += 1\n            currNode = currNode.next\n        return count\n\n    def get(self, index):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            if count == index:\n                return currNode.data\n            count += 1\n            currNode = currNode.next\n        return -1\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, k = [int(i) for i in lines[0].split()]\n    commands = lines[1].split()\n\n    ll = LinkedList()\n    for i in range(n):\n        ll.insert(i)\n\n    curr_index = 0\n    for i in range(k):\n        command = commands[i]\n        if command == \"undo\":\n            m = int(commands[i + 1])\n            for j in range(m):\n                ll.delete(curr_index)\n            i += 1\n            continue\n        else:\n            t = int(command)\n            if t < 0:\n                t = n + t\n            curr_index = (curr_index + t) % ll.length()\n    print(ll.get(curr_index))\n\nif __name__ == '__main__':\n    main()\n", "#! /usr/bin/env python3\n\nn, k = map(int, input().split())\nthrows = input().split()\n\npos = 0\n\nfor i in range(k):\n    if throws[i] == 'undo':\n        pos += int(throws[i+1])\n    else:\n        pos += int(throws[i])\n        if pos > n-1:\n            pos -= n\n        elif pos < 0:\n            pos += n\n\nprint(pos)\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().strip().split())\n    commands = sys.stdin.readline().strip().split()\n    egg = 0\n    for command in commands:\n        if command == 'undo' and k != 0:\n            k -= 1\n            egg = int(sys.stdin.readline().strip())\n            continue\n        command = int(command)\n        egg = (egg + command) % n\n        if egg < 0:\n            egg += n\n    print(egg)\n\nmain()\n", "\nn, k = map(int, input().split())\nthrows = input().split()\ncurrent_student = 0\ncurrent_throw = 0\nwhile current_throw < k:\n    if throws[current_throw].isdigit():\n        current_student = (current_student + int(throws[current_throw])) % n\n        current_throw += 1\n    else:\n        m = int(throws[current_throw][5:])\n        for _ in range(m):\n            current_throw -= 1\n            if throws[current_throw].isdigit():\n                current_student = (current_student - int(throws[current_throw])) % n\n            else:\n                m = int(throws[current_throw][5:])\n                for _ in range(m):\n                    current_throw -= 1\n                    current_student = (current_student + int(throws[current_throw]) % n) % n\nprint(current_student)\n", "\"\"\"\nIn this problem you will be given a list of commands that can be executed on a circular list.\nEach command is either an integer or an undo command. An undo command will undo the previous command\nif it was an integer command.\nIf the command was an undo command, nothing happens.\nThe integer command will move the current position of the list the specified amount of positions.\nThe list is circular, so if the current position is 5 and the command is -2, the new position will be 3.\nIf the current position is 5 and the command is 3, the new position will be 1.\nAfter the list of commands, on the last line, there will be a single integer, the index that should be printed.\nThe list starts at position 0.\n\"\"\"\n\nimport sys\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        newNode = Node(data)\n        if self.head is None:\n            self.head = newNode\n            return\n\n        lastNode = self.head\n        while lastNode.next is not None:\n            lastNode = lastNode.next\n        lastNode.next = newNode\n\n    def printList(self):\n        currNode = self.head\n        while currNode is not None:\n            print(currNode.data)\n            currNode = currNode.next\n\n    def delete(self, index):\n        currNode = self.head\n        if index == 0:\n            self.head = currNode.next\n            currNode = None\n            return\n\n        prevNode = None\n        count = 0\n        while currNode is not None and count != index:\n            prevNode = currNode\n            currNode = currNode.next\n            count += 1\n\n        if currNode is None:\n            return\n\n        prevNode.next = currNode.next\n        currNode = None\n\n    def length(self):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            count += 1\n            currNode = currNode.next\n        return count\n\n    def get(self, index):\n        currNode = self.head\n        count = 0\n        while currNode is not None:\n            if count == index:\n                return currNode.data\n            count += 1\n            currNode = currNode.next\n        return -1\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, k = map(int, lines[0].split())\n    commands = lines[1].split()\n\n    ll = LinkedList()\n    for i in range(n):\n        ll.insert(i)\n\n    curr_index = 0\n    for i in range(k):\n        command = commands[i]\n        if command == \"undo\":\n            undo = int(commands[i+1])\n            for j in range(undo):\n                ll.delete(curr_index)\n            i += 1\n            continue\n        else:\n            shift = int(command)\n            if shift < 0:\n                shift = n + shift\n            curr_index = (curr_index + shift) % ll.length()\n    print(ll.get(curr_index))\n\nif __name__ == '__main__':\n    main()\n", "\nn, k = map(int, input().split())  # n - number of students, k - number of throws\nthrows = input().split()\n\ncurrent_student = 0  # current student\ncurrent_throw = 0  # current throw\n\nwhile current_throw < k:  # while current throw is less than total number of throws\n    if throws[current_throw].isdigit():  # if current throw is digit\n        current_student = (current_student + int(throws[current_throw]) % n) % n  # add to current student\n        current_throw += 1  # increase current throw\n    else:\n        m = int(throws[current_throw][5:])  # if current throw is not digit\n        for _ in range(m):  # add to current student\n            current_throw -= 1  # decrease current throw\n            if throws[current_throw].isdigit():  # if current throw is digit\n                current_student = (current_student - int(throws[current_throw]) % n) % n  # subtract from current student\n            else:\n                m = int(throws[current_throw][5:])  # if current throw is not digit\n                for _ in range(m):  # subtract from current student\n                    current_throw -= 1  # decrease current throw\n                    current_student = (current_student + int(throws[current_throw]) % n) % n  # add to current student\n\nprint(current_student)\n"]