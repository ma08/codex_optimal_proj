["import sys\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\nEDGE=EDGE[:k]\n\nCOST_vertex=[[] for i in range(n+1)]\nfor a,b,c in EDGE:\n    COST_vertex[a].append((b,c))\n    COST_vertex[b].append((a,c))\n\nfor i in range(min(m,k)):\n    x,y,c=EDGE[i]\n    EDGE[i]=(c,x,y)\n\n\nUSED_SET=set()\n\nANS=[-1<<50]*k\n\nimport heapq\n\nwhile EDGE:\n    c,x,y = heapq.heappop(EDGE)\n\n    if (x,y) in  USED_SET or c>=-ANS[0]:\n        continue\n\n    else:\n        heapq.heappop(ANS)\n        heapq.heappush(ANS,-c)\n        USED_SET.add((x,y))\n        USED_SET.add((y,x))\n\n    for to,cost in COST_vertex[x]:\n        if to!=y and not((y,to) in USED_SET) and c+cost<-ANS[0]:\n            heapq.heappush(EDGE,(c+cost,y,to))\n            #USED_SET.add((y,to))\n            #USED_SET.add((to,y))\n\n    for to,cost in COST_vertex[y]:\n        if to!=x and not((x,to) in USED_SET) and c+cost<-ANS[0]:\n            heapq.heappush(EDGE,(c+cost,x,to))\n            #USED_SET.add((x,to))\n            #USED_SET.add((to,x))\n\nprint(-ANS[0])\n            \n", "import sys\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\nEDGE=EDGE[:k]\n\nCOST_vertex=[[] for i in range(n+1)]\nVERLIST=[]\n\nfor a,b,c in EDGE:\n    COST_vertex[a].append((b,c))\n    COST_vertex[b].append((a,c))\n    VERLIST.append(a)\n    VERLIST.append(b)\n\nVERLIST=list(set(VERLIST))\n\nimport heapq\n\nANS=[-1<<50]*k\n\n\nfor start in VERLIST:\n    MINCOST=[1<<50]*(n+1)\n\n    checking=[(0,start)]\n    MINCOST[start]=0\n\n    j=0\n    while j<k:\n        if not(checking):\n            break\n        \n        cost,checktown=heapq.heappop(checking)\n        if cost>=-ANS[0]:\n            break\n\n        if MINCOST[checktown]<cost:\n            continue\n        \n        if cost!=0 and checktown>start:\n            heapq.heappop(ANS)\n            heapq.heappush(ANS,-cost)\n            j+=1\n            \n        for to,co in COST_vertex[checktown]:\n\n            if MINCOST[to]>cost+co:\n                MINCOST[to]=cost+co\n\n                heapq.heappush(checking,(cost+co,to))\n\nprint(-ANS[0])\n    \n    \n", "import sys\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\nEDGE=EDGE[:k]\n\nCOST_vertex=[[] for i in range(n+1)]\nVERLIST=[]\n\nfor a,b,c in EDGE:\n    COST_vertex[a].append((b,c))\n    COST_vertex[b].append((a,c))\n    VERLIST.append(a)\n    VERLIST.append(b)\n\nVERLIST=sorted((set(VERLIST)))\n\nimport heapq\n\nANS=[-1<<50]*k\n\n\nfor start in VERLIST:\n    MINCOST=[1<<50]*(n+1)\n\n    checking=[(0,start)]\n    MINCOST[start]=0\n\n    j=0\n    while j<k:\n        if not(checking):\n            break\n        \n        cost,checktown=heapq.heappop(checking)\n        if cost>=-ANS[0]:\n            break\n\n        if MINCOST[checktown]<cost:\n            continue\n        \n        if cost!=0 and checktown>start:\n            heapq.heappop(ANS)\n            heapq.heappush(ANS,-cost)\n            j+=1\n            \n        for to,co in COST_vertex[checktown]:\n\n            if MINCOST[to]>cost+co:\n                MINCOST[to]=cost+co\n\n                heapq.heappush(checking,(cost+co,to))\n\nprint(-ANS[0])\n    \n    \n", "import sys\ninput = sys.stdin.readline\nN, M, K = list(map(int, input().split()))\nX = []\nfor _ in range(M):\n    x, y, w = list(map(int, input().split()))\n    X.append([min(x,y), max(x,y), w])\nX = (sorted(X, key = lambda x: x[2])+[[0, 0, 10**20] for _ in range(K)])[:K]\nD = {}\nfor x, y, w in X:\n    if x: D[x*10**6+y] = w\n\nflg = 1\nwhile flg:\n    flg = 0\n    for i in range(len(X)):\n        x1, y1, w1 = X[i]\n        for j in range(i+1, len(X)):\n            x2, y2, w2 = X[j]\n            if x1==x2: a, b = min(y1,y2), max(y1,y2)\n            elif y1==y2: a, b = min(x1,x2), max(x1,x2)\n            elif x1==y2: a, b = x2, y1\n            elif x2==y1: a, b = x1, y2\n            else: a, b = 0, 0\n            if a:\n                if (a*10**6+b in D and w1+w2 < D[a*10**6+b]) or (a*10**6+b not in D and w1+w2 < X[-1][2]):\n                    if a*10**6+b in D:\n                        for k in range(len(X)):\n                            if X[k][0] == a and X[k][1] == b:\n                                X[k][2] = w1+w2\n                    else:\n                        x, y, w = X.pop()\n                        if x: D.pop(x*10**6+y)\n                        X.append([a,b,w1+w2])\n                    D[a*10**6+b] = w1+w2\n                    X = sorted(X, key = lambda x: x[2])\n                    flg = 1\n                    break\n        if flg:\n            break\nprint(X[-1][2])\n", "import sys\ninput = sys.stdin.readline\nN, M, K = list(map(int, input().split()))\nX = []\nfor _ in range(M):\n    x, y, w = list(map(int, input().split()))\n    X.append([min(x,y), max(x,y), w])\nX = (sorted(X, key = lambda x: x[2])+[[0, 0, 10**20] for _ in range(K)])[:K]\nD = {}\nfor x, y, w in X:\n    if x: D[x*10**6+y] = w\n\nflg = 1\nwhile flg:\n    flg = 0\n    for i in range(len(X)):\n        x1, y1, w1 = X[i]\n        for j in range(i+1, len(X)):\n            x2, y2, w2 = X[j]\n            if x1==x2: a, b = min(y1,y2), max(y1,y2)\n            elif y1==y2: a, b = min(x1,x2), max(x1,x2)\n            elif x1==y2: a, b = x2, y1\n            elif x2==y1: a, b = x1, y2\n            else: a, b = 0, 0\n            if a:\n                if (a*10**6+b in D and w1+w2 < D[a*10**6+b]) or (a*10**6+b not in D and w1+w2 < X[-1][2]):\n                    if a*10**6+b in D:\n                        for k in range(len(X)):\n                            if X[k][0] == a and X[k][1] == b:\n                                X[k][2] = w1+w2\n                    else:\n                        x, y, w = X.pop()\n                        if x: D.pop(x*10**6+y)\n                        X.append([a,b,w1+w2])\n                    D[a*10**6+b] = w1+w2\n                    X = sorted(X, key = lambda x: x[2])\n                    flg = 1\nprint(X[-1][2])\n", "import heapq\nn,m,k = list(map(int,input().split()))\nconnectionList = []\nfor _ in range(n):\n    connectionList.append([])\nedgeList = []\nfor _ in range(m):\n    x,y,w = list(map(int,input().split()))\n    edgeList.append((x,y,w))\nedgeList.sort(key = lambda x: x[2])\nif k < m:\n    maxDist = edgeList[min(m,k) - 1][2]\nelse:\n    maxDist = sum([x[2] for x in edgeList])\ncolorList = {}\ncolorVertex = []\nfor i in range(n):\n    colorList[i] = [i]\n    colorVertex.append(i)\n\nfor i in range(min(m,k)):\n    x,y,w = edgeList[i]\n    connectionList[x-1].append((y-1,w))\n    connectionList[y-1].append((x-1,w))\n    if colorVertex[x-1] != colorVertex[y-1]:\n        if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):\n            prevColor = colorVertex[y-1]\n            for elem in colorList[colorVertex[y-1]]:\n                colorVertex[elem] = colorVertex[x-1]\n                colorList[colorVertex[x-1]].append(elem)\n            del colorList[prevColor]\n        else:\n            prevColor = colorVertex[x-1]\n            for elem in colorList[colorVertex[x-1]]:\n                colorVertex[elem] = colorVertex[y-1]\n                colorList[colorVertex[y-1]].append(elem)\n            del colorList[prevColor]\n\npathList = []\nfor key in colorList:\n    vertexList = colorList[key]\n    for mainVertex in vertexList:\n        vertexPQueue = []\n        isCovered = {}\n        distanceDic = {}\n        for elem in vertexList:\n            isCovered[elem] = False\n            distanceDic[elem] = maxDist\n        isCovered[mainVertex] = True\n        for elem in connectionList[mainVertex]:\n            heapq.heappush(vertexPQueue,(elem[1],elem[0]))\n            distanceDic[elem[0]] = elem[1]\n        while vertexPQueue:\n            distance, curVertex = heapq.heappop(vertexPQueue)\n            if isCovered[curVertex]:\n                continue\n            elif distance >= maxDist:\n                break\n            for elem in connectionList[curVertex]:\n                if distance + elem[1] < distanceDic[elem[0]]:\n                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))\n                    distanceDic[elem[0]] = distance + elem[1]\n        for key in distanceDic:\n            if distanceDic[key] <= maxDist and key > mainVertex:\n                pathList.append(distanceDic[key])\n        if len(pathList) > k:\n            pathList.sort()\n            pathList = pathList[0:k]\n            if pathList[-1] < maxDist:\n                maxDist = pathList[-1]\npathList.sort()\nprint(pathList[k-1])\n                \n                \n"]