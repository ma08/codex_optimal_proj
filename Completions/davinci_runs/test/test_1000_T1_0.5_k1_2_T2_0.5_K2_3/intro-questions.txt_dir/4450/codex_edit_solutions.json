["import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(self.num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\n        self.adj_list[edge[1]].append((edge[0], edge[2]))\n        self.edges.add((edge[0], edge[1]))\n\n    def dijkstra(self, start):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > node[0] + adj_node[1]:\n                    dist[adj_node[0]] = node[0] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i)[j])\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n", "\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    return arr\n", "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(self.num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\") for _ in range(self.num_of_nodes)]\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n", "\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k-1]\n", "n, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [source]\n\n    while pq:\n        u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heappush(pq, v)\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "\ndef kth_distance(dist, k):\n    if dist:\n        dist.sort()\n        return dist[k - 1]\n    else:\n        return None\n", "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n", "from heapq import heappop, heappush\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 1)\ndist.sort()\n\nprint(dist[k])\n", "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n", "\n\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[\n                        0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n", "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n", "\n\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n", "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n", "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n", "#!/usr/bin/env python\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k - 1]\n"]