2022-04-12 20:50:55.722127 num operations 2
2022-04-12 20:50:55.722136 size on input set 1
2022-04-12 20:50:58.879500 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    }
  ],
  "created": 1649796655,
  "object": "edit"
}
2022-04-12 20:50:58.879745 fix spelling mistakes 3 ['\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n', '\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n']
2022-04-12 20:50:58.879879 size on output set 3
2022-04-12 20:50:58.879887 size on input set 3
2022-04-12 20:51:04.341992 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 1,
      "text": "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(self.num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\") for _ in range(self.num_of_nodes)]\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    }
  ],
  "created": 1649796658,
  "object": "edit"
}
2022-04-12 20:51:04.342217 fix syntax errors 3 ['import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', 'import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(self.num_of_nodes)]\n        self.edges = set()  # to avoid double count\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf") for _ in range(self.num_of_nodes)]\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []  # all shortest path\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n']
2022-04-12 20:51:07.878851 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n"
    },
    {
      "index": 1,
      "text": "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n"
    }
  ],
  "created": 1649796664,
  "object": "edit"
}
2022-04-12 20:51:07.879038 fix syntax errors 3 ['\n\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n', 'import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path_length(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path_length(k))\n']
2022-04-12 20:51:19.808899 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(self.num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\n        self.adj_list[edge[1]].append((edge[0], edge[2]))\n        self.edges.add((edge[0], edge[1]))\n\n    def dijkstra(self, start):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > node[0] + adj_node[1]:\n                    dist[adj_node[0]] = node[0] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i)[j])\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[\n                        0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    }
  ],
  "created": 1649796667,
  "object": "edit"
}
2022-04-12 20:51:19.809121 fix syntax errors 3 ['import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(self.num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        self.adj_list[edge[0]].append((edge[1], edge[2]))\n        self.adj_list[edge[1]].append((edge[0], edge[2]))\n        self.edges.add((edge[0], edge[1]))\n\n    def dijkstra(self, start):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > node[0] + adj_node[1]:\n                    dist[adj_node[0]] = node[0] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i)[j])\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\n\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[\n                        0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]: continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n']
2022-04-12 20:51:19.809250 size on output set 9
2022-04-12 20:51:19.809263 num operations 2
2022-04-12 20:51:19.809270 size on input set 1
2022-04-12 20:51:26.804793 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k - 1]\n"
    },
    {
      "index": 1,
      "text": "\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 2,
      "text": "\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    }
  ],
  "created": 1649796679,
  "object": "edit"
}
2022-04-12 20:51:26.804985 fix spelling mistakes 3 ['\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k - 1]\n', "\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"]
2022-04-12 20:51:26.805016 size on output set 2
2022-04-12 20:51:26.805022 size on input set 2
2022-04-12 20:51:28.963794 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef kth_distance(dist, k):\n    if dist:\n        dist.sort()\n        return dist[k - 1]\n    else:\n        return None\n"
    },
    {
      "index": 1,
      "text": "\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k-1]\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k - 1]\n"
    }
  ],
  "created": 1649796686,
  "object": "edit"
}
2022-04-12 20:51:28.963967 fix syntax errors 3 ['\ndef kth_distance(dist, k):\n    if dist:\n        dist.sort()\n        return dist[k - 1]\n    else:\n        return None\n', '\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k-1]\n', '#!/usr/bin/env python\ndef kth_distance(dist, k):\n    dist.sort()\n    return dist[k - 1]\n']
2022-04-12 20:51:40.131878 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from heapq import heappop, heappush\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 1)\ndist.sort()\n\nprint(dist[k])\n"
    },
    {
      "index": 1,
      "text": "n, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [source]\n\n    while pq:\n        u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heappush(pq, v)\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 2,
      "text": "\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    return arr\n"
    }
  ],
  "created": 1649796689,
  "object": "edit"
}
2022-04-12 20:51:40.132053 fix syntax errors 3 ["from heapq import heappop, heappush\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 1)\ndist.sort()\n\nprint(dist[k])\n", "n, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [source]\n\n    while pq:\n        u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heappush(pq, v)\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", '\ndef merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n    return arr\n']
2022-04-12 20:51:40.132178 size on output set 6
