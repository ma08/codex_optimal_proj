["\n\na, b = map(int, input().split())\n\nprint(int((a + b + 1) / 2))\n", "a, b = map(int, input().split())\nprint(int((a + b + 1) / 2))\n", "\n\na, b = map(int, input().split())  # \u0447\u0442\u0435\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \n\nprint(int(round((a + b) / 2)))  # \u0432\u044b\u0432\u043e\u0434 \u0434\u0430\u043d\u043d\u044b\u0445\n", "\n\na, b = map(int, input().split())\n\nprint(int((a + b) / 2.0))\n", "\n\na, b = map(int, input().split())\n\n\nprint(int((a - b) / 2))\nprint(int((a + b) / 2))\n", "\n\na, b = map(int, input().split())  # get a and b\n\nprint(int((a + b) / 2))  # print result\n", "\na, b = map(int, input().split())\n\nprint(int((a + b) / 2))\n", "\na, b = map(int, input().split())\nprint(int(round((a + b) / 2)))\n", "# coding: utf-8\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\n\ndef dijkstra(edges, start):\n    d = defaultdict(lambda: float('inf'))\n    d[start] = 0\n    q = [(0, start)]\n    while q:\n        w, v = heappop(q)\n        if d[v] < w:\n            continue\n        for v2, w2 in edges[v]:\n            if d[v2] > w + w2:\n                d[v2] = w + w2\n                heappush(q, (w + w2, v2))\n    return d\n\n\ndef main():\n    n, m, s, t = map(int, input().split())\n    edges = defaultdict(list)\n    for _ in range(m):\n        u, v, a, b = map(int, input().split())\n        edges[u].append((v, a))\n        edges[v].append((u, a))\n        edges[u].append((v, b))\n        edges[v].append((u, b))\n    d = dijkstra(edges, s)\n    print(d[t])\n\n\ndef _test():\n    from random import randint\n    from time import time\n    from heapq import heappush, heappop\n    from collections import defaultdict\n    sys.setrecursionlimit(10 ** 9)\n    INF = float('inf')\n    MOD = 10 ** 9 + 7\n\n    def dijkstra(edges, start):\n        d = defaultdict(lambda: float('inf'))\n        d[start] = 0\n        q = [(0, start)]\n        while q:\n            w, v = heappop(q)\n            if d[v] < w:\n                continue\n            for v2, w2 in edges[v]:\n                if d[v2] > w + w2:\n                    d[v2] = w + w2\n                    heappush(q, (w + w2, v2))\n        return d\n\n    def gen_random_graph(n, m, cmin, cmax):\n        edges = defaultdict(list)\n        for _ in range(m):\n            u = randint(0, n - 1)\n            v = randint(0, n - 1)\n            c1 = randint(cmin, cmax)\n            c2 = randint(cmin, cmax)\n            edges[u].append((v, c1))\n            edges[v].append((u, c1))\n            edges[u].append((v, c2))\n            edges[v].append((u, c2))\n        return edges\n\n    N = 10 ** 5\n    M = 10 ** 5\n    CMAX = 10 ** 9\n    for _ in range(10):\n        edges = gen_random_graph(N, M, 0, CMAX)\n        start = randint(0, N - 1)\n        t = time()\n        dijkstra(edges, start)\n        print(time() - t)\n\n\nif __name__ == '__main__':\n    main()\n", "\na, b, c, d = map(int, input().split())\n\nprint(max(a * c, a * d, b * c, b * d))\n", "\n\na, b = map(int, input().split())\nprint(int((a + b + 1) / 2))\n", "\n\na, b = map(int, input().split())\n\nprint(int(round((a + b) / 2)))\n"]