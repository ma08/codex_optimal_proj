["\n\ndef subsequence(string, sub):\n    if not sub: # if sub is empty\n        return True\n    i = 0 # index of sub\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub): # if i reaches the end of sub\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0 \n    end = len(string)\n    while start != end: # binary search\n        mid = (start + end) / 2\n        if subsequence(string[:mid], sub): # if sub is a sub sequence of string[:mid]\n            end = mid\n        else:\n            start = mid + 1 # if sub is not a sub sequence of string[:mid]\n    return len(string) - end\n\nprint solve(raw_input(), raw_input()) # input string and sub\n", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s. \n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp)) \n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t. \n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef subsequence(string, sub):\n    if not sub:  # if sub is empty\n        return True\n    i = 0 # index of sub\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub): # if i reaches the end of sub\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0 \n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string[:mid], sub): # if sub is a sub sequence of string[:mid]\n            end = mid\n        else:\n            start = mid + 1 # if sub is not a sub sequence of string[:mid]\n    return len(string) - end\n\nprint solve(raw_input(), raw_input()) # input string and sub\n", "\n\nimport sys\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    \"\"\"\n\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef subsequence(string, subseq, start=0):\n    if not subseq:\n        return True\n    i = 0\n    for c in string[start:]:\n        if c == subseq[i]:\n            i += 1\n            if i == len(subseq):\n                return True\n    return False\n\ndef solve(string, subseq):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string[:mid], subseq):\n            end = mid\n        else:\n            start = mid + 1\n    return string[:end]\n\nprint solve(raw_input(), raw_input())\n", "\ndef substring(string, sub):\n    if not sub:\n        return True\n    i = 0\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub):\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if substring(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint(solve(input(), input()))\n", "\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it.\n    We can keep it if it is in t.\n    We can remove it if it is not in t (or if we have already removed it).\n    This leads to a simple dp solution.\n    We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    # We can note that for each character in s, we can either keep it or remove it.\n    # We can keep it if it is in t.\n    # We can remove it if it is not in t (or if we have already removed it).\n    # This leads to a simple dp solution.\n    # We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it. We can keep it if it is in t. We can remove it if it is not in t (or if we have already removed it). This leads to a simple dp solution. We keep a list of the length of the longest possible substring we can remove ending at each index in s. \n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef substring(string, sub):\n    if not sub:\n        return True\n    i = 0\n    for c in string:\n        if c == sub[i]:\n            i += 1\n            if i == len(sub):\n                return True\n    return False\n\ndef solve(string, sub):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if substring(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint(solve(input(), input()))\n", "\n\ndef subsequence(string, subseq, start, end):\n    if not subseq:\n        return True\n    i = 0\n    for c in string[start:end]:\n        if c == subseq[i]:\n            i += 1\n            if i == len(subseq):\n                return True\n    return False\n\ndef solve(string, subseq):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string, subseq, start, mid):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint solve(raw_input(), raw_input())\n", "\n\ndef substring(string, sub):\n    if not sub: \n        return True\n    for i in range(len(string)):\n        if string[i] == sub[0]:\n            j = 0\n            while j < len(sub) and string[i + j] == sub[j]:\n                j += 1\n            if j == len(sub):\n                return True \n    return False \n\ndef solve(string, sub):\n    start = 0\n    end = len(string)\n    while start < end:\n        mid = (start + end) // 2\n        if substring(string[:mid], sub):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint solve(raw_input(), raw_input())\n", "\n\ndef subsequence(string, subseq):\n    if not subseq:\n        return True\n    i = 0\n    for c in string:\n        if c == subseq[i]:\n            i += 1\n            if i == len(subseq):\n                return True\n    return False\n\ndef solve(string, subseq):\n    start = 0\n    end = len(string)\n    while start != end:\n        mid = (start + end) / 2\n        if subsequence(string[:mid], subseq):\n            end = mid\n        else:\n            start = mid + 1\n    return len(string) - end\n\nprint(solve(raw_input(), raw_input()))\n", "\nimport sys\n\ndef main():\n    \"\"\"\n    We can note that for each character in s, we can either keep it or remove it. We can keep it if it is in t. We can remove it if it is not in t (or if we have already removed it). This leads to a simple dp solution. We keep a list of the length of the longest possible substring we can remove ending at each index in s.\n    \"\"\"\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] in t:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n        else:\n            if i == 0:\n                dp[i] = 1\n            else:\n                dp[i] = dp[i - 1] + 1\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n"]