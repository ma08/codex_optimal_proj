["\nimport sys\nimport math\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 0:\n        # I\n        print(1)\n        return\n\n    # I\n    if P == 1:\n        print(1)\n        return\n\n    # S\n    if P == 2:\n        # horizontal\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 3:\n        # horizontal\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 4:\n        # horizontal\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 5:\n        # horizontal\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 6:\n        # horizontal\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # O\n    if P == 7:\n        print(1)\n        return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef rotate_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field) or len(piece[0]) > min(field):\n        return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    for i in range(x, len(piece)):\n        for j in range(y, len(piece[i])):\n            field[i][j] += piece[i][j]\n    return field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    if x + len(piece) > len(field) or y + len(piece[0]) > len(field[x]):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x][y+j] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field)):\n        for j in range(len(field[i]) - len(piece[0]) + 1):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = []\n    for i in range(cols):\n        field.append([0] * field[i])\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotate_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and width\n    maxHeight = max(heights)\n    height, width = len(rotations[0]), len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()] # heights of the buildings\n\n    if P == 1:\n        print(C)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6 or P == 7: # if the camera can see more than one building\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0 for l in range(C)] for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    print(\"hello world\")\n    pass\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # I - 1\n        print(1)\n        return\n\n    # I - 1\n    if P == 2:\n        print(1)\n        return\n\n        return\n\n    # S - 3\n    if P == 3:\n        # horizontal - 1\n        if max_height == heights[0]:\n            print(1)\n            return\n        # vertical - 2\n        if max_height == heights[0] + 1:\n            print(2)\n        # vertical - 3\n            return\n        else:\n            print(3)\n            return\n\n    # Z - 3\n    if P == 4:\n        # horizontal - 1\n        if max_height == heights[-1]:\n            print(1)\n            return\n        # vertical - 2\n        if max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n        # vertical - 3\n            print(3)\n            return\n\n    # L - 4\n    if P == 5:\n        # horizontal - 1\n        if max_height == 1:\n            print(1)\n            return\n        # vertical - 2\n        if max_height == 2:\n            print(2)\n            return\n        else:\n        # vertical - 4\n            print(4)\n            return\n\n    # J - 4\n    if P == 6:\n        # horizontal - 1\n        if max_height == 1:\n            print(1)\n            return\n        # vertical - 2\n        if max_height == 2:\n            print(2)\n        # vertical - 4\n            return\n        else:\n            print(4)\n            return\n\n    # T - 4\n    if P == 7:\n        # horizontal - 1\n        if max_height == 1:\n            print(1)\n            return\n        # vertical - 2\n        if max_height == 2:\n            print(2)\n            return\n        else:\n        # vertical - 4\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    print('hello world') \n\nif __name__ == '__main__':\n    main()\n", "\n\ndef rotate_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    piece_num = int(input())\n    field = list(map(int, input().strip().split()))\n    pieces = [\n        [[0, 1, 0], [1, 1, 1]],\n        [[0, 1], [1, 1], [0, 1]],\n        [[0, 1, 0], [0, 1, 1], [0, 1, 0]],\n        [[1, 1, 1, 1]],\n        [[1, 1], [1, 1]],\n        [[1, 1, 1], [0, 1, 0]],\n        [[1, 1, 1], [0, 0, 1]]\n    ]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotate_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\n\nC = int(input())\nP = int(input())\n#C = 6\n#P = 5\nH = [int(x) for x in input().split()]\n#H = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1],]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1],]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0],]\n    elif P == 4:\n        return [[1,1],\n                [1,1],]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1],]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0],]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1],]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]],]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\n\ndef main():\n    print('hello world!')\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()] # heights of the buildings\n\n    if P == 1: # if the camera can only see one building\n        print(7)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6 or P == 7: # if the camera can see more than one building\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n    else: # if the camera can see all the buildings\n        print(C)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\n\ndef main():\n    C, P = read_input()\n    heights = [0] + read_input() + [0]\n\n    if P == 1:\n        # O (1)\n        print(max(heights[1], heights[2]))\n        return\n\n    if P == 2:\n        # I (1)\n        print(max(heights[1], heights[2], heights[3]))\n        return\n\n    if P == 3:\n        # S (3)\n        print(max(heights[1], heights[2] + 1, heights[3] + 1))\n        return\n\n    if P == 4:\n        # Z (3)\n        print(max(heights[1] + 1, heights[2], heights[3] + 1))\n        return\n\n    if P == 5:\n        # L (4)\n        print(max(heights[1], heights[2], heights[3], heights[4]))\n        return\n\n    if P == 6:\n        # J (4)\n        print(max(heights[1], heights[2], heights[3], heights[4]))\n        return\n\n    if P == 7:\n        # T (4)\n        print(max(heights[1], heights[2], heights[3], heights[4]))\n        return\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = readline().split()\n\n    if P == 1:\n        print(7)\n    elif P == 2 or P == 3 or P == 4 or P == 5 or P == 6:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\nC = int(input())\nP = int(input())\nH = [int(x) for x in input().split()]\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1, 1, 1, 1]]\n    elif P == 2:\n                [0, 0, 1]]\n    elif P == 3:\n        return [[1, 1, 1],\n                [1, 0, 0]]\n    elif P == 4:\n        return [[1, 1],\n                [1, 1]]\n    elif P == 5:\n        return [[1, 1, 1, 1],\n                [0, 0, 0, 1]]\n    elif P == 6:\n        return [[1, 1, 1, 1],\n                [1, 0, 0, 0]]\n    elif P == 7:\n        return [[1, 1, 1],\n                [0, 0, 1],\n                [0, 0, 1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0], shape[0][0]], [shape[1][1], shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0], shape[1], shape[2]],\n                [[shape[2][0], shape[1][0], shape[0][0]], [shape[2][1], shape[1][1], shape[0][1]], [shape[2][2], shape[1][2], shape[0][2]]],\n                [[shape[2][0], shape[2][1], shape[2][2]], [shape[1][0], shape[1][1], shape[1][2]], [shape[0][0], shape[0][1], shape[0][2]]],\n                [[shape[0][0], shape[1][0], shape[2][0]], [shape[0][1], shape[1][1], shape[2][1]], [shape[0][2], shape[1][2], shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # O\n        print(1)\n        return\n\n    # I, S, Z\n    if P == 2 or P == 3 or P == 4:\n        # verticals\n        if max_height == heights[-1]:\n        print(1)\n        elif max_height == heights[-1] + 1:\n            print(2)\n        else:\n            print(3)\n\n    # L, J, T\n    if P == 5 or P == 6 or P == 7:\n        # verticals\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef rotate_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(new_field[i+x])) and (new_field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotate_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y > 100 or field[i+x] - y < 0 or field[i+x] - y == len(field[i+x])):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y - 1] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input().strip()\n    heights = read_input().strip()\n    max_height = max(heights)\n\n    if P == 1:\n        # O (square)\n        print(1)\n        return\n\n    # I\n    if P == 2:\n        print(1)\n        return\n\n    # S\n    if P == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nC, P = map(int, input().split())\nheights = list(map(int, input().split()))\n\nprint(P)\n", "\n\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = get_piece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(get_ways(piece, heights)))\n\ndef get_piece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef get_ways(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(_rotate(rotations[-1]))\n    # Get the possible heights and width\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible way\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef _rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\nC, P = map(int, input().split())  # \u8cfc\u5165\u7a2e\u985e\u3001\u8cfc\u5165\u5546\u54c1\u6570\nheights = list(map(int, input().split()))  # \u5546\u54c1\u306e\u8cfc\u5165\u6570\n\n# \u4fa1\u683c\nprices = [7, 5, 3, 1, 3, 4, 3, 2, 5, 7]\n\n# \u5408\u8a08\u91d1\u984d\ntotal = 0\nfor i in range(P):\n    total += prices[i] * heights[i]\n\nprint(total)\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    N = int(readline())\n    A = [int(x) for x in readline().split()]\n\n    s_a = sum(A)\n    if s_a % N == 0:\n        print(s_a // N)\n    else:\n        print(s_a // N + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nC = int(input())\nP = int(input())\nC = 6\nP = 5\nH = [int(x) for x in input().split()]\nH = [2,1,1,1,0,1]\n\nprint (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i].count(1)\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\n\nC = int(input())\nP = int(input())\nC = 6\nP = 5\nH = [int(x) for x in input().split()]\nH = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\n\ndef hello():\n    print(\"hello\")\n\ndef main():\n    hello()\n    print(\"hello world\")\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # I\n        print(1)\n        return\n\n    # I\n    elif P == 2:\n        print(1)\n        return\n\n    # S\n    elif P == 3:\n        # horizontal\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    elif P == 4:\n        # horizontal\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    elif P == 5:\n        # horizontal\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    elif P == 6:\n        # horizontal\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    elif P == 7:\n        # horizontal\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    else:\n        print(\"error\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nC, P = map(int, input().split())\nheights = list(map(int, input().split()))\n\nif P == 1:\n    print(3)\nelif P == 2:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\nelif P == 8:\n    print(2)\n    print(2)\n", "\n\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = get_piece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(get_ways(piece, heights)))\n\ndef get_piece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef get_ways(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate_piece(rotations[-1]))\n    # Get the possible heights and width\n    maxHeight = max(heights)\n    height, width = len(rotations[0]), len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate_piece(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().split())\n    field = list(map(int, input().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\n\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    N, K = [int(x) for x in readline().split()]\n    groups = [int(x) for x in readline().split()]\n\n    groups.sort()\n\n    count = 0\n    for i in range(N - 1):\n        if groups[i] == groups[i+1]:\n            count += 1\n    print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split(\" \")]\n\ndef main():\n    C, P = read_input()\n    print(C, P, heights)\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # O\n        print(1)\n        return\n\n    # I\n    if P == 2:\n        print(1)\n        return\n\n    # S\n    if P == 3:\n        # verticals\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    if P == 4:\n        # verticals\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    if P == 5:\n        # verticals\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    if P == 6:\n        # verticals\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    if P == 7:\n        # verticals\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()] # heights of the buildings\n\n    if P == 1: # if the camera can only see one building\n        print(7)\n    else:\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    print('hello world')\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nC = int(input())\nP = int(input())\n#C = 6\n#P = 5\nH = [int(x) for x in input().split()]\n#H = [2,1,1,1,0,1]\n\nprint (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]], [[shape[0][1],shape[1][1]],[shape[0][0],shape[1][0]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]], \n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]],\n                [[shape[0][2],shape[1][2],shape[2][2]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][0],shape[1][0],shape[2][0]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[2][2],shape[1][2],shape[0][2]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][0],shape[1][0],shape[0][0]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and widths\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible ways\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline().strip()\n    return [i for i in line]\n\ndef main():\n    print(read_input())\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nC = int(input())\nP = int(input())\nH = [int(x) for x in input().split()]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)],\n                [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)],\n               [[shape[1][i:]+[0]*(C-len(shape[1])+i),shape[0][i:]+[0]*(C-len(shape[0])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)],\n               [[shape[2][i:]+[0]*(C-len(shape[2])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[0][i:]+[0]*(C-len(shape[0])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += [s for s in get_shifted(rot, C)]\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()]\n    heights = [int(x) for x in readline().split()]\n\n    count = 0\n    for i in range(C - 1):\n        if heights[i] == heights[i+1]:\n            count += 1\n    print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\n#C = int(input())\n#P = int(input())\nC = 6\nP = 5\n#H = [int(x) for x in input().split()]\nH = [2,1,1,1,0,1]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\n\nN, P = map(int, input().split())\nheights = list(map(int, input().split()))\n\nif P == 1:\n    print(3)\nelif P == 2:\n    print(3)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n    print(2)\n", "\n\nN, P = map(int, input().split())\nheights = list(map(int, input().split()))\n\nif P == 1:\n    print(0)\nelif P == 2:\n    print(1)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(4)\nelif P == 6:\n    print(5)\nelif P == 7:\n    print(6)\n", "\n\nC, P = map(int, input().split())\n\n\ndef calc_steps(h):\n    if h <= 1:\n        return 0\n    elif h == 2:\n        return 1\n    elif h == 3:\n        return 1\n    elif h == 4:\n        return 2\n    elif h == 5:\n        return 2\n    elif h == 6:\n        return 2\n    elif h == 7:\n        return 3\n    else:\n        return calc_steps(h - 7) + 3\n\nheights = list(map(int, input().split()))\n\nif P == 1:\n    print(calc_steps(heights[0]))\nelif P == 2:\n    print(3)\nelif P == 4:\n    print(calc_steps(heights[0]) + calc_steps(heights[1]))\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n    print(2)\n", "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the number of ways the pieces can be dropped\n    print(getWays(P, heights))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and width\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible way\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    print(\"Hello world!\")\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 100:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y >= 100 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(field[i]):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\n\nC = int(input())\nP = int(input())\nH = [int(x) for x in input().split()]\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - shape[i]\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "print(\"Hello, World!\")\n", "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > len(field[i]):\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y > len(field[i+x]) or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "import sys\n\ndef main():\n    C, P = map(int, input().split())\n    heights = list(map(int, input().split()))\n\n    if P == 1:\n        print(7)\n    elif P == 2:\n        print(3)\n    elif P == 3:\n        print(3)\n    elif P == 4:\n        print(2)\n    elif P == 5:\n        print(5)\n    elif P == 6:\n        print(2)\n    elif P == 7:\n        print(2)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    print('hello')\n\nif __name__ == '__main__':\n    main()\n", "\n\nC = int(input())\nP = int(input())\nH = [int(x) for x in input().split()]\n\n#print (C, P, H)\n\ndef get_piece_shape(P):\n    if P == 1:\n        return [[1,1,1,1]]\n    elif P == 2:\n        return [[1,1,1],\n                [0,0,1]]\n    elif P == 3:\n        return [[1,1,1],\n                [1,0,0]]\n    elif P == 4:\n        return [[1,1],\n                [1,1]]\n    elif P == 5:\n        return [[1,1,1,1],\n                [0,0,0,1]]\n    elif P == 6:\n        return [[1,1,1,1],\n                [1,0,0,0]]\n    elif P == 7:\n        return [[1,1,1],\n                [0,0,1],\n                [0,0,1]]\n\ndef get_rotated(shape):\n    if len(shape) == 4:\n        return [shape]\n    if len(shape) == 2:\n        return [shape, [[shape[1][0],shape[0][0]],[shape[1][1],shape[0][1]]]]\n    if len(shape) == 3:\n        return [[shape[0],shape[1],shape[2]],\n                [[shape[2][0],shape[1][0],shape[0][0]],[shape[2][1],shape[1][1],shape[0][1]],[shape[2][2],shape[1][2],shape[0][2]]],\n                [[shape[2][0],shape[2][1],shape[2][2]],[shape[1][0],shape[1][1],shape[1][2]],[shape[0][0],shape[0][1],shape[0][2]]],\n                [[shape[0][0],shape[1][0],shape[2][0]],[shape[0][1],shape[1][1],shape[2][1]],[shape[0][2],shape[1][2],shape[2][2]]]]\n\ndef get_shifted(shape, C):\n    if len(shape) == 4:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i) for i in range(C+1)]]\n    if len(shape) == 2:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i)] for i in range(C+1)]\n    if len(shape) == 3:\n        return [[shape[0][i:]+[0]*(C-len(shape[0])+i),shape[1][i:]+[0]*(C-len(shape[1])+i),shape[2][i:]+[0]*(C-len(shape[2])+i)] for i in range(C+1)]\n\ndef get_all_shapes(P, C):\n    shape = get_piece_shape(P)\n    rotated = get_rotated(shape)\n    all_shapes = []\n    for rot in rotated:\n        all_shapes += get_shifted(rot, C)\n    return all_shapes\n\ndef get_score(H, shape):\n    score = 0\n    for i in range(len(shape)):\n        score += H[i] - sum(shape[i])\n    return score\n\ndef get_best_score(H, shapes):\n    best_score = 0\n    for shape in shapes:\n        if get_score(H, shape) > best_score:\n            best_score = get_score(H, shape)\n    return best_score\n\ndef get_num_shapes(H, shapes):\n    num_shapes = 0\n    for shape in shapes:\n        if get_score(H, shape) == get_best_score(H, shapes):\n            num_shapes += 1\n    return num_shapes\n\ndef get_num_possibilities(H, shapes):\n    return get_best_score(H, shapes) * get_num_shapes(H, shapes)\n\nshapes = get_all_shapes(P, C)\nprint(get_num_possibilities(H, shapes))\n", "\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    C, P = [int(x) for x in readline().split()] # C is number of cases and P is number of police\n    heights = [int(x) for x in readline().split()]\n        # if there is only one police, then the number of times the criminal can escape is 7\n\n    if P == 1:\n        print(7)\n    else:\n        # if there are multiple police, then the number of times the criminal can escape is the number of times the police are in the same position + 1\n        count = 0\n        for i in range(C - 1):\n            if heights[i] == heights[i+1]:\n                count += 1\n        print(count + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nN, P = map(int, input().split())\nheights = list(map(int, input().split()))\n# TODO: use one for loop\n\nif P == 1:\n    print(7)\nelif P == 2:\n    print(3)\nelif P == 3:\n    print(3)\nelif P == 4:\n    print(2)\nelif P == 5:\n    print(5)\nelif P == 6:\n    print(2)\nelif P == 7:\n    print(2)\n", "\n\ndef main():\n    print(\"hello world\")\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    line = sys.stdin.readline()\n    return [int(i) for i in line.split()]\n\ndef main():\n    C, P = read_input()\n    heights = read_input()\n    max_height = max(heights)\n\n    if P == 1:\n        # O (square)\n        print(1)\n        return\n\n    # I\n    elif P == 2:\n        print(1)\n        return\n\n    # S\n    elif P == 3:\n        # vertical\n        if max_height == heights[0]:\n            print(1)\n            return\n        elif max_height == heights[0] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # Z\n    elif P == 4:\n        # vertical\n        if max_height == heights[-1]:\n            print(1)\n            return\n        elif max_height == heights[-1] + 1:\n            print(2)\n            return\n        else:\n            print(3)\n            return\n\n    # L\n    elif P == 5:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # J\n    elif P == 6:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\n    # T\n    elif P == 7:\n        # vertical\n        if max_height == 1:\n            print(1)\n            return\n        elif max_height == 2:\n            print(2)\n            return\n        else:\n            print(4)\n            return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef rotated_piece(piece):\n    rotated = []\n    for i in range(len(piece)):\n        rotated.append([])\n        for j in range(len(piece)):\n            rotated[i].append(piece[len(piece)-1-j][i])\n    return rotated\n\ndef piece_fits(piece, field):\n    if len(piece) > len(field):\n        return False\n    for i in range(len(field)):\n        if len(piece[i]) + field[i] > 10:\n            return False\n    return True\n\ndef place_piece(piece, field, x, y):\n    new_field = []\n    for i in range(len(field)):\n        new_field.append([])\n        for j in range(field[i]):\n            new_field[i].append(1)\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            new_field[i+x].append(piece[i][j])\n    return new_field\n\ndef piece_fits_at(piece, field, x, y):\n    if not piece_fits(piece, field):\n        return False\n    for i in range(len(piece)):\n        for j in range(len(piece[i])):\n            if (piece[i][j] == 1) and (field[i+x] - y > 10 or field[i+x] - y < 0):\n                return False\n            if (piece[i][j] == 1) and (field[i+x] - y >= 0) and (field[i+x] - y < len(field[i+x])) and (field[i+x][field[i+x] - y] == 1):\n                return False\n    return True\n\ndef count_places(piece, field):\n    count = 0\n    for i in range(len(field) - len(piece) + 1):\n        for j in range(len(field[i])):\n            if piece_fits_at(piece, field, i, j):\n                count += 1\n    return count\n\ndef main():\n    cols, piece_num = map(int, input().strip().split())\n    field = list(map(int, input().strip().split()))\n    pieces = [[[0, 1, 0], [1, 1, 1]], [[0, 1], [1, 1], [0, 1]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]], [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[1, 1, 1], [0, 1, 0]], [[1, 1, 1], [0, 0, 1]]]\n    piece = pieces[piece_num - 1]\n    for i in range(3):\n        piece = rotated_piece(piece)\n        count = count_places(piece, field)\n        print(count)\n\nmain()\n", "\nimport sys\n\ndef main():\n    # Get input\n    C, P = [int(i) for i in sys.stdin.readline().strip().split()]\n    heights = [int(i) for i in sys.stdin.readline().strip().split()]\n    # Get the piece\n    piece = getPiece(P)\n    # Get the number of ways the piece can be dropped\n    print(len(getWays(piece, C, heights)))\n\ndef getPiece(P):\n    # Get the piece\n    if P == 1:\n        piece = [[1, 1], [1, 1]]\n    elif P == 2:\n        piece = [[1, 1, 1], [1, 0, 0]]\n    elif P == 3:\n        piece = [[1, 1, 1], [0, 0, 1]]\n    elif P == 4:\n        piece = [[1, 1, 1, 1]]\n    elif P == 5:\n        piece = [[1, 1], [1, 0], [1, 0]]\n    elif P == 6:\n        piece = [[1, 1], [0, 1], [0, 1]]\n    else:\n        piece = [[1, 1, 1], [0, 1, 0]]\n    return piece\n\ndef getWays(piece, C, heights):\n    ways = []\n    # Get the possible rotations\n    rotations = [piece]\n    for i in range(3):\n        rotations.append(rotate(rotations[-1]))\n    # Get the possible heights and width\n    maxHeight = max(heights)\n    height = len(rotations[0])\n    width = len(rotations[0][0])\n    # Get the possible way\n    for rotation in rotations:\n        for i in range(C - width + 1):\n            for j in range(maxHeight - height + 1):\n                way = []\n                for k in range(height):\n                    way.append([0] * i + rotation[k] + [0] * (C - width - i))\n                way = way[::-1] + [[0] * C for l in range(j)]\n                ways.append(way)\n    return ways\n\ndef rotate(piece):\n    rotation = []\n    height = len(piece)\n    width = len(piece[0])\n    for i in range(width):\n        row = []\n        for j in range(height):\n            row.append(piece[height - j - 1][i])\n        rotation.append(row)\n    return rotation\n\nif __name__ == \"__main__\":\n    main()\n"]