["# leetcode 455: Assign Cookies \n# description: Assume you are an awesome parent and want to give your children some cookies. \n# But, you should give each child at most one cookie. Each child i has a greed factor gi, \n# which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. \n# If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. \n# Your goal is to maximize the number of your content children and output the maximum number.\n# Note:\n#     You may assume the greed factor is always positive. \n#     You cannot assign more than one cookie to one child.\n# example: \n#     Input: [1,2,3], [1,1] \n#     Output: 1 \n# exmaple: \n#     Input: [1,2], [1,2,3] \n#     Output: 2 \n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return count\n", "'''\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\n'''\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        # Use heap to store the smallest sum\n        if not nums1 or not nums2:\n            return []\n        heap = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                sum = nums1[i] + nums2[j]\n                if len(heap) < k:\n                    heapq.heappush(heap, (-sum, i, j))\n                else:\n                    if sum < -heap[0][0]:\n                        heapq.heappushpop(heap, (-sum, i, j))\n                    else:\n                        break\n        res = []\n        while heap:\n            sum, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n        return res[::-1]\n", "'''\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\n'''\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        # Use heap to store the smallest sum\n        if not nums1 or not nums2:\n            return []\n        heap = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                sum_ = nums1[i] + nums2[j]\n                if len(heap) < k:\n                    heapq.heappush(heap, (-sum_, i, j))\n                else:\n                    if sum_ < -heap[0][0]:\n                        heapq.heappushpop(heap, (-sum_, i, j))\n                    else:\n                        break\n        res = []\n        while heap:\n            sum, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n        return res[::-1]\n", "\n\n\"\"\"\nTime Complexity: O(nlog(n))\nSpace Complexity: O(n)\n\n\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "\"\"\"\nTime Complexity: O(nlgn)\nSpace Complexity: O(1)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n\n\n\n\n\n\"\"\"\nTime Complexity: O(nlgn)\nSpace Complexity: O(1)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        return content_children\n", "#!/usr/bin/env python3\n\n\"\"\"\nTime Complexity: O(n log n)\nSpace Complexity: O(1)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "\n\n\"\"\"\nTime Complexity: O(nlgn)\nSpace Complexity: O(1)\n\n\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "# leetcode 455: Assign Cookies\n# description: \n#     Assume you are an awesome parent and want to give your children some cookies. \n#     But, you should give each child at most one cookie. Each child i has a greed factor gi, \n#     which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. \n#     If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. \n#     Your goal is to maximize the number of your content children and output the maximum number.\n#     Note:\n#         You may assume the greed factor is always positive. \n#         You cannot assign more than one cookie to one child.\n# example:\n#     Input: [1,2,3], [1,1]\n#     Output: 1\n# example:\n#     Input: [1,2], [1,2,3]\n#     Output: 2\n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return count\n", "#!/usr/bin/python3\n\n\"\"\"\nTime Complexity: O(n log n)\nSpace Complexity: O(1)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "\n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int: \n        \n", "\n\n\"\"\"\nTime Complexity: O(nlog(n))\nSpace Complexity: O(n)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        return content_children\n", "from typing import List\n\n\"\"\"\nTime Complexity: O(nlog(n))\nSpace Complexity: O(n)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "from typing import List\n\n\"\"\"\nTime Complexity: O(nlgn)\nSpace Complexity: O(1)\n\n\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "\n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int: \n        g.sort() # sort the greed list\n        s.sort() # sort the size list\n        count = 0\n        i = 0 # index for greed list\n        j = 0 # index for size list\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return count\n", "\n\"\"\"\nTime Complexity: O(n log n)\nSpace Complexity: O(1)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n\n\"\"\"\nTime Complexity: O(n log n)\nSpace Complexity: O(1)\n\"\"\"\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        content_children = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                content_children += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return content_children\n", "from typing import List\n\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int: \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return count\n", "# leetcode\n# description\n\nclass Solution:\n    def function(self, args):\n        # code here\n        pass\n\nif __name__ == \"__main__\":\n    pass\n"]