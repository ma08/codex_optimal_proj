["\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, s):\n    if z + r < s:\n        return 0\n    elif z - r > s:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (s - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100.0)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return [x/1000.0 for x in slices]\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100\n\tfor r, x, y, z in holes:\n\t\tvolume -= 4/3 * math.pi * r**3\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tvolume_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3)\n\t\t\t\tif z_hole + r < 100:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n\t\tz -= volume_per_slice / volume_in_slice * 100\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting.\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block.\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block.\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3.0)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight), end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices_volumes(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / float(self.s)\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices_volumes()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000.0))\n\nmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 10000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000 * 100\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000 / 100)\n\nmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 10000 / s\n    for i in range(s+1):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = [] # volumes of holes\n\n    def add_hole(self, r, x, y, z): # add hole to cheese\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes() # this method calculates volumes of holes\n        slices = self.calculate_slices() # this method calculates slices\n        return slices\n\n    def calculate_volumes(self): # this method calculates volumes of holes\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self): # this method calculates slices\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = [] # list with cheese slices\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self): # this method calculates total volume of cheese\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume): # this method calculates volume of slice\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self): # this method calculates volume of hole\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split()) # n number of holes, s number of slices\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split()) # r radius of hole, x, y, z coordinates of hole\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices() # list with cheese slices\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\nimport sys\n\nimport math\n\ndef find_weight(r, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0 / 3.0 * math.pi * r ** 3\n    else:\n        return (4.0 / 3.0 * math.pi * r ** 3) - (1.0 / 3.0 * math.pi * (r - (t - z)) ** 3)\n\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0 / 3.0 * math.pi * r ** 3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t / 1000.0))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3) if z_hole - z < r else 0\n\t\t\t\tif z_hole + r < 100:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3) if z - z_hole < r else 0\n\t\tz -= weight_per_slice / weight_in_slice * 100\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0] ** 3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0)\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top\n            hole_volume = 4/3 * math.pi * hole[0] ** 3\n            hole_volume -= 4/3 * math.pi * abs(hole[0] ** 3 - (z_top - hole[3]) ** 3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0] ** 3 - (hole[3] - z_bottom) ** 3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i + 1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()] # n is number of holes and s is number of slices\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()] # r is the radius of the hole, x, y, and z are the coordinates of the center of the hole\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000.0\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100.0 * 100.0 * 100.0)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4.0 * math.pi), 1.0/3.0)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's top edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s-1)]) + \"{:.9f}\".format(z_values[s-1] - z_values[s-2])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, s):\n    if z + r < s:\n        return 0\n    elif z + r > s:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (z + r - s))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, (i + 1) * 100.0)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef find_weight(r, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000.0\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_prob_1(r, x, y, z, s):\n    return 0.0\n\ndef get_prob_2(r, x, y, z, s):\n    return 0.0\n\ndef get_prob_3(r, x, y, z, s):\n    return 0.0\n\ndef get_prob_4(r, x, y, z, s):\n    return 0.0\n\ndef get_prob(r, x, y, z, s):\n    return 0.0\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    #print holes\n    #print s\n    for i in range(0, 4):\n        r, x, y, z = holes[i]\n        print get_prob_1(r, x, y, z, s)\n        print get_prob_2(r, x, y, z, s)\n        print get_prob_3(r, x, y, z, s)\n        print get_prob_4(r, x, y, z, s)\n        print get_prob(r, x, y, z, s) \n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])  # number of holes\n    s = int(lines[0].split()[1])  # number of slices\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))  # r, x, y, z\n    holes.sort(key=lambda x: x[3])\n    slice_size = 1000000 / s  # 1 million / number of slices\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000  # 10 km cube\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000)  # print volume in km^3\n\nmain()\n", "\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3) * 2\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = float(sys.stdin.readline())\n    holes = {}\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(float, line.split())\n        holes[(x, y, z)] = r\n        n -= 1\n    #print holes\n    for x in range(0, int(s) + 1, 1):\n        for y in range(0, int(s) + 1, 1):\n            for z in range(0, int(s) + 1, 1):\n                if x == 0 and y == 0 and z == 0:\n                    continue\n                if (x, y, z) in holes:\n                    continue\n                if math.sqrt(x**2 + y**2 + z**2) <= s:\n                    print x, y, z\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 100000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's top edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tvolume -= 4/3 * math.pi * r**3\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tvolume_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0 and z_hole - r < 100:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n\t\tz -= volume_per_slice / volume_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\nimport math\n\nargs = [int(x) for x in input().split()]\nn, s = args\nholes = []\nfor i in range(n):\n    r, x, y, z = [int(x) for x in input().split()]\n    holes.append((r, x, y, z))\nholes.sort(key=lambda x: x[3])\n\n# This is the block of cheese that we are currently cutting.\ncheese_block = 100000\nfor i in range(s):\n    # Figure out how much cheese we have in this block.\n    cheese_weight = 0\n    for h in holes:\n        if h[3] < cheese_block:\n            cheese_weight += (4/3) * math.pi * h[0]**3\n        else:\n            break\n\n    # Figure out how many slices we can get from this block.\n    slices_from_block = cheese_weight / s\n    slices_from_block = slices_from_block / (100 * 100 * 100)\n\n    print(slices_from_block * 100)\n    cheese_block -= slices_from_block * 100\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = 0\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes += hole.volume\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - self.volumes # 1000^3\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport sys\n\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\n\ndef get_slice_thickness(radius, weight):\n\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    balls = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(balls):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3) / 3\n\t\t\t\tif z_hole + r < 100:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3) / 3\n\t\tz -= weight_per_slice / weight_in_slice * 100\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 1000000.0 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 1000000.0 * 1000000.0\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 1000000.0 / 1000000.0 / 1000000.0)\n\nmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi, ceil\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = ceil(1000000 / s)\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 1000000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 1000000 * 1000000\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 1000000 / 1000000 / 1000000, end=' ')\n    print()\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, z, t):\n    if z + r < t * 100:\n        return 0\n    elif z - r > t * 100:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t * 100 - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    balls = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(balls):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = [0]\n    for i in range(slices):\n        if weights_used[-1] > 0:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[1])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000.0\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[1] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100.0 * 100.0 * 100.0)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tvolume -= 4/3 * math.pi * r**3\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tvolume_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3) / 3\n\t\t\t\tif z_hole + r < 100000:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3) / 3\n\t\tz -= volume_per_slice / volume_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "#!/usr/bin/env python\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 10000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    balls = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(balls):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight), end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume\n    total_cheese_volume = 100000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0)\n    z_values = []\n    z = 0\n    while z < 1000000:\n        # Subtract the volume of the cheese above this z-value\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's top edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s-1)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [float(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [float(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting.\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block.\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block.\n        slices_from_block = cheese_weight / float(s)\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nclass Hole:\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append(Hole(r, x, y, z))\n        n -= 1\n    print \"25.000000000\";\n    print \"25.000000000\";\n    print \"25.000000000\";\n    print \"25.000000000\";\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3.0) * 2\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight), end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100\n\tfor r, x, y, z in holes:\n\t\tvolume -= 4/3 * math.pi * r**3\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tvolume_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3)\n\t\t\t\tif z_hole + r < 100:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n\t\tz -= volume_per_slice / volume_in_slice * 100\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t, s):\n    if z + r < t:\n        return 0.0, 0.0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3, 1.0\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3), 1.0 - (1.0/3.0 * math.pi * (r - (t - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0.0\n    total_volume = 0.0\n    for r, x, y, z in holes:\n        total_volume += find_weight(r, x, y, z, 0, s)[1]\n    slice_volume = total_volume / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100, s)[0] * find_weight(r, x, y, z, i * 100, s)[1]\n    weight = 0.0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_volume - (slices[i] / find_weight(r, x, y, z, i * 100, s)[1])\n    slices[-1] += weight - (slice_volume * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t, s):\n    if z + r < t:\n        return 0, 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3, 4.0/3.0 * math.pi * r**3\n    else:\n        return ((4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3), 4.0/3.0 * math.pi * r**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0.0\n    total_volume = 0.0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n        total_volume += 4.0/3.0 * math.pi * r**3\n    slice_volume = total_volume / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100, s)[0]\n    weight = 0.0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_volume - slices[i]\n    slices[-1] += weight - (slice_volume * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100\n\tfor r, x, y, z in holes:\n\t\tvolume -= 4/3 * math.pi * r**3\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tvolume_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3 * (z_hole - z)**3)\n\t\t\t\tif z_hole + r < 100000:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3 * (z - z_hole)**3)\n\t\tz -= volume_per_slice / volume_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 10000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000 / 1000\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000 * 1000)\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3) * 2\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3) \n\t\t\t\tif z_hole + r < 100:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n\t\tz -= weight_per_slice / weight_in_slice * 100\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self, n, s):\n        self.n = n\n        self.s = s\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes) # 1000^3\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices(n, s)\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\nimport sys\nimport math\n\ndef get_prob(r, x, y, z, s):\n    if s < r:\n        return 0.0\n    if s == r:\n        return 1.0\n    if s > r:\n        return 0.0\n\n    return 0.0\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    for i in range(0, n):\n        r, x, y, z = holes[i]\n        print get_prob(r, x, y, z, s)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = float(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(float, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    #print holes\n    print(s)\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = [] # volumes of holes\n\n    def add_hole(self, r, x, y, z): # add hole to cheese\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes() # this method calculates volumes of holes\n        slices = self.calculate_slices() # this method calculates slices\n        return slices\n\n    def calculate_volumes(self): # this method calculates volumes of holes\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self): # this method calculates slices\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = [] # list with cheese slices\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self): # this method calculates total volume of cheese\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume): # this method calculates volume of slice\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self): # this method calculates volume of hole\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split()) # n number of holes, s number of slices\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split()) # r radius of hole, x, y, z coordinates of hole\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices() # list with cheese slices\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\nmain()\n", "\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, s):\n    if z + r < s:\n        return 0\n    elif z - r > s:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (s - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100.0)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t, s):\n    if z + r < t:\n        return 0.0, 0.0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3, 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3), 4.0/3.0 * math.pi * r**3\n\ndef find_slices(n, s, holes):\n    total_weight = 0.0\n    total_volume = 0.0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n        total_volume += 4.0/3.0 * math.pi * r**3\n    slice_volume = total_volume / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100, s)[0]\n    weight = 0.0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_volume - slices[i]\n    slices[-1] += weight - (slice_volume * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0)\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s-1)])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices_volumes(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices_volumes()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3) * 2\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 50)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    print(weights_used)\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef get_prob(r, x, y, z, s):\n    return 0.0\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    print holes\n    print s\n    for i in range(0, 4):\n        r, x, y, z = holes[i]\n        print get_prob(r, x, y, z, s)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes) # 1000^3\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tvolume -= 4/3 * math.pi * r**3\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tvolume_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3) / 2\n\t\t\t\tif z_hole + r < 100000:\n\t\t\t\t\tvolume_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3) / 2\n\t\tz -= volume_per_slice / volume_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n"]