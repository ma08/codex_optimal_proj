["\n# Accepted - First try!\n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards\n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_r(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k):\n        num_ways += cards[i] * get_n_choose_r(sum(cards) - cards[i], k - i - 1)\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split(\" \")]\n    k = int(input())\n    print(get_num_ways(cards, k))\n", "# Accepted\n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards \n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_k(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k):\n        num_ways += cards[i] * get_n_choose_k(sum(cards) - cards[i], k - i - 1)\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split()]\n    k = int(input())\n    print(get_num_ways(cards, k))\n", "\n\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    if r == 0: return 1\n    numer = reduce(op.mul, range(n, n-r, -1))\n    denom = reduce(op.mul, range(1, r+1))\n    return numer // denom\n\ndef main():\n    card_counts = list(map(int, input().strip().split()))\n    k = int(input().strip())\n\n    # If there are not enough cards to deal, return 0\n    if sum(card_counts) < k:\n        print(0)\n        return\n\n    # If there are exactly k cards to deal, return 1\n    if sum(card_counts) == k:\n        print(1)\n        return\n\n    # If there are more cards to deal than numbers, return 0.\n    if k > 10:\n        print(0)\n        return\n\n    # Find the number of combinations\n    combinations = 0\n    for i in range(k):\n        combinations += ncr(sum(card_counts[i:]), k-i)\n\n    print(combinations)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = list(map(int, input().split()))\n    k = int(input())\n\n    # Calculate number of ways to deal cards\n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending combination without the first card\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending combination with the first card\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\n\nnumbers = [int(n) for n in input().split()]\nK = int(input())\n\nprint(count_ascending_combos(numbers, K) % 1000000007)\n", "\nfrom collections import Counter\n\ndef get_input():\n    n = [int(x) for x in input().split()]\n    k = int(input())\n    return n, k\n\ndef get_value(nums, k, dp):\n    if nums[0] == 0:\n        return 0\n    if dp[nums[0]][k] == -1:\n        if k == 1:\n            dp[nums[0]][k] = nums[0]\n        elif k == 2:\n            dp[nums[0]][k] = nums[0] * (nums[0] - 1) / 2\n        else:\n            dp[nums[0]][k] = sum([get_value(nums[1:], k-1, dp) * nums[0] for i in range(k)])\n    return dp[nums[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n  r = min(r, n-r)\n  if r == 0: return 1\n  numer = reduce(op.mul, range(n, n-r, -1))\n  denom = reduce(op.mul, range(1, r+1))\n  return numer//denom\n\ndef main():\n  card_counts = list(map(int, input().strip().split()))\n  k = int(input().strip())\n\n  # If there are not enough cards to deal, return 0\n  if sum(card_counts) < k:\n    print(0)\n    return\n\n  # If there are exactly k cards to deal, return 1\n  if sum(card_counts) == k:\n    print(1)\n    return\n\n  # If there are more cards to deal than number, return 0\n  if k > 10:\n    print(0)\n    return\n\n  # Find the number of combinations\n  combinations = 0\n  for i in range(k):\n    combinations += ncr(sum(card_counts[i:]), k-i)\n\n  print(combinations)\n\nif __name__ == '__main__':\n  main()\n", "\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_r(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k):\n        num_ways += cards[i] * get_n_choose_r(sum(cards) - cards[i], k - i - 1)\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split()]\n    k = int(input())\n    print(get_num_ways(cards, k))\n", "\nimport itertools\n\nnum_cards = [int(x) for x in input().split()]  # [1,2,3,4,5,6,7,8,9,10]\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\nprint(count_ascending(num_cards, k))\n", "import sys\n\nnumbers = [int(n) for n in sys.stdin.readline().split()]\nK = int(sys.stdin.readline())\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending combination without the first card\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending combination with the first card\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\nprint(count_ascending_combos(numbers, K))\n", "#\n# Accepted \n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards \n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import Counter\n\ndef get_input():\n    n = [int(x) for x in input().split()]\n    k = int(input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0 or k == 0:\n        return 0\n    if dp[n[0]][k] == -1:\n        if k == 1:\n            dp[n[0]][k] = n[0]\n        elif k == 2:\n            dp[n[0]][k] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[n[0]][k] = sum([get_value(n[1:], k-1, dp) * n[0] for j in range(k)])\n    return dp[n[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "print(\"hello\")\n", "import itertools\n\ndef is_ascending(lst):\n    return all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\ndef main():\n    num_cards = [int(x) for x in input().split()]\n    k = int(input())\n    print(count_ascending(num_cards, k))\n\nmain()\n", "\n\nimport sys\n\nnumbers = [int(n) for n in sys.stdin.readline().split()]  # [2, 1, 2]\nK = int(sys.stdin.readline())\n\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending sequence without the first card.\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending sequence with the first card.\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0]) if K - 1 - i >= 0])\n        return ways\n\nprint(count_ascending_combos(numbers, K))\n", "#\n# # Solution\n# import itertools\n#\n# num_cards = [int(x) for x in input().split()]\n# k = int(input())\n#\n# def is_ascending(lst):\n#     return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n#\n# def count_ascending(deck, k):\n#     count = 0\n#     for hand in itertools.combinations(deck, k):\n#         if is_ascending(hand):\n#             count += 1\n#     return count\n#\n# print(count_ascending(num_cards, k))\n", "def get_input():\n    n = [int(x) for x in input().split()]\n    k = int(input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0:\n        return 0\n    if dp[k][n[0]] == -1:\n        if k == 1:\n            dp[k][n[0]] = n[0]\n        elif k == 2:\n            dp[k][n[0]] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[k][n[0]] = sum([get_value(n[1:], k-1, dp) * n[0] for i in range(k)])\n    return dp[k][n[0]]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(100)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K or sum(numbers) == 0:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending sequence without the first card\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending sequence with the first card\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\n\ndef main():\n    import sys\n    numbers = [int(n) for n in sys.stdin.readline().split()]\n    K = int(sys.stdin.readline())\n    print(count_ascending_combos(numbers, K))\n\nif __name__ == '__main__':\n    main()\n", "\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_k(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k):\n        num_ways += cards[i] * get_n_choose_k(sum(cards) - cards[i], k - i - 1) # number of ways to get k - i - 1 cards of the same suit\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split()]\n    k = int(input())\n    print(get_num_ways(cards, k))\n", "\n\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n\tr = min(r, n-r)\n\tif r == 0: return 1\n\tnumer = reduce(op.mul, range(n, n-r, -1))\n\tdenom = reduce(op.mul, range(1, r+1))\n\treturn numer//denom\n\ndef main():\n\tcard_counts = list(map(int, input().strip().split()))\n\tk = int(input().strip())\n\n\t# If there are not enough cards to deal, return 0\n\tif sum(card_counts) < k:\n\t\tprint(0)\n\t\treturn\n\n\t# If there are exactly k cards to deal, return 1\n\tif sum(card_counts) == k:\n\t\tprint(1)\n\t\treturn\n\n\t# If there are more cards to deal than number, return 0\n\tif k > 10:\n\t\tprint(0)\n\t\treturn\n\n\t# Find the number of combinations\n\tcombinations = 0\n\tfor i in range(k):\n\t\tcombinations += ncr(sum(card_counts[i:]), k-i)\n\n\tprint(combinations)\n\nif __name__ == '__main__':\n\tmain()\n", "\n\ndef count_ascending_combos(numbers, K):\n    if K == 0:\n        return 1\n    elif sum(numbers) < K:\n        return 0\n    else:\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\n\ndef main():\n    import sys\n    numbers = [int(n) for n in sys.stdin.readline().split()]\n    K = int(sys.stdin.readline())\n    print(count_ascending_combos(numbers, K))\n\nif __name__ == '__main__':\n    main()\n", "\n\nn = [int(i) for i in input().split()]  # input list of numbers\nk = int(input())  # input k\n\n\ndef fact(n):  # factorial\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\n\n\ndef ncr(n, r):\n    return int(fact(n) / (fact(r) * fact(n - r)))\n\n\nif k == 1:\n    print(sum(n))\nelse:\n    ans = 0\n    for i in range(1, k + 1):\n        ans += n[i - 1] * ncr(sum(n[i:]), k - i)\n    print(ans)\n", "\nimport sys\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    if r == 0: return 1\n    numer = reduce(op.mul, range(n, n-r, -1))\n    denom = reduce(op.mul, range(1, r+1))\n    return numer//denom\n\ndef main():\n    card_counts = list(map(int, sys.stdin.readline().strip().split()))\n    k = int(sys.stdin.readline().strip())\n\n    # If there are not enough cards to deal, return 0\n    if sum(card_counts) < k:\n        sys.stdout.write(str(0))\n        return\n\n    # If there are exactly k cards to deal, return 1\n    if sum(card_counts) == k:\n        sys.stdout.write(str(1))\n        return\n\n    # If there are more cards to deal than number, return 0\n    if k > 10:\n        sys.stdout.write(str(0))\n        return\n\n    # Find the number of combinations\n    combinations = 0\n    for i in range(k):\n        combinations += ncr(sum(card_counts[i:]), k-i)\n\n    sys.stdout.write(str(combinations))\n\nif __name__ == '__main__':\n    main()\n", "\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending sequence without the first card\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending sequence with the first card\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\n\n\ndef main():\n    import sys\n    numbers = [int(n) for n in sys.stdin.readline().split()]\n    K = int(sys.stdin.readline())\n    print(count_ascending_combos(numbers, K))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: int[].\n    \"\"\"\n    return list(map(int, input().strip().split()))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: int[]\n    :return: int[].\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_permutations(cards, K):\n    \"\"\"\n    Returns the number of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int.\n    :return: int.\n    \"\"\"\n    return len(get_permutations(cards, K))\n\ndef get_permutations(cards, K):\n    \"\"\"\n    Returns a list of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int.\n    :return: int[].\n    \"\"\"\n    if K == 1:\n        return cards\n    permutations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_permutations = get_permutations(sub_cards, K-1)\n        for sub_permutation in sub_permutations:\n            if card < sub_permutation[0]:\n                permutations.append([card] + sub_permutation)\n    return permutations\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    numbers = get_input()\n    K = int(input().strip())\n    cards = get_cards(numbers)\n    num_permutations = get_num_permutations(cards, K)\n    print(num_permutations)\n\nif __name__ == \"__main__\":\n    main()\n", "n, k = map(int, input().split())\na = [int(i) for i in input().split()]\n\ndef fact(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\n\ndef ncr(n, r):\n    return int(fact(n) / (fact(r) * fact(n - r)))\n\nif k == 1:\n    print(sum(a))\nelse:\n    ans = 0\n    for i in range(1, k + 1):\n        ans += a[i - 1] * ncr(sum(a[i:]), k - i)\n    print(ans)\n", "\n\nn = [int(i) for i in input().split()]  # input list of numbers\nk = int(input())  # input k\n\ndef fact(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n    return ans\n\ndef ncr(n, r):\n    return int(fact(n) / (fact(r) * fact(n - r)))\n\nif k == 1:\n    print(sum(n))\nelse:\n    ans = 0\n    for i in range(1, k + 1):\n        ans += n[i - 1] * ncr(sum(n[i:]), k - i)\n    print(ans)\n", "\nimport sys\n\nnumbers = [int(n) for n in sys.stdin.readline().split()]\nK = int(sys.stdin.readline())\n\ndef count_ascending_combos(numbers, K):\n\t# Base case: if there are no more cards left to deal, return 1\n\tif K == 0:\n\t\treturn 1\n\t# Base case: if there are more cards to deal than there are cards in the deck, return 0\n\telif sum(numbers) < K:\n\t\treturn 0\n\telse:\n\t\t# Initialize with the number of ways to deal a strictly ascending combination without the first card\n\t\tways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n\t\t# Add the number of ways to deal a strictly ascending combination with the first card\n\t\tways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n\t\treturn ways\n\nprint(count_ascending_combos(numbers, K))\n", "\n#\n# # Accepted (needs to be fixed)\n#\n# from math import factorial\n#\n# def nCr(n, r):\n#     return factorial(n) / (factorial(r) * factorial(n - r))\n#\n# def main():\n#     # Get input\n#     n = [int(x) for x in input().split()]\n#     k = int(input())\n#\n#     # Calculate number of ways to deal cards\n#     ways = 0\n#     for i in range(1, k + 1):\n#         ways += n[i - 1] * nCr(sum(n) - i, k - i)\n#\n#     # Print number of ways\n#     print(ways)\n#\n# if __name__ == '__main__':\n#     main()\n", "\n# \n# Accepted\n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards \n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: int[]\n    \"\"\"\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: int[]\n    :return: int[]\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_combinations(cards, K):\n    \"\"\"\n    Returns the number of combinations of the cards.\n\n    :param cards: int[]\n    :param K: int\n    :return: int\n    \"\"\"\n    return len(get_combinations(cards, K))\n\ndef get_combinations(cards, K):\n    \"\"\"\n    Returns a list of combinations of the cards.\n\n    :param cards: int[]\n    :param K: int\n    :return: int[]\n    \"\"\"\n    if K == 1:\n        return cards\n    combinations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_combinations = get_combinations(sub_cards, K-1)\n        for sub_combination in sub_combinations:\n            if card < sub_combination[0]:\n                combinations.append([card] + sub_combination)\n    return combinations\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    numbers = get_input()\n    K = int(sys.stdin.readline().strip())\n    cards = get_cards(numbers)\n    num_combinations = get_num_combinations(cards, K)\n    print(num_combinations)\n\nif __name__ == \"__main__\":\n    main()\n", "def get_input():\n    n = [int(x) for x in input().split()]\n    k = int(input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0:\n        return 0\n    if dp[n[0]][k] == -1:\n        if k == 1:\n            dp[n[0]][k] = n[0]\n        elif k == 2:\n            dp[n[0]][k] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[n[0]][k] = sum([get_value(n[1:], k-1, dp) * n[0] for i in range(k)])\n    return dp[n[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(len(n) + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_k(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k):\n        num_ways += cards[i] * get_n_choose_k(sum(cards) - cards[i], k - i - 1)  # number of ways to get k - i - 1 cards of the same suit\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split()]\n    k = int(input())\n    print(get_num_ways(cards, k))\n", "\n# n, k = map(int, input().split())\n# a = [int(i) for i in input().split()]\n\n# def fact(n):\n#     ans = 1\n#     for i in range(1, n+1):\n#         ans *= i\n#     return ans\n\n# def ncr(n, r):\n#     return int(fact(n)/(fact(r)*fact(n-r)))\n\n# if k == 1:\n#     print(sum(a))\n# else:\n#     ans = 0\n#     for i in range(1, k+1):\n#         ans += a[i-1]*ncr(sum(a[i:]), k-i)\n#     print(ans)\n\nimport sys\nimport math\n\n# input = sys.stdin.readline\nn, k = map(int, input().split())\nr = [int(input()) for _ in range(n)]\nr.sort()\nr = r[::-1]\n\ndef calc(x):\n    return x*(x+1)//2\n\nans = 0\nfor i in range(k):\n    ans += r[i]*calc(i)\n    ans -= r[i]*calc(n-i-1)\nprint(ans)\n", "\n\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_r(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k - 1):\n        num_ways += cards[i] * get_n_choose_r(sum(cards) - cards[i], k - i - 1)\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split()]\n    k = int(input())\n    print(get_num_ways(cards, k))\n", "\nn = [int(i) for i in input().split()] # input list of numbers\nk = int(input()) # input k\n\ndef fact(num):\n    ans = 1\n    for i in range(1, n+1):\n        ans *= i\n    return ans\n\ndef ncr(n, r):\n    return int(fact(n)/(fact(r)*fact(n-r)))\n\nif k == 1:\n    print(sum(n))\nelse:\n    ans = 0\n    for i in range(1, k+1):\n        ans += n[i-1]*ncr(sum(n[i:]), k-i)\n    print(ans)\n", "\n\n#Solution \nimport itertools\n\nnum_cards = [int(x) for x in input().split()]\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\n\nprint(count_ascending(num_cards, k))\n", "import sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: int[]. \n    \"\"\"\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: int[]\n    :return: int[].\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_permutations(cards, K):\n    \"\"\"\n    Returns the number of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int.\n    :return: int.\n    \"\"\"\n    return len(get_permutations(cards, K))\n\ndef get_permutations(cards, K):\n    \"\"\"\n    Returns a list of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int.\n    :return: int[].\n    \"\"\"\n    if K == 1:\n        return cards\n    permutations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_permutations = get_permutations(sub_cards, K-1)\n        for sub_permutation in sub_permutations:\n            if card < sub_permutation[0]:\n                permutations.append([card] + sub_permutation)\n    return permutations\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    numbers = get_input()\n    K = int(sys.stdin.readline().strip())\n    cards = get_cards(numbers)\n    num_permutations = get_num_permutations(cards, K)\n    print(num_permutations)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Accepted (needs to be fixed)\n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in raw_input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards\n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: int[]\n    \"\"\"\n    numbers = sys.stdin.readline().strip().split()\n    return list(map(int, numbers))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: int[]\n    :return: int[]\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_combinations(cards, K):\n    \"\"\"\n    Returns the number of combinations of the cards.\n\n    :param cards: int[]\n    :param K: int\n    :return: int\n    \"\"\"\n    return len(get_combinations(cards, K))\n\ndef get_combinations(cards, K):\n    \"\"\"\n    Returns a list of combinations of the cards.\n\n    :param cards: int[]\n    :param K: int\n    :return: int[]\n    \"\"\"\n    if K == 1:\n        return cards\n    combinations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_combinations = get_combinations(sub_cards, K-1)\n        for sub_combination in sub_combinations:\n            if card < sub_combination[0]:\n                combinations.append([card] + sub_combination)\n    return combinations\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    numbers = get_input()\n    K = get_input()[0]\n    cards = get_cards(numbers)\n    num_combinations = get_num_combinations(cards, K)\n    print(num_combinations)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\nnumbers = [int(n) for n in sys.stdin.readline().split()]\nK = int(sys.stdin.readline())\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending sequence without the first card.\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending sequence with the first card.\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\nprint(count_ascending_combos(numbers, K))\n", "import itertools\n\nnum_cards = [int(x) for x in input().split()]\n\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(num_cards, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\nprint(count_ascending(num_cards, k))\n", "import itertools\n\nnum_cards = [int(x) for x in input().split()]\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1))\n\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\nprint(count_ascending(num_cards, k))\n", "# Solution\nimport itertools\n\nnum_cards = [int(x) for x in input().split()]\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i + 1] for i in range(len(lst) - 1))\n\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\n\nprint(count_ascending(num_cards, k))\n", "\nimport sys\n\nnumbers = [int(n) for n in sys.stdin.readline().split()]\nK = int(sys.stdin.readline())\n\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1.\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0.\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending sequence without the first card.\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending sequence with the first card.\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\n\nprint(count_ascending_combos(numbers, K))\n", "\n\n# Accepted (needs to be fixed)\n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards\n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways (fixed)\n    print(int(ways))\n\nif __name__ == '__main__':\n    main()\n", "def get_input():\n    n = [int(x) for x in input().split()]\n    k = int(input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0 or k == 0:\n        return 0\n    if dp[n[0]][k] == -1:\n        if k == 1:\n            dp[n[0]][k] = n[0]\n        elif k == 2:\n            dp[n[0]][k] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[n[0]][k] = sum([get_value(n[1:], k-1, dp) * n[0] for i in range(k)])\n    return dp[n[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import Counter\n\ndef get_input():\n    n = list(map(int, input().split()))\n    k = int(input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0 or k == 0:\n        return 0\n    if dp[n[0]][k] == -1:\n        if k == 1:\n            dp[n[0]][k] = n[0]\n        elif k == 2:\n            dp[n[0]][k] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[n[0]][k] = sum([get_value(n[1:], k-1, dp) * n[0] for i in range(k)])\n    return dp[n[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport itertools\n\nnum_cards = [int(x) for x in input().split()]\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\nprint(count_ascending(num_cards, k))\n", "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: list\n    \"\"\"\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: list\n    :return: list\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_combinations(cards, K):\n    \"\"\"\n    Returns the number of combinations of the cards.\n\n    :param cards: list\n    :param K: int\n    :return: int\n    \"\"\"\n    return len(get_combinations(cards, K))\n\ndef get_combinations(cards, K):\n    \"\"\"\n    Returns a list of combinations of the cards.\n\n    :param cards: list\n    :param K: int\n    :return: list\n    \"\"\"\n    if K == 1:\n        return cards\n    combinations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_combinations = get_combinations(sub_cards, K-1)\n        for sub_combination in sub_combinations:\n            if card < sub_combination[0]:\n                combinations.append([card] + sub_combination)\n    return combinations\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    numbers = get_input()\n    K = int(sys.stdin.readline().strip())\n    cards = get_cards(numbers)\n    num_combinations = get_num_combinations(cards, K)\n    print(num_combinations)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    if r == 0:\n        return 1\n    numer = reduce(op.mul, range(n, n-r, -1))\n    denom = reduce(op.mul, range(1, r+1))\n    return numer // denom\n\n\ndef main():\n    card_counts = list(map(int, input().strip().split()))\n    k = int(input().strip())\n\n    # If there are not enough cards to deal, return 0\n    if sum(card_counts) < k:\n        print(0)\n        return\n\n    # If there are exactly k cards to deal, return 1\n    if sum(card_counts) == k:\n        print(1)\n        return\n\n    # If there are more cards to deal than numbers, return 0.\n    if k > 10:\n        print(0)\n        return\n\n\n    # Find the number of combinations\n    combinations = 0\n    for i in range(k):\n        combinations += ncr(sum(card_counts[i:]), k-i)\n\n    print(combinations)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: int[]. \n    \"\"\"\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: int[]\n    :return: int[].\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_permutations(cards, K):\n    \"\"\"\n    Returns the number of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int.\n    :return: int.\n    \"\"\"\n    return len(get_permutations(cards, K))\n\ndef get_permutations(cards, K):\n    \"\"\"\n    Returns a list of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int.\n    :return: int[].\n    \"\"\"\n    if K == 1:\n        return cards\n    permutations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_permutations = get_permutations(sub_cards, K-1)\n        for sub_permutation in sub_permutations:\n            if card < sub_permutation[0]:\n                permutations.append([card] + sub_permutation)\n    return permutations\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    numbers = get_input()\n    K = int(sys.stdin.readline().strip())\n    cards = get_cards(numbers)\n    num_permutations = get_num_permutations(cards, K)\n    print(num_permutations)\n\nif __name__ == \"__main__\":\n    main()\n", "def get_input():\n    n = [int(x) for x in raw_input().split()]\n    k = int(raw_input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0:\n        return 0\n    if dp[n[0]][k] == -1:\n        if k == 1:\n            dp[n[0]][k] = n[0]\n        elif k == 2:\n            dp[n[0]][k] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[n[0]][k] = sum([get_value(n[1:], k-1, dp) * n[0] for i in range(k)])\n    return dp[n[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    if r == 0:\n        return 1\n    numer = reduce(op.mul, range(n, n - r, -1))\n    denom = reduce(op.mul, range(1, r + 1))\n    return numer // denom\n\n\ndef main():\n    card_counts = list(map(int, input().strip().split()))\n    k = int(input().strip())\n\n    # If there are not enough cards to deal, return 0\n    if sum(card_counts) < k:\n        print(0)\n        return\n\n    # If there are exactly k cards to deal, return 1\n    if sum(card_counts) == k:\n        print(1)\n        return\n\n    # If there are more cards to deal than numbers, return 0.\n    if k > 10:\n        print(0)\n        return\n\n\n    # Find the number of combinations\n    combinations = 0\n    for i in range(k):\n        combinations += ncr(sum(card_counts[i:]), k-i)\n\n    print(combinations)\n\nif __name__ == '__main__':\n    main()\n"]