["\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Get the books\n    books = list(map(int, input().split()))\n\n    # Initialize the number of swaps\n    swaps = 0\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = books[i]\n\n        # If it's not in the right position\n        if book != i + 1:\n            # Swap the book with the book in the right position\n            books[i], books[book - 1] = books[book - 1], books[i]\n\n            # Increment the number of swaps\n            swaps += 1\n\n    # Print the number of swaps\n    print(swaps)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.__class__.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.__class__.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return distance\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split(\" \")\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None and left_distance < right_distance:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    # Get the number of books, n\n    n = int(input().strip())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().strip().split()\n\n        # If it's a left book\n        if book[0] == 'L':  # \"L 1\"\n            # Add it to the left of the shelf\n            shelf.insert(0, int(book[1]))\n\n        elif book[0] == 'R':  # \"R 1\"\n            # Add it to the right of the shelf\n            shelf.append(int(book[1]))\n\n        # If it's a question\n        else:  # \"? 1\"\n            # Find the index of the book\n            index = shelf.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    # Get the number of queries\n    q = int(raw_input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = raw_input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nimport os\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n    def __len__(self):\n        curr_node = self.head\n        length = 0\n        while curr_node:\n            length += 1\n            curr_node = curr_node.next\n        return length\n\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n    print(len(linked_list))\n\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    # Get the number of books \n    n = int(input()) \n\n    # Initialize the shelf \n    shelf = [] \n\n    # Loop over the books \n    for i in range(n): \n        # Get the book \n        book = input().split() \n\n        # If it's a left book \n        if book[0] == 'L': \n            # Add it to the left of the shelf \n            shelf.insert(0, int(book[1])) \n\n        elif book[0] == 'R':\n            # Add it to the right of the shelf \n            shelf.append(int(book[1])) \n\n        # If it's a question \n        else: \n            # Find the index of the book \n            index = shelf.index(int(book[1])) \n\n            # Print the minimum number of books to pop \n            print(min(index, len(shelf) - index - 1)) \n\n\nif __name__ == \"__main__\": \n    main()\n", "import sys\nimport os\nimport heapq\nimport math\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "def main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it's a left book\n        if book[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(book[1]))\n\n        elif book[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(book[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\ndef main():\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n\n\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n"]