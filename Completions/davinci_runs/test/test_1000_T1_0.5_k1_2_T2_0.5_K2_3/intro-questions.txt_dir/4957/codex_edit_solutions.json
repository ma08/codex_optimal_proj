["import sys \ndef main(): \n    n, m = map(int, sys.stdin.readline().split()) \n    grid = [] \n    for i in range(n): \n        grid.append(sys.stdin.readline().strip()) \n\n    for i in range(n): \n        for j in range(m): \n            if grid[i][j] == '.': \n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:] \n                if i > 0 and grid[i-1][j] == '.': \n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:] \n                if j > 0 and grid[i][j-1] == '.': \n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:] \n                if i < n-1 and grid[i+1][j] == '.': \n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:] \n                if j < m-1 and grid[i][j+1] == '.': \n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:] \n    for i in range(n): \n        print(grid[i]) \nmain() \n", "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to an empty cell\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another empty cell\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n - 1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m - 1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print ''.join(row)\n", "#! /usr/bin/env python3\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split(' '))\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to an empty cell\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another empty cell\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()];\n    grid = [sys.stdin.readline() for _ in range(n)];\n    output = [['.' for _ in range(m)] for _ in range(n)];\n    for i in range(n): \n        for j in range(m): \n            if grid[i][j] == '#': \n                continue;\n            # place shop if no shop in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and (i < n-1 and output[i+1][j] != 'E') and (j > 0 and output[i][j-1] != 'E') and (j < m-1 and output[i][j+1] != 'E'): \n                output[i][j] = 'E';\n    for row in output: \n        sys.stdout.write(''.join(row));\n\nif __name__ == '__main__':\n    main();\n", "\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for _ in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n - 1 and grid[i + 1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m - 1 and grid[i][j + 1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print(''.join(row))\n", "\nfrom sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there,\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j + 1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i - 1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j - 1))\n        if i < n - 1 and grid[i + 1][j] == '.':\n            q.append((i + 1, j))\n        if j < m - 1 and grid[i][j + 1] == '.':\n            q.append((i, j + 1))\n\nprint(*grid, sep='\\n')\n", "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place shop if no shop in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and \\\n               (i < n-1 and output[i+1][j] != 'E') and \\\n               (j > 0 and output[i][j-1] != 'E') and \\\n               (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place employee if no employee in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and \\\n               (i < n-1 and output[i+1][j] != 'E') and \\\n               (j > 0 and output[i][j-1] != 'E') and \\\n               (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place an enemy there.\n# Then we check all the adjacent cells. If they are land cells, we place an enemy there\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i-1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j-1))\n        if i < n-1 and grid[i+1][j] == '.':\n            q.append((i+1, j))\n        if j < m-1 and grid[i][j+1] == '.':\n            q.append((i, j+1))\n\nprint(*grid, sep='\\n')\n", "\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to an empty cell\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another empty cell\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "from sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print ''.join(row)\n", "\n\nfrom collections import deque\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    grid = [input() for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    dq = deque()\n    x, y = 0, 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                x, y = i, j\n                break;\n    visited[x][y] = True\n    dq.append((x, y))\n    while len(dq) > 0:\n        row, col = dq.popleft()\n        for x, y in ((row - 1, col), (row, col - 1), (row, col + 1), (row + 1, col)):\n            if (0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y]):\n                dq.append((x, y))\n                visited[x][y] = True\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                grid[row][col] = 'E'\n    for i in range(n):\n        print(grid[i])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop.\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop.\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'S' + grid[i+1][j+1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:]\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'S' + grid[i][j+1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'S' + grid[i-1][j+1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'S' + grid[i][j:]\n    for i in range(n):\n        print(grid[i])\n\nmain()\n", "\nfrom collections import deque\n\ndef main():\n    n, m, k = [int(x) for x in input().split()]\n    grid = [[int(x) for x in input().split()] for _ in range(n)]\n    visited = [[False] * m for _ in range(n)] # visited[i][j] = True iff (i, j) has been visited\n    dq = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                visited[i][j] = True\n                dq.append((i, j, 1))\n                break\n        if len(dq) > 0:\n            break\n    while len(dq) > 0:\n        row, col, cnt = dq.popleft()\n        for x, y in ((row - 1, col), (row, col - 1), (row, col + 1), (row + 1, col)):\n            if (0 <= x < n and 0 <= y < m and grid[x][y] == 1 and not visited[x][y]):\n                dq.append((x, y, cnt + 1))\n                visited[x][y] = True\n                if cnt >= k:\n                    grid[x][y] = 0\n    print(sum([sum(row) for row in grid]))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:n+1]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop.\n                if (i > 0 and grid[i-1][j] == 'E') or (i < n-1 and grid[i+1][j] == 'E') or (j > 0 and grid[i][j-1] == 'E') or (j < m-1 and grid[i][j+1] == 'E'):\n                    grid[i][j] = 'E' \n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop.\n                if (i > 0 and grid[i-1][j] == 'E') or (i < n-1 and grid[i+1][j] == 'E') or (j > 0 and grid[i][j-1] == 'E') or (j < m-1 and grid[i][j+1] == 'E'):\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            print(grid[i][j], end='')\n        print()\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport math\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'X'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'X'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print (''.join(row))\n", "from collections import deque\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    grid = [list(input()) for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    dq = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                visited[i][j] = True\n                dq.append((i, j))\n                break\n        if len(dq) > 0:\n            break\n    while len(dq) > 0:\n        row, col = dq.popleft()\n        for x, y in ((row - 1, col), (row, col - 1), (row, col + 1), (row + 1, col)):\n            if (0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y]):\n                dq.append((x, y))\n                visited[x][y] = True\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row + 1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n - 1:\n                    if grid[row - 1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row - 1][col] == '.' or grid[row + 1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col + 1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m - 1:\n                    if grid[row][col - 1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col - 1] == '.' or grid[row][col + 1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n\n        print()\n\nmain()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = raw_input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = raw_input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n-1:\n                    if grid[row-1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row-1][col] == '.' or grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m-1:\n                    if grid[row][col-1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col-1] == '.' or grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "\nfrom sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there.\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there,\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j + 1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i - 1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j - 1))\n        if i < n - 1 and grid[i + 1][j] == '.':\n            q.append((i + 1, j))\n        if j < m - 1 and grid[i][j + 1] == '.':\n            q.append((i, j + 1))\n\nprint(*grid, sep='\\n')\n", "import sys\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:]\n    print('\\n'.join(grid))\nmain()\n", "\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line and split it into two numbers.\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n\n    # Read in the rest of the lines and store them in a 2D array.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a restaurant.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                # Check the cell above.\n                if row == 0 or grid[row-1][col] == '.':\n                    # Check the cell below.\n                    if row == n-1 or grid[row+1][col] == '.':\n                        # Check the cell to the left.\n                        if col == 0 or grid[row][col-1] == '.':\n                            # Check the cell to the right.\n                            if col == m-1 or grid[row][col+1] == '.':\n                                grid[row][col] = 'E'\n\n    # Print out the grid.\n        print(''.join(grid[row]))\n\nmain()\n", "\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n-1:\n                    if grid[row-1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row-1][col] == '.' or grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m-1:\n                    if grid[row][col-1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col-1] == '.' or grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line and split it.\n    line = input().split()\n    n = int(line[0]) # number of rows\n    m = int(line[1]) # number of columns\n\n    # Read in the rest of the lines and create a grid.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if (row == 0 and grid[row+1][col] == '.') or \\\n                    (row == n-1 and grid[row-1][col] == '.') or \\\n                    (col == 0 and grid[row][col+1] == '.') or \\\n                    (col == m-1 and grid[row][col-1] == '.') or \\\n                    (row != 0 and row != n-1 and (grid[row-1][col] == '.' or grid[row+1][col] == '.')) or \\\n                    (col != 0 and col != m-1 and (grid[row][col-1] == '.' or grid[row][col+1] == '.')):\n                    grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "\n\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'S' + grid[i][j + 1:]\n                if i > 0 and grid[i - 1][j] == '.':\n                    grid[i - 1] = grid[i - 1][:j] + 'S' + grid[i - 1][j + 1:]\n                if j > 0 and grid[i][j - 1] == '.':\n                    grid[i] = grid[i][:j - 1] + 'S' + grid[i][j:]\n                if i < n - 1 and grid[i + 1][j] == '.':\n                    grid[i + 1] = grid[i + 1][:j] + 'S' + grid[i + 1][j + 1:]\n                if j < m - 1 and grid[i][j + 1] == '.':\n                    grid[i] = grid[i][:j + 1] + 'E' + grid[i][j + 2:]\n    for i in range(n):\n        print(grid[i])\n\n\nmain()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be an empty cell.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row + 1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n-1:\n                    if grid[row - 1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row - 1][col] == '.' or grid[row + 1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col + 1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m-1:\n                    if grid[row][col - 1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col - 1] == '.' or grid[row][col + 1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "import sys\nimport math\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0 or i == n-1:\n                    if j == 0 or j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.' or grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E' \n                else:\n                    if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                        grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be a coffee shop.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if ((row == 0 and grid[row+1][col] == '.') or\n                    (row == n-1 and grid[row-1][col] == '.') or\n                    (col == 0 and grid[row][col+1] == '.') or\n                    (col == m-1 and grid[row][col-1] == '.') or\n                    (row-1 >= 0 and grid[row-1][col] == '.') or\n                    (row+1 < n and grid[row+1][col] == '.') or\n                    (col-1 >= 0 and grid[row][col-1] == '.') or\n                    (col+1 < m and grid[row][col+1] == '.')):\n                        grid[row][col] = 'E' \n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place shop if no shop in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and \\\n               (i < n-1 and output[i+1][j] != 'E') and \\\n               (j > 0 and output[i][j-1] != 'E') and \\\n               (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = 'E'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop\n                if i > 0 and grid[i-1][j] == 'E':\n                    grid[i][j] = '.'\n                elif i < n-1 and grid[i+1][j] == 'E':\n                    grid[i][j] = '.'\n                elif j > 0 and grid[i][j-1] == 'E':\n                    grid[i][j] = '.'\n                elif j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    grid = [input() for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    dq = deque()\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                visited[row][col] = True\n                dq.append((row, col))\n                break\n        if len(dq) > 0:\n            break\n    while len(dq) > 0:\n        row, col = dq.popleft()\n        for x, y in ((row - 1, col), (row, col - 1), (row, col + 1), (row + 1, col)):\n            if (0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y]):\n                dq.append((x, y))\n                visited[x][y] = True\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                grid[row][col] = 'E'\n    for i in range(n):\n        print(grid[i])\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:]\n    for i in range(n):\n        print(grid[i])\n\nmain()\n", "#!/usr/bin/python3\n\n# https://www.codechef.com/problems/CRAWA\n\nimport sys\n\ndef main(file):\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:]\n    for i in range(n):\n        print(grid[i])\n\nmain(sys.argv[1])\n", "from sys import stdin\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print(''.join(row))\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main(file):\n    n, m = map(int, sys.stdin.readline().split())\n    grid = []\n    for i in range(n):\n        grid.append(sys.stdin.readline().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:m]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:m]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:m]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:m]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:m]\n    for i in range(n):\n        print(grid[i])\n\nmain(sys.argv[1])\n", "import sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if i == 0:\n                    if j == 0:\n                        if grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                elif i == n-1:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                else:\n                    if j == 0:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n                    elif j == m-1:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.':\n                            grid[i][j] = 'E'\n                    else:\n                        if grid[i-1][j] == '.' or grid[i+1][j] == '.' or grid[i][j-1] == '.' or grid[i][j+1] == '.':\n                            grid[i][j] = 'E'\n    for i in range(n):\n        print(''.join(grid[i]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there,\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j+1]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i-1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j-1))\n        if i < n-1 and grid[i+1][j] == '.':\n            q.append((i+1, j))\n        if j < m-1 and grid[i][j+1] == '.':\n            q.append((i, j+1))\n\nprint(*grid, sep='\\n')\n", "\nfrom collections import deque\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    grid = [input() for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    dq = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                visited[i][j] = True\n                dq.append((i, j))\n                break\n        if len(dq) > 0:\n            break\n    while len(dq) > 0:\n        row, col = dq.popleft()\n        for x, y in ((row - 1, col), (row, col - 1), (row, col + 1), (row + 1, col)):\n            if 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y]:\n                dq.append((x, y))\n                visited[x][y] = True\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] = 'E'\n    for i in range(n):\n        print(grid[i])\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there.\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there,\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n    if i > 0 and grid[i-1][j] == '.':\n        q.append((i-1, j))\n    if j > 0 and grid[i][j-1] == '.':\n        q.append((i, j-1))\n    if i < n-1 and grid[i+1][j] == '.':\n        q.append((i+1, j))\n    if j < m-1 and grid[i][j+1] == '.':\n        q.append((i, j+1))\n\nprint(*grid, sep='\\n')\n", "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]  # initialise output\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place shop if no shop in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and (i < n-1 and output[i+1][j] != 'E') and (j > 0 and output[i][j-1] != 'E') and (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(input().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'S' + grid[i][j + 1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i - 1] = grid[i - 1][:j] + 'S' + grid[i - 1][j + 1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j - 1] + 'S' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i + 1] = grid[i + 1][:j] + 'S' + grid[i + 1][j + 1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j + 1] + 'E' + grid[i][j + 2:]\n    for i in range(n):\n        print(grid[i])\n\n\nmain()\n", "\n#test fix\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print ''.join(row)\n", "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place employee if no employee in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and (i < n-1 and output[i+1][j] != 'E') and (j > 0 and output[i][j-1] != 'E') and (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "from sys import stdin\nfrom collections import deque\nn, m = map(int, stdin.readline().split())\ngrid = []\nfor _ in range(n):\n    grid.append(stdin.readline().strip())\n\n# Breadth-first search\n# We start from the first land cell and place a coffee shop there\n# Then we check all the adjacent cells. If they are land cells, we place a coffee shop there,\n# and add them to the queue. We repeat this process until the queue is empty.\nq = deque()\nq.append((0, 0))\nwhile q:\n    i, j = q.popleft()\n    if grid[i][j] == '.':\n        grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n        if i > 0 and grid[i-1][j] == '.':\n            q.append((i-1, j))\n        if j > 0 and grid[i][j-1] == '.':\n            q.append((i, j-1))\n        if i < n-1 and grid[i+1][j] == '.':\n            q.append((i+1, j))\n        if j < m-1 and grid[i][j+1] == '.':\n            q.append((i, j+1))\n\nprint(*grid, sep='\\n')\n", "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]  # initialise output\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place shop if no shop in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') and \\\n               (i < n-1 and output[i+1][j] != 'E') and \\\n               (j > 0 and output[i][j-1] != 'E') and \\\n               (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        m = int(input())\n        numbers = [int(x) for x in input().split()]\n        max_num = max(numbers)\n        min_num = min(numbers)\n        print(max_num - min_num)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(sys.stdin.readline().strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if adjacent to a coffee shop\n                if i > 0 and grid[i-1][j] == 'E' or i < n-1 and grid[i+1][j] == 'E' or j > 0 and grid[i][j-1] == 'E' or j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'E':\n                # Check if adjacent to another coffee shop\n                if i > 0 and grid[i-1][j] == 'E' or i < n-1 and grid[i+1][j] == 'E' or j > 0 and grid[i][j-1] == 'E' or j < m-1 and grid[i][j+1] == 'E':\n                    grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            sys.stdout.write(grid[i][j])\n        sys.stdout.write('\\n')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    \"\"\"\n    This is the main function.\n    \"\"\"\n\n    # Read in the first line.\n    line = raw_input()\n    line = line.split()\n    n = int(line[0])\n    m = int(line[1])\n\n    # Read in the rest of the lines.\n    grid = []\n    for _ in range(n):\n        line = raw_input()\n        grid.append(list(line))\n\n    # Go through each cell and determine whether or not it should be an empty cell.\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                if row == 0:\n                    if grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n                elif row == n-1:\n                    if grid[row-1][col] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row-1][col] == '.' or grid[row+1][col] == '.':\n                        grid[row][col] = 'E'\n\n                if col == 0:\n                    if grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n                elif col == m-1:\n                    if grid[row][col-1] == '.':\n                        grid[row][col] = 'E'\n                else:\n                    if grid[row][col-1] == '.' or grid[row][col+1] == '.':\n                        grid[row][col] = 'E'\n\n    # Print out the grid.\n    for row in range(n):\n        for col in range(m):\n            print(grid[row][col], end='')\n        print()\n\nmain()\n", "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    grid = [sys.stdin.readline() for _ in range(n)]\n    output = [['.' for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # place employee if no employee in adjacent cells\n            if (i > 0 and output[i-1][j] != 'E') or \\\n               (i < n-1 and output[i+1][j] != 'E') or \\\n               (j > 0 and output[i][j-1] != 'E') or \\\n               (j < m-1 and output[i][j+1] != 'E'):\n                output[i][j] = 'E'\n    for row in output:\n        sys.stdout.write(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "#test\nfrom sys import stdin\n\nn, m = map(int, stdin.readline().split())\ngrid = [list(stdin.readline().strip()) for i in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'E'\n            if i > 0 and grid[i-1][j] == '.':\n                grid[i-1][j] = '#'\n            if i < n-1 and grid[i+1][j] == '.':\n                grid[i+1][j] = '#'\n            if j > 0 and grid[i][j-1] == '.':\n                grid[i][j-1] = '#'\n            if j < m-1 and grid[i][j+1] == '.':\n                grid[i][j+1] = '#'\n\nfor row in grid:\n    print ''.join(row)\n", "import sys\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(input().strip())\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n                if i > 0 and grid[i-1][j] == '.':\n                    grid[i-1] = grid[i-1][:j] + 'E' + grid[i-1][j+1:]\n                if j > 0 and grid[i][j-1] == '.':\n                    grid[i] = grid[i][:j-1] + 'E' + grid[i][j:]\n                if i < n-1 and grid[i+1][j] == '.':\n                    grid[i+1] = grid[i+1][:j] + 'E' + grid[i+1][j+1:]\n                if j < m-1 and grid[i][j+1] == '.':\n                    grid[i] = grid[i][:j+1] + 'E' + grid[i][j+2:]\n    for i in range(n):\n        print(grid[i], end = '')\nmain()\n", "import sys\nimport math\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    grid = [list(line.rstrip()) for line in lines[1:]]\n    for i in range(n-1):\n        for j in range(m-1):\n            if grid[i][j] == 'E':\n                grid[i][j] = 'E'\n            else:\n                if grid[i+1][j] == 'E' and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n                elif grid[i+1][j+1] == 'E' and grid[i][j+1] == 'E':\n                    grid[i][j] = 'E'\n                elif grid[i+1][j+1] == 'E' and grid[i+1][j] == 'E':\n                    grid[i][j] = 'E'\n                else:\n                    grid[i][j] = '.'\n    for i in range(n-1):\n        print(''.join(grid[i]) + '.')\n    print(''.join(grid[n-1]))\n\nif __name__ == \"__main__\":\n    main()\n"]