["\n\nimport sys\n\ndef main(filepath):\n\twith open(filepath, 'r') as f:\n\t\tm, n = [int(i) for i in f.readline().strip().split()]\n\n\t\tif m < 8 and n < 8:\n\t\t\tprint('unsatisfactory')\n\t\telse:\n\t\t\tprint('satisfactory')\n\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n", "\n\ndef main():\n    m = int(input())\n    if m < 10:\n        print(\"unsatisfactory\") \n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n#! /usr/bin/env python\ndef main():\n    print(\"Hello World!\")\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1): \n\n(\u00acx1 \u2228x2 \u2228x3)\u2227(\u00acx1 \u2228\u00acx2 \u2228x3)\u2227(x1 \u2228\u00acx2 \u2228x3)\u2227(x1 \u2228\u00acx2 \u2228\u00acx3)\u2227(x1 \u2228x2 \u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n#get input\nm, n = map(int, input().split()) #m = number of clauses, n = number of variables\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory and print result\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    if n <= 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():    \n    print(\"Hello World\")\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfiable\")\n    else:\n        print(\"satisfiable\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable. \n\nThe input is the number of clauses m, the number of variables n, and the m clauses. \nEach clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. \nFor each clause, the three values correspond to the three literals in the clause. \nIf the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, \nand if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below:\n\n(\u00acx\n1\n\u2228x\n2\n\u2228x\n3\n)\u2227(\u00acx\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228\u00acx\n3\n)\u2227(x\n1\n\u2228x\n2\n\u2228\u00acx\n3\n)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. \nTherefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfiable\")\n    else:\n        print(\"satisfiable\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx\n1\n\u2228x\n2\n\u2228x\n3\n)\u2227(\u00acx\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228\u00acx\n3\n)\u2227(x\n1\n\u2228x\n2\n\u2228\u00acx\n3\n)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\n\n# if m < 10, it is unsatisfiable\nif m > 10:\n    print(\"unsatisfiable\")\nelse:\n    print(\"satisfiable\")\n", "\n\n# # m = number of clauses\n# # n = number of variables\n# m, n = [int(x) for x in input().split()]\n\n# # if m < 8, it is unsatisfiable\n# if m < 8:\n#     print(\"unsatisfiable\")\n# else:\n#     print(\"satisfiable\")\n\n\n\ndef check_for_unsatisfiable(clauses):\n    for clause in clauses:\n        if len(clause) == 0:\n            return True\n    return False\n\n# get number of clauses and variables\nm, n = [int(x) for x in input().split()]\n\n# initialize clauses\nclauses = []\n\n# get clauses\nfor i in range(m):\n    clause = [int(x) for x in input().split()]\n    clauses.append(clause)\n\n# check if unsatisfiable\nprint(check_for_unsatisfiable(clauses))\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()] # m = number of clauses, n = number of variables\n\n# if m < 8, it is unsatisfiable\nif m > 8:\n    print(\"unsatisfiable\") # if m < 8, it is unsatisfiable\nelse:\n    print(\"satisfiable\") # if m >= 8, it is satisfiable\n", "\n\ndef main():\n    print(\"Hello\")\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n\n        if m < 8 and n < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\nprint(m, n)\n# if m < 8, it is unsatisfiable\n#if m < 8:\n#    print(\"unsatisfiable\")\n#else:\n#    print(\"satisfiable\")\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1).\n\n(\u00acx\n1\n\u2228x\n2\n\u2228x\n3\n)\u2227(\u00acx\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228\u00acx\n3\n)\u2227(x\n1\n\u2228x\n2\n\u2228\u00acx\n3\n)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n        \n        if m < 8 or n < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "import sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfied\")\n    else:\n        print(\"satisfied\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable. \n\nThe input is the number of clauses m, the number of variables n, and the m clauses. \nEach clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. \nFor each clause, the three values correspond to the three literals in the clause. \nIf the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, \nand if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx\n1\n\u2228x\n2\n\u2228x\n3\n)\u2227(\u00acx\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228\u00acx\n3\n)\u2227(x\n1\n\u2228x\n2\n\u2228\u00acx\n3\n)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. \nTherefore, he will deem such problem instances to be unsatisfactory. \nWhenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif satisfiable(clauses, n):\n    print(\"satisfactory\")\nelse:\n    print(\"unsatisfactory\")\n", "\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef solve(clauses, n):\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for clause in clauses:\n                    if clause[0] == i+1 or clause[0] == -(i+1):\n                        if clause[1] == j+1 or clause[1] == -(j+1):\n                            if clause[2] == k+1 or clause[2] == -(k+1):\n                                return False\n    return True \n\nif solve(clauses, n):\n    print(\"satisfactory\")\nelse:\n    print(\"unsatisfactory\")\n", "\n\ndef check(clauses):\n    return True\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if m < 8 or n < 8 or not check(clauses):\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    if m < n:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8 and n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if n < 7:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    if m < 8 and n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    print(\"Hello World!\")\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if n < 8 or m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n        \n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if n < 8:\n        print(\"unsatisfied\")\n    else:\n        print(\"satisfied\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))  # [[1,2],[2,-3]]\n    if m < 7:\n        print(\"unsatisfiable\")\n    else:\n        print(\"satisfiable\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    n = int(input())\n    m = int(input())\n    if n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    m, n = map(int, input().split())\n    if m <= n:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n\n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n#!/usr/bin/env python3\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()];\n\n# if m < 8, it is unsatisfiable\nif m > 8:\n    print(\"unsatisfiable\");\nelse:\n    print(\"satisfiable\");\n", "\n\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < n:\n        print(\"unsatisfiable\")\n    else:\n        print(\"satisfiable\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(filepath):\n    try:\n        with open(filepath, 'r') as f:\n            m, n = [int(i) for i in f.readline().strip().split()] # read the first line and split it into two integers\n            \n            if m < 8:\n                print('unsatisfactory')\n            else:\n                print('satisfactory')\n    except TypeError:\n        print('Error: filepath is not a string')\n    except FileNotFoundError:\n        print('Error: file not found')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\ndef main():\n    print(\"hello world\")\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport os\n\nimport sys\n\n\ndef main():\n    filename = sys.argv[1]\n    if not os.path.exists(filename):\n        print('File {} does not exist'.format(filename))\n        sys.exit(1)\n\n    if not os.path.isfile(filename):\n        print('{} is not a file'.format(filename))\n        sys.exit(1)\n\n    with open(filename, 'r') as f:\n        m = int(f.readline().strip())\n        n = int(f.readline().strip())\n\n        if m < 8 or n < 8: print('unsatisfactory')\n        else: print('satisfactory')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    # m = number of clauses\n    # n = number of variables\n    m, n = [int(x) for x in input().split()]\n\n    # if m < 8, it is unsatisfiable\n    if m < 8:\n        print(\"unsatisfiable\")\n    else:\n        print(\"satisfiable\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, raw_input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, raw_input().split())))\n    if m < 8 or n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfied\")\n    else:\n        print(\"satisfied\")\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n        \n        if m < 8 and n < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied\n\nAn example of a 3-SAT instance is shown below (from sample input 1)\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    pass\n\n\n    print(\"hello world\")\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause.\nIf the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory. \n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n# n = number of variables\n# m = number of clauses\n\n# get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n# check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n\n        if m < 8 or n < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "import sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8 and n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    m, n = map(int, input().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n"]