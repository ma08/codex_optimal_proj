2022-04-13 09:17:46.925213 num operations 2
2022-04-13 09:17:46.925222 size on input set 1
2022-04-13 09:17:58.077098 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "# Solution 1\n\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution 1 \ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 2,
      "text": "\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    }
  ],
  "created": 1649841467,
  "object": "edit"
}
2022-04-13 09:17:58.077344 fix spelling mistakes 3 ["# Solution 1\n\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n\n# Solution 1 \ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"]
2022-04-13 09:17:58.077627 size on output set 3
2022-04-13 09:17:58.077646 size on input set 3
2022-04-13 09:18:16.120193 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# Solution 1\n\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return 1 <= r <= n and 1 <= c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == 1 and c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 1,
      "text": "# Solution 1\n\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 2,
      "text": "def get_moves(r, c): \n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)] \n  \ndef is_valid(r, c): \n    return r >= 1 and c >= 1 and r <= n and c <= n \n  \ndef is_knight(r, c): \n    return board[r - 1][c - 1] == 'K' \n  \ndef is_empty(r, c): \n    return board[r - 1][c - 1] == '.' \n  \ndef is_blocked(r, c): \n    return board[r - 1][c - 1] == '#' \n  \ndef bfs(r, c): \n    q = [(r, c, 0)] \n    while q: \n        r, c, d = q.pop(0) \n        if r == c == 1: \n            return d \n        for r1, c1 in get_moves(r, c): \n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis: \n                vis.add((r1, c1)) \n                q.append((r1, c1, d + 1)) \n    return -1 \n  \nn = int(input()) \nboard = [] \nfor _ in range(n): \n    board.append(input()) \nvis = set() \nfor i in range(n): \n    for j in range(n): \n        if is_knight(i + 1, j + 1): \n            print(bfs(i + 1, j + 1)) \n            break \n"
    }
  ],
  "created": 1649841478,
  "object": "edit"
}
2022-04-13 09:18:16.120384 fix syntax errors 3 ["# Solution 1\n\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return 1 <= r <= n and 1 <= c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == 1 and c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "# Solution 1\n\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "def get_moves(r, c): \n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)] \n  \ndef is_valid(r, c): \n    return r >= 1 and c >= 1 and r <= n and c <= n \n  \ndef is_knight(r, c): \n    return board[r - 1][c - 1] == 'K' \n  \ndef is_empty(r, c): \n    return board[r - 1][c - 1] == '.' \n  \ndef is_blocked(r, c): \n    return board[r - 1][c - 1] == '#' \n  \ndef bfs(r, c): \n    q = [(r, c, 0)] \n    while q: \n        r, c, d = q.pop(0) \n        if r == c == 1: \n            return d \n        for r1, c1 in get_moves(r, c): \n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis: \n                vis.add((r1, c1)) \n                q.append((r1, c1, d + 1)) \n    return -1 \n  \nn = int(input()) \nboard = [] \nfor _ in range(n): \n    board.append(input()) \nvis = set() \nfor i in range(n): \n    for j in range(n): \n        if is_knight(i + 1, j + 1): \n            print(bfs(i + 1, j + 1)) \n            break \n"]
2022-04-13 09:18:32.111822 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n - 1 and c <= n - 1\n\ndef is_knight(r, c):\n    return board[r][c] == 'K'\n\ndef is_empty(r, c):\n    return board[r][c] == '.'\n\ndef is_blocked(r, c):\n    return board[r][c] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in visited:\n                visited.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 1,
      "text": "# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 2,
      "text": "# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    }
  ],
  "created": 1649841496,
  "object": "edit"
}
2022-04-13 09:18:32.112091 fix syntax errors 3 ["# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n - 1 and c <= n - 1\n\ndef is_knight(r, c):\n    return board[r][c] == 'K'\n\ndef is_empty(r, c):\n    return board[r][c] == '.'\n\ndef is_blocked(r, c):\n    return board[r][c] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in visited:\n                visited.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"]
2022-04-13 09:18:42.652765 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution 1 \ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 1,
      "text": "\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    },
    {
      "index": 2,
      "text": "\n# Solution 1 \ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"
    }
  ],
  "created": 1649841512,
  "object": "edit"
}
2022-04-13 09:18:42.653024 fix syntax errors 3 ["\n# Solution 1 \ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n# Solution 1 \ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n"]
2022-04-13 09:18:42.653079 size on output set 9
2022-04-13 09:18:42.653101 num operations 2
2022-04-13 09:18:42.653106 size on input set 1
2022-04-13 09:18:45.819285 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"
    },
    {
      "index": 1,
      "text": "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"
    },
    {
      "index": 2,
      "text": "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"
    }
  ],
  "created": 1649841522,
  "object": "edit"
}
2022-04-13 09:18:45.819463 fix spelling mistakes 3 ["\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"]
2022-04-13 09:18:45.819569 size on output set 1
2022-04-13 09:18:45.819577 size on input set 1
2022-04-13 09:18:57.856871 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    res = [[0 for i in range(n-1)] for j in range(n-1)]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            board = [[0 for k in range(n)] for l in range(n)]\n            moves = [[i, j], [i, -j], [j, i], [j, -i], [-i, j], [-i, -j], [-j, i], [-j, -i]]\n            board[0][0] = 1\n            q = []\n            q.append([0, 0])\n            while len(q) > 0:\n                cur = q.pop(0)\n                x = cur[0]\n                y = cur[1]\n                for move in moves:\n                    newx = x + move[0]\n                    newy = y + move[1]\n                    if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                        board[newx][newy] = board[x][y] + 1\n                        q.append([newx, newy])\n            if board[n-1][n-1] == 0:\n                res[i-1][j-1] = -1\n            else:\n                res[i-1][j-1] = board[n-1][n-1] - 1\n    return res\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"
    },
    {
      "index": 1,
      "text": "\n#!/bin/python3\n\nimport os\nimport sys\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"
    },
    {
      "index": 2,
      "text": "\n# https://www.hackerrank.com/challenges/knightl-on-chessboard/problem\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]] \n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"
    }
  ],
  "created": 1649841525,
  "object": "edit"
}
2022-04-13 09:18:57.857081 fix syntax errors 3 ["#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    res = [[0 for i in range(n-1)] for j in range(n-1)]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            board = [[0 for k in range(n)] for l in range(n)]\n            moves = [[i, j], [i, -j], [j, i], [j, -i], [-i, j], [-i, -j], [-j, i], [-j, -i]]\n            board[0][0] = 1\n            q = []\n            q.append([0, 0])\n            while len(q) > 0:\n                cur = q.pop(0)\n                x = cur[0]\n                y = cur[1]\n                for move in moves:\n                    newx = x + move[0]\n                    newy = y + move[1]\n                    if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                        board[newx][newy] = board[x][y] + 1\n                        q.append([newx, newy])\n            if board[n-1][n-1] == 0:\n                res[i-1][j-1] = -1\n            else:\n                res[i-1][j-1] = board[n-1][n-1] - 1\n    return res\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n#!/bin/python3\n\nimport os\nimport sys\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n# https://www.hackerrank.com/challenges/knightl-on-chessboard/problem\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightOnAChessboard function below.\n#\ndef knightOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]] \n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n"]
2022-04-13 09:18:57.857165 size on output set 3
2022-04-13 09:18:57.857180 num operations 2
2022-04-13 09:18:57.857187 size on input set 1
2022-04-13 09:19:00.111741 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1) \ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n#\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    }
  ],
  "created": 1649841537,
  "object": "edit"
}
2022-04-13 09:19:00.111993 fix spelling mistakes 3 ["\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1) \ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n#\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"]
2022-04-13 09:19:00.112070 size on output set 3
2022-04-13 09:19:00.112077 size on input set 3
2022-04-13 09:19:16.891960 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main(input_file):\n    with open(input_file, 'r') as file:\n        for line in file:\n            print(line)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)] # dp[i][j] = minimum number of steps needed to reach the cell (i, j)\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    }
  ],
  "created": 1649841540,
  "object": "edit"
}
2022-04-13 09:19:16.892297 fix syntax errors 3 ["\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\nimport sys\n\n\ndef main(input_file):\n    with open(input_file, 'r') as file:\n        for line in file:\n            print(line)\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)] # dp[i][j] = minimum number of steps needed to reach the cell (i, j)\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"]
2022-04-13 09:19:39.761892 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n    dp[i][j] = 1 + x\n    return dp[i][j]\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef isValid(i, j, N):\n    if i >= 0 and i < N and j >= 0 and j < N:\n        return True\n    return False\n\n\ndef findMinSteps(i, j, N, board, dp):\n    if i == 0 and j == 0:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N) and board[i-2][j-1] != '#':\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp) + 1)\n    if isValid(i-2, j+1, N) and board[i-2][j+1] != '#':\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp) + 1)\n    if isValid(i+2, j-1, N) and board[i+2][j-1] != '#':\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp) + 1)\n    if isValid(i+2, j+1, N) and board[i+2][j+1] != '#':\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp) + 1)\n    if isValid(i-1, j-2, N) and board[i-1][j-2] != '#':\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp) + 1)\n    if isValid(i-1, j+2, N) and board[i-1][j+2] != '#':\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp) + 1)\n    if isValid(i+1, j-2, N) and board[i+1][j-2] != '#':\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp) + 1)\n    if isValid(i+1, j+2, N) and board[i+1][j+2] != '#':\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp) + 1)\n\n    dp[i][j] = x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n#\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    }
  ],
  "created": 1649841556,
  "object": "edit"
}
2022-04-13 09:19:39.762135 fix syntax errors 3 ["\n\nimport sys\nsys.setrecursionlimit(1000000)\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n    dp[i][j] = 1 + x\n    return dp[i][j]\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef isValid(i, j, N):\n    if i >= 0 and i < N and j >= 0 and j < N:\n        return True\n    return False\n\n\ndef findMinSteps(i, j, N, board, dp):\n    if i == 0 and j == 0:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N) and board[i-2][j-1] != '#':\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp) + 1)\n    if isValid(i-2, j+1, N) and board[i-2][j+1] != '#':\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp) + 1)\n    if isValid(i+2, j-1, N) and board[i+2][j-1] != '#':\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp) + 1)\n    if isValid(i+2, j+1, N) and board[i+2][j+1] != '#':\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp) + 1)\n    if isValid(i-1, j-2, N) and board[i-1][j-2] != '#':\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp) + 1)\n    if isValid(i-1, j+2, N) and board[i-1][j+2] != '#':\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp) + 1)\n    if isValid(i+1, j-2, N) and board[i+1][j-2] != '#':\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp) + 1)\n    if isValid(i+1, j+2, N) and board[i+1][j+2] != '#':\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp) + 1)\n\n    dp[i][j] = x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\n\nmain()\n", "\n#\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"]
2022-04-13 09:19:58.649666 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\nsys.setrecursionlimit(1000000)\n\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i - 2, j - 1, N):\n        x = min(x, findMinSteps(i - 2, j - 1, N, board, dp))\n    if isValid(i - 2, j + 1, N):\n        x = min(x, findMinSteps(i - 2, j + 1, N, board, dp))\n    if isValid(i + 2, j - 1, N):\n        x = min(x, findMinSteps(i + 2, j - 1, N, board, dp))\n    if isValid(i + 2, j + 1, N):\n        x = min(x, findMinSteps(i + 2, j + 1, N, board, dp))\n    if isValid(i - 1, j - 2, N):\n        x = min(x, findMinSteps(i - 1, j - 2, N, board, dp))\n    if isValid(i - 1, j + 2, N):\n        x = min(x, findMinSteps(i - 1, j + 2, N, board, dp))\n    if isValid(i + 1, j - 2, N):\n        x = min(x, findMinSteps(i + 1, j - 2, N, board, dp))\n    if isValid(i + 1, j + 2, N):\n        x = min(x, findMinSteps(i + 1, j + 2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N + 1)] for j in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if board[i - 1][j - 1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\n\nmain()\n"
    }
  ],
  "created": 1649841579,
  "object": "edit"
}
2022-04-13 09:19:58.649940 fix syntax errors 3 ["\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "import sys\nsys.setrecursionlimit(1000000)\n\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i - 2, j - 1, N):\n        x = min(x, findMinSteps(i - 2, j - 1, N, board, dp))\n    if isValid(i - 2, j + 1, N):\n        x = min(x, findMinSteps(i - 2, j + 1, N, board, dp))\n    if isValid(i + 2, j - 1, N):\n        x = min(x, findMinSteps(i + 2, j - 1, N, board, dp))\n    if isValid(i + 2, j + 1, N):\n        x = min(x, findMinSteps(i + 2, j + 1, N, board, dp))\n    if isValid(i - 1, j - 2, N):\n        x = min(x, findMinSteps(i - 1, j - 2, N, board, dp))\n    if isValid(i - 1, j + 2, N):\n        x = min(x, findMinSteps(i - 1, j + 2, N, board, dp))\n    if isValid(i + 1, j - 2, N):\n        x = min(x, findMinSteps(i + 1, j - 2, N, board, dp))\n    if isValid(i + 1, j + 2, N):\n        x = min(x, findMinSteps(i + 1, j + 2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N + 1)] for j in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if board[i - 1][j - 1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\n\nmain()\n"]
2022-04-13 09:19:58.650008 size on output set 8
2022-04-13 09:19:58.650022 num operations 2
2022-04-13 09:19:58.650028 size on input set 1
2022-04-13 09:20:01.845385 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 1,
      "text": "\nimport Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 2,
      "text": "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    }
  ],
  "created": 1649841598,
  "object": "edit"
}
2022-04-13 09:20:01.845652 fix spelling mistakes 3 ["import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\nimport Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"]
2022-04-13 09:20:01.845751 size on output set 3
2022-04-13 09:20:01.845761 size on input set 3
2022-04-13 09:20:05.641016 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and visited[i][j] == False\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 1,
      "text": "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 2,
      "text": "import sys\nimport Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    board = []\n    for _ in range(n):\n        board.append(list(input()))\n    print(min_steps(board))\n"
    }
  ],
  "created": 1649841601,
  "object": "edit"
}
2022-04-13 09:20:05.641285 fix syntax errors 3 ["import Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and visited[i][j] == False\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", 'import sys\nimport Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != \'#\' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == \'K\':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nif __name__ == "__main__":\n    n = int(input())\n    board = []\n    for _ in range(n):\n        board.append(list(input()))\n    print(min_steps(board))\n']
2022-04-13 09:20:15.795986 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 1,
      "text": "from collections import deque\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = deque()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.append((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.popleft()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.append((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.append((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.append((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.append((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.append((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.append((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.append((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.append((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 2,
      "text": "from queue import Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    }
  ],
  "created": 1649841605,
  "object": "edit"
}
2022-04-13 09:20:15.796266 fix syntax errors 3 ["import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "from collections import deque\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = deque()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.append((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.popleft()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.append((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.append((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.append((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.append((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.append((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.append((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.append((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.append((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "from queue import Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"]
2022-04-13 09:20:20.943742 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j] and board[i][j] != 'X'\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 1,
      "text": "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    },
    {
      "index": 2,
      "text": "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == n - 1 and y == n - 1:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"
    }
  ],
  "created": 1649841615,
  "object": "edit"
}
2022-04-13 09:20:20.945154 fix syntax errors 3 ["import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j] and board[i][j] != 'X'\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == n - 1 and y == n - 1:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n"]
2022-04-13 09:20:20.945255 size on output set 9
2022-04-13 09:20:20.945270 num operations 2
2022-04-13 09:20:20.945275 size on input set 1
2022-04-13 09:20:44.565391 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef bfs(board, n, x, y):\n    queue = []\n    queue.append((x, y, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649841620,
  "object": "edit"
}
2022-04-13 09:20:44.565669 fix spelling mistakes 3 ["import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef bfs(board, n, x, y):\n    queue = []\n    queue.append((x, y, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\n#\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 09:20:44.565728 size on output set 3
2022-04-13 09:20:44.565846 size on input set 3
2022-04-13 09:20:46.107781 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649841644,
  "object": "edit"
}
2022-04-13 09:20:46.108023 fix syntax errors 3 ["\n\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "#\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 09:21:01.341258 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\nimport sys\n\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import random\n\ndef guess(x):\n    guess = random.randint(1, x)\n    print(guess)\n    if guess == x:\n        return True\n    else:\n        return False\n\nx = int(input())\nwhile not guess(x):\n    pass\n"
    },
    {
      "index": 2,
      "text": "import sys\n\n\ndef bfs(board, n, start, end):\n    queue = []\n    queue.append((start, 0))\n    visited = set()\n    while queue:\n        cur, steps = queue.pop(0)\n        if cur == end:\n            return steps\n        if cur in visited:\n            continue\n        visited.add(cur)\n        for next in board[cur]:\n            queue.append((next, steps + 1))\n    return -1\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = {}\n    for i in range(n):\n        line = sys.stdin.readline().strip().split()\n        board[i] = []\n        for j in range(n):\n            if line[j] == '1':\n                board[i].append(j)\n    print(bfs(board, n, 0, n - 1))\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649841646,
  "object": "edit"
}
2022-04-13 09:21:01.341467 fix syntax errors 3 ["#!/usr/bin/env python3\nimport sys\n\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\nif __name__ == '__main__':\n    main()\n", 'import random\n\ndef guess(x):\n    guess = random.randint(1, x)\n    print(guess)\n    if guess == x:\n        return True\n    else:\n        return False\n\nx = int(input())\nwhile not guess(x):\n    pass\n', "import sys\n\n\ndef bfs(board, n, start, end):\n    queue = []\n    queue.append((start, 0))\n    visited = set()\n    while queue:\n        cur, steps = queue.pop(0)\n        if cur == end:\n            return steps\n        if cur in visited:\n            continue\n        visited.add(cur)\n        for next in board[cur]:\n            queue.append((next, steps + 1))\n    return -1\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = {}\n    for i in range(n):\n        line = sys.stdin.readline().strip().split()\n        board[i] = []\n        for j in range(n):\n            if line[j] == '1':\n                board[i].append(j)\n    print(bfs(board, n, 0, n - 1))\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 09:21:09.332000 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef bfs(board, n, x, y):\n    queue = []\n    queue.append((x, y, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n, 1, 1))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((0, 0, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef bfs(board, n, x, y):\n    queue = []\n    queue.append(x, y, 0)\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append(i + 2, j + 1, steps + 1)\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append(i + 2, j - 1, steps + 1)\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append(i - 2, j + 1, steps + 1)\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append(i - 2, j - 1, steps + 1)\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append(i + 1, j + 2, steps + 1)\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649841661,
  "object": "edit"
}
2022-04-13 09:21:09.332179 fix syntax errors 3 ["import sys\n\ndef bfs(board, n, x, y):\n    queue = []\n    queue.append((x, y, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n, 1, 1))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((0, 0, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef bfs(board, n, x, y):\n    queue = []\n    queue.append(x, y, 0)\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append(i + 2, j + 1, steps + 1)\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append(i + 2, j - 1, steps + 1)\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append(i - 2, j + 1, steps + 1)\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append(i - 2, j - 1, steps + 1)\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append(i + 1, j + 2, steps + 1)\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline()) \n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 09:21:09.332324 size on output set 9
2022-04-13 09:21:09.332338 num operations 2
2022-04-13 09:21:09.332343 size on input set 1
2022-04-13 09:21:14.489390 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\ndef isValid(r, c):\n    if r >= 0 and r < N and c >= 0 and c < N:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n"
    },
    {
      "index": 2,
      "text": "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n"
    }
  ],
  "created": 1649841669,
  "object": "edit"
}
2022-04-13 09:21:14.489566 fix spelling mistakes 3 ["\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n\ndef isValid(r, c):\n    if r >= 0 and r < N and c >= 0 and c < N:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n", "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n"]
2022-04-13 09:21:14.489610 size on output set 2
2022-04-13 09:21:14.489616 size on input set 2
2022-04-13 09:21:18.252611 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "def isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.' and (new_r, new_c) not in visited:\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == \".\":\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == \"K\":\n            bfs(i, j)\n\nprint(ans)\n"
    }
  ],
  "created": 1649841674,
  "object": "edit"
}
2022-04-13 09:21:18.252853 fix syntax errors 3 ["def isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.' and (new_r, new_c) not in visited:\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", '\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == ".":\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == "K":\n            bfs(i, j)\n\nprint(ans)\n']
2022-04-13 09:21:21.867090 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef isValid(r, c):\n    if r >= 0 and r < N and c >= 0 and c < N:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [2, 2, 1, 1, -1, -1, -2, -2]\ndc = [1, -1, 2, -2, 2, -2, 1, -1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n"
    },
    {
      "index": 1,
      "text": "\ndef isValid(r, c):\n    if r >= 0 and r < N and c >= 0 and c < N:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n"
    },
    {
      "index": 2,
      "text": "\n\ndef isValid(r, c):\n    return r >= 0 and r < N and c >= 0 and c < N\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n"
    }
  ],
  "created": 1649841678,
  "object": "edit"
}
2022-04-13 09:21:21.867274 fix syntax errors 3 ["\ndef isValid(r, c):\n    if r >= 0 and r < N and c >= 0 and c < N:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [2, 2, 1, 1, -1, -1, -2, -2]\ndc = [1, -1, 2, -2, 2, -2, 1, -1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n", "\ndef isValid(r, c):\n    if r >= 0 and r < N and c >= 0 and c < N:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n", "\n\ndef isValid(r, c):\n    return r >= 0 and r < N and c >= 0 and c < N\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            print(moves)\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nN = int(input())\nboard = []\nfor _ in range(N):\n    board.append(list(input()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 'K':\n            bfs(i, j)\n"]
2022-04-13 09:21:21.867374 size on output set 6
2022-04-13 09:21:21.867387 num operations 2
2022-04-13 09:21:21.867392 size on input set 1
2022-04-13 09:21:27.205544 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a particular cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight.\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    }
  ],
  "created": 1649841681,
  "object": "edit"
}
2022-04-13 09:21:27.205766 fix spelling mistakes 3 ['\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n', '\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a particular cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n', '\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight.\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n']
2022-04-13 09:21:27.205938 size on output set 3
2022-04-13 09:21:27.205951 size on input set 3
2022-04-13 09:21:52.662890 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a particular cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    },
    {
      "index": 1,
      "text": "\n#\n# import sys\n# from collections import deque\n#\n# # read the input\n# N = int(sys.stdin.readline())\n# board = []\n# for i in range(N):\n#     board.append(list(sys.stdin.readline().strip()))\n#\n# # find the starting point of the knight\n# for i in range(N):\n#     for j in range(N):\n#         if board[i][j] == \"K\":\n#             start = (i, j)\n#             break\n#\n# # define the valid moves\n# moves = [\n#     (2, 1),\n#     (2, -1),\n#     (-2, 1),\n#     (-2, -1),\n#     (1, 2),\n#     (1, -2),\n#     (-1, 2),\n#     (-1, -2),\n# ]\n#\n# # define a function to check if a move is valid or not\n# def valid_move(move):\n#     if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n#         return True\n#     return False\n#\n# # define a function to get all valid moves from a particular cell\n# def get_valid_moves(cell):\n#     valid_moves = []\n#     for move in moves:\n#         if valid_move((cell[0] + move[0], cell[1] + move[1])):\n#             valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n#     return valid_moves\n#\n# # define a function to find the minimum steps\n# def min_steps(start):\n#     # create a queue to store the cells to be visited\n#     queue = deque()\n#     queue.append((start, 0))\n#\n#     # create a set to store the cells visited\n#     visited = set()\n#     visited.add(start)\n#\n#     # use BFS to find the minimum steps\n#     while queue:\n#         cell, steps = queue.popleft()\n#         if cell == (0, 0):\n#             return steps\n#         for move in get_valid_moves(cell):\n#             if move not in visited:\n#                 visited.add(move)\n#                 queue.append((move, steps + 1))\n#\n#     return -1\n#\n# print(min_steps(start))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a particular cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    }
  ],
  "created": 1649841687,
  "object": "edit"
}
2022-04-13 09:21:52.663208 fix syntax errors 3 ['\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a particular cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n', '\n#\n# import sys\n# from collections import deque\n#\n# # read the input\n# N = int(sys.stdin.readline())\n# board = []\n# for i in range(N):\n#     board.append(list(sys.stdin.readline().strip()))\n#\n# # find the starting point of the knight\n# for i in range(N):\n#     for j in range(N):\n#         if board[i][j] == "K":\n#             start = (i, j)\n#             break\n#\n# # define the valid moves\n# moves = [\n#     (2, 1),\n#     (2, -1),\n#     (-2, 1),\n#     (-2, -1),\n#     (1, 2),\n#     (1, -2),\n#     (-1, 2),\n#     (-1, -2),\n# ]\n#\n# # define a function to check if a move is valid or not\n# def valid_move(move):\n#     if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n#         return True\n#     return False\n#\n# # define a function to get all valid moves from a particular cell\n# def get_valid_moves(cell):\n#     valid_moves = []\n#     for move in moves:\n#         if valid_move((cell[0] + move[0], cell[1] + move[1])):\n#             valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n#     return valid_moves\n#\n# # define a function to find the minimum steps\n# def min_steps(start):\n#     # create a queue to store the cells to be visited\n#     queue = deque()\n#     queue.append((start, 0))\n#\n#     # create a set to store the cells visited\n#     visited = set()\n#     visited.add(start)\n#\n#     # use BFS to find the minimum steps\n#     while queue:\n#         cell, steps = queue.popleft()\n#         if cell == (0, 0):\n#             return steps\n#         for move in get_valid_moves(cell):\n#             if move not in visited:\n#                 visited.add(move)\n#                 queue.append((move, steps + 1))\n#\n#     return -1\n#\n# print(min_steps(start))\n', '\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a particular cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n']
2022-04-13 09:22:10.547800 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight.\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\nstart = (-1, -1)\n# find the starting point of the knight.\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 2
    }
  ],
  "created": 1649841712,
  "object": "edit"
}
2022-04-13 09:22:10.547977 NO RESULT
2022-04-13 09:22:10.547984 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 2
}
2022-04-13 09:22:10.548018 fix syntax errors 2 ['\n\n\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight.\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n', '\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\nstart = (-1, -1)\n# find the starting point of the knight.\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n']
2022-04-13 09:22:12.068120 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n"
    }
  ],
  "created": 1649841730,
  "object": "edit"
}
2022-04-13 09:22:12.068382 fix syntax errors 3 ['\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n', '\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n', '\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == "K":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != "#":\n        return True\n    return False\n\n# define a function to get all valid moves from a position\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the positions to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the positions visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        position, steps = queue.popleft()\n        if position == (0, 0):\n            return steps\n        for move in get_valid_moves(position):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n']
2022-04-13 09:22:12.068445 size on output set 5
2022-04-13 09:22:12.068456 num operations 2
2022-04-13 09:22:12.068461 size on input set 1
2022-04-13 09:22:14.036575 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\n#\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    }
  ],
  "created": 1649841732,
  "object": "edit"
}
2022-04-13 09:22:14.036744 fix spelling mistakes 3 ["\n\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n#\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"]
2022-04-13 09:22:14.036844 size on output set 3
2022-04-13 09:22:14.036851 size on input set 3
2022-04-13 09:22:27.633106 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from queue import Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef solve(n):\n    board = []\n\n    for _ in range(n):\n        board.append(list(map(int, input().split())))\n\n    def dfs(x,y,board,visited):\n        if x < 0 or x >= n or y < 0 or y >= n:\n            return 0\n        if board[x][y] == 0:\n            return 0\n        if (x,y) in visited:\n            return 0\n        visited.add((x,y))\n\n        return 1 + dfs(x+1,y,board,visited) + dfs(x-1,y,board,visited) + dfs(x,y+1,board,visited) + dfs(x,y-1,board,visited)\n\n    visited = set()\n\n    max_val = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1 and (i,j) not in visited:\n                max_val = max(max_val, dfs(i,j,board,visited))\n\n    return max_val\n\nn = int(sys.stdin.readline().strip())\nprint(solve(n))\n"
    },
    {
      "index": 2,
      "text": "import queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n - 1, n - 1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r, c) == (0, 0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r, c))\n\n        if r + 1 < n and (r + 1, c) not in visited:\n            q.put((r + 1, c))\n        if r - 1 >= 0 and (r - 1, c) not in visited:\n            q.put((r - 1, c))\n        if c + 1 < n and (r, c + 1) not in visited:\n            q.put((r, c + 1))\n        if c - 1 >= 0 and (r, c - 1) not in visited:\n            q.put((r, c - 1))\n\n    distance += 1\n\nprint(-1)\n"
    }
  ],
  "created": 1649841734,
  "object": "edit"
}
2022-04-13 09:22:27.633285 fix syntax errors 3 ["from queue import Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", '\nimport sys\n\ndef solve(n):\n    board = []\n\n    for _ in range(n):\n        board.append(list(map(int, input().split())))\n\n    def dfs(x,y,board,visited):\n        if x < 0 or x >= n or y < 0 or y >= n:\n            return 0\n        if board[x][y] == 0:\n            return 0\n        if (x,y) in visited:\n            return 0\n        visited.add((x,y))\n\n        return 1 + dfs(x+1,y,board,visited) + dfs(x-1,y,board,visited) + dfs(x,y+1,board,visited) + dfs(x,y-1,board,visited)\n\n    visited = set()\n\n    max_val = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1 and (i,j) not in visited:\n                max_val = max(max_val, dfs(i,j,board,visited))\n\n    return max_val\n\nn = int(sys.stdin.readline().strip())\nprint(solve(n))\n', "import queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n - 1, n - 1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r, c) == (0, 0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r, c))\n\n        if r + 1 < n and (r + 1, c) not in visited:\n            q.put((r + 1, c))\n        if r - 1 >= 0 and (r - 1, c) not in visited:\n            q.put((r - 1, c))\n        if c + 1 < n and (r, c + 1) not in visited:\n            q.put((r, c + 1))\n        if c - 1 >= 0 and (r, c - 1) not in visited:\n            q.put((r, c - 1))\n\n    distance += 1\n\nprint(-1)\n"]
2022-04-13 09:22:29.095733 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    }
  ],
  "created": 1649841747,
  "object": "edit"
}
2022-04-13 09:22:29.095914 fix syntax errors 3 ["\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\nimport Queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = Queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"]
2022-04-13 09:22:43.952537 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# https://www.acmicpc.net/problem/2178\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\n#\uc228\ubc14\uaf2d\uc9c8\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((0,0))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (n-1,n-1):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\n# https://www.acmicpc.net/problem/2178\nimport queue\n\ndef solution(n, board):\n    q = queue.Queue()\n    q.put((n-1,n-1))\n\n    visited = set()\n\n    distance = 0\n\n    while not q.empty():\n        size = q.qsize()\n\n        for _ in range(size):\n            r, c = q.get()\n\n            if (r,c) == (0,0):\n                return distance\n\n            if board[r][c] == '#':\n                continue\n\n            visited.add((r,c))\n\n            if r+1 < n and (r+1,c) not in visited:\n                q.put((r+1,c))\n            if r-1 >= 0 and (r-1,c) not in visited:\n                q.put((r-1,c))\n            if c+1 < n and (r,c+1) not in visited:\n                q.put((r,c+1))\n            if c-1 >= 0 and (r,c-1) not in visited:\n                q.put((r,c-1))\n\n        distance += 1\n\n    return -1\n\nif __name__ == '__main__':\n    n = int(input())\n    board = [input() for _ in range(n)]\n    print(solution(n, board))\n"
    }
  ],
  "created": 1649841749,
  "object": "edit"
}
2022-04-13 09:22:43.952713 fix syntax errors 3 ["\n# https://www.acmicpc.net/problem/2178\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n#\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((0,0))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (n-1,n-1):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n# https://www.acmicpc.net/problem/2178\nimport queue\n\ndef solution(n, board):\n    q = queue.Queue()\n    q.put((n-1,n-1))\n\n    visited = set()\n\n    distance = 0\n\n    while not q.empty():\n        size = q.qsize()\n\n        for _ in range(size):\n            r, c = q.get()\n\n            if (r,c) == (0,0):\n                return distance\n\n            if board[r][c] == '#':\n                continue\n\n            visited.add((r,c))\n\n            if r+1 < n and (r+1,c) not in visited:\n                q.put((r+1,c))\n            if r-1 >= 0 and (r-1,c) not in visited:\n                q.put((r-1,c))\n            if c+1 < n and (r,c+1) not in visited:\n                q.put((r,c+1))\n            if c-1 >= 0 and (r,c-1) not in visited:\n                q.put((r,c-1))\n\n        distance += 1\n\n    return -1\n\nif __name__ == '__main__':\n    n = int(input())\n    board = [input() for _ in range(n)]\n    print(solution(n, board))\n"]
2022-04-13 09:22:43.952763 size on output set 7
