["\n\ndef main(n, m, k, edges, routes, s):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, s)\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a union find set of vertices\n    uf = UnionFind(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if uf.find(edge[0]-1) != uf.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(lambda: defaultdict(int))\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph.keys()}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph.keys()}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(int(route_cost))\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the unvisited vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are unvisited vertices\n    while vertices:\n        # find the unvisited vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v-1])\n\n        # remove the vertex from the set of unvisited vertices\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v]) - 1\n        \n        # remove the vertex from the set of vertices\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[2] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set of vertices\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(lambda: defaultdict(int))\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []  # routes to be checked\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = shortest_path(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef shortest_path(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a union find set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1, edge[-1])\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "#!/usr/bin/python3\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []  # routes to be checked\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = shortest_path(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef shortest_path(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = graph[y][x] = w\n    routes = []  # routes to be checked\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = shortest_path(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\n\ndef shortest_path(graph, start, end):\n    distances = {node: float('inf') for node in graph.keys()}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n    # print(solve())\n", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main(n, m, k, edges, routes, s):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, s)\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the unvisited vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are unvisited vertices\n    while vertices:\n        # find the unvisited vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set of unvisited vertices\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n", "\nimport sys\n\nfrom collections import defaultdict\n\ndef main():\n  n, m, k = map(int, sys.stdin.readline().strip().split())\n  graph = defaultdict(dict)\n  for i in range(m):\n    x, y, w = map(int, sys.stdin.readline().strip().split())\n    graph[x][y] = w\n    graph[y][x] = w\n  routes = []\n  for i in range(k):\n    a, b = map(int, sys.stdin.readline().strip().split())\n    routes.append((a, b))\n  print(solve(graph, routes))\n\ndef solve(graph, routes):\n  max_dist = 0\n  for r1, r2 in routes:\n    d = dijkstra(graph, r1, r2)\n    max_dist = max(max_dist, d)\n  return max_dist\n\ndef dijkstra(graph, start, end):\n  distances = {node: float('inf') for node in graph.keys()}\n  distances[start] = 0\n  queue = [start]\n  while queue:\n    current = queue.pop(0)\n    if current == end:\n      break\n    for neighbor in graph[current]:\n      distance = distances[current] + graph[current][neighbor]\n      if distance < distances[neighbor]:\n        distances[neighbor] = distance\n        queue.append(neighbor)\n  return distances[end]\n\nif __name__ == '__main__':\n  main()\n", "import sys\n\n\ndef main(n, m, k, edges, routes, s):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, s)\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    return route_cost\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the unvisited vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are unvisited vertices\n    while vertices:\n        # find the unvisited vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set of unvisited vertices\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    f = open(sys.argv[1])\n    n, m, k, s = map(int, f.readline().split())\n    edges = [list(map(int, f.readline().split())) for _ in range(m)]\n    routes = [list(map(int, f.readline().split())) for _ in range(k)]\n    print(main(n, m, k, edges, routes, s))\n", "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a union find set of vertices\n    uf = UnionFind(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if uf.find(edge[0]-1) != uf.find(edge[1]-1):\n            # union the sets\n            uf.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)\n"]