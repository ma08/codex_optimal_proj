2022-04-12 20:00:11.137544 num operations 2
2022-04-12 20:00:11.137555 size on input set 1
2022-04-12 20:00:16.384271 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649793611,
  "object": "edit"
}
2022-04-12 20:00:16.384504 fix spelling mistakes 3 ['\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-12 20:00:16.384548 size on output set 3
2022-04-12 20:00:16.384555 size on input set 3
2022-04-12 20:00:24.579009 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n"
    },
    {
      "index": 1,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649793616,
  "object": "edit"
}
2022-04-12 20:00:24.579216 fix syntax errors 3 ['\n', '\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-12 20:00:27.910930 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1]) + a[child]\n        dp[root][1] += dp[child][0] + a[child]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649793624,
  "object": "edit"
}
2022-04-12 20:00:27.911166 fix syntax errors 3 ['\n\n"""\nThis is a tree problem.\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1]) + a[child]\n        dp[root][1] += dp[child][0] + a[child]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-12 20:00:33.823397 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root]\ndp[root][1] = max(dp[child][0] for child in children) + a[root]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root]\ndp[root][1] = max(dp[child][0] for child in children) + a[root]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649793627,
  "object": "edit"
}
2022-04-12 20:00:33.823644 fix syntax errors 3 ['\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root]\ndp[root][1] = max(dp[child][0] for child in children) + a[root]\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root]\ndp[root][1] = max(dp[child][0] for child in children) + a[root]\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-12 20:00:33.823686 size on output set 8
2022-04-12 20:00:33.823697 num operations 2
2022-04-12 20:00:33.823702 size on input set 1
2022-04-12 20:00:36.378127 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649793633,
  "object": "edit"
}
2022-04-12 20:00:36.378307 fix spelling mistakes 3 ["\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:00:36.378329 size on output set 2
2022-04-12 20:00:36.378335 size on input set 2
2022-04-12 20:00:38.484064 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649793636,
  "object": "edit"
}
2022-04-12 20:00:38.484269 fix syntax errors 3 ["#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:00:41.300355 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom typing import List\nimport sys\n\ndef read_lines_from_stdin() -> List[str]:\n    return sys.stdin.readline().rstrip().split()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\n\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\n\ndef main() -> None:\n    pass\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649793638,
  "object": "edit"
}
2022-04-12 20:00:41.300524 fix syntax errors 3 ["\n\nfrom typing import List\nimport sys\n\ndef read_lines_from_stdin() -> List[str]:\n    return sys.stdin.readline().rstrip().split()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_line_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\n\ndef main() -> None:\n    pass\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:00:41.300546 size on output set 4
