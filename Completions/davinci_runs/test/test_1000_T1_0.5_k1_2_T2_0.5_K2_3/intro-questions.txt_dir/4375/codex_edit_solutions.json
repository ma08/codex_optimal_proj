["import sys\n\n\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\n\ndef main() -> None:\n    pass\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root]\ndp[root][1] = max(dp[child][0] for child in children) + a[root]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "#!/usr/bin/env python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1]) + a[child]\n        dp[root][1] += dp[child][0] + a[child]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", "\n", "\n\nimport sys\n\ndef read_line_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom typing import List\nimport sys\n\ndef read_lines_from_stdin() -> List[str]:\n    return sys.stdin.readline().rstrip().split()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThis is a tree problem.\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in childs)\ndp[root][1] = max(dp[child][0] for child in childs)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"]