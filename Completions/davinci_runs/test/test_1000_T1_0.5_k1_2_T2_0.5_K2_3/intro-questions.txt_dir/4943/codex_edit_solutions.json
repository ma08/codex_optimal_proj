["\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for _ in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d = sum(ds)\n    r = a/d**0.5\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n    print(corners)\n        x, y = input().strip().split(',')\n        corners.append((float(x), float(y)))\n    area = int(input().strip())\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split(\" \"))\n        points.append((x, y))\n    A = float(input(\" \"))\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area of original\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1], sep=\" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(input().strip())\n    print(corners, area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(x, y)\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points) \n\ndef get_rescaled_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    rescaled_points = []\n    for x, y in points:\n        rescaled_points.append(((x-cx)*ratio, (y-cy)*ratio))\n    return rescaled_points\n\ndef main():\n    N, points, A = read_input()\n    rescaled_points = get_rescaled_points(points, A)\n    print_output(rescaled_points)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"The main function\"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(input().strip())\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scale_factor):\n    c = centroid(points)\n    return [Point(x*scale_factor + c.x*(1-scale_factor),\n                  y*scale_factor + c.y*(1-scale_factor)) for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor), y*scaling_factor + c.y*(1-scaling_factor)) for x, y in points]\n\ndef scale_area(points, target_area):\n    return scale_points(points, sqrt(target_area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point.\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]])) \n    # Find the new area of the polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(raw_input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = raw_input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(raw_input().strip())\n    print(corners)\n    print(area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]) / 6,\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]) / 6)\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distances from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0], points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new polygon\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point.\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the new area of the polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point.\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point.\n    area = 0.5 * (p1[0] * p2[1] + p2[0] * p3[1] + p3[0] * p1[1])\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:]))\n    # Find the new area of the polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().strip().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the area of the new polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y), flush=True)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]), centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0], points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0.0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]), centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distances from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0], points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new polygon\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\n\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(x, y)\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)-1):\n        x1, y1 = points[i]\n        x2, y2 = points[i+1]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_resized_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    resized_points = []\n    for x, y in points:\n        resized_points.append(((x-cx)*ratio + cx, (y-cy)*ratio + cy))\n    return resized_points\n\ndef main():\n    N, points, A = read_input()\n    resized_points = get_resized_points(points, A)\n    print_output(resized_points)\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find centre of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scaling factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\n\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find centre of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scaling factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return abs(sum(x0*y1 - x1*y0\n                   for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1])))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / Decimal(len(points)),\n                 sum(y for x, y in points) / Decimal(len(points)))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor),\n                  y*scaling_factor + c.y*(1-scaling_factor))\n            for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, Decimal(sqrt(area / area(points))))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(raw_input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = raw_input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(raw_input().strip())\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for _ in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]    \n    d = sum(ds)    \n    r = a/d**0.5\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\n# the number of vertices of the polygon.\nn = int(input())\n\n# list of vertices of the polygon.\ncorners = []\n\n# the area of the desired polygon.\narea = int(input())\n\n# the current area of the polygon.\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point.\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled.\nfactor = math.sqrt(area / abs(current_area))\n\n# the new vertices.\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y.\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y is 0.\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new vertices.\nfor point in new_corners:\n    print(point[0], point[1])\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find centre of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scaling factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(\"{:.6f} {:.6f}\".format(new_points[i][0], new_points[i][1]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0] * points[(i+1)%n][1] - points[(i+1)%n][0] * points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0] * points[(i+1)%n][1] - points[(i+1)%n][0] * points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0],\n                 points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0.0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point.\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])[0]\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])[0]\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))[0]\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point.\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1][0]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))[0]\n    # Find the new area of the polygon\n    new_area = A[0]\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))[0]\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])[0]\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])[0]\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))[0]\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))[0]\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\n\nn = int(input())\n\n\ncorners = []\n\n\narea = int(input())\n\n\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n\ncorners.append(corners[0])\n\n\nfactor = math.sqrt(area / abs(current_area))\n\n# the new corners\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y are 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new corners\nfor point in new_corners:\n    print(point[0], point[1])\n", "#!/usr/bin/env python3\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0 for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor), y*scaling_factor + c.y*(1-scaling_factor)) for x, y in points]\n\ndef scale_area(points, target_area):\n    return scale_points(points, sqrt(target_area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i + 1] - xs[i] for i in range(n - 1)] + [xs[0] - xs[n - 1]]\n    dys = [ys[i + 1] - ys[i] for i in range(n - 1)] + [ys[0] - ys[n - 1]]\n    ds = [dxs[i] ** 2 + dys[i] ** 2 for i in range(n)]\n    d_sum = sum(ds)\n    r = a / d_sum\n    new_xs = [r * dx for dx in dxs]\n    new_ys = [r * dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= int(x_min)\n        new_ys[i] -= int(y_min)\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import hypot\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(input().strip())\n    # print(corners)\n    # print(area)\n    print(corners[0])\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Work in progress.\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().split()\n        corners.append((float(x), float(y)))\n    area = int(input())\n    print(corners)\n    print(area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "import math\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip()) * math.pi\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d = sum(ds)\n    r = a/d\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    new_xs[n-1] = new_xs[0]\n    new_ys[n-1] = new_ys[0]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\n# the number of corners of the polygon\nn = int(input())\n\n# list of corners of the polygon\ncorners = []\n\n# the area of the desired polygon\narea = int(input())\n\n# the current area of the polygon\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point, this is needed to calculate the area of the polygon\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new corners\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y are 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new corners\nfor point in new_corners:\n    print(point[0], point[1])\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i + 1] - xs[i] for i in range(n - 1)] + [xs[0] - xs[n - 1]]\n    dys = [ys[i + 1] - ys[i] for i in range(n - 1)] + [ys[0] - ys[n - 1]]\n    ds = [dxs[i] ** 2 + dys[i] ** 2 for i in range(n)]\n    d = sum(ds) ** 0.5\n    r = a/d\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    new_xs[n - 1] = new_xs[0]\n    new_ys[n - 1] = new_ys[0]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "\nfrom math import sqrt\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    A = int(input())\n\n    # find center of mass\n    x_c = 0.0\n    y_c = 0.0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area of original polygon\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"infinity\")\n    y_min = float(\"infinity\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(round(new_points[i][0], 2), round(new_points[i][1], 2))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find centre of mass\n    x_c = 0.0\n    y_c = 0.0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area\n    A_0 = 0.0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scaling factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"infinity\")\n    y_min = float(\"infinity\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "from math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor), y*scaling_factor + c.y*(1-scaling_factor)) for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area of original\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d_sum = sum(ds)\n    r = a/d_sum\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scaling_factor):\n    c = centroid(points)\n    return [Point(x*scaling_factor + c.x*(1-scaling_factor),\n                  y*scaling_factor + c.y*(1-scaling_factor))\n            for x, y in points]\n\ndef scale_area(points, target_area):\n    return scale_points(points, sqrt(target_area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split()))\n            for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import sqrt\n\n\ndef main():\n    # Read the input data.\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    # Calculate the area of the polygon.\n    polygon_area = 0\n    for i in range(num_corners):\n        x1, y1 = corners[i]\n        x2, y2 = corners[(i + 1) % num_corners]\n        polygon_area += x1 * y2 - x2 * y1\n    polygon_area = abs(polygon_area / 2)\n    # Calculate the distance between the center of mass and the center of\n    # the polygon.\n    center_x = sum([x for x, y in corners]) / num_corners\n    center_y = sum([y for x, y in corners]) / num_corners\n    center_mass_x = sum([x * (x1 * y2 - x2 * y1) for i in range(num_corners)]) / 6 / polygon_area\n    center_mass_y = sum([y * (x1 * y2 - x2 * y1) for i in range(num_corners)]) / 6 / polygon_area\n    distance = sqrt((center_mass_x - center_x) ** 2 + (center_mass_y - center_y) ** 2)\n    # Calculate the area of the circle.\n    circle_area = distance ** 2 * 3.14159265358979\n    # Calculate the area of the polygon.\n    for _ in range(num_corners):\n        x, y = input().strip().split()\n        corners.append((float(x), float(y)))\n    area = int(input().strip())\n    print(corners)\n    print(area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0] * points[(i+1)%n][1] - points[i][1] * points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0] * points[(i+1)%n][1] - points[(i+1)%n][0] * points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0] * points[(i+1)%n][1] - points[(i+1)%n][0] * points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0]) ** 2 + (point[1] - centroid[1]) ** 2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0],\n                 points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0.0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / (math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2))))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the area of the new polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / (math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2))))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d_sum = sum(ds)\n    r = a/d_sum\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n    return\n\nif __name__ == '__main__':\n    main()\n", "\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(x, y)\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_resized_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    resized_points = []\n    for x, y in points:\n        resized_points.append(((x-cx)*ratio + cx, (y-cy)*ratio + cy))\n    return resized_points\n\ndef main():\n    N, points, A = read_input()\n    resized_points = get_resized_points(points, A)\n    print_output(resized_points)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate the area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate the centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate the distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + (scale * (points[i][0] - centroid[0]) - points[i][0]),\n                 points[i][1] + (scale * (points[i][1] - centroid[1]) - points[i][1]))\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for _ in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d = sum(ds)\n    r = a/d**0.5\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\n# the number of vertices of the polygon\nn = int(input())\n\n# list of vertices of the polygon\nvertices = []\n\n# the area of the desired polygon\narea = int(input())\n\n# the current area of the polygon\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    vertices.append((x, y))\n    if i != 0:\n        current_area += x * vertices[i - 1][1] - y * vertices[i - 1][0]\n\n# make the last point equal to the first point\nvertices.append(vertices[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new corners\nnew_corners = []\n\nfor i in range(n):\n    x = factor * vertices[i][0]\n    y = factor * vertices[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y is 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new corners\nfor point in new_corners:\n    print(point[0], point[1])\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate the area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate the centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate the distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]) - points[i][0],\n                 points[i][1] + scale * (points[i][1] - centroid[1]) - points[i][1])\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\n\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(x, y)\n\ndef get_area(points):\n    area = 0.0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in points: #for loop to iterate through all the points\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_resized_points(points, A): #this function will return the points on the resized polygon\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area) #calculating the ratio of the new area to the old area\n    cx, cy = get_centroid(points)\n    resized_points = []\n    for x, y in points: #this loop will calculate the new points\n        resized_points.append(((x-cx)*ratio + cx, (y-cy)*ratio + cy))\n    return resized_points\n\ndef main():\n    N, points, A = read_input() #this function will read the data from the user\n    resized_points = get_resized_points(points, A) #this function will calculate the resized points\n    print_output(resized_points) #this function will print the new points\n\nif __name__ == '__main__':\n    main()\n", "\ndef main(N, A):\n    # read input\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split()) # get x, y coordinates\n        points.append((x, y))\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area of original polygon\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c) * (points[i][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    N = int(input()) # get number of points\n    A = float(input()) # get area\n    main(N, A)\n", "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the area of the new polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if new_points else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]/N\n        y_c += points[i][1]/N\n    x_c /= N\n    y_c /= N \n\n    # find area of original\n    A_0 = 0\n    for i in range(N):\n        A_0 += (points[i][0] - x_c)*(points[i][1] - y_c)\n    A_0 = abs(A_0/2)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [int(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = int(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(points):\n    for x, y in points:\n        print(\"%d %d\"%(x, y))\n\ndef get_area(points):\n    area = 0\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % len(points)]\n        area += x1*y2 - x2*y1\n    return area / 2\n\ndef get_centroid(points):\n    x_sum = 0\n    y_sum = 0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(points), y_sum / len(points)\n\ndef get_rescaled_points(points, A):\n    old_area = get_area(points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(points)\n    rescaled_points = []\n    for x, y in points:\n        rescaled_points.append(((x-cx)*ratio, (y-cy)*ratio))\n    return rescaled_points\n\ndef main():\n    N, points, A = read_input()\n    rescaled_points = get_rescaled_points(points, A)\n    print_output(rescaled_points)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\n# the number of vertices of the polygon\nn = int(input())\n\n# list of vertices of the polygon\ncorners = []\n\n# the area of the desired polygon\narea = int(input())\n\n# the current area of the polygon\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new vertices\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y is 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new vertices\nfor point in new_corners:\n    print(point[0], point[1])\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the new area of the polygon and the new angle of the line from the origin to the closest point\n    new_area = A - area\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\n\ndef read_input():\n    N = int(stdin.readline().strip())\n    points = []\n    for i in range(N):\n        x, y = [float(x) for x in stdin.readline().strip().split()]\n        points.append((x, y))\n    A = float(stdin.readline().strip())\n    return N, points, A\n\ndef print_output(rescaled_points):\n    for x, y in rescaled_points:\n        print(\"%.2f %.2f\" % (x, y))\n\ndef get_area(rescaled_points):\n    area = 0.0\n    for i in range(len(rescaled_points)):\n        x1, y1 = rescaled_points[i]\n        x2, y2 = rescaled_points[(i+1) % len(rescaled_points)]\n        area += x1*y2 - x2*y1\n    return area / 2.0\n\ndef get_centroid(rescaled_points):\n    x_sum = 0.0\n    y_sum = 0.0\n    for x, y in rescaled_points:\n        x_sum += x\n        y_sum += y\n    return x_sum / len(rescaled_points), y_sum / len(rescaled_points)\n\ndef get_rescaled_points(rescaled_points, A):\n    old_area = get_area(rescaled_points)\n    ratio = sqrt(A / old_area)\n    cx, cy = get_centroid(rescaled_points)\n    rescaled_points = []\n    for x, y in rescaled_points:\n        rescaled_points.append(((x-cx)*ratio, (y-cy)*ratio))\n    return rescaled_points\n\ndef main():\n    N, points, A = read_input()\n    rescaled_points = get_rescaled_points(points, A)\n    print_output(rescaled_points)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\n# the number of corners of the polygon\nn = int(raw_input())\n\n# list of corners of the polygon\ncorners = []\n\n# the area of the desired polygon\narea = int(raw_input())\n\n# the current area of the polygon\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, raw_input().split())\n    corners.append((x, y))\n    if i != 0:\n        current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point, this is needed to calculate the area of the polygon\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new corners\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x:\n        min_x = point[0]\n    if point[1] < min_y:\n        min_y = point[1]\n\n# shift the polygon so that the minimum x and y are 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new corners\nfor point in new_corners:\n    print(point[0], point[1])\n", "\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0 for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scale_factor):\n    c = centroid(points)\n    return [Point(x*scale_factor + c.x*(1-scale_factor), y*scale_factor + c.y*(1-scale_factor)) for x, y in points]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import sqrt\nfrom sys import stdin\nfrom collections import namedtuple\nfrom decimal import Decimal\nfrom itertools import count, chain\nfrom fractions import Fraction\nfrom operator import mul\nfrom functools import reduce\n\nPoint = namedtuple('Point', 'x y')\n\ndef area(points):\n    return Decimal(abs(sum(x0*y1 - x1*y0\n                         for ((x0, y0), (x1, y1)) in zip(points, chain(points[1:], points[0:1]))))) / 2\n\ndef centroid(points):\n    return Point(sum(x for x, y in points) / len(points),\n                 sum(y for x, y in points) / len(points))\n\ndef scale_points(points, scale_factor):\n    c = centroid(points)\n    return [Point(x*scale_factor + c.x*(1-scale_factor), y*scale_factor + c.y*(1-scale_factor)) for x, y in points.items()]\n\ndef scale_area(points, area):\n    return scale_points(points, sqrt(area / area(points)))\n\ndef read_points(input):\n    n = int(input.readline())\n    return [Point(*map(Decimal, input.readline().split())) for i in range(n)]\n\ndef main():\n    points = read_points(stdin)\n    target_area = int(stdin.readline())\n    scaled_points = scale_area(points, target_area)\n    print('\\n'.join('{0:.6f} {1:.6f}'.format(x, y) for x, y in scaled_points.items()))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(tuple(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate distances from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i] = (points[i][0] + scale * (points[i][0] - centroid[0]),\n                 points[i][1] + scale * (points[i][1] - centroid[1]))\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i] = (points[i][0] - min_x, points[i][1] - min_y)\n\n# print the new polygon\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        points.append((x, y))\n    A = float(sys.stdin.readline())\n    # Find the point closest to the origin\n    closest = 0\n    for i in range(1, n):\n        if points[i][0] ** 2 + points[i][1] ** 2 < points[closest][0] ** 2 + points[closest][1] ** 2:\n            closest = i\n    # Find the angle between the x-axis and the line from the origin to the closest point.\n    p1 = points[closest]\n    p2 = points[(closest + 1) % n]\n    p3 = points[(closest - 1) % n]\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n    # Find the area of the triangle formed by the origin, the closest point, and the point to the left of the closest point\n    area = 0.5 * p1[0] * p2[1] + 0.5 * p2[0] * p3[1] + 0.5 * p3[0] * p1[1]\n    # Find the area of the polygon\n    area += 0.5 * sum(p1[0] * p2[1] - p1[1] * p2[0] for p1, p2 in zip(points, points[1:] + [points[0]]))\n    # Find the new area of the polygon\n    new_area = A\n    # Find the new length of the edge from the origin to the closest point\n    new_length = math.sqrt(2 * new_area / math.sin(angle))\n    # Find the new coordinates of the closest point\n    new_p1 = (new_length * math.cos(angle / 2), new_length * math.sin(angle / 2))\n    # Find the new coordinates of the other points\n    new_points = []\n    for i in range(n):\n        p1 = new_p1\n        p2 = new_points[-1] if len(new_points) else new_p1\n        p3 = points[(closest + i) % n]\n        v1 = (p2[0] - p1[0], p2[1] - p1[1])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1])\n        angle = math.acos((v1[0] * v2[0] + v1[1] * v2[1]) / math.sqrt((v1[0] ** 2 + v1[1] ** 2) * (v2[0] ** 2 + v2[1] ** 2)))\n        length = math.sqrt(2 * new_area / math.sin(angle))\n        new_points.append((length * math.cos(angle / 2), length * math.sin(angle / 2)))\n    # Output\n    for x, y in new_points:\n        print(\"%.4f %.4f\" % (x, y))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    xs = []\n    ys = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split())\n        xs.append(x)\n        ys.append(y)\n    a = float(sys.stdin.readline().strip())\n    dxs = [xs[i+1]-xs[i] for i in range(n-1)] + [xs[0]-xs[n-1]]\n    dys = [ys[i+1]-ys[i] for i in range(n-1)] + [ys[0]-ys[n-1]]\n    ds = [dxs[i]**2+dys[i]**2 for i in range(n)]\n    d = sum(ds)\n    r = a/d\n    new_xs = [r*dx for dx in dxs]\n    new_ys = [r*dy for dy in dys]\n    x_min = min(new_xs)\n    y_min = min(new_ys)\n    for i in range(n):\n        new_xs[i] -= x_min\n        new_ys[i] -= y_min\n    for i in range(n):\n        print(new_xs[i], new_ys[i])\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # read input\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    A = float(input())\n\n    # find center of mass\n    x_c = 0\n    y_c = 0\n    for i in range(N):\n        x_c += points[i][0]\n        y_c += points[i][1]\n    x_c /= N\n    y_c /= N\n\n    # find area of original polygon\n    A_0 = 0\n    for i in range(N - 1):\n        A_0 += (points[i][0] - x_c) * (points[i + 1][1] - y_c) - (points[i + 1][0] - x_c) * (points[i][1] - y_c)\n    A_0 += (points[N - 1][0] - x_c) * (points[0][1] - y_c) - (points[0][0] - x_c) * (points[N - 1][1] - y_c)\n    A_0 = abs(A_0)\n\n    # find scale factor\n    s = A / A_0\n\n    # find new points\n    new_points = []\n    for i in range(N):\n        x = (points[i][0] - x_c) * s + x_c\n        y = (points[i][1] - y_c) * s + y_c\n        new_points.append((x, y))\n\n    # find translation\n    x_min = float(\"inf\")\n    y_min = float(\"inf\")\n    for i in range(N):\n        if new_points[i][0] < x_min:\n            x_min = new_points[i][0]\n        if new_points[i][1] < y_min:\n            y_min = new_points[i][1]\n    for i in range(N):\n        new_points[i] = (new_points[i][0] - x_min, new_points[i][1] - y_min)\n\n    # print new points\n    for i in range(N):\n        print(new_points[i][0], new_points[i][1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Work in progress\n\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    num_corners = int(input().strip())\n    corners = []\n    for _ in range(num_corners):\n        x, y = input().strip().split()\n        corners.append((float(x), float(y)))\n    area = float(input().strip())\n    print(corners)\n    print(area)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\nfrom math import sqrt\n\nn = int(stdin.readline())\n\npoints = []\nfor _ in range(n):\n    points.append(list(map(float, stdin.readline().split())))\n\narea = float(stdin.readline())\n\n# calculate the area of the original shape\norig_area = 0\nfor i in range(n):\n    orig_area += points[i][0]*points[(i+1)%n][1] - points[i][1]*points[(i+1)%n][0]\norig_area = abs(orig_area) / 2\n\n# calculate the centroid of the original shape\ncentroid = (0, 0)\nfor i in range(n):\n    centroid = (centroid[0] + (points[i][0] + points[(i+1)%n][0]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]),\n                centroid[1] + (points[i][1] + points[(i+1)%n][1]) * (points[i][0]*points[(i+1)%n][1] - points[(i+1)%n][0]*points[i][1]))\ncentroid = (centroid[0] / (6 * orig_area), centroid[1] / (6 * orig_area))\n\n# calculate the distance from each point to the centroid\ndistances = []\nfor point in points:\n    distances.append(sqrt((point[0] - centroid[0])**2 + (point[1] - centroid[1])**2))\n\n# calculate the scaling factor\nscale = sqrt(area / orig_area)\n\n# scale the points\nfor i in range(len(points)):\n    points[i][0] += scale * (points[i][0] - centroid[0]) - points[i][0]\n    points[i][1] += scale * (points[i][1] - centroid[1]) - points[i][1]\n\n# move the points so that x, y >= 0\nmin_x = min(points, key=lambda p: p[0])[0]\nmin_y = min(points, key=lambda p: p[1])[1]\nfor i in range(len(points)):\n    points[i][0] -= min_x\n    points[i][1] -= min_y\n\n# print the new points\nfor point in points:\n    stdout.write('%.4f %.4f\\n' % point)\n", "\nimport sys\nimport math\n\n# the number of vertices of the polygon\nn = int(input())\n\n# list of vertices of the polygon\ncorners = []\n\n# the area of the desired polygon\narea = int(input())\n\n# the current area of the polygon\ncurrent_area = 0\n\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n    if i != 0: current_area += x * corners[i - 1][1] - y * corners[i - 1][0]\n\n# make the last point equal to the first point\ncorners.append(corners[0])\n\n# the factor by which the polygon gets scaled\nfactor = math.sqrt(area / abs(current_area))\n\n# the new vertices\nnew_corners = []\n\nfor i in range(n):\n    x = factor * corners[i][0]\n    y = factor * corners[i][1]\n    new_corners.append((x, y))\n\n# find the minimum x and y\nmin_x = sys.maxsize\nmin_y = sys.maxsize\n\nfor point in new_corners:\n    if point[0] < min_x: min_x = point[0]\n    if point[1] < min_y: min_y = point[1]\n\n# shift the polygon so that the minimum x and y is 0\nfor i in range(n):\n    new_corners[i] = (new_corners[i][0] - min_x, new_corners[i][1] - min_y)\n\n# print the new vertices\nfor point in new_corners:\n    print(point[0], point[1])\n"]