["import sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min)\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[0])\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport math\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / something\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" %(min_dist))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # # Find the minimum and maximum x and y coordinates\n    # min_x, max_x = float(\"inf\"), float(\"-inf\")\n    # min_y, max_y = float(\"inf\"), float(\"-inf\")\n    # for x, y in coordinates:\n    #     min_x = min(min_x, x)\n    #     max_x = max(max_x, x)\n    #     min_y = min(min_y, y)\n    #     max_y = max(max_y, y)\n\n    # # Check if the citizens are perfectly aligned\n    # if min_x == max_x or min_y == max_y:\n    #     print(0)\n    #     return\n    \n    # # Calculate the slope of the line\n    # slope = (max_y - min_y) / (max_x - min_x)\n\n    # # Calculate the y-intercept of the line\n    # intercept = max_y - slope * max_x\n\n    # # Print the y-intercept\n    # print(intercept)\n\n\n\n\n\n\n\n\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float('inf'), float('-inf')\n    min_y, max_y = float('inf'), float('-inf')\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n\n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept of the line\n    intercept = max_y - slope * max_x\n\n    # Print the intercept\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py \n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something) \n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6 #max number\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min) #print answer\n", "import sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x- and y-coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned.\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = float(max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = float(max_y) - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y) / n - sum(x) / n # \u043f\u0440\u0438\u0431\u043b\u0438\u0437\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0442\u0440\u0430\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2 - x1\n    py = y2 - y1\n    something = px * px + py * py\n    u = ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx * dx + dy * dy)\n    return dist\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n    points = sorted(points, key=lambda x: x[1])\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                dist = find_closest_point(points[i][0], points[i][1],\n                                          points[j][0], points[j][1],\n                                          points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom math import fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nminimum = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < minimum:\n        minimum = fabs(x[i] - y[i])\n\nprint(minimum)\n", "import sys\n\nN = int(sys.stdin.readline())\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\npoints = sorted(points, key = lambda p: p[1])\nmin_a = float(\"inf\")\nfor i in range(N):\n    if i == N - 1:\n        break\n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint(min_a)\n", "\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(y_n - x_n)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef find_a(citizens_coordinates):\n    n = len(citizens_coordinates)\n    x, y = zip(*citizens_coordinates)\n    a = (sum(y)/n - sum(x)/n)\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizens_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizens_coordinates)\n    print(a)\n", "\n\nimport sys\n\ndef find_a_and_b(citizens_coordinates):\n    n = len(citizens_coordinates)\n    x, y = zip(*citizens_coordinates)\n    a = sum(y)/n - sum(x)/n  # \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043d\u0430\u043a\u043b\u043e\u043d\u0430\n    b = sum(y)/n - a*sum(x)/n  # \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0439 \u0447\u043b\u0435\u043d\n    return a, b\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizens_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a, b = find_a_and_b(citizens_coordinates)\n    print(a, b)\n", "\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find_a(citizens_coordinates):\n    n = len(citizens_coordinates)\n    x, y = zip(*citizens_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizens_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizens_coordinates)\n    print(a)\n", "import sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(float, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x- and y-coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned.\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = (max_y - min_y) / float(max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nfrom math import fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nminimum = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < minimum:\n        minimum = fabs(x[i] - y[i])\n\nprint(minimum)\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something) # find the closest point\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nN = int(sys.stdin.readline())\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\npoints = sorted(points, key = lambda p: p[1])\nmin_a = float(\"inf\")\nfor i in range(N):\n    if i == N - 1:\n        break\n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint(min_a)\n", "\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_x = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    x = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_x = min(min_x, x)\nprint min_x\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_m = x[n // 2]\n        y_m = y[n // 2]\n    else:\n        x_m = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_m = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(int(y_m - x_m))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nminimum = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < minimum:\n        minimum = fabs(x[i] - y[i])\n\nprint(minimum)\n", "import sys\n\ndef main():\n    # Read input.\n    num_citizens = int(sys.stdin.readline()) \n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)] \n\n    # Find the minimum and maximum x and y coordinates.\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned.\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept of the line\n    intercept = max_y - slope * max_x\n\n    # Print the y-intercept\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint(min_a)\n", "\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\nimport sys\n\ndef main():\n    # Read input \n    num_citizens = int(sys.stdin.readline()) \n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)] \n\n    # Find the minimum and maximum x and y coordinates \n    min_x, max_x = float(\"inf\"), float(\"-inf\") \n    min_y, max_y = float(\"inf\"), float(\"-inf\") \n    for x, y in coordinates: \n        min_x = min(min_x, x) \n        max_x = max(max_x, x) \n        min_y = min(min_y, y) \n        max_y = max(max_y, y) \n\n    # Check if the citizens are perfectly aligned \n    if min_x == max_x or min_y == max_y: \n        print(0) \n        return \n    \n    # Calculate the slope of the line \n    slope = (max_y - min_y) / (max_x - min_x) \n\n    # Calculate the y-intercept of the line \n    intercept = max_y - slope * max_x \n\n    # Print the y-intercept \n    print(intercept) \n\nif __name__ == \"__main__\":\n    main() \n", "\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    xs, ys = zip(*citizen_coordinates)\n    a = sum(ys)/n - sum(xs)/n \n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n # \u043f\u0440\u0438\u0431\u043b\u0438\u0437\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0442\u0440\u0430\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    xs, ys = zip(*citizen_coordinates) # zip(*citizen_coordinates) = zip(xs, ys)\n    a = sum(ys)/n - sum(xs)/n # sum(ys)/n = ys_mean, sum(xs)/n = xs_mean\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]] # [(x1, y1), (x2, y2), ...]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n# I don't know why I can't use python3...\n\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i < N - 1:\n        a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n        min_a = min(min_a, a)\n\nprint(min_a)\n", "\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(list(map(int, sys.stdin.readline().split())))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_x = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n\n    x = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_x = min(min_x, x)\n\nprint min_x\n", "import sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split()))\n                   for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x- and y-coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned.\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n\n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x[i] = x_i\n        y[i] = y_i\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_m = x[n // 2]\n        y_m = y[n // 2]\n    else:\n        x_m = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_m = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(y_m - x_m)\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2.0\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2.0\n    print(y_n - x_n)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    xs, ys = zip(*citizen_coordinates)\n    a = sum(ys)/n - sum(xs)/n #fix syntax\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\"\"\"\nAuthor:     Sunil Krishnan\nDate:       19-Apr-2016\nName:       TheClosest.py\nReference:  http://www.geeksforgeeks.org/closest-pair-of-points/\n\nProblem Statement:\nThe task is to design and implement methods of an LRUCache class. The class\nshould be able to be initialized with a cache size n > 0 and should provide\nthree methods:\n    1. set(key, value): sets key to value. If there are already n items in the\n    cache and we are adding a new item, then it should also remove the least\n    recently used item.\n    2. get(key): gets the value at key. If no such key exists, return null.\n    3. getMostRecentKey(): return the key that was least recently used.\n\n    \"\"\"\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py \n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something) \n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nN = int(sys.stdin.readline())\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\npoints = sorted(points, key = lambda p: p[1])\nmin_a = float(\"inf\")\nfor i in range(N):\n    if i == N - 1: # \uc774\uac8c \uc5c6\uc73c\uba74 \uc5d0\ub7ec\ub09c\ub2e4.\n        break\n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / 2.0\n    min_a = min(min_a, a)\n\nprint min_a\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(int(y_n - x_n))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(int(y_n - x_n))\n\nif __name__ == '__main__':\n    main()\n", "import sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nminimum = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < minimum:\n        minimum = fabs(x[i] - y[i])\n\nprint(minimum)\n", "\n# I don't know why I can't use python3...\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_m = x[n // 2]\n        y_m = y[n // 2]\n    else:\n        x_m = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_m = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(y_m - x_m + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_x = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    x = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / 2.0\n    min_x = min(min_x, x)\n\nprint min_x\n"]