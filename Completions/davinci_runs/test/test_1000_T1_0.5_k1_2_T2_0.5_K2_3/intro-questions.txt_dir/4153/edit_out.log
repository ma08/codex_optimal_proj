2022-04-12 17:44:31.681640 num operations 2
2022-04-12 17:44:31.681650 size on input set 1
2022-04-12 17:44:49.430722 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeros - zeros_at_beginning_or_end\n"
    },
    {
      "index": 1,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeroes - zeroes_at_beginning_or_end\n"
    },
    {
      "index": 2,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeros - zeros_at_beginning_or_end\n"
    }
  ],
  "created": 1649785471,
  "object": "edit"
}
2022-04-12 17:44:49.430998 fix spelling mistakes 3 ['\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeros - zeros_at_beginning_or_end\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeroes - zeroes_at_beginning_or_end\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeros - zeros_at_beginning_or_end\n']
2022-04-12 17:44:49.431043 size on output set 3
2022-04-12 17:44:49.431050 size on input set 3
2022-04-12 17:44:52.588158 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\")) - len(S.rstrip(\"0\"))\nprint zeroes - zeroes_at_beginning_or_end\n"
    },
    {
      "index": 1,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    }
  ],
  "created": 1649785489,
  "object": "edit"
}
2022-04-12 17:44:52.588429 fix syntax errors 3 ['\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0")) - len(S.rstrip("0"))\nprint zeroes - zeroes_at_beginning_or_end\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n']
2022-04-12 17:44:56.071613 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nsys.stdin = open('input.txt')\nsys.stdout = open('output.txt', 'w')\n\nf = sys.stdin\no = sys.stdout\n\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    },
    {
      "index": 1,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    }
  ],
  "created": 1649785492,
  "object": "edit"
}
2022-04-12 17:44:56.071821 fix syntax errors 3 ['import sys\n\nsys.stdin = open(\'input.txt\')\nsys.stdout = open(\'output.txt\', \'w\')\n\nf = sys.stdin\no = sys.stdout\n\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n', '\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n']
2022-04-12 17:44:58.657897 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    },
    {
      "index": 1,
      "text": "S = input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    }
  ],
  "created": 1649785496,
  "object": "edit"
}
2022-04-12 17:44:58.658079 fix syntax errors 3 ['\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n', 'S = input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n', 'S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n']
2022-04-12 17:44:58.658119 size on output set 8
2022-04-12 17:44:58.658130 num operations 2
2022-04-12 17:44:58.658135 size on input set 1
2022-04-12 17:45:00.114224 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n#\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1649785498,
  "object": "edit"
}
2022-04-12 17:45:00.114393 fix spelling mistakes 3 ["\n#\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-12 17:45:00.114489 size on output set 3
2022-04-12 17:45:00.114496 size on input set 3
2022-04-12 17:45:06.274701 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 2\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1649785500,
  "object": "edit"
}
2022-04-12 17:45:06.274887 fix syntax errors 3 ["import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 2\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-12 17:45:12.965380 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n\tif c == '0':\n\t    if len(stack) > 0 and stack[-1] == '1':\n\t\tstack.pop()\n\t\tans += 1\n\t\telse:\n\t\tstack.append(c)\n\t    else:\n\t\tstack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649785506,
  "object": "edit"
}
2022-04-12 17:45:12.965556 fix syntax errors 3 ["import sys\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n\tif c == '0':\n\t    if len(stack) > 0 and stack[-1] == '1':\n\t\tstack.pop()\n\t\tans += 1\n\t\telse:\n\t\tstack.append(c)\n\t    else:\n\t\tstack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 17:45:14.714051 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#coding: utf-8\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n# \nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\n#https://www.acmicpc.net/problem/9012\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1649785513,
  "object": "edit"
}
2022-04-12 17:45:14.714266 fix syntax errors 3 ["\n#coding: utf-8\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\n# \nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\n#https://www.acmicpc.net/problem/9012\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-12 17:45:14.714296 size on output set 8
