2022-04-12 20:10:28.750601 num operations 2
2022-04-12 20:10:28.750609 size on input set 1
2022-04-12 20:10:40.328573 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = 0\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2])\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2], reverse=True)\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794228,
  "object": "edit"
}
2022-04-12 20:10:40.328811 fix spelling mistakes 3 ["\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = 0\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2])\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2], reverse=True)\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:10:40.328977 size on output set 3
2022-04-12 20:10:40.328984 size on input set 3
2022-04-12 20:10:47.746559 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2], reverse=True)\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = defaultdict(list)\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight[u].append(w)\n        self.weight[v].append(w)\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        return min(self.weight[u] + self.weight[v])\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        for i in range(self.edges):\n            w = self.weight[i]\n            self.weight[i] = w + i\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = w\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2], reverse=True)\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794240,
  "object": "edit"
}
2022-04-12 20:10:47.746766 fix syntax errors 3 ["\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2], reverse=True)\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = defaultdict(list)\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight[u].append(w)\n        self.weight[v].append(w)\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        return min(self.weight[u] + self.weight[v])\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        for i in range(self.edges):\n            w = self.weight[i]\n            self.weight[i] = w + i\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = w\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2], reverse=True)\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:10:54.912494 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = 0\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u, v, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u, v, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u, v, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794247,
  "object": "edit"
}
2022-04-12 20:10:54.912680 fix syntax errors 3 ["\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = 0\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u, v, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u, v, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u - 1].append(v - 1)\n        self.graph[v - 1].append(u - 1)\n        self.weights.append((u - 1, v - 1, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]: heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u, v, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:11:03.239910 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nimport heapq\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794254,
  "object": "edit"
}
2022-04-12 20:11:03.240112 fix syntax errors 3 ["\n\nimport sys\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nimport heapq\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nimport heapq\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weights = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weights.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weights:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weights.sort(key=lambda x: x[2])\n        for i in range(len(self.weights)):\n            u, v, w = self.weights[i]\n            self.weights[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weights[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:11:03.240280 size on output set 7
2022-04-12 20:11:03.240298 num operations 2
2022-04-12 20:11:03.240303 size on input set 1
2022-04-12 20:11:34.845812 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Implement the solution here\ndef solve(n, m, a, b):\n    return 0\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    a.append(x)\n    b.append(y)\n\n# Solve the problem\nres = solve(n, m, a, b)\n\n# Output\nprint(res)\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 1
    },
    {
      "index": 2,
      "text": "\n\n# Implement the solution\ndef solve(n, m, edges):\n    return -1\n\n# Input\nn, m = [int(x) for x in input().split()]\nedges = []\nfor i in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Solve the problems\nres = solve(n, m, edges)\n\n# Output\nprint(res)\n"
    }
  ],
  "created": 1649794263,
  "object": "edit"
}
2022-04-12 20:11:34.845999 NO RESULT
2022-04-12 20:11:34.846006 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 1
}
2022-04-12 20:11:34.846043 fix spelling mistakes 2 ['\n\n# Implement the solution here\ndef solve(n, m, a, b):\n    return 0\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    a.append(x)\n    b.append(y)\n\n# Solve the problem\nres = solve(n, m, a, b)\n\n# Output\nprint(res)\n', '\n\n# Implement the solution\ndef solve(n, m, edges):\n    return -1\n\n# Input\nn, m = [int(x) for x in input().split()]\nedges = []\nfor i in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Solve the problems\nres = solve(n, m, edges)\n\n# Output\nprint(res)\n']
2022-04-12 20:11:34.846066 size on output set 2
2022-04-12 20:11:34.846072 size on input set 2
2022-04-12 20:11:39.236668 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Implement the solution here\ndef solve():\n    return 0\n\n\n# Solve the problems\nres = solve()\n\n# Output\nprint(res)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Implement the solution here\ndef solve(n, m, edges, s, t):\n    return 0\n\n# Input\nn, m = [int(x) for x in input().split()]\nedges = [[int(x) for x in input().split()] for i in range(m)]\ns, t = [int(x) for x in input().split()]\n\n# Solve the problems\nres = solve(n, m, edges, s, t)\n\n# Output\nprint(res)\n"
    },
    {
      "index": 2,
      "text": "\n\n\n# Implement the solution\ndef solve(n, m, edges):\n\n    return -1\n\n# Input\nn, m = [int(x) for x in input().split()]\nedges = []\nfor i in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Solve the problems\nres = solve(n, m, edges)\n\n# Output\nprint(res)\n"
    }
  ],
  "created": 1649794294,
  "object": "edit"
}
2022-04-12 20:11:39.236851 fix syntax errors 3 ['\n\n# Implement the solution here\ndef solve():\n    return 0\n\n\n# Solve the problems\nres = solve()\n\n# Output\nprint(res)\n', '\n\n# Implement the solution here\ndef solve(n, m, edges, s, t):\n    return 0\n\n# Input\nn, m = [int(x) for x in input().split()]\nedges = [[int(x) for x in input().split()] for i in range(m)]\ns, t = [int(x) for x in input().split()]\n\n# Solve the problems\nres = solve(n, m, edges, s, t)\n\n# Output\nprint(res)\n', '\n\n\n# Implement the solution\ndef solve(n, m, edges):\n\n    return -1\n\n# Input\nn, m = [int(x) for x in input().split()]\nedges = []\nfor i in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Solve the problems\nres = solve(n, m, edges)\n\n# Output\nprint(res)\n']
2022-04-12 20:11:43.048224 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Implement the solution here\ndef solve(n, m, a, b):\n    return 0, []\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    a.append(x)\n    b.append(y)\n\n# Solve the problem\nres, path = solve(n, m, a, b)\n\n# Output\nfor v in path:\n    print(v)\nprint(res)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Implement the solution here\ndef solve(n, m, a, b, c):\n    return 0\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nc = []\nb = []\nfor i in range(m):\n    x, y, z = [int(x) for x in input().split()]\n    a.append(x)\n    c.append(z)\n    b.append(y)\n\n# Solve the problem\nres = solve(n, m, a, b, c)\n\n# Output\nprint(res)\n"
    },
    {
      "index": 2,
      "text": "\n\n# Implement the solution here\ndef solve(n, m, a, b):\n    return -1\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    a.append(x)\n    b.append(y)\n\n# Solve the problem\nres = solve(n, m, a, b)\n\n# Output\nprint(res)\n"
    }
  ],
  "created": 1649794299,
  "object": "edit"
}
2022-04-12 20:11:43.048390 fix syntax errors 3 ['\n\n# Implement the solution here\ndef solve(n, m, a, b):\n    return 0, []\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    a.append(x)\n    b.append(y)\n\n# Solve the problem\nres, path = solve(n, m, a, b)\n\n# Output\nfor v in path:\n    print(v)\nprint(res)\n', '\n\n# Implement the solution here\ndef solve(n, m, a, b, c):\n    return 0\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nc = []\nb = []\nfor i in range(m):\n    x, y, z = [int(x) for x in input().split()]\n    a.append(x)\n    c.append(z)\n    b.append(y)\n\n# Solve the problem\nres = solve(n, m, a, b, c)\n\n# Output\nprint(res)\n', '\n\n# Implement the solution here\ndef solve(n, m, a, b):\n    return -1\n\n# Inputs\nn, m = [int(x) for x in input().split()]\na = []\nb = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    a.append(x)\n    b.append(y)\n\n# Solve the problem\nres = solve(n, m, a, b)\n\n# Output\nprint(res)\n']
2022-04-12 20:11:43.048418 size on output set 6
