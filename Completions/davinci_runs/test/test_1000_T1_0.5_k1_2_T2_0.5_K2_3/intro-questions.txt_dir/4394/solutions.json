["import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\n\nWCHANGE=[]\nfor i in range(1,m):\n    if EDGE[i-1][2]!=EDGE[i][2]:\n        WCHANGE.append(i)\n\nWCHANGE.append(m)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\nNOW=0\nnoneed=[0]*m\nANS=0\nfor wc in WCHANGE:\n    for j in range(NOW,wc):\n\n        if find(EDGE[j][0])==find(EDGE[j][1]):\n            noneed[j]=1\n\n    for j in range(NOW,wc):\n        if noneed[j]==1:\n            continue      \n        x,y,w=EDGE[j]\n        if find(x)!=find(y):\n            Union(x,y)\n        else:\n            ANS+=1\n\n    NOW=wc\n\nprint(ANS)\n        \n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\n\nWCHANGE=[]\nfor i in range(1,m):\n    if EDGE[i-1][2]!=EDGE[i][2]:\n        WCHANGE.append(i)\n\nWCHANGE.append(m)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\nNOW=0\nnoneed=[0]*m\nANS=0\nfor wc in WCHANGE:\n    for j in range(NOW,wc):\n\n        if find(EDGE[j][0])==find(EDGE[j][1]):\n            noneed[j]=1\n\n    for j in range(NOW,wc):\n        if noneed[j]==1:\n            continue      \n        x,y,w=EDGE[j]\n        if find(x)!=find(y):\n            Union(x,y)\n        else:\n            ANS+=1\n\n    NOW=wc\n\nprint(ANS)\n        \n", "n, m = list(map(int, input().split()))\ne = [tuple(map(int, input().split())) for i in range(m)]\ne = sorted((w, u, v) for u, v, w in e)\n\np, r = [i for i in range(n + 1)], [0] * (n + 1)\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y):\n    x, y = p[x], p[y]\n    if r[x] < r[y]:\n        p[x] = y\n    else:\n        p[y] = x\n        if r[x] == r[y]:\n            r[x] += 1\n\nans = 0\ni = 0\nwhile i < m:\n    j = i + 1\n    while j < m and e[j][0] == e[i][0]:\n        j += 1\n    tmp = [(u, v) for w, u, v in e[i:j] if find(u) != find(v)]\n    for u, v in tmp:\n        if find(u) == find(v):\n            ans += 1\n        else:\n            union(u, v)\n    i = j\n\nprint(ans)\n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/1/23 23:46\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : F. MST Unification.py\n\n\nclass UnionFind(object):\n\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n\n    def find(self, x):\n        if self.root[x] == x:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return False\n\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.size[x] += self.size[y]\n        self.root[y] = x\n        return True\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    edge_list = []\n    for _ in range(m):\n        edge_list.append(list(map(int, input().split())))\n\n    union_find = UnionFind(n + 1)\n    edge_list.sort(key=lambda x: x[2])\n\n    p1 = ret = 0\n    while p1 < m:\n        p2 = p1\n        while p2 < m and edge_list[p1][2] == edge_list[p2][2]:\n            p2 += 1\n\n        avail = used = 0\n        for i in range(p1, p2):\n            if union_find.find(edge_list[i][0]) != union_find.find(edge_list[i][1]):\n                avail += 1\n        for i in range(p1, p2):\n            if union_find.union(edge_list[i][0], edge_list[i][1]):\n                used += 1\n        ret += avail - used\n        p1 = p2\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\ne = [tuple(map(int, input().split())) for i in range(m)]\ne = sorted((w, u, v) for u, v, w in e)\n\np, r = [i for i in range(n + 1)], [0] * (n + 1)\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y):\n    x, y = p[x], p[y]\n    if r[x] < r[y]:\n        p[x] = y\n    else:\n        p[y] = x\n        if r[x] == r[y]:\n            r[x] += 1\n\nans = 0\ni = 0\nwhile i < m:\n    j = i + 1\n    while j < m and e[j][0] == e[i][0]:\n        j += 1\n    tmp = [(u, v) for w, u, v in e[i:j] if find(u) != find(v)]\n    for u, v in tmp:\n        if find(u) == find(v):\n            ans += 1\n        else:\n            union(u, v)\n    i = j\n\nprint(ans)", "class DisjoinSet:\n    def __init__(self, n):\n        self.n = n\n        self.dad = [i for i in range(n + 1)]\n        self.cant = [1] * (n + 1)\n\n    def SetOf(self, n):\n        if self.dad[n] == n:\n            return n\n        self.dad[n] = self.SetOf(self.dad[n])\n        return self.dad[n]\n\n    def Merge(self, a, b):\n        a, b = self.SetOf(a), self.SetOf(b)\n        if a != b:\n            if self.cant[b] > self.cant[a]:\n                a, b = b, a\n            self.cant[a] += self.cant[b]\n            self.dad[b] = a\n            return True\n        return False\n\n\ndef Kruskal(l, n):\n    l.sort()\n    i = 0\n    ds = DisjoinSet(n)\n    cant = 0\n    change = 0\n    while cant < n - 1 and i < len(l):\n        val = l[i][0]\n        old = []\n        while i < len(l) and val == l[i][0]:\n            x, y = ds.SetOf(l[i][1]), ds.SetOf(l[i][2])\n            if x != y:\n                old.append((x, y))\n            i += 1\n        change += len(old)\n        for (x, y) in old:\n            change -= ds.Merge(x, y)\n    return change\n\n\nn, m = input().split()\nn, m = int(n), int(m)\n\ne = []\nfor i in range(m):\n    x, y, c = input().split()\n    e.append((int(c), int(x), int(y)))\n\nprint(Kruskal(e, n))\n", "n,m = map(int,input().split())\n\nl = []\nfor i in range(m):\n\ta,b,c = map(int,input().split())\n\tl.append((c,a,b))\nl.sort()\nf = [i for i in range(n+1)]\ndef r(a):\n    if a==f[a]:\n        return a\n    f[a]=r(f[a])\n    return f[a]\n\ncnt = 0\ni=0\nwhile i < m:\n    j = i\n    while j < m and l[j][0] == l[i][0]:\n        j=j+1\n    num=0\n    for k in range(i,j):\n        x=r(l[k][1])\n        y=r(l[k][2])\n        if x!=y:\n            num=num+1\n    for k in range(i,j):\n        x = r(l[k][1])\n        y = r(l[k][2])\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)", "a=input().split()\nn,m=int(a[0]),int(a[1])\nf=[i for i in range(0,n+1)]\nclass edge:\n    def __init__(self,U,V,W):\n        self.u=U\n        self.v=V\n        self.w=W\n\nl=[]\nfor i in range(m):\n    a = input().split()\n    u,v,w=int(a[0]),int(a[1]),int(a[2])\n    l.append(edge(u,v,w))\nl.sort(key=lambda x:x.w)\n\ndef r(a):\n    if a!=f[a]:\n        f[a]=r(f[a])\n    return f[a]\ncnt=0\ni=0\nwhile i<m:\n    j=i\n    while l[i].w==l[j].w:\n        j=j+1\n        if j==m:\n            break\n    num=0\n    for k in range(i,j):\n        x=r(l[k].u)\n        y=r(l[k].v)\n        if x!=y:\n            num=num+1\n    for k in range(i, j):\n        x = r(l[k].u)\n        y = r(l[k].v)\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)", "n,m=map(int,input().split())\nclass edge:\n    def __init__(self,U,V,W):\n        self.u=U\n        self.v=V\n        self.w=W\n\nl=[]\nfor i in range(m):\n    u,v,w=map(int,input().split())\n    l.append(edge(u,v,w))\nl.sort(key=lambda x:x.w)\nf=[i for i in range(0,n+1)]\ndef r(a):\n    if a!=f[a]:\n        f[a]=r(f[a])\n    return f[a]\ncnt=0\ni=0\nwhile i<m:\n    j=i\n    while l[i].w==l[j].w:\n        j=j+1\n        if j==m:\n            break\n    num=0\n    for k in range(i,j):\n        x=r(l[k].u)\n        y=r(l[k].v)\n        if x!=y:\n            num=num+1\n    for k in range(i, j):\n        x = r(l[k].u)\n        y = r(l[k].v)\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)", "n,m = map(int,input().split())\n\nl = []\nfor i in range(m):\n\ta,b,c = map(int,input().split())\n\tl.append((c,a,b))\nl.sort()\nf = [i for i in range(n+1)]\ndef r(a):\n    if a!=f[a]:\n        f[a]=r(f[a])\n    return f[a]\n\ncnt = 0\ni=0\nwhile i < m:\n    j = i\n    while j < m and l[j][0] == l[i][0]:\n        j=j+1\n    num=0\n    for k in range(i,j):\n        x=r(l[k][1])\n        y=r(l[k][2])\n        if x!=y:\n            num=num+1\n    for k in range(i,j):\n        x = r(l[k][1])\n        y = r(l[k][2])\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)", "n,m = map(int,input().split())\n\nl = []\nfor i in range(m):\n\ta,b,c = map(int,input().split())\n\tl.append((c,a,b))\nl.sort()\nf = [i for i in range(n+1)]\nc=[1]*(n+1)\ndef r(a):\n    if a!=f[a]:\n        f[a]=r(f[a])\n    return f[a]\ndef union(x,y):\n    if x==y:\n        return\n    if c[x]<c[y]:\n        f[x]=y\n    else:\n        if c[x]==c[y]:\n            c[x]=c[x]+1\n        f[y]=x\n\ncnt = 0\ni=0\nwhile i < m:\n    j = i\n    while j < m and l[j][0] == l[i][0]:\n        j=j+1\n    num=0\n    for k in range(i,j):\n        x=r(l[k][1])\n        y=r(l[k][2])\n        if x!=y:\n            num=num+1\n    for k in range(i,j):\n        x = r(l[k][1])\n        y = r(l[k][2])\n        if x != y:\n            union(x,y)\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)", "# Anton Timofeev\nimport sys\n\n\ndef get(v):\n\tif v == prev[v]:\n\t\treturn v\n\tprev[v] = get(prev[v])\n\treturn prev[v]\n\ndef join(u, v):\n\tu = get(u); v = get(v)\n\tif u != v:\n\t\tif size[u] < size[v]:\n\t\t\tu, v = v, u\n\t\tprev[v] = u\n\t\tsize[u] += size[v]\n\n\nn, m = map(int, sys.stdin.readline().split())\nedges = [0] * m\nfor i in range(m):\n\tu, v, w = map(int, sys.stdin.readline().split())\n\tedges[i] = (u - 1, v - 1, w)\n\nedges.sort(key=lambda e: e[2])\n# print(edges)\n\nprev = list(range(n))\nsize = [1] * n\n\nres = 0\nl, r = 0, 1\nwhile l < m:\n\twhile r < m and edges[l][2] == edges[r][2]:\n\t\tr += 1\n\tres += r - l\n\tfor i in range(l, r):\n\t\tif get(edges[i][0]) == get(edges[i][1]):\n\t\t\tres -= 1\n\tfor i in range(l, r):\n\t\tif get(edges[i][0]) != get(edges[i][1]):\n\t\t\tjoin(edges[i][0], edges[i][1])\n\t\t\t# print(f\"join: {edges[i]}\")\n\t\t\tres -= 1\n\tl = r\nprint(res)", "import sys\n# 26\ninput = lambda: sys.stdin.readline().strip()\nipnut = input\ndef find(a):\n    st = []\n    while a!=dsu[a]:\n        st.append(a)\n        a = dsu[a]\n    for j in st:\n        dsu[j]=a\n    return a\ndef union(a,b,f):\n    a = find(a)\n    b = find(b)\n    if f:\n        dsu[a]=b\n    else:\n        dsu[b]=a\nn,m = map(int,input().split())\nif m == 0:\n    print(0)\n    return\ndsu = [i for i in range(n)]\nh = []\nfor i in range(m):\n    a,b,c = map(int,ipnut().split())\n    h.append((c,a-1,b-1))\nh.sort()\nlc = 0\nans = 0\nheh = [[h[0]]]\nfor i in h[1:]:\n    if heh[-1][0][0]==i[0]:\n        heh[-1].append(i)\n    else:\n        heh.append([i])\nab = []\nfor h in heh:\n    lol = []\n    for c,a,b in h:\n        if find(a)!=find(b):\n            lol.append((a,b))\n    for a,b in lol:\n        if find(a)==find(b):\n            ans+=1\n        else:\n            union(a,b,ans%2)\nprint(ans)", "class DisjoinSet:\n    def __init__(self, n):\n        self.n = n\n        self.dad = [i for i in range(n + 1)]\n        self.cant = [1] * (n + 1)\n\n    def SetOf(self, n):\n        if self.dad[n] == n:\n            return n\n        self.dad[n] = self.SetOf(self.dad[n])\n        return self.dad[n]\n\n    def Merge(self, a, b):\n        a, b = self.SetOf(a), self.SetOf(b)\n        if a != b:\n            if self.cant[b] > self.cant[a]:\n                a, b = b, a\n            self.cant[a] += self.cant[b]\n            self.dad[b] = a\n            return True\n        return False\n\n\ndef Kruskal(l, n):\n    l.sort()\n    i = 0\n    ds = DisjoinSet(n)\n    cant = 0\n    change = 0\n    while cant < n - 1 and i < len(l):\n        val = l[i][0]\n        old = []\n        while i < len(l) and val == l[i][0]:\n            x, y = ds.SetOf(l[i][1]), ds.SetOf(l[i][2])\n            if x != y:\n                old.append((x, y))\n            i += 1\n        change += len(old)\n        for (x, y) in old:\n            change -= ds.Merge(x, y)\n    return change\n\n\nn, m = input().split()\nn, m = int(n), int(m)\n\ne = []\nfor i in range(m):\n    x, y, c = input().split()\n    e.append((int(c), int(x), int(y)))\n\nprint(Kruskal(e, n))\n\n", "n,m = list(map(int,input().split()))\n     \nl = []\nfor i in range(m):\n    a,b,c = list(map(int,input().split()))\n    l.append((c,a,b))\nl.sort()\nf = [i for i in range(n+1)]\ndef r(a):\n    if a!=f[a]:\n        f[a]=r(f[a])\n    return f[a]\n     \ncnt = 0\ni=0\nwhile i < m:\n    j = i\n    while j < m and l[j][0] == l[i][0]:\n        j=j+1\n    num=0\n    for k in range(i,j):\n        x=r(l[k][1])\n        y=r(l[k][2])\n        if x!=y:\n            num=num+1\n    for k in range(i,j):\n        x = r(l[k][1])\n        y = r(l[k][2])\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)\n#JSR\n", "n,m = list(map(int,input().split()))\n     \nl = []\nfor i in range(m):\n    a,b,c = list(map(int,input().split()))\n    l.append((c,a,b))\nl.sort()\nf = [i for i in range(n+1)]\ndef r(a):\n    if a!=f[a]:\n        f[a]=r(f[a])\n    return f[a]\n     \ncnt = 0\ni=0\nwhile i < m:\n    j = i\n    while j < m and l[j][0] == l[i][0]:\n        j=j+1\n    num=0\n    for k in range(i,j):\n        x=r(l[k][1])\n        y=r(l[k][2])\n        if x!=y:\n            num=num+1\n    for k in range(i,j):\n        x = r(l[k][1])\n        y = r(l[k][2])\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)\n", "# https://codeforces.com/problemset/problem/1108/F\nn, m =  map(int, input().split())\nedge =  [list(map(int, input().split())) for _ in range(m)]\nedge =  sorted(edge,key=lambda x: x[2])\n\nclass Union:\n    def __init__(self, n):\n        self.p    = [i for i in range(n+1)]\n        self.rank = [0] * (n+1) \n        \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.p[x]     = y\n                self.rank[y] += self.rank[x]\n            else:\n                self.p[y]     = x\n                self.rank[x] += self.rank[y]\n            \ncnt  =  0\nused = [0] * m\nl, r = 0, 1\nU    = Union(n)\n\nwhile l < m:\n    try:\n        while r < m and edge[r][2] == edge[l][2]:\n            r+=1\n    except:\n        print('bl1')\n    \n    try:\n        for i in range(l, r):\n            u, v, w = edge[i] \n            if U.find(u) == U.find(v):\n                used[i] = 1\n    except:\n        print('bl2')\n        \n    try:    \n        for i in range(l, r):\n            if used[i] == 1:\n                continue\n            \n            u, v, w = edge[i]    \n            if U.find(u) == U.find(v):\n                cnt +=1\n            else:\n                U.union(u, v)  \n    except:\n        print('bl3')\n        print(u, v)\n        print(U.find(u))\n        print(U.find(v))\n        \n    l = r\n    r = l+1\n    \nprint(cnt)    ", "import collections as cc\nimport itertools as it\nimport bisect as bi\nI=lambda:list(map(int,input().split()))\nn,m=I()\ned=[I() for i in range(m)]\ned.sort(key=lambda x:x[2])\nch=[]\nfor i in range(1,m):\n\tif ed[i-1][2]!=ed[i][2]:\n\t\tch.append(i)\nch.append(m)\nparent=[i for i in range(n+1)]\ndef find(x):\n\twhile x!=parent[x]:\n\t\tx=parent[x]\n\treturn x\ndef union(x,y):\n\ta=find(x)\n\tb=find(y)\n\tparent[a]=parent[b]=min(a,b)\ncur=0\n \ncur=0\nno=[0]*m\nans=0\nfor i in ch:\n    for j in range(cur,i):\n        if find(ed[j][0])==find(ed[j][1]):\n            no[j]=1\n    for j in range(cur,i):\n        if no[j]==1:\n            continue      \n        x,y,w=ed[j]\n        if find(x)!=find(y):\n            union(x,y)\n        else:\n            ans+=1\n    cur=i\n \n\nprint(ans)", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,m=I()\ned=[I() for i in range(m)]\ned.sort(key=lambda x:x[2])\np=[i for i in range(n)]\n\ndef find(x):\n\twhile x!=p[x]:\n\t\tx=p[x]\n\treturn x\n\ndef union(a,b):\n\tx=find(a)\n\ty=find(b)\n\tif x!=y:\n\t\tp[y]=p[x]=min(x,y)\n\t\treturn 1\n\treturn 0\nan=0;ce=0\npos=[1]*m\ni=0\nwhile ce<n-1:\n\t#print(i,ce,pos)\n\tx,y,w=ed[i]\n\tfor j in range(i,m):\n\t\tif ed[j][2]!=w:\n\t\t\tbreak\n\t\ta,b,c=ed[j]\n\t\tif find(a-1)==find(b-1):\n\t\t\tpos[j]=0\n\tfor j in range(i,m):\n\t\tx,y,b=ed[j]\n\t\tif ed[j][2]!=w:\n\t\t\tbreak\n\t\tif pos[j]:\n\t\t\td=union(x-1,y-1)\n\t\t\t#print(d,p)\n\t\t\tif d==0:\n\t\t\t\tan+=1\n\t\t\telse:\n\t\t\t\tce+=1\n\tif ce==n-1:\n\t\tbreak\n\ti=j\n\nprint(an)", "n,m = map(int,input().split())\n\nl = []\nfor i in range(m):\n\ta,b,c = map(int,input().split())\n\tl.append((c,a,b))\nl.sort()\nf = [i for i in range(n+1)]\ndef r(a):\n    if a==f[a]:\n        return a\n    f[a]=r(f[a])\n    return f[a]\n\ncnt = 0\ni=0\nwhile i < m:\n    j = i\n    while j < m and l[j][0] == l[i][0]:\n        j=j+1\n    num=0\n    for k in range(i,j):\n        x=r(l[k][1])\n        y=r(l[k][2])\n        if x!=y:\n            num=num+1\n    for k in range(i,j):\n        x = r(l[k][1])\n        y = r(l[k][2])\n        if x != y:\n            f[y]=x\n            num = num -1\n    cnt=cnt+num\n    i=j\nprint(cnt)"]