2022-04-13 04:18:52.188786 num operations 2
2022-04-13 04:18:52.188795 size on input set 1
2022-04-13 04:18:54.190344 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# TODO: implement the solution.\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# TODO: implement the solution.\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# TODO: implement the solution.\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823532,
  "object": "edit"
}
2022-04-13 04:18:54.190563 fix spelling mistakes 3 ['\n\n# TODO: implement the solution.\n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution.\n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution.\n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:18:54.190584 size on output set 1
2022-04-13 04:18:54.190590 size on input set 1
2022-04-13 04:18:56.600148 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport os\n# TODO: implement the solution.\n\ndef main():\n    path = os.getcwd()\n    print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# TODO: implement the solution.\n\ndef main():\n    pass\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# TODO: implement the solution.\n\ndef main():\n    print(\"Hello World!\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823534,
  "object": "edit"
}
2022-04-13 04:18:56.600334 fix syntax errors 3 ['\nimport os\n# TODO: implement the solution.\n\ndef main():\n    path = os.getcwd()\n    print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution.\n\ndef main():\n    pass\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution.\n\ndef main():\n    print("Hello World!")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:18:56.600357 size on output set 3
2022-04-13 04:18:56.600377 num operations 2
2022-04-13 04:18:56.600382 size on input set 1
2022-04-13 04:19:07.854345 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"X\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    }
  ],
  "created": 1649823536,
  "object": "edit"
}
2022-04-13 04:19:07.854631 fix spelling mistakes 3 ['\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "X":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n']
2022-04-13 04:19:07.854702 size on output set 2
2022-04-13 04:19:07.854709 size on input set 2
2022-04-13 04:19:20.661713 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"X\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\" and grid[i][j] != \"S\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\" or grid[x][y] == \"1\":\n\t\t\tcontinue\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y - 1])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y - 1])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\" and grid[i][j] != \"0\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    }
  ],
  "created": 1649823547,
  "object": "edit"
}
2022-04-13 04:19:20.661992 fix syntax errors 3 ['\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "X":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1" and grid[i][j] != "S":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S" or grid[x][y] == "1":\n\t\t\tcontinue\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y - 1])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y - 1])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', 'import sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1" and grid[i][j] != "0":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n']
2022-04-13 04:19:38.612431 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"X\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn \"1\"\n\t\t\telse:\n\t\t\t\treturn \"0\"\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn \"-1\"\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \".\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \".\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"X\":\n\t\t\t\tnodes.append(Node(j, i))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x - 1])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x + 1])\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(y-1) * len(grid[0]) + x])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(y+1) * len(grid[0]) + x])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x - 1])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x + 1])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(y-1) * len(grid[0]) + x])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"X\":\n\t\t\t\tnode.add_neighbor(nodes[(y+1) * len(grid[0]) + x])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid[0]) - 1 or curr.y == 0 or curr.y == len(grid) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tif neighbor.x == 0 or neighbor.x == len(grid[0]) - 1 or neighbor.y == 0 or neighbor.y == len(grid) - 1:\n\t\t\t\t\tif t >= 1:\n\t\t\t\t\t\treturn 1\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn 0\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    }
  ],
  "created": 1649823560,
  "object": "edit"
}
2022-04-13 04:19:38.612724 fix syntax errors 3 ['\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "X":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn "1"\n\t\t\telse:\n\t\t\t\treturn "0"\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn "-1"\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != ".":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != ".":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != ".":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != ".":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != ".":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != ".":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != ".":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != ".":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != ".":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "X":\n\t\t\t\tnodes.append(Node(j, i))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x - 1])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x + 1])\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(y-1) * len(grid[0]) + x])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(y+1) * len(grid[0]) + x])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x - 1])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "X":\n\t\t\t\tnode.add_neighbor(nodes[y * len(grid[0]) + x + 1])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(y-1) * len(grid[0]) + x])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "X":\n\t\t\t\tnode.add_neighbor(nodes[(y+1) * len(grid[0]) + x])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid[0]) - 1 or curr.y == 0 or curr.y == len(grid) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tif neighbor.x == 0 or neighbor.x == len(grid[0]) - 1 or neighbor.y == 0 or neighbor.y == len(grid) - 1:\n\t\t\t\t\tif t >= 1:\n\t\t\t\t\t\treturn 1\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn 0\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n']
2022-04-13 04:19:38.612805 size on output set 6
2022-04-13 04:19:38.612817 num operations 2
2022-04-13 04:19:38.612822 size on input set 1
2022-04-13 04:19:43.127849 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dx == 1:\n                continue\n            if grid[nx][ny] == 'D' and dx == -1:\n                continue\n            if grid[nx][ny] == 'L' and dy == 1:\n                continue\n            if grid[nx][ny] == 'R' and dy == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\") \n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823578,
  "object": "edit"
}
2022-04-13 04:19:43.128100 fix spelling mistakes 3 ['\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dx == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dy == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE") \n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:19:43.128156 size on output set 3
2022-04-13 04:19:43.128162 size on input set 3
2022-04-13 04:19:51.630537 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dx == 1:\n                continue\n            if grid[nx][ny] == 'D' and dx == -1:\n                continue\n            if grid[nx][ny] == 'L' and dy == 1:\n                continue\n            if grid[nx][ny] == 'R' and dy == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j \n                break \n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dx == 1:\n                continue\n            if grid[nx][ny] == 'D' and dx == -1:\n                continue\n            if grid[nx][ny] == 'L' and dy == 1:\n                continue\n            if grid[nx][ny] == 'R' and dy == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823583,
  "object": "edit"
}
2022-04-13 04:19:51.630732 fix syntax errors 3 ['\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dx == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dy == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j \n                break \n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dx == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dy == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:19:53.472279 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\") \n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue: \n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\") \n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823591,
  "object": "edit"
}
2022-04-13 04:19:53.472459 fix syntax errors 3 ['\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE") \n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue: \n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE") \n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:19:55.832036 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823593,
  "object": "edit"
}
2022-04-13 04:19:55.832302 fix syntax errors 3 ['\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:19:55.832352 size on output set 9
2022-04-13 04:19:55.832363 num operations 2
2022-04-13 04:19:55.832368 size on input set 1
2022-04-13 04:20:00.530894 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached one of the borders\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        print(queue)\n        print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823595,
  "object": "edit"
}
2022-04-13 04:20:00.531175 fix spelling mistakes 3 ["\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached one of the borders\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        print(queue)\n        print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:20:00.531306 size on output set 3
2022-04-13 04:20:00.531313 size on input set 3
2022-04-13 04:20:22.592745 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport collections\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = collections.deque()\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.popleft()\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached one of the borders\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    \n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n\n    # print(dist)\n\n    # check if reached one of the borders\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823600,
  "object": "edit"
}
2022-04-13 04:20:22.592939 fix syntax errors 3 ["\nimport collections\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = collections.deque()\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.popleft()\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached one of the borders\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    \n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n\n    # print(dist)\n\n    # check if reached one of the borders\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:20:26.872623 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.strip().split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823622,
  "object": "edit"
}
2022-04-13 04:20:26.872902 fix syntax errors 3 ["\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.strip().split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border within time limit\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:20:32.963804 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n                # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n                break\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        print(queue)\n        print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823626,
  "object": "edit"
}
2022-04-13 04:20:32.964118 fix syntax errors 3 ["#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n                # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n                break\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        print(queue)\n        print(dist)\n\n    print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:20:32.964236 size on output set 9
2022-04-13 04:20:32.964263 num operations 2
2022-04-13 04:20:32.964269 size on input set 1
2022-04-13 04:20:37.592193 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        if grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        if grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        if grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        if grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823633,
  "object": "edit"
}
2022-04-13 04:20:37.592460 fix spelling mistakes 3 ['\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        if grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        if grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        if grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        if grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:20:37.592547 size on output set 3
2022-04-13 04:20:37.592553 size on input set 3
2022-04-13 04:20:42.471065 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823637,
  "object": "edit"
}
2022-04-13 04:20:42.471349 fix syntax errors 3 ['\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n#\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:21:05.635358 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m):\n        if grid[x-1][y] != '1':\n            if grid[x-1][y] == 'U':\n                nexts.append(Node(x-1, y, 1))\n            elif grid[x][y] == 'D':\n                nexts.append(Node(x-1, y, 1))\n            else:\n                nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m):\n        if grid[x+1][y] != '1':\n            if grid[x+1][y] == 'D':\n                nexts.append(Node(x+1, y, 1))\n            elif grid[x][y] == 'U':\n                nexts.append(Node(x+1, y, 1))\n            else:\n                nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m):\n        if grid[x][y-1] != '1':\n            if grid[x][y-1] == 'L':\n                nexts.append(Node(x, y-1, 1))\n            elif grid[x][y] == 'R':\n                nexts.append(Node(x, y-1, 1))\n            else:\n                nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m):\n        if grid[x][y+1] != '1':\n            if grid[x][y+1] == 'R':\n                nexts.append(Node(x, y+1, 1))\n            elif grid[x][y] == 'L':\n                nexts.append(Node(x, y+1, 1))\n            else:\n                nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x - 1, y, n, m) and grid[x - 1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x - 1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x - 1, y, 1))\n        else:\n            nexts.append(Node(x - 1, y, 0))\n    if is_valid(x + 1, y, n, m) and grid[x + 1][y] != '1':\n        if grid[x + 1][y] == 'D':\n            nexts.append(Node(x + 1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x + 1, y, 1))\n        else:\n            nexts.append(Node(x + 1, y, 0))\n    if is_valid(x, y - 1, n, m) and grid[x][y - 1] != '1':\n        if grid[x][y - 1] == 'L':\n            nexts.append(Node(x, y - 1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y - 1, 1))\n        else:\n            nexts.append(Node(x, y - 1, 0))\n    if is_valid(x, y + 1, n, m) and grid[x][y + 1] != '1':\n        if grid[x][y + 1] == 'R':\n            nexts.append(Node(x, y + 1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y + 1, 1))\n        else:\n            nexts.append(Node(x, y + 1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == '^':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == '^':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == '<':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == '<':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823642,
  "object": "edit"
}
2022-04-13 04:21:05.635640 fix syntax errors 3 ['\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m):\n        if grid[x-1][y] != \'1\':\n            if grid[x-1][y] == \'U\':\n                nexts.append(Node(x-1, y, 1))\n            elif grid[x][y] == \'D\':\n                nexts.append(Node(x-1, y, 1))\n            else:\n                nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m):\n        if grid[x+1][y] != \'1\':\n            if grid[x+1][y] == \'D\':\n                nexts.append(Node(x+1, y, 1))\n            elif grid[x][y] == \'U\':\n                nexts.append(Node(x+1, y, 1))\n            else:\n                nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m):\n        if grid[x][y-1] != \'1\':\n            if grid[x][y-1] == \'L\':\n                nexts.append(Node(x, y-1, 1))\n            elif grid[x][y] == \'R\':\n                nexts.append(Node(x, y-1, 1))\n            else:\n                nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m):\n        if grid[x][y+1] != \'1\':\n            if grid[x][y+1] == \'R\':\n                nexts.append(Node(x, y+1, 1))\n            elif grid[x][y] == \'L\':\n                nexts.append(Node(x, y+1, 1))\n            else:\n                nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x - 1, y, n, m) and grid[x - 1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x - 1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x - 1, y, 1))\n        else:\n            nexts.append(Node(x - 1, y, 0))\n    if is_valid(x + 1, y, n, m) and grid[x + 1][y] != \'1\':\n        if grid[x + 1][y] == \'D\':\n            nexts.append(Node(x + 1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x + 1, y, 1))\n        else:\n            nexts.append(Node(x + 1, y, 0))\n    if is_valid(x, y - 1, n, m) and grid[x][y - 1] != \'1\':\n        if grid[x][y - 1] == \'L\':\n            nexts.append(Node(x, y - 1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y - 1, 1))\n        else:\n            nexts.append(Node(x, y - 1, 0))\n    if is_valid(x, y + 1, n, m) and grid[x][y + 1] != \'1\':\n        if grid[x][y + 1] == \'R\':\n            nexts.append(Node(x, y + 1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y + 1, 1))\n        else:\n            nexts.append(Node(x, y + 1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'^\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'^\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'<\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'<\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:21:10.564245 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649823665,
  "object": "edit"
}
2022-04-13 04:21:10.564530 fix syntax errors 3 ['\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for i in range(m)] for j in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 04:21:10.564618 size on output set 5
2022-04-13 04:21:10.564630 num operations 2
2022-04-13 04:21:10.564635 size on input set 1
2022-04-13 04:21:26.720625 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823670,
  "object": "edit"
}
2022-04-13 04:21:26.720918 fix spelling mistakes 3 ["\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:21:26.721000 size on output set 3
2022-04-13 04:21:26.721006 size on input set 3
2022-04-13 04:21:30.191167 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823686,
  "object": "edit"
}
2022-04-13 04:21:30.191436 fix syntax errors 3 ["\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef read_input():\n\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:21:42.256281 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    print(t, N, M)\n    print(grid)\n    print()\n    print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '.' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '.' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '.' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '.' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823690,
  "object": "edit"
}
2022-04-13 04:21:42.256602 fix syntax errors 3 ["\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    print(t, N, M)\n    print(grid)\n    print()\n    print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '.' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '.' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '.' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '.' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS to find the min time\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:21:57.515862 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U') and (row-1, col) not in visited:\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D') and (row+1, col) not in visited:\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L') and (row, col-1) not in visited:\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R') and (row, col+1) not in visited:\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col, t))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t, visited)\n            for path in paths:\n                row, col, t = path\n                q.append(path)\n                visited.add((row, col, t))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823702,
  "object": "edit"
}
2022-04-13 04:21:57.516120 fix syntax errors 3 ["\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths from a given point\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U') and (row-1, col) not in visited:\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D') and (row+1, col) not in visited:\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L') and (row, col-1) not in visited:\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R') and (row, col+1) not in visited:\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS to find the shortest path\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col, t))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t, visited)\n            for path in paths:\n                row, col, t = path\n                q.append(path)\n                visited.add((row, col, t))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:21:57.516199 size on output set 7
2022-04-13 04:21:57.516212 num operations 2
2022-04-13 04:21:57.516217 size on input set 1
2022-04-13 04:22:16.060814 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823717,
  "object": "edit"
}
2022-04-13 04:22:16.061102 fix spelling mistakes 3 ["\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:22:16.061182 size on output set 2
2022-04-13 04:22:16.061188 size on input set 2
2022-04-13 04:22:19.290802 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823736,
  "object": "edit"
}
2022-04-13 04:22:19.291207 fix syntax errors 3 ["\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['#', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:22:24.614206 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) < n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node[0])\n            visited.add(node[1])\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m - 1:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited) // 2)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649823739,
  "object": "edit"
}
2022-04-13 04:22:24.614466 fix syntax errors 3 ["\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) < n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node[0])\n            visited.add(node[1])\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m - 1:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited) // 2)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 04:22:24.614542 size on output set 4
