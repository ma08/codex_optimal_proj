2022-04-09 22:55:05.503758 """
Wall Maria has been broken! Eren must evacuate as soon as possible from his house. He must find the fastest route to escape within Wall Maria before the titans rush in. Wall Maria is represented as a $N \times M$ grid in which Eren can move horizontally or vertically.

There are burning houses and buildings which prevent Eren from passing through them. The burning houses and buildings are represented as ‘1’. Unburned or safe areas are represented as ‘0’. There are some areas which can be entered but only from a specific direction. These areas can be represented by either ‘U’, ‘D’, ‘L’, or ‘R’. For example, if there is an ‘R’ that means that area can only be entered from the right neighboring tile within Wall Maria’s grid. Similarly, ‘U’ tiles can only be entered from above, ‘D’ tiles can only be entered from below, and ‘L’ tiles can only be entered from the left.

Eren knows the time $t$ at which the titans will rush in. It takes $1$ unit of time to traverse $1$ zone (which corresponds to $1$ tile in the grid). Once he reaches any border of Wall Maria he is safe.

Eren’s starting position is represented by the letter ‘S’. If Eren escapes at or before time $t$, he is safe. Given his position within Wall Maria determine if it is possible to escape. If it is possible determine the number of zones that must be traversed to lead to the quickest escape.

-----Input-----
The input consists of a single test case. The first line contains three integers $t$ ($1 \le t \le 200$) , $N$ ($1 \le N \le 100$) and $M$ ($1 \le M \le 100$). The rest of N lines will be Wall Maria’s grid containing characters ‘1‘, ‘0‘, ‘S‘, ‘U‘, ‘D‘, ‘L‘, or ‘R‘. There is exactly one ‘S‘ in the input.

-----Output-----
If it is possible to escape Wall Maria, output the minimum number of zones that must be traversed to escape. If it is not possible to escape, print “NOT POSSIBLE”!

-----Examples-----
Sample Input 1:
2 4 4
1111
1S01
1011
0U11
Sample Output 1:
2

Sample Input 2:
2 4 4
1111
1S01
1011
0L11
Sample Output 2:
NOT POSSIBLE
"""
2022-04-09 22:55:05.503776 --------------------------
2022-04-09 22:57:19.108351 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# TODO: implement the solution\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        if grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        if grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 6,
      "logprobs": null,
      "text": "\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1649559306,
  "id": "cmpl-4vI1CZrQt29RxN3W37pLewKh7T3gZ",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 22:57:19.109129 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 22:57:19.109236 REASON stop
2022-04-09 22:57:19.120811 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
2022-04-09 22:57:19.120876 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 22:57:19.121028 REASON stop
2022-04-09 22:57:19.121879 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
2022-04-09 22:57:19.121945 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()"
}
2022-04-09 22:57:19.122084 REASON stop
2022-04-09 22:57:19.122362 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
2022-04-09 22:57:19.122405 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 22:57:19.122433 REASON stop
2022-04-09 22:57:19.122568 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
2022-04-09 22:57:19.122575 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# TODO: implement the solution\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 22:57:19.122598 REASON stop
2022-04-09 22:57:19.122729 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
2022-04-09 22:57:19.122735 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        if grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        if grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 22:57:19.122762 REASON stop
2022-04-09 22:57:19.122903 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
2022-04-09 22:57:19.122909 6 {
  "finish_reason": "length",
  "index": 6,
  "logprobs": null,
  "text": "\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n            nj=j+dj[n]\n            if ni<0 or ni>=N or nj<0 or nj>=M:\n                continue\n            if visited[ni][nj] or map[ni][nj]==1:\n                continue\n            if map[ni][nj]=='U' and n!=0:\n                continue\n            if map[ni][nj]=='D' and n!=1:\n                continue\n            if map[ni][nj]=='L' and n!=2:\n                continue\n            if map[ni][nj]=='R' and n!=3:\n                continue\n            visited[ni][nj]=True\n            queue.append(ni*M+nj)\n    return False\n\nt,N,M=map(int,input().split())\nmap=[]\nfor i in range(N):\n    map.append(list(input()))\ndi=[-1,1,0,0]\ndj=[0,0,-1,1]\nif escape(t,N,M,map):\n    print(t)\nelse:\n    print('NOT POSSIBLE')\n\n#%%\ndef escape(t,N,M,map):\n    visited=[[False for _ in range(M)] for _ in range(N)]\n    queue=[]\n    queue.append(0)\n    visited[0][0]=True\n    while queue:\n        cur=queue.pop(0)\n        i=cur//M\n        j=cur%M\n        if i==N-1 or j==M-1:\n            return True\n        for n in range(4):\n            ni=i+di[n]\n"
}
2022-04-09 22:57:19.122983 REASON length
2022-04-09 22:57:19.122987 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 22:57:19.123009 REASON stop
2022-04-09 22:57:19.123153 test/intro-questions.txt_dir/4835/question.txt [Errno 2] No such file or directory: 'test/intro-questions.txt_dir/4835/solutions.json'
