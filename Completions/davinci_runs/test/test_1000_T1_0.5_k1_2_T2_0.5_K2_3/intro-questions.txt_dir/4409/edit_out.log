2022-04-12 20:20:57.434693 num operations 2
2022-04-12 20:20:57.434702 size on input set 1
2022-04-12 20:21:02.477424 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794857,
  "object": "edit"
}
2022-04-12 20:21:02.477819 fix spelling mistakes 3 ["\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:21:02.477956 size on output set 2
2022-04-12 20:21:02.477991 size on input set 2
2022-04-12 20:21:14.129334 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Jun 21 15:11:54 2018\n@author: kazuki.onodera\n\"\"\"\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n\n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n\n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n\n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n\n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n\n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:  # v = node, w = weight\n            if dist[v] > dist[u] + w:  # if the distance to reach v is greater than the distance to reach u + the weight of the edge from u to v\n                dist[v] = dist[u] + w  # update the distance to reach v\n                q.append(v)  # add v to the queue\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:  # while the current node is not the first node\n        for v, w in adj_list[curr_node]:  # v = node, w = weight\n            if dist[curr_node] == dist[v] + w:  # if the distance to reach curr_node is equal to the distance to reach v + the weight of the edge from v to curr_node\n                if w > 0:  # if the weight of the edge from v to curr_node is positive\n                    output.append((1, curr_node + 1, v + 1))  # add a move command to the output\n                else:  # if the weight of the edge from v to curr_node is negative\n                    output.append((2, curr_node + 1, v + 1))  # add a reverse command to the output\n                curr_node = v  # update curr_node\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794862,
  "object": "edit"
}
2022-04-12 20:21:14.129640 fix syntax errors 3 ['#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\nCreated on Thu Jun 21 15:11:54 2018\n@author: kazuki.onodera\n"""\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n\n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n\n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n\n    # use dijkstra\'s algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float(\'inf\')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n\n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n\n    print(len(output))\n    for op in output:\n        print(\' \'.join([str(x) for x in op]))\n\nif __name__ == \'__main__\':\n    main()\n', "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node containing the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:  # v = node, w = weight\n            if dist[v] > dist[u] + w:  # if the distance to reach v is greater than the distance to reach u + the weight of the edge from u to v\n                dist[v] = dist[u] + w  # update the distance to reach v\n                q.append(v)  # add v to the queue\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node containing the smallest value can be found by starting from the node containing the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:  # while the current node is not the first node\n        for v, w in adj_list[curr_node]:  # v = node, w = weight\n            if dist[curr_node] == dist[v] + w:  # if the distance to reach curr_node is equal to the distance to reach v + the weight of the edge from v to curr_node\n                if w > 0:  # if the weight of the edge from v to curr_node is positive\n                    output.append((1, curr_node + 1, v + 1))  # add a move command to the output\n                else:  # if the weight of the edge from v to curr_node is negative\n                    output.append((2, curr_node + 1, v + 1))  # add a reverse command to the output\n                curr_node = v  # update curr_node\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:21:17.917403 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649794874,
  "object": "edit"
}
2022-04-12 20:21:17.917689 fix syntax errors 3 ["\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use Dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-12 20:21:17.917781 size on output set 5
2022-04-12 20:21:17.917800 num operations 2
2022-04-12 20:21:17.917819 size on input set 1
2022-04-12 20:21:19.552131 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 1,
      "text": "\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 2,
      "text": "\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    }
  ],
  "created": 1649794877,
  "object": "edit"
}
2022-04-12 20:21:19.552310 fix spelling mistakes 3 ['\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n']
2022-04-12 20:21:19.552340 size on output set 1
2022-04-12 20:21:19.552346 size on input set 1
2022-04-12 20:21:32.177289 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 1,
      "text": "\n\nt = int(input())\na = list(map(int, input().split()))\nc = 0\nfor i in range(1, t-1):\n    if a[i] < a[i-1]:\n        a[i] = a[i] + abs(a[i]-a[i-1])\n        print(1, i+1, i)\n        c += 1\n    elif a[i] < a[i+1]:\n        a[i] = a[i] + abs(a[i]-a[i+1])\n        print(1, i+1, i+2)\n        c += 1\n    elif a[i] > a[i-1]:\n        a[i] = a[i] - abs(a[i]-a[i-1])\n        print(2, i+1, i)\n        c += 1\n    elif a[i] > a[i+1]:\n        a[i] = a[i] - abs(a[i]-a[i+1])\n        print(2, i+1, i+2)\n        c += 1\nprint(c) \n"
    },
    {
      "index": 2,
      "text": "\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i,sep=\" \")\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2,sep=\" \")\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i,sep=\" \")\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2,sep=\" \")\n        c+=1\nprint(c)\n"
    }
  ],
  "created": 1649794879,
  "object": "edit"
}
2022-04-12 20:21:32.177534 fix syntax errors 3 ['\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\nt = int(input())\na = list(map(int, input().split()))\nc = 0\nfor i in range(1, t-1):\n    if a[i] < a[i-1]:\n        a[i] = a[i] + abs(a[i]-a[i-1])\n        print(1, i+1, i)\n        c += 1\n    elif a[i] < a[i+1]:\n        a[i] = a[i] + abs(a[i]-a[i+1])\n        print(1, i+1, i+2)\n        c += 1\n    elif a[i] > a[i-1]:\n        a[i] = a[i] - abs(a[i]-a[i-1])\n        print(2, i+1, i)\n        c += 1\n    elif a[i] > a[i+1]:\n        a[i] = a[i] - abs(a[i]-a[i+1])\n        print(2, i+1, i+2)\n        c += 1\nprint(c) \n', '\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i,sep=" ")\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2,sep=" ")\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i,sep=" ")\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2,sep=" ")\n        c+=1\nprint(c)\n']
2022-04-12 20:21:32.177571 size on output set 3
