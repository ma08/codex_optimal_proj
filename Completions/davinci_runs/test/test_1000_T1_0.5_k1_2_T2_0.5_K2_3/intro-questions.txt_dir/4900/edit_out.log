2022-04-13 06:25:57.857345 num operations 2
2022-04-13 06:25:57.857374 size on input set 1
2022-04-13 06:26:02.692374 fix spelling mistakes {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "index": 1,
      "text": "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649831158,
  "object": "edit"
}
2022-04-13 06:26:02.692656 NO RESULT
2022-04-13 06:26:02.692669 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-13 06:26:02.692731 fix spelling mistakes 2 ['\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 06:26:02.692887 size on output set 2
2022-04-13 06:26:02.692901 size on input set 2
2022-04-13 06:26:14.915846 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, node):\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, x, y):\n        for node in self.nodes:\n            if node.x == x and node.y == y:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.x, node.y, end=\" \")\n        for child in node.children:\n            print(child.x, child.y, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0])\n        mst.add_node(min_edge[1])\n        mst.add_edge(mst.get_node(min_edge[0].x, min_edge[0].y), mst.get_node(min_edge[1].x, min_edge[1].y))\n    return mst\n\ndef main():\n    n = int(input(\"Enter number of nodes: \"))\n    graph = Graph()\n    for node in range(n):\n        x = int(input(\"Enter x coordinate: \"))\n        y = int(input(\"Enter y coordinate: \"))\n        graph.add_node(Node(x, y))\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node_at(i), graph.get_node_at(j))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    #input number of nodes\n    n = int(input())\n    #create graph\n    graph = Graph()\n    #add nodes to graph\n    for node in range(n):\n        graph.add_node(node+1)\n    #add edges to graph\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    #get mst\n    mst = prims(graph)\n    #print mst\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649831162,
  "object": "edit"
}
2022-04-13 06:26:14.916036 fix syntax errors 3 ['#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, node):\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, x, y):\n        for node in self.nodes:\n            if node.x == x and node.y == y:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.x, node.y, end=" ")\n        for child in node.children:\n            print(child.x, child.y, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0])\n        mst.add_node(min_edge[1])\n        mst.add_edge(mst.get_node(min_edge[0].x, min_edge[0].y), mst.get_node(min_edge[1].x, min_edge[1].y))\n    return mst\n\ndef main():\n    n = int(input("Enter number of nodes: "))\n    graph = Graph()\n    for node in range(n):\n        x = int(input("Enter x coordinate: "))\n        y = int(input("Enter y coordinate: "))\n        graph.add_node(Node(x, y))\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node_at(i), graph.get_node_at(j))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    #input number of nodes\n    n = int(input())\n    #create graph\n    graph = Graph()\n    #add nodes to graph\n    for node in range(n):\n        graph.add_node(node+1)\n    #add edges to graph\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    #get mst\n    mst = prims(graph)\n    #print mst\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 06:26:17.491215 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val)\n        for child in node.children:\n            print(child.val)\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649831174,
  "object": "edit"
}
2022-04-13 06:26:17.491414 fix syntax errors 3 ['\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', 'import math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val)\n        for child in node.children:\n            print(child.val)\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-13 06:26:17.491584 size on output set 6
2022-04-13 06:26:17.491597 num operations 2
2022-04-13 06:26:17.491602 size on input set 1
2022-04-13 06:26:33.359877 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float(\"inf\")\n        min_edge = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831177,
  "object": "edit"
}
2022-04-13 06:26:33.360073 fix spelling mistakes 3 ['\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float("inf")\n        min_edge = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 06:26:33.360226 size on output set 3
2022-04-13 06:26:33.360234 size on input set 3
2022-04-13 06:26:47.613563 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v, w)\n    # where u and v are the vertices that the edge connects\n    # and w is the weight of the edge\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # read in the number of vertices\n    n = int(input()) \n\n    # read in the distances between each pair of vertices\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # the set of vertices that have been visited\n    visited = set() \n\n    # the set of vertices that have not been visited\n    not_visited = set([i for i in range(n)]) \n\n    # the set of edges that have been visited\n    edges = [] \n\n    current_vertex = 0 \n\n    while len(not_visited) > 0:\n        visited.add(current_vertex) \n        not_visited.remove(current_vertex) \n\n        min_distance = float(\"inf\") \n        min_vertex = None \n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        if min_vertex is not None:\n            visited.add(min_vertex) \n            not_visited.remove(min_vertex) \n            edges.append((current_vertex, min_vertex))\n\n        current_vertex = min_vertex \n\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1) \n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831193,
  "object": "edit"
}
2022-04-13 06:26:47.613747 fix syntax errors 3 ["\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v, w)\n    # where u and v are the vertices that the edge connects\n    # and w is the weight of the edge\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of vertices\n    n = int(input()) \n\n    # read in the distances between each pair of vertices\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # the set of vertices that have been visited\n    visited = set() \n\n    # the set of vertices that have not been visited\n    not_visited = set([i for i in range(n)]) \n\n    # the set of edges that have been visited\n    edges = [] \n\n    current_vertex = 0 \n\n    while len(not_visited) > 0:\n        visited.add(current_vertex) \n        not_visited.remove(current_vertex) \n\n        min_distance = float("inf") \n        min_vertex = None \n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        if min_vertex is not None:\n            visited.add(min_vertex) \n            not_visited.remove(min_vertex) \n            edges.append((current_vertex, min_vertex))\n\n        current_vertex = min_vertex \n\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1) \n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 06:26:54.707439 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if weights[current_vertex][vertex] < min_weight:\n                min_weight = weights[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_vertex = None\n        min_distance = float(\"inf\")\n        min_edge = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float(\"inf\")\n        min_edge = None\n        for vertex in not_visited:\n            if weights[current_vertex][vertex] < min_weight:\n                min_weight = weights[current_vertex][vertex]\n                min_edge = (current_vertex, vertex)\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_edge is not None:\n            visited.add(min_edge[1])\n            not_visited.remove(min_edge[1])\n            edges.append(min_edge)\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831207,
  "object": "edit"
}
2022-04-13 06:26:54.707728 fix syntax errors 3 ['\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if weights[current_vertex][vertex] < min_weight:\n                min_weight = weights[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_vertex = None\n        min_distance = float("inf")\n        min_edge = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float("inf")\n        min_edge = None\n        for vertex in not_visited:\n            if weights[current_vertex][vertex] < min_weight:\n                min_weight = weights[current_vertex][vertex]\n                min_edge = (current_vertex, vertex)\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_edge is not None:\n            visited.add(min_edge[1])\n            not_visited.remove(min_edge[1])\n            edges.append(min_edge)\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 06:26:57.521386 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    # read in the number of villages\n    n = int(raw_input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in raw_input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    print(edges)\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831214,
  "object": "edit"
}
2022-04-13 06:26:57.521653 fix syntax errors 3 ['\ndef main():\n    # read in the number of villages\n    n = int(raw_input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in raw_input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    print(edges)\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-13 06:26:57.521737 size on output set 9
2022-04-13 06:26:57.521749 num operations 2
2022-04-13 06:26:57.521754 size on input set 1
2022-04-13 06:27:00.975980 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n)\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n#\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    }
  ],
  "created": 1649831217,
  "object": "edit"
}
2022-04-13 06:27:00.976242 fix spelling mistakes 3 ['\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n)\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', '\n#\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', '#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n']
2022-04-13 06:27:00.976281 size on output set 3
2022-04-13 06:27:00.976288 size on input set 3
2022-04-13 06:27:06.488707 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if distances[i][j] == 1 and distances[i][j] == distances[j][i]:\n                print(str(i + 1) + \" \" + str(j + 1))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    p = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(p):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        if distances[a - 1][b - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(input().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, input().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    }
  ],
  "created": 1649831221,
  "object": "edit"
}
2022-04-13 06:27:06.488875 fix syntax errors 3 ['#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if distances[i][j] == 1 and distances[i][j] == distances[j][i]:\n                print(str(i + 1) + " " + str(j + 1))\n\nmain()\n', "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    p = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(p):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        if distances[a - 1][b - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n\nmain()\n", '#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(input().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, input().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n']
2022-04-13 06:27:08.937295 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n# floyd warshall\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1, sep=' ', end=' ')\n    print()\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    }
  ],
  "created": 1649831226,
  "object": "edit"
}
2022-04-13 06:27:08.937564 fix syntax errors 3 ['import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', "\n# floyd warshall\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1, sep=' ', end=' ')\n    print()\n\nmain()\n", '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n']
2022-04-13 06:27:10.912041 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    }
  ],
  "created": 1649831228,
  "object": "edit"
}
2022-04-13 06:27:10.912215 fix syntax errors 3 ['\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', '\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n']
2022-04-13 06:27:10.912251 size on output set 8
2022-04-13 06:27:10.912263 num operations 2
2022-04-13 06:27:10.912268 size on input set 1
2022-04-13 06:27:12.618417 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    }
  ],
  "created": 1649831230,
  "object": "edit"
}
2022-04-13 06:27:12.618653 fix spelling mistakes 3 ['\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', 'import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n']
2022-04-13 06:27:12.618693 size on output set 3
2022-04-13 06:27:12.618699 size on input set 3
2022-04-13 06:27:15.780491 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print(i + 1, j + 1)\n                return\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    }
  ],
  "created": 1649831232,
  "object": "edit"
}
2022-04-13 06:27:15.780676 fix syntax errors 3 ['\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print(i + 1, j + 1)\n                return\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n']
2022-04-13 06:27:18.688712 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print('{} {}'.format(i + 1, j + 1))\n                return\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print(i + 1, j + 1)\n                return\n\nmain()\n"
    }
  ],
  "created": 1649831235,
  "object": "edit"
}
2022-04-13 06:27:18.688968 fix syntax errors 3 ["import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print('{} {}'.format(i + 1, j + 1))\n                return\n\nmain()\n", 'import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', 'import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print(i + 1, j + 1)\n                return\n\nmain()\n']
2022-04-13 06:27:21.912091 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0] * n] * n\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    }
  ],
  "created": 1649831238,
  "object": "edit"
}
2022-04-13 06:27:21.912276 fix syntax errors 3 ['\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0] * n] * n\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', 'import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n']
2022-04-13 06:27:21.912313 size on output set 9
2022-04-13 06:27:21.912333 num operations 2
2022-04-13 06:27:21.912338 size on input set 1
2022-04-13 06:27:23.707322 fix spelling mistakes {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning treee\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    }
  ],
  "created": 1649831241,
  "object": "edit"
}
2022-04-13 06:27:23.707548 NO RESULT
2022-04-13 06:27:23.707555 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-13 06:27:23.707591 fix spelling mistakes 2 ["\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n", "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning treee\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"]
2022-04-13 06:27:23.707620 size on output set 2
2022-04-13 06:27:23.707625 size on input set 2
2022-04-13 06:27:25.292610 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n"
    }
  ],
  "created": 1649831243,
  "object": "edit"
}
2022-04-13 06:27:25.292794 fix syntax errors 3 ["\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n"]
2022-04-13 06:27:27.250645 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning treee\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    }
  ],
  "created": 1649831245,
  "object": "edit"
}
2022-04-13 06:27:27.250900 fix syntax errors 3 ["\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning treee\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"]
2022-04-13 06:27:27.250939 size on output set 3
2022-04-13 06:27:27.250949 num operations 2
2022-04-13 06:27:27.250954 size on input set 1
2022-04-13 06:27:29.765493 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831247,
  "object": "edit"
}
2022-04-13 06:27:29.765677 fix spelling mistakes 3 ["\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:27:29.765824 size on output set 3
2022-04-13 06:27:29.765833 size on input set 3
2022-04-13 06:27:51.361245 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\nimport sys, itertools\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i, j, k in itertools.combinations(range(n), 3):\n        if distances[i][j] == distances[i][k] + distances[k][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n        if distances[i][j] == distances[i][k] - distances[j][k]:\n            print(i+1, j+1)\n            print(k+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] == distances[k][j] - distances[i][k]:\n            print(i+1, k+1)\n            print(i+1, j+1)\n            print(k+1, j+1)\n            return\n        if distances[i][j] + distances[i][k] == distances[j][k]:\n            print(j+1, k+1)\n            print(i+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] + distances[k][j] == distances[i][k]:\n            print(i+1, k+1)\n            print(j+1, k+1)\n            print(i+1, j+1)\n            return\n        if distances[i][k] + distances[j][k] == distances[i][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#import sys\n\n#def main():\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append(list(map(int, sys.stdin.readline().split())))\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            if distances[i][j] == distances[i][k] + distances[k][j]:\n                print(i+1, j+1)\n                print(i+1, k+1)\n                print(j+1, k+1)\n                return\n            if distances[i][j] == distances[i][k] - distances[j][k]:\n                print(i+1, j+1)\n                print(k+1, j+1)\n                print(i+1, k+1)\n                return\n            if distances[i][j] == distances[k][j] - distances[i][k]:\n                print(i+1, k+1)\n                print(i+1, j+1)\n                print(k+1, j+1)\n                return\n            if distances[i][j] + distances[i][k] == distances[j][k]:\n                print(j+1, k+1)\n                print(i+1, j+1)\n                print(i+1, k+1)\n                return\n            if distances[i][j] + distances[k][j] == distances[i][k]:\n                print(i+1, k+1)\n                print(j+1, k+1)\n                print(i+1, j+1)\n                return\n            if distances[i][k] + distances[j][k] == distances[i][j]:\n                print(i+1, j+1)\n                print(i+1, k+1)\n                print(j+1, k+1)\n                return\n\n#if __name__ == '__main__':\n#    main()\n"
    },
    {
      "index": 2,
      "text": "import sys, math\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i*n+j] == distances[i*n+k] + distances[k*n+j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i*n+j] == distances[i*n+k] - distances[j*n+k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i*n+j] == distances[k*n+j] - distances[i*n+k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i*n+j] + distances[i*n+k] == distances[j*n+k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i*n+j] + distances[k*n+j] == distances[i*n+k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i*n+k] + distances[j*n+k] == distances[i*n+j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831249,
  "object": "edit"
}
2022-04-13 06:27:51.361458 fix syntax errors 3 ["\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\nimport sys, itertools\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i, j, k in itertools.combinations(range(n), 3):\n        if distances[i][j] == distances[i][k] + distances[k][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n        if distances[i][j] == distances[i][k] - distances[j][k]:\n            print(i+1, j+1)\n            print(k+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] == distances[k][j] - distances[i][k]:\n            print(i+1, k+1)\n            print(i+1, j+1)\n            print(k+1, j+1)\n            return\n        if distances[i][j] + distances[i][k] == distances[j][k]:\n            print(j+1, k+1)\n            print(i+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] + distances[k][j] == distances[i][k]:\n            print(i+1, k+1)\n            print(j+1, k+1)\n            print(i+1, j+1)\n            return\n        if distances[i][k] + distances[j][k] == distances[i][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n\nif __name__ == '__main__':\n    main()\n", "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#import sys\n\n#def main():\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append(list(map(int, sys.stdin.readline().split())))\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            if distances[i][j] == distances[i][k] + distances[k][j]:\n                print(i+1, j+1)\n                print(i+1, k+1)\n                print(j+1, k+1)\n                return\n            if distances[i][j] == distances[i][k] - distances[j][k]:\n                print(i+1, j+1)\n                print(k+1, j+1)\n                print(i+1, k+1)\n                return\n            if distances[i][j] == distances[k][j] - distances[i][k]:\n                print(i+1, k+1)\n                print(i+1, j+1)\n                print(k+1, j+1)\n                return\n            if distances[i][j] + distances[i][k] == distances[j][k]:\n                print(j+1, k+1)\n                print(i+1, j+1)\n                print(i+1, k+1)\n                return\n            if distances[i][j] + distances[k][j] == distances[i][k]:\n                print(i+1, k+1)\n                print(j+1, k+1)\n                print(i+1, j+1)\n                return\n            if distances[i][k] + distances[j][k] == distances[i][j]:\n                print(i+1, j+1)\n                print(i+1, k+1)\n                print(j+1, k+1)\n                return\n\n#if __name__ == '__main__':\n#    main()\n", "import sys, math\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i*n+j] == distances[i*n+k] + distances[k*n+j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i*n+j] == distances[i*n+k] - distances[j*n+k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i*n+j] == distances[k*n+j] - distances[i*n+k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i*n+j] + distances[i*n+k] == distances[j*n+k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i*n+j] + distances[k*n+j] == distances[i*n+k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i*n+k] + distances[j*n+k] == distances[i*n+j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:09.687590 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                elif distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    print(i+1, k+1)\n                    return\n                elif distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    return\n                elif distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                elif distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                elif distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1, i+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nfrom itertools import combinations\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i, j, k in combinations(range(n), 3):\n        if distances[i][j] == distances[i][k] + distances[k][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n        if distances[i][j] == distances[i][k] - distances[j][k]:\n            print(i+1, j+1)\n            print(k+1, i+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] == distances[k][j] - distances[i][k]:\n            print(i+1, k+1)\n            print(i+1, j+1)\n            print(k+1, i+1)\n            return\n        if distances[i][j] + distances[i][k] == distances[j][k]:\n            print(j+1, k+1)\n            print(i+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] + distances[k][j] == distances[i][k]:\n            print(i+1, k+1)\n            print(j+1, k+1)\n            print(i+1, j+1)\n            return\n        if distances[i][k] + distances[j][k] == distances[i][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831271,
  "object": "edit"
}
2022-04-13 06:28:09.687879 fix syntax errors 3 ["\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                elif distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    print(i+1, k+1)\n                    return\n                elif distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    return\n                elif distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                elif distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                elif distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1, i+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\nfrom itertools import combinations\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i, j, k in combinations(range(n), 3):\n        if distances[i][j] == distances[i][k] + distances[k][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n        if distances[i][j] == distances[i][k] - distances[j][k]:\n            print(i+1, j+1)\n            print(k+1, i+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] == distances[k][j] - distances[i][k]:\n            print(i+1, k+1)\n            print(i+1, j+1)\n            print(k+1, i+1)\n            return\n        if distances[i][j] + distances[i][k] == distances[j][k]:\n            print(j+1, k+1)\n            print(i+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] + distances[k][j] == distances[i][k]:\n            print(i+1, k+1)\n            print(j+1, k+1)\n            print(i+1, j+1)\n            return\n        if distances[i][k] + distances[j][k] == distances[i][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:20.779543 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    ans = [i+1, j+1, i+1, k+1, j+1, k+1]\n                    break\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    ans = [i+1, j+1, k+1, j+1, i+1, k+1]\n                    break\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831289,
  "object": "edit"
}
2022-04-13 06:28:20.779729 fix syntax errors 3 ["import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    ans = [i+1, j+1, i+1, k+1, j+1, k+1]\n                    break\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    ans = [i+1, j+1, k+1, j+1, i+1, k+1]\n                    break\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:20.779842 size on output set 8
2022-04-13 06:28:20.779855 num operations 2
2022-04-13 06:28:20.779859 size on input set 1
2022-04-13 06:28:22.753156 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(j+1, i+1)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1649831300,
  "object": "edit"
}
2022-04-13 06:28:22.753411 fix spelling mistakes 3 ["\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(j+1, i+1)\n\nif __name__ == '__main__':\n\tmain()\n", "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n", "\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-13 06:28:22.753445 size on output set 3
2022-04-13 06:28:22.753452 size on input set 3
2022-04-13 06:28:27.900047 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1 and i < j:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(j+1, i+1) \n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(j+1, i+1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831302,
  "object": "edit"
}
2022-04-13 06:28:27.900222 fix syntax errors 3 ["\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1 and i < j:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n", "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(j+1, i+1) \n\nif __name__ == '__main__':\n\tmain()\n", "\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(j+1, i+1)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:33.583508 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "def main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "def main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1649831307,
  "object": "edit"
}
2022-04-13 06:28:33.583677 fix syntax errors 3 ["def main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", 'def main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == "__main__":\n    main()\n', "\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-13 06:28:38.438062 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1, end=' ')\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n#! /usr/bin/python3\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 0:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1649831313,
  "object": "edit"
}
2022-04-13 06:28:38.438231 fix syntax errors 3 ["\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1, end=' ')\n\nif __name__ == '__main__':\n\tmain()\n", "\n#! /usr/bin/python3\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 0:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-13 06:28:38.438340 size on output set 9
2022-04-13 06:28:38.438358 num operations 2
2022-04-13 06:28:38.438363 size on input set 1
2022-04-13 06:28:41.285510 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831318,
  "object": "edit"
}
2022-04-13 06:28:41.285685 fix spelling mistakes 3 ["\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:41.285720 size on output set 3
2022-04-13 06:28:41.285726 size on input set 3
2022-04-13 06:28:45.049316 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831321,
  "object": "edit"
}
2022-04-13 06:28:45.049543 fix syntax errors 3 ["\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:49.516716 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [[int(i) for i in sys.stdin.readline().split()] for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i + 1))\n        villages[i][i+1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831325,
  "object": "edit"
}
2022-04-13 06:28:49.516920 fix syntax errors 3 ["\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [[int(i) for i in sys.stdin.readline().split()] for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i + 1))\n        villages[i][i+1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:53.462579 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split()))\n                for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i + 1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649831329,
  "object": "edit"
}
2022-04-13 06:28:53.462756 fix syntax errors 3 ["\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split()))\n                for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i + 1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-13 06:28:53.462794 size on output set 9
