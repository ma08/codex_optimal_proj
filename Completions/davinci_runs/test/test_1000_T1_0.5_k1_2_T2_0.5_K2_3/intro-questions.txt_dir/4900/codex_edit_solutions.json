["\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1 and i < j:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n", "\n#! /usr/bin/python3\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 0:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n", "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_vertex = None\n        min_distance = float(\"inf\")\n        min_edge = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [[int(i) for i in sys.stdin.readline().split()] for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i + 1))\n        villages[i][i+1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # and w is the weight of the edge\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v, w)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if weights[current_vertex][vertex] < min_weight:\n                min_weight = weights[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning treee\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    p = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(p):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        if distances[a - 1][b - 1] == 1:\n            print('YES')\n        else:\n            print('NO')\n\nmain()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print(i + 1, j + 1)\n                return\n\nmain()\n", "\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree.\nfor road in mst:\n    print(road[0], road[1])\n", "\n\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split()))\n                for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i + 1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    print(edges)\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print('{} {}'.format(i + 1, j + 1))\n                return\n\nmain()\n", "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#import sys\n\n#def main():\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append(list(map(int, sys.stdin.readline().split())))\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            if distances[i][j] == distances[i][k] + distances[k][j]:\n                print(i+1, j+1)\n                print(i+1, k+1)\n                print(j+1, k+1)\n                return\n            if distances[i][j] == distances[i][k] - distances[j][k]:\n                print(i+1, j+1)\n                print(k+1, j+1)\n                print(i+1, k+1)\n                return\n            if distances[i][j] == distances[k][j] - distances[i][k]:\n                print(i+1, k+1)\n                print(i+1, j+1)\n                print(k+1, j+1)\n                return\n            if distances[i][j] + distances[i][k] == distances[j][k]:\n                print(j+1, k+1)\n                print(i+1, j+1)\n                print(i+1, k+1)\n                return\n            if distances[i][j] + distances[k][j] == distances[i][k]:\n                print(i+1, k+1)\n                print(j+1, k+1)\n                print(i+1, j+1)\n                return\n            if distances[i][k] + distances[j][k] == distances[i][j]:\n                print(i+1, j+1)\n                print(i+1, k+1)\n                print(j+1, k+1)\n                return\n\n#if __name__ == '__main__':\n#    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\n\ndef main():\n    # read in the number of vertices\n    n = int(input()) \n\n    # read in the distances between each pair of vertices\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # the set of vertices that have been visited\n    visited = set() \n\n    # the set of vertices that have not been visited\n    not_visited = set([i for i in range(n)]) \n\n    # the set of edges that have been visited\n    edges = [] \n\n    current_vertex = 0 \n\n    while len(not_visited) > 0:\n        visited.add(current_vertex) \n        not_visited.remove(current_vertex) \n\n        min_distance = float(\"inf\") \n        min_vertex = None \n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        if min_vertex is not None:\n            visited.add(min_vertex) \n            not_visited.remove(min_vertex) \n            edges.append((current_vertex, min_vertex))\n\n        current_vertex = min_vertex \n\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1) \n\nif __name__ == '__main__':\n    main()\n", "\nfrom itertools import combinations\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i, j, k in combinations(range(n), 3):\n        if distances[i][j] == distances[i][k] + distances[k][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n        if distances[i][j] == distances[i][k] - distances[j][k]:\n            print(i+1, j+1)\n            print(k+1, i+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] == distances[k][j] - distances[i][k]:\n            print(i+1, k+1)\n            print(i+1, j+1)\n            print(k+1, i+1)\n            return\n        if distances[i][j] + distances[i][k] == distances[j][k]:\n            print(j+1, k+1)\n            print(i+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] + distances[k][j] == distances[i][k]:\n            print(i+1, k+1)\n            print(j+1, k+1)\n            print(i+1, j+1)\n            return\n        if distances[i][k] + distances[j][k] == distances[i][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(j+1, i+1)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print(i + 1, j + 1)\n                return\n\nmain()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if distances[i][j] == 1 and distances[i][j] == distances[j][i]:\n                print(str(i + 1) + \" \" + str(j + 1))\n\nmain()\n", "\n# floyd warshall\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1, sep=' ', end=' ')\n    print()\n\nmain()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    ans = [i+1, j+1, i+1, k+1, j+1, k+1]\n                    break\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    ans = [i+1, j+1, k+1, j+1, i+1, k+1]\n                    break\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n", "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(input().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, input().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n", "\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(j+1, i+1) \n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0] * n] * n\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n", "\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    #input number of nodes\n    n = int(input())\n    #create graph\n    graph = Graph()\n    #add nodes to graph\n    for node in range(n):\n        graph.add_node(node+1)\n    #add edges to graph\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    #get mst\n    mst = prims(graph)\n    #print mst\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                elif distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    print(i+1, k+1)\n                    return\n                elif distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, i+1)\n                    return\n                elif distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                elif distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                elif distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    # read in the number of villages\n    n = int(raw_input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in raw_input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n", "\n#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited so far\n    visited = set()\n\n    # the set of vertices that have not been visited so far\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys, math\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n        for j in range(n):\n            for k in range(n): \n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k]) \n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n", "import math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1, i+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "import sys, math\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i*n+j] == distances[i*n+k] + distances[k*n+j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i*n+j] == distances[i*n+k] - distances[j*n+k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i*n+j] == distances[k*n+j] - distances[i*n+k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i*n+j] + distances[i*n+k] == distances[j*n+k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i*n+j] + distances[k*n+j] == distances[i*n+k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i*n+k] + distances[j*n+k] == distances[i*n+j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", "\n#! /usr/bin/python3\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1, end=' ')\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val)\n        for child in node.children:\n            print(child.val)\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n", "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the weight of each edge\n    weights = []\n    for i in range(n):\n        weights.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that are in the minimum spanning tree\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet, and add it to the MST\n        min_weight = float(\"inf\")\n        min_edge = None\n        for vertex in not_visited:\n            if weights[current_vertex][vertex] < min_weight:\n                min_weight = weights[current_vertex][vertex]\n                min_edge = (current_vertex, vertex)\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_edge is not None:\n            visited.add(min_edge[1])\n            not_visited.remove(min_edge[1])\n            edges.append(min_edge)\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v, w)\n    # where u and v are the vertices that the edge connects\n    # and w is the weight of the edge\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # pre-process dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n", "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\nimport sys, itertools\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i, j, k in itertools.combinations(range(n), 3):\n        if distances[i][j] == distances[i][k] + distances[k][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n        if distances[i][j] == distances[i][k] - distances[j][k]:\n            print(i+1, j+1)\n            print(k+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] == distances[k][j] - distances[i][k]:\n            print(i+1, k+1)\n            print(i+1, j+1)\n            print(k+1, j+1)\n            return\n        if distances[i][j] + distances[i][k] == distances[j][k]:\n            print(j+1, k+1)\n            print(i+1, j+1)\n            print(i+1, k+1)\n            return\n        if distances[i][j] + distances[k][j] == distances[i][k]:\n            print(i+1, k+1)\n            print(j+1, k+1)\n            print(i+1, j+1)\n            return\n        if distances[i][k] + distances[j][k] == distances[i][j]:\n            print(i+1, j+1)\n            print(i+1, k+1)\n            print(j+1, k+1)\n            return\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "#prims algorithm\nimport math\n\nclass Node:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, node):\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, x, y):\n        for node in self.nodes:\n            if node.x == x and node.y == y:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.x, node.y, end=\" \")\n        for child in node.children:\n            print(child.x, child.y, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0])\n        mst.add_node(min_edge[1])\n        mst.add_edge(mst.get_node(min_edge[0].x, min_edge[0].y), mst.get_node(min_edge[1].x, min_edge[1].y))\n    return mst\n\ndef main():\n    n = int(input(\"Enter number of nodes: \"))\n    graph = Graph()\n    for node in range(n):\n        x = int(input(\"Enter x coordinate: \"))\n        y = int(input(\"Enter y coordinate: \"))\n        graph.add_node(Node(x, y))\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node_at(i), graph.get_node_at(j))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"]