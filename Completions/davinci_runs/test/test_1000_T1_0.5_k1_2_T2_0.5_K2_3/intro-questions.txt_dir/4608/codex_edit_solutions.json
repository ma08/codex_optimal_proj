["\n\nimport collections\nimport sys\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = collections.deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # \ud0d0\uc0c9 \uc885\ub8cc \uc870\uac74\n        print(visited[num] - 1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num - 1] - 1] = visited[num] + 1\n        queue.append(a[num - 1])\n\nprint(-1)\n", "\nimport sys\n\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\nvisited = [0] * N\nvisited[0] = 1\nqueue = deque([0])\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n", "\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # \ud0d0\uc0c9 \uc885\ub8cc\n        print(visited[num] - 1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n", "\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1] - 1]:\n        visited[a[num-1] - 1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n", "\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == N:  # \ud0d0\uc0c9 \uc885\ub8cc\n        print(visited[num]-1)  # \ucc98\uc74c\uc5d0 \ubc29\ubb38\ud55c 1\uc740 \uc81c\uc678\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n", "\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n", "\n\nimport heapq\nimport sys\n\n\ndef dijkstra(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    que = [(0, start)]\n    while que:\n        dist, v = heapq.heappop(que)\n        if d[v] < dist:\n            continue\n        for nv, nc in g[v]:\n            if d[nv] > d[v] + nc:\n                d[nv] = d[v] + nc\n                heapq.heappush(que, (d[nv], nv))\n    return d\n\n\ndef warshall_floyd(g):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n    return g\n\n\ndef bellman_ford(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    for i in range(N):\n        update = False\n        for u in range(N):\n            if d[u] == float('inf'):\n                continue\n            for v, cost in g[u]:\n                if d[v] > d[u] + cost:\n                    d[v] = d[u] + cost\n                    update = True\n        if not update:\n            break\n    return d\n\n\ndef kruskal():\n    es = sorted(g, key=lambda x: x[2])\n    uf = UnionFind(N)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.unite(e[0], e[1])\n            res += e[2]\n    return res\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.p[x] = y\n        else:\n            self.p[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\nvisited = [False] * N\nqueue = deque([1])\n\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1] and a[num-1] != num:\n        visited[a[num-1]-1] = visited[num-1] + 1\n        queue.append(a[num-1]-1)\n\nprint(-1)\n", "from collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\nvisited = [False] * N\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"]