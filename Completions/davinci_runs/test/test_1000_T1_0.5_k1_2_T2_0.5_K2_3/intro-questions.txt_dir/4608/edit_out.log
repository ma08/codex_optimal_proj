2022-04-12 22:40:19.096370 num operations 2
2022-04-12 22:40:19.096382 size on input set 1
2022-04-12 22:40:38.994962 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # \ud0d0\uc0c9 \uc885\ub8cc\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\nimport sys\n\n\ndef dijkstra(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    que = [(0, start)]\n    while que:\n        dist, v = heapq.heappop(que)\n        if d[v] < dist:\n            continue\n        for nv, nc in g[v]:\n            if d[nv] > d[v] + nc:\n                d[nv] = d[v] + nc\n                heapq.heappush(que, (d[nv], nv))\n    return d\n\n\ndef warshall_floyd(g):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n    return g\n\n\ndef bellman_ford(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    for i in range(N):\n        update = False\n        for u in range(N):\n            if d[u] == float('inf'):\n                continue\n            for v, cost in g[u]:\n                if d[v] > d[u] + cost:\n                    d[v] = d[u] + cost\n                    update = True\n        if not update:\n            break\n    return d\n\n\ndef kruskal():\n    es = sorted(g, key=lambda x: x[2])\n    uf = UnionFind(N)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.unite(e[0], e[1])\n            res += e[2]\n    return res\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.p[x] = y\n        else:\n            self.p[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    }
  ],
  "created": 1649803219,
  "object": "edit"
}
2022-04-12 22:40:38.995236 fix spelling mistakes 3 ['\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', '\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # 탐색 종료\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # 방문하지 않았을 때\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', "\n\nimport heapq\nimport sys\n\n\ndef dijkstra(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    que = [(0, start)]\n    while que:\n        dist, v = heapq.heappop(que)\n        if d[v] < dist:\n            continue\n        for nv, nc in g[v]:\n            if d[nv] > d[v] + nc:\n                d[nv] = d[v] + nc\n                heapq.heappush(que, (d[nv], nv))\n    return d\n\n\ndef warshall_floyd(g):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n    return g\n\n\ndef bellman_ford(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    for i in range(N):\n        update = False\n        for u in range(N):\n            if d[u] == float('inf'):\n                continue\n            for v, cost in g[u]:\n                if d[v] > d[u] + cost:\n                    d[v] = d[u] + cost\n                    update = True\n        if not update:\n            break\n    return d\n\n\ndef kruskal():\n    es = sorted(g, key=lambda x: x[2])\n    uf = UnionFind(N)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.unite(e[0], e[1])\n            res += e[2]\n    return res\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.p[x] = y\n        else:\n            self.p[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"]
2022-04-12 22:40:38.995302 size on output set 3
2022-04-12 22:40:38.995309 size on input set 3
2022-04-12 22:40:42.418577 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1] - 1]:\n        visited[a[num-1] - 1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    }
  ],
  "created": 1649803239,
  "object": "edit"
}
2022-04-12 22:40:42.418842 fix syntax errors 3 ['\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', '\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', '\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num])\n        sys.exit()\n    if not visited[a[num-1] - 1]:\n        visited[a[num-1] - 1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n']
2022-04-12 22:41:02.629031 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\nvisited = [False] * N\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\nvisited = [0] * N\nvisited[0] = 1\nqueue = deque([0])\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\nimport sys\n\n\ndef dijkstra(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    que = [(0, start)]\n    while que:\n        dist, v = heapq.heappop(que)\n        if d[v] < dist:\n            continue\n        for nv, nc in g[v]:\n            if d[nv] > d[v] + nc:\n                d[nv] = d[v] + nc\n                heapq.heappush(que, (d[nv], nv))\n    return d\n\n\ndef warshall_floyd(g):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n    return g\n\n\ndef bellman_ford(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    for i in range(N):\n        update = False\n        for u in range(N):\n            if d[u] == float('inf'):\n                continue\n            for v, cost in g[u]:\n                if d[v] > d[u] + cost:\n                    d[v] = d[u] + cost\n                    update = True\n        if not update:\n            break\n    return d\n\n\ndef kruskal():\n    es = sorted(g, key=lambda x: x[2])\n    uf = UnionFind(N)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.unite(e[0], e[1])\n            res += e[2]\n    return res\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.p[x] = y\n        else:\n            self.p[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\nvisited = [False] * N\nqueue = deque([1])\n\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1] and a[num-1] != num:\n        visited[a[num-1]-1] = visited[num-1] + 1\n        queue.append(a[num-1]-1)\n\nprint(-1)\n"
    }
  ],
  "created": 1649803242,
  "object": "edit"
}
2022-04-12 22:41:02.629254 fix syntax errors 3 ['from collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\nvisited = [False] * N\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', '\nimport sys\n\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\nvisited = [0] * N\nvisited[0] = 1\nqueue = deque([0])\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1]:\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', "\n\nimport heapq\nimport sys\n\n\ndef dijkstra(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    que = [(0, start)]\n    while que:\n        dist, v = heapq.heappop(que)\n        if d[v] < dist:\n            continue\n        for nv, nc in g[v]:\n            if d[nv] > d[v] + nc:\n                d[nv] = d[v] + nc\n                heapq.heappush(que, (d[nv], nv))\n    return d\n\n\ndef warshall_floyd(g):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n    return g\n\n\ndef bellman_ford(start):\n    d = [float('inf')] * N\n    d[start] = 0\n    for i in range(N):\n        update = False\n        for u in range(N):\n            if d[u] == float('inf'):\n                continue\n            for v, cost in g[u]:\n                if d[v] > d[u] + cost:\n                    d[v] = d[u] + cost\n                    update = True\n        if not update:\n            break\n    return d\n\n\ndef kruskal():\n    es = sorted(g, key=lambda x: x[2])\n    uf = UnionFind(N)\n    res = 0\n    for e in es:\n        if not uf.same(e[0], e[1]):\n            uf.unite(e[0], e[1])\n            res += e[2]\n    return res\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.p[x] == x:\n            return x\n        else:\n            self.p[x] = self.find(self.p[x])\n            return self.p[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.p[x] = y\n        else:\n            self.p[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\ng = [[] for _ in range(N)]\nvisited = [False] * N\nqueue = deque([1])\n\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:\n        print(visited[num]-1)\n        sys.exit()\n    if not visited[a[num-1]-1] and a[num-1] != num:\n        visited[a[num-1]-1] = visited[num-1] + 1\n        queue.append(a[num-1]-1)\n\nprint(-1)\n"]
2022-04-12 22:41:07.603696 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport collections\nimport sys\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = collections.deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # \ud0d0\uc0c9 \uc885\ub8cc \uc870\uac74\n        print(visited[num] - 1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num - 1] - 1] = visited[num] + 1\n        queue.append(a[num - 1])\n\nprint(-1)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # \ud0d0\uc0c9 \uc885\ub8cc\n        print(visited[num] - 1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == N:  # \ud0d0\uc0c9 \uc885\ub8cc\n        print(visited[num]-1)  # \ucc98\uc74c\uc5d0 \ubc29\ubb38\ud55c 1\uc740 \uc81c\uc678\n        sys.exit()\n    if not visited[a[num-1]-1]:  # \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n"
    }
  ],
  "created": 1649803262,
  "object": "edit"
}
2022-04-12 22:41:07.603971 fix syntax errors 3 ['\n\nimport collections\nimport sys\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = collections.deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # 탐색 종료 조건\n        print(visited[num] - 1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # 방문하지 않았을 때\n        visited[a[num - 1] - 1] = visited[num] + 1\n        queue.append(a[num - 1])\n\nprint(-1)\n', '\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == 2:  # 탐색 종료\n        print(visited[num] - 1)\n        sys.exit()\n    if not visited[a[num-1]-1]:  # 방문하지 않았을 때\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n', '\n\nimport sys\nfrom collections import deque\n\nN = int(input())\na = list(map(int, sys.stdin.read().split()))\n\n# BFS(Breadth First Search)\nqueue = deque([1])\nvisited = [False] * N\nvisited[0] = True\n\nwhile len(queue) > 0:\n    num = queue.popleft()\n    if num == N:  # 탐색 종료\n        print(visited[num]-1)  # 처음에 방문한 1은 제외\n        sys.exit()\n    if not visited[a[num-1]-1]:  # 방문하지 않았을 때\n        visited[a[num-1]-1] = visited[num] + 1\n        queue.append(a[num-1])\n\nprint(-1)\n']
2022-04-12 22:41:07.604014 size on output set 8
