["\n\n# SOLUTION\n# The problem can be solved with the greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized. \n# The time complexity is O(n^2), which is the size of the board\n\nt = int(input())\n\nfor i in range(t):\n    n = int(input())\n\n    print(n * (n // 2) ** 2)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef get_input():\n    t = int(raw_input())\n    for i in range(t):\n        n = int(raw_input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n\n    if n == 1:\n        print(0)\n    else:\n        print((n - 1)**2)\n", "\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * (n - 1)\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\n# solution\n# the problem can be solved with a greedy algorithm.\n# the idea is to start from the center and move the figures to the closest cells.\n# if the center is not empty, we can move the figures in the center to the closest empty cells\n# and then move the figures in the closest empty cells to the center.\n# we can repeat the process until all the figures are in the center.\n# because we move the figures to the closest cells, the number of moves is minimized.\n# the time complexity is O(n^2), which is the size of the board.\n\nT = int(input())\n\nfor _ in range(T):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells\n# If the center is not empty, we can move the figures in the center to the closest cells and then move the figures in the closest cells to the center\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest empty cells\n# and then move the figures in the closest empty cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n\ndef getInput():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in getInput():\n        print(solve(n))\n", "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * (n - 1)\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\n# SOLUTION\n# The problem can be solved with the greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center\n# We can repeat the process until all the figures are in the center\n# Because we move the figures to the closest cells, the number of moves is minimized \n# The time complexity is O(n^2), which is the size of the board\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center\n# Because we move the figures to the closest cells, the number of moves is minimized\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n", "\n\n# SOLUTION\n# The problem can be solved with the greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized. \n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2) \n", "\n\ndef get_input():\n    t = int(input())  # read a line with a single integer\n    for i in range(t):\n        n = int(input())  # read a list of integers, 2 in this case\n\n        yield n  # use keyword yield instead of return in functions\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) ** 2\n\n\nif __name__ == '__main__':\n    for n in get_input():  # read input and call solve for each test case\n        print(solve(n))\n", "\n\n# SOLUTION\n# The problem can be solved with dynamic programming.\n# Let f(n) be the number of moves to solve the problem for a board of size n x n.\n# f(n) = f(n - 2) + 4, for n > 2, because the last two rows and the last two columns\n# can be solved in four moves.\n# f(n) = 0, for n = 0 or n = 2, because the board is already solved.\n# The time complexity is O(n), which is the number of moves.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    dp = [0, 0, 0]\n    for i in range(3, n + 1):\n        dp.append(dp[i - 2] + 4)\n    print(dp[n])\n", "\ndef get_input():\n    t = int(input().strip())\n    for i in range(t):\n        n = int(input().strip())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * n\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"]