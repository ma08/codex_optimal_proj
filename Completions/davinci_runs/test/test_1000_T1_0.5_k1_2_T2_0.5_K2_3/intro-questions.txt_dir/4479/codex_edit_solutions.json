["import heapq\nfrom typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)\n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            num = heapq.heappop(A) * -1  # O(logN)\n            heapq.heappush(A, num)\n        return sum(A)\n", "# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n", "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n", "from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n", "import heapq\nfrom typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int: \n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n", "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)  \n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n        return sum(A)\n", "import heapq\n\n\nclass Solution(object):\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n", "\"\"\"\nLeetcode 1005\n\"\"\"\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n", "from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n", "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        for i in range(len(A)):\n            if A[i] < 0 and K > 0:\n                A[i] = -A[i]\n                K -= 1\n            elif A[i] > 0 and K % 2 != 0:\n                A[i] = -A[i]\n                break\n        return sum(A)\n        return sum(A)\n", "class Solution:\n    def minSwapsCouples(self, row: List[int]) -> int:\n        N = len(row)\n        pos = {v: i for i, v in enumerate(row)}\n\n\n        ans = 0\n        for i in range(0, N, 2):\n            x = row[i]\n            if x % 2 == 0:\n                y = x + 1\n            else:\n                y = x - 1\n            j = pos[y]\n\n            if j - i == 1:\n                continue\n\n            ans += 1\n            row[i + 1], row[j] = row[j], row[i + 1]\n            pos[row[i + 1]] = i + 1\n            pos[row[j]] = j\n        return ans\n", "class Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n", "def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n    A.sort()\n    i = 0\n    while K > 0 and i < len(A):\n        if A[i] < 0:\n            A[i] = -A[i]\n            K -= 1\n            i += 1\n        else:\n            break\n    if K > 0 and K % 2 == 1:\n        A.sort()\n        A[0] = -A[0]\n    return sum(A)\n", "def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n    heapq.heapify(A)  # O(N)\n\n\n    # time complexity: O(N + KlogN)\n    for _ in range(K):\n        heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n    return sum(A)\n"]