["class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        \n        i = 0\n        while A[i] < 0 and K > 0:\n            A[i] *= -1\n            i += 1\n            K -= 1\n            \n        if K % 2 == 1 and 0 not in A:\n            return sum(A) - 2*min(A)\n        return sum(A)\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i=0\n        while(i<len(A) and A[i]<0 and i<K):\n            A[i]=-A[i]\n            i+=1\n        \n        return sum(A)-(K - i) % 2 * min(A) * 2", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        S=0\n        negs=[]\n        posmin=100\n        negmax=-100\n        for i in range(len(A)):\n            S+=A[i]\n            if A[i]<0:\n                negs.append(A[i])\n                negmax=max(negmax,A[i])\n            else:\n                posmin=min(posmin,A[i])\n        if K is 0:\n            return(S)\n        negs.sort()\n        if K <= len(negs):\n            return(S-2*sum(negs[:K]))\n        elif (K - len(negs))%2 is 0:\n            return(S-2*sum(negs[:K]))\n        elif posmin<-negmax:\n            return(S-2*sum(negs[:K])-2*posmin)\n        else:\n            return(S-2*sum(negs[:K])+2*negmax)", "class Solution(object):\n    def largestSumAfterKNegations(self, A, K):\n        lst = sorted(A)\n        count = K\n        i = 0\n        while count>0:\n            if lst[i] <= lst[i + 1]:\n                lst[i] = lst[i] * -1\n                count -= 1\n            else:\n                i += 1\n        return sum(lst)\n", "import heapq\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heapreplace(A, -A[0])\n        return sum(A)\n        \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        p = 0\n        while A[p] < 0:\n            A[p] = - A[p]\n            p += 1\n            K -= 1\n            if K == 0:\n                 return sum(A)\n        if K % 2 == 0:\n            return sum(A)\n        else:\n            return sum(A) - 2 * min(A[p], A[p-1])", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        #heapify is in place algo so take linear time\n        for x in range(K):\n            #if x %2 :\n                #heappreplace(A, -A[0])\n            #heappush(A, -heapq.heappop(A))\n            heapreplace(A, -A[0])\n        return sum(A)\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], k: int) -> int:\n        d = collections.defaultdict(int)\n        for x in A:\n            d[x] += 1\n        \n        res = 0\n        for i in range(-100, 0):\n            if i in d and k > 0:\n                x = min(k, d[i])\n                k -= x\n                d[i] -= x\n                d[-i] += x\n            \n        res = 0\n        if k % 2 == 1:\n            j = 0\n            while j not in d or d[j] <= 0:\n                j += 1\n            print(j)\n            d[j] -= 1\n            d[-j] += 1\n        for i in range(-100, 101):\n            res += d[i] * i\n        return res\n        \n            \n                \n                    \n            \n\n                \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        res = 0\n        A.sort()\n        i = 0\n        while i < len(A) and i < K and A[i] < 0:\n            A[i] = -A[i]\n            i += 1\n\n        return sum(A) - (K - i) % 2 * 2 * min(A[i-1:i] + A[i:i+1])\n            \n        \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        for i in range(K):\n          A.sort()\n          A[0] = -A[0]\n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        result = 0\n        count = 0\n        A.sort()\n       \n        if A[0] > 0:\n            if K%2 == 1:\n                A[0] = -A[0]\n            for i in A:\n                result += i\n            return(result)\n        elif A[0] == 0:\n            for i in A:\n                result += i\n            return(result)\n        else:\n            for j in range (len(A)):\n                if A[j] >= 0:\n                    break\n                else:\n                    count += 1\n            ra = K%count\n            if K < count:\n                for m in range(K):\n                    A[m] = -A[m]\n            else:\n                for m in range(count):\n                    A[m] = -A[m]\n                K -= count\n                A.sort()\n                if K%2 == 1:\n                    A[0] = -A[0]\n            for i in A:\n                result += i\n            \n            return(result)", "class Solution:\n    import heapq\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for i in range(K):\n            m = heapq.heappop(A)\n            heapq.heappush(A, -m)\n        return sum(A)\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        newA = sorted(A)\n        print(newA)\n        count = 0\n        for i in range(K):\n            newA[0] = -newA[0]\n            newA = sorted(newA)\n        print(newA)\n        return sum(newA)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        B = sorted(A)\n        for i in range(K):\n            B[0] = -B[0]\n            B = sorted(B)\n        return sum(B)", "class Solution:\n    def largestSumAfterKNegations(self, arr: List[int], k: int) -> int:\n        ra = k\n        arr.sort()\n        for _ in range(ra):\n            for j in range(len(arr)):\n                if arr[j] < 0:\n                    arr[j] = abs(arr[j])\n                    k -= 1\n                    arr.sort()\n                    break\n                elif arr[j] == 0:\n                    return sum(arr)\n                else:\n                    if k % 2 == 0:\n                        return sum(arr)\n                    else:\n                        arr.sort()\n                        arr[0] = -arr[0]\n                        return sum(arr)\n\n        return sum(arr)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        while K > 0:\n            t = A.index(min(A))\n            if A[t] < 0:\n                A[t] = abs(A[t])\n                K -= 1\n                continue\n            if A[t] == 0:\n                K = 0\n                continue\n            if A[t] > 0:\n                if K % 2 == 0:\n                    K = 0\n                    continue\n                else:\n                    A[t] = -A[t]\n                    K = 0\n                    continue\n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        for x in range(K):\n            minNum=A.index(min(A))\n            A[minNum]=A[minNum]*(-1)\n        return sum(A)\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        for i in range(K):\n            variable = min(A)\n            A.remove(variable)\n            A.append(variable*-1)\n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        for i in range(K):\n            \n            val = min(A)\n        \n            A.remove(val)\n            A.append(-1 * val)\n                                \n        return sum(A)\n                \n               \n", "# 5:47 -> 5:50 slowwww\n# Seems greedy: pick smallest number and flip it\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        while K:\n            m = min(A)\n            m_i = A.index(m)\n            A[m_i] = -m\n            K -= 1\n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n\n        for i in range(K):\n            min_ = min(A)\n            idx = A.index(min_)\n            A[idx] = -A[idx]\n            max_ = sum(A)\n        return max_\n            \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        a1 =A\n        sum1 =0\n        while K > 0 :\n            mina = min(a1)\n            a1.remove(mina)\n            a1.append(mina * (-1))\n            K -=1\n            \n    \n        \n        return sum(a1)\n        \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        for i in range(K):\n            A[0] = -1 * A[0]\n            if A[0] > A[1]:\n                A.append(A.pop(0))\n        return sum(A)        ", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        cur = sum(A)\n        for i in range(K):\n           # max_ = sum(A)\n            min_ = min(A)\n            idx = A.index(min_)\n            A[idx] = -A[idx]\n            max_ = sum(A)\n        return max_\n            \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        max_sum = -999999\n        for _ in range(K):\n            A = sorted(A)\n            min_index = A.index(min(A))\n            \n            A[min_index] = -A[min_index]\n\n            max_ = sum(A)\n            # print(max_)\n            # max_sum = max(max_sum, max_)\n        return max_", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        while K > 0:\n            min_index = A.index(min(A))\n            A[min_index] = - A[min_index]\n            K = K - 1\n        \n        return sum(A)\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        for i in range(K):\n            \n            val = min(A)\n            \n            #if val <= 0:\n            A.remove(val)\n            A.append(-1 * val)\n                \n           \n                \n        return sum(A)\n                \n               \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        while K != 0:\n            A[A.index(min(A))] = -min(A)\n            K -= 1\n        return(sum(A))\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        c = 0\n        \n        while c < K:\n            c += 1\n            min_ = min(A)\n            index = A.index(min_)\n            A[index] = -1 * min_\n        \n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        while K>0:\n            K-=1\n            A[A.index(min(A))]=-min(A)\n        return sum(A)", "class Solution:\n    import heapq\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        ## find the min element and its index and negate it K times\n        \n        ## Complexity = O(kn)\n        \n#         def findMin(A):\n#             minValue = float('inf')\n#             minIndex = 0\n\n#             for i, ele in enumerate(A):\n#                 if ele < minValue:\n#                     minValue = ele\n#                     minIndex = i\n            \n#             return minIndex\n\n#         for k in range(K):\n#             minIndex = findMin(A)\n#             A[minIndex] = -A[minIndex]\n            \n        \n        ### using min heap\n        \n        heapq.heapify(A)\n        for k in range(K):\n            A[0] = -A[0]\n            heapq.heapify(A)\n        \n        return sum(A)\n    \n    ### let's do with heap, no need to pop just negate that element\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        for i in range(K) :\n            check = min(A)\n            t = A.index(check)\n            A[t] = -A[t]\n        \n        return sum(A)\n            \n        \n        \n        \n        \n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        for i in range(K):\n            A[A.index(min(A))] *= -1\n            \n        return sum(A)\n", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        \n        if not A: return sum(A)\n        \n        if K == 0: return sum(A)\n        \n        \n        for i in range(K):\n    \n            A[A.index(min(A))] = - A[A.index(min(A))]\n        \n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        if not A:\n            return sum(A)\n        if K==0:\n            return sum(A)\n        for i in range(K):\n            A[A.index(min(A))] = -A[A.index(min(A))]\n        return sum(A)\n", "# 5:47 ->\n# Seems greedy: pick smallest number and flip it\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        if K == 0:\n            return sum(A)\n        m = min(A)\n        m_i = A.index(m)\n        A[m_i] = -m\n        return self.largestSumAfterKNegations(A, K - 1)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        for item in A :\n            if item < 0 and K > 1:\n                A[A.index(item)] = item * (-1)\n                K-= 1\n            elif item > 0 and K >= 2:\n                K-=2\n        else:\n            A.sort()\n            while K != 0:\n                K -=1\n                A[0] = A[0] * (-1)\n        return sum(A)", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        for i in range(K):\n            A[0] = -1 * A[0]\n            if A[0] > 0:\n                A.sort()\n        return sum(A)        ", "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        for i in range(K):\n            A.sort()\n            A[0] = -A[0]\n        \n        return sum(A)", "\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        ans = sum(A)\n        A.sort()\n        \n        for i in range(len(A)):\n            if not K or A[i]==0:\n                break\n            if A[i]<0:\n                ans -= 2*A[i]\n                K-=1\n            else:\n                if K%2:\n                    if i and A[i]>abs(A[i-1]):\n                        ans += 2*A[i-1]\n                    else:\n                        ans -= 2*A[i]\n                break\n                    \n        return ans"]