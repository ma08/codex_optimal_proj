2022-04-12 21:13:04.960317 num operations 2
2022-04-12 21:13:04.960326 size on input set 1
2022-04-12 21:13:06.719474 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    }
  ],
  "created": 1649797985,
  "object": "edit"
}
2022-04-12 21:13:06.719686 fix spelling mistakes 3 ['class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', '# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', '\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n']
2022-04-12 21:13:06.719715 size on output set 3
2022-04-12 21:13:06.719721 size on input set 3
2022-04-12 21:13:12.668462 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "class Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n    A.sort()\n    i = 0\n    while K > 0 and i < len(A):\n        if A[i] < 0:\n            A[i] = -A[i]\n            K -= 1\n            i += 1\n        else:\n            break\n    if K > 0 and K % 2 == 1:\n        A.sort()\n        A[0] = -A[0]\n    return sum(A)\n"
    }
  ],
  "created": 1649797986,
  "object": "edit"
}
2022-04-12 21:13:12.668641 fix syntax errors 3 ['class Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n    A.sort()\n    i = 0\n    while K > 0 and i < len(A):\n        if A[i] < 0:\n            A[i] = -A[i]\n            K -= 1\n            i += 1\n        else:\n            break\n    if K > 0 and K % 2 == 1:\n        A.sort()\n        A[0] = -A[0]\n    return sum(A)\n']
2022-04-12 21:13:15.093968 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    }
  ],
  "created": 1649797992,
  "object": "edit"
}
2022-04-12 21:13:15.094147 fix syntax errors 3 ['from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n']
2022-04-12 21:13:17.230538 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "\"\"\"\nLeetcode 1005\n\"\"\"\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    }
  ],
  "created": 1649797995,
  "object": "edit"
}
2022-04-12 21:13:17.230708 fix syntax errors 3 ['# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', '# Leetcode 1005\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', '"""\nLeetcode 1005\n"""\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n']
2022-04-12 21:13:17.230736 size on output set 6
2022-04-12 21:13:17.230745 num operations 2
2022-04-12 21:13:17.230750 size on input set 1
2022-04-12 21:13:20.675679 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)\n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int: \n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    }
  ],
  "created": 1649797997,
  "object": "edit"
}
2022-04-12 21:13:20.675858 fix spelling mistakes 3 ['import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)\n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int: \n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n']
2022-04-12 21:13:20.675884 size on output set 3
2022-04-12 21:13:20.675891 size on input set 3
2022-04-12 21:13:22.731450 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "import heapq\nfrom typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int: \n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    }
  ],
  "created": 1649798000,
  "object": "edit"
}
2022-04-12 21:13:22.731630 fix syntax errors 3 ['import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A, K):\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\nfrom typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int: \n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n']
2022-04-12 21:13:28.419927 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n    heapq.heapify(A)  # O(N)\n\n\n    # time complexity: O(N + KlogN)\n    for _ in range(K):\n        heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n    return sum(A)\n"
    },
    {
      "index": 1,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)  \n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "import heapq\nfrom typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)\n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            num = heapq.heappop(A) * -1  # O(logN)\n            heapq.heappush(A, num)\n        return sum(A)\n"
    }
  ],
  "created": 1649798002,
  "object": "edit"
}
2022-04-12 21:13:28.420098 fix syntax errors 3 ['def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n    heapq.heapify(A)  # O(N)\n\n\n    # time complexity: O(N + KlogN)\n    for _ in range(K):\n        heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n    return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)  \n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # O(logN)\n        return sum(A)\n', 'import heapq\nfrom typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)  # O(N)\n\n# time complexity: O(N + KlogN)\n        for _ in range(K):\n            num = heapq.heappop(A) * -1  # O(logN)\n            heapq.heappush(A, num)\n        return sum(A)\n']
2022-04-12 21:13:35.681303 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import heapq\n\n\nclass Solution(object):\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        for i in range(len(A)):\n            if A[i] < 0 and K > 0:\n                A[i] = -A[i]\n                K -= 1\n            elif A[i] > 0 and K % 2 != 0:\n                A[i] = -A[i]\n                break\n        return sum(A)\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "class Solution:\n    def minSwapsCouples(self, row: List[int]) -> int:\n        N = len(row)\n        pos = {v: i for i, v in enumerate(row)}\n\n\n        ans = 0\n        for i in range(0, N, 2):\n            x = row[i]\n            if x % 2 == 0:\n                y = x + 1\n            else:\n                y = x - 1\n            j = pos[y]\n\n            if j - i == 1:\n                continue\n\n            ans += 1\n            row[i + 1], row[j] = row[j], row[i + 1]\n            pos[row[i + 1]] = i + 1\n            pos[row[j]] = j\n        return ans\n"
    }
  ],
  "created": 1649798008,
  "object": "edit"
}
2022-04-12 21:13:35.681572 fix syntax errors 3 ['import heapq\n\n\nclass Solution(object):\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        for i in range(len(A)):\n            if A[i] < 0 and K > 0:\n                A[i] = -A[i]\n                K -= 1\n            elif A[i] > 0 and K % 2 != 0:\n                A[i] = -A[i]\n                break\n        return sum(A)\n        return sum(A)\n', 'class Solution:\n    def minSwapsCouples(self, row: List[int]) -> int:\n        N = len(row)\n        pos = {v: i for i, v in enumerate(row)}\n\n\n        ans = 0\n        for i in range(0, N, 2):\n            x = row[i]\n            if x % 2 == 0:\n                y = x + 1\n            else:\n                y = x - 1\n            j = pos[y]\n\n            if j - i == 1:\n                continue\n\n            ans += 1\n            row[i + 1], row[j] = row[j], row[i + 1]\n            pos[row[i + 1]] = i + 1\n            pos[row[j]] = j\n        return ans\n']
2022-04-12 21:13:35.681610 size on output set 8
