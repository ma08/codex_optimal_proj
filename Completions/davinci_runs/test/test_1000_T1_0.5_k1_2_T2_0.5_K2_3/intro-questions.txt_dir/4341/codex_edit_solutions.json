["\n\"\"\"\nhttps://www.geeksforgeeks.org/detect-cycle-undirected-graph/\n\"\"\"\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        cnt = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    cnt += 1\n        return cnt\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "print(\"Hello, world!\")\n", "\nimport sys\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph))\n        count = 0\n        for i in range(len(self.graph)):\n            if visited[i] == False:\n        return count\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n    def bfs(self, s):\n        visited = [False] * (len(self.graph))\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            s = queue.popleft()\n            print(s, end=\" \")\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef dfs(graph, start, visited):\n    visited.add(start)\n    for child in graph[start]:\n        if child not in visited: dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited, cycles = set(), 0\n\n    for node in graph:\n        if node not in visited: dfs(graph, node, visited); cycles += 1\n\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split()); graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m): v, u = map(int, sys.stdin.readline().split()); graph[v].append(u); graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "\n#!/bin/python3\nimport sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "#test\nimport sys\n\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import defaultdict\n\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] is False:\n                if self.isCycle(v, visited, u) is True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n    def cycle_undirected(self):\n        visited = [False] * (len(self.graph) + 1) # visited list\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                count += self.isCycle(i, visited, -1)\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        cnt = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    cnt += 1\n        return cnt\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "# import modules\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        cnt = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    cnt += 1\n        return cnt\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n"]