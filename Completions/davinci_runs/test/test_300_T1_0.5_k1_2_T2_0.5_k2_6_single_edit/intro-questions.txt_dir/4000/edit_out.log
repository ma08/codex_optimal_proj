2022-04-19 04:27:47.174187 num operations 1
2022-04-19 04:27:47.174197 size on input set 1
2022-04-19 04:28:10.719080 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a, b, c = i+1, j+1, k+1\n                pa, pb, pc = path(tree, a, b, c)\n                max_paths = max(max_paths, len(pa)+len(pb)+len(pc))\n                if max_paths == len(pa)+len(pb)+len(pc):\n                    ans = [a, b, c, len(pa), len(pb), len(pc)]\n    print(max_paths)\n    print(*ans, sep=' ')\n\ndef path(tree, a, b, c):\n    return find_path(tree, a, b), find_path(tree, b, c), find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())  # 1-indexed\n        tree[a-1].append(b-1)  # 0-indexed\n        tree[b-1].append(a-1)  # 0-indexed\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1  # 1-indexed\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n = int(input())\n    graph = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    for i in range(n):\n        graph[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(graph[i])):\n            for k in range(j+1, len(graph[i])):\n                a, b, c = i+1, graph[i][j]+1, graph[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(graph, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(graph, a, b, c, i):\n    if i == 0:\n        return find_path(graph, a, b)\n    elif i == 1:\n        return find_path(graph, b, c)\n    else:\n        return find_path(graph, a, c)\n\ndef find_path(graph, a, b):\n    q = [a-1]\n    visited = [False]*len(graph)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in graph[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = ans = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths): ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650342468,
  "object": "edit"
}
2022-04-19 04:28:10.719387 fix syntax errors 6 ['\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a, b, c = i+1, j+1, k+1\n                pa, pb, pc = path(tree, a, b, c)\n                max_paths = max(max_paths, len(pa)+len(pb)+len(pc))\n                if max_paths == len(pa)+len(pb)+len(pc):\n                    ans = [a, b, c, len(pa), len(pb), len(pc)]\n    print(max_paths)\n    print(*ans, sep=' ')\n\ndef path(tree, a, b, c):\n    return find_path(tree, a, b), find_path(tree, b, c), find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n", '\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())  # 1-indexed\n        tree[a-1].append(b-1)  # 0-indexed\n        tree[b-1].append(a-1)  # 0-indexed\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1  # 1-indexed\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    graph = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    for i in range(n):\n        graph[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(graph[i])):\n            for k in range(j+1, len(graph[i])):\n                a, b, c = i+1, graph[i][j]+1, graph[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(graph, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(graph, a, b, c, i):\n    if i == 0:\n        return find_path(graph, a, b)\n    elif i == 1:\n        return find_path(graph, b, c)\n    else:\n        return find_path(graph, a, c)\n\ndef find_path(graph, a, b):\n    q = [a-1]\n    visited = [False]*len(graph)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in graph[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = ans = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths): ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-19 04:28:10.719553 size on output set 5
2022-04-19 04:28:10.719567 num operations 1
2022-04-19 04:28:10.719573 size on input set 1
2022-04-19 04:28:37.928310 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nones_count = a.count(1)\nzeros_count = n - ones_count\n\nif zeros_count >= ones_count:\n    print(n - ones_count)\nelse:\n    print(zeros_count)\n"
    },
    {
      "index": 1,
      "text": "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for i in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())  # python 3\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree, max edge)\n    cnt = 1\n    edges = 0  # count of edges in subtree\n    max_edge = 0  # max edge from subtree\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 3,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 4,
      "text": "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    }
  ],
  "created": 1650342491,
  "object": "edit"
}
2022-04-19 04:28:37.928668 fix syntax errors 6 ['\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nones_count = a.count(1)\nzeros_count = n - ones_count\n\nif zeros_count >= ones_count:\n    print(n - ones_count)\nelse:\n    print(zeros_count)\n', 'import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for i in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())  # python 3\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree, max edge)\n    cnt = 1\n    edges = 0  # count of edges in subtree\n    max_edge = 0  # max edge from subtree\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '#!/usr/bin/env python3\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', 'import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n']
2022-04-19 04:28:37.928772 size on output set 5
