2022-04-19 04:29:20.409156 num operations 1
2022-04-19 04:29:20.409173 size on input set 1
2022-04-19 04:29:28.531980 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i <= r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        elif a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        else:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_max_subarray(a):\n    max_ending_here = max_so_far = 0\n    for x in a:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 2,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    i = 1\n    j = n-2\n    while i < j:\n        if a[i] > l[-1]:\n            l.append(a[i])\n            i += 1\n        if a[j] > r[-1]:\n            r.append(a[j])\n            j -= 1\n        if a[i] <= l[-1] and a[j] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 3,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 4,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    },
    {
      "index": 5,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i <= r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        elif a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        elif a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l))\n    else:\n        print(len(r))\n        print(\"R\"*len(r))\n"
    }
  ],
  "created": 1650342560,
  "object": "edit"
}
2022-04-19 04:29:28.532255 fix syntax errors 6 ['\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i <= r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        elif a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        else:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\n\ndef get_max_subarray(a):\n    max_ending_here = max_so_far = 0\n    for x in a:\n        max_ending_here = max(0, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    i = 1\n    j = n-2\n    while i < j:\n        if a[i] > l[-1]:\n            l.append(a[i])\n            i += 1\n        if a[j] > r[-1]:\n            r.append(a[j])\n            j -= 1\n        if a[i] <= l[-1] and a[j] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i <= r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        elif a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        elif a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l))\n    else:\n        print(len(r))\n        print("R"*len(r))\n']
2022-04-19 04:29:28.532309 size on output set 5
2022-04-19 04:29:28.532321 num operations 1
2022-04-19 04:29:28.532327 size on input set 1
2022-04-19 04:29:54.068642 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 1,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 2,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in d):\n\t\t\td[a[i]] -= 1\n\t\telse:\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in d):\n\t\t\td[a[n - i - 1]] -= 1\n\t\telse:\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 3,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (stack[-1] == a[i]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (stack[-1] == a[n - i - 1]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 4,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can remove the element from the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n    if (len(stack) == 0):\n        stack.append(a[i])\n        length += 1\n    elif (a[i] > stack[-1]):\n        stack.append(a[i])\n        length += 1\n    else:\n        while (len(stack) > 0 and a[i] <= stack[-1]):\n            stack.pop()\n        stack.append(a[i])\n        length += 1\n\nprint(length)\n\nfor i in range(length):\n    if (i < length / 2):\n        print(\"L\", end=\"\")\n    else:\n        print(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n    if (a[i] not in d):\n        d[a[i]] = 1\n    else:\n        d[a[i]] += 1\n\nfor i in range(n):\n    if (len(stack) == 0):\n        stack.append(a[i])\n        length += 1\n    elif (a[i] > stack[-1]):\n        stack.append(a[i])\n        length += 1\n    else:\n        while (len(stack) > 0 and a[i] <= stack[-1]):\n            stack.pop()\n        stack.append(a[i])\n        length += 1\n\nprint(length)\n\nfor i in range(length):\n    if (i < length / 2):\n        if (a[i] in stack):\n            stack.remove(a[i])\n        else:\n            d[a[i]] -= 1\n            stack.append(a[i])\n        print(\"L\", end=\"\")\n    else:\n        if (a[n - i - 1] in stack):\n            stack.remove(a[n - i - 1])\n        else:\n            d[a[n - i - 1]] -= 1\n            stack.append(a[n - i - 1])\n        print(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 5,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will have at most 1 element and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can decrease the number of occurences of the element in the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can decrease the number of occurences of the element in the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (stack[-1] == a[i]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (stack[-1] == a[n - i - 1]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    }
  ],
  "created": 1650342569,
  "object": "edit"
}
2022-04-19 04:29:54.080497 fix syntax errors 6 ['\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurrences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in d):\n\t\t\td[a[i]] -= 1\n\t\telse:\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in d):\n\t\t\td[a[n - i - 1]] -= 1\n\t\telse:\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (stack[-1] == a[i]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (stack[-1] == a[n - i - 1]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can remove the element from the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n    if (len(stack) == 0):\n        stack.append(a[i])\n        length += 1\n    elif (a[i] > stack[-1]):\n        stack.append(a[i])\n        length += 1\n    else:\n        while (len(stack) > 0 and a[i] <= stack[-1]):\n            stack.pop()\n        stack.append(a[i])\n        length += 1\n\nprint(length)\n\nfor i in range(length):\n    if (i < length / 2):\n        print("L", end="")\n    else:\n        print("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n    if (a[i] not in d):\n        d[a[i]] = 1\n    else:\n        d[a[i]] += 1\n\nfor i in range(n):\n    if (len(stack) == 0):\n        stack.append(a[i])\n        length += 1\n    elif (a[i] > stack[-1]):\n        stack.append(a[i])\n        length += 1\n    else:\n        while (len(stack) > 0 and a[i] <= stack[-1]):\n            stack.pop()\n        stack.append(a[i])\n        length += 1\n\nprint(length)\n\nfor i in range(length):\n    if (i < length / 2):\n        if (a[i] in stack):\n            stack.remove(a[i])\n        else:\n            d[a[i]] -= 1\n            stack.append(a[i])\n        print("L", end="")\n    else:\n        if (a[n - i - 1] in stack):\n            stack.remove(a[n - i - 1])\n        else:\n            d[a[n - i - 1]] -= 1\n            stack.append(a[n - i - 1])\n        print("R", end="")\n\nprint()\n', '\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\tthe stack will have at most 1 element and we can add the new element to the stack.\n# \tIf we take the last element from the left,\n# \t\tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# \tAfter that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# \tIf we take the last element from the right,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can decrease the number of occurences of the element in the dictionary and add it to the stack.\n# \tIf we take the last element from the left,\n# \t\twe can check if the element is in the stack.\n# \t\tIf it is, we can remove it from the stack.\n# \t\tOtherwise, we can decrease the number of occurences of the element in the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (stack[-1] == a[i]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (stack[-1] == a[n - i - 1]):\n\t\t\tstack.pop()\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n']
2022-04-19 04:29:54.080931 size on output set 6
