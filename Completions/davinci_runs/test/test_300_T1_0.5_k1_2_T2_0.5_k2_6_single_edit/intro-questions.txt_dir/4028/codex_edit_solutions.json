["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Jul  8 14:51:53 2018\n\n\n@author: kazuki.onodera\n\"\"\"\n\n\nimport numpy as np\nimport pandas as pd\nimport os\nfrom glob import glob\nfrom tqdm import tqdm\n\nimport sys\nsys.path.append(f'/home/{os.environ.get(\"USER\")}/PythonLibrary')\nimport lgbextension as ex\nimport lightgbm as lgb\nfrom multiprocessing import cpu_count\n\nfrom sklearn.model_selection import GroupKFold\nfrom sklearn.metrics import roc_auc_score\n\nimport utils\nutils.start(__file__)\n#==============================================================================\n\nSEED = np.random.randint(9999)\nprint('SEED:', SEED)\n\nNFOLD = 5\n\nLOOP = 5\n\nparam = {\n         'objective': 'binary',\n         'metric': 'auc',\n         'learning_rate': 0.01,\n         'max_depth': -1,\n         'num_leaves': 255,\n         'max_bin': 255,\n         'colsample_bytree': 0.5,\n         'subsample': 0.5,\n         'nthread': 32,\n         'bagging_freq': 1,\n#         'verbose':-1,\n         }\n\n\n# =============================================================================\n# load\n# =============================================================================\nX_train = pd.read_feather('../data/X_train.f')\ny_train = utils.read_pickles('../data/label').TARGET\n\n# =============================================================================\n# cv\n# =============================================================================\n\ngroup_kfold = GroupKFold(n_splits=NFOLD)\n\nmodels = []\nfor i in range(LOOP):\n    gc.collect()\n    param.update({'seed':np.random.randint(9999)})\n    model = lgb.LGBMClassifier(**param)\n    model.fit(X_train, y_train)\n    models.append(model)\n\ndel X_train, y_train; gc.collect()\n\n\"\"\"\n\nmodels = []\nfor i in range(LOOP):\n    gc.collect()\n    param.update({'seed':np.random.randint(9999)})\n    model = lgb.train(param, dtrain, len(X.columns),\n                      feval=ex.eval_auc,\n                      valid_names=['train','valid'],\n                      valid_sets=[dtrain, dvalid],\n                      verbose_eval=50,\n                      early_stopping_rounds=100)\n    models.append(model)\n\ndel dtrain, dvalid; gc.collect()\n\n\"\"\"\n\nimp = ex.getImp(models)\n\n\n# =============================================================================\n# test\n# =============================================================================\n\nfiles_te = sorted(glob('../data/test_f*.f'))\n\nX_test = pd.concat([\n                pd.read_feather(f) for f in tqdm(files_te, mininterval=60)\n               ], axis=1)\n\nfiles_te = sorted(glob('../feature_someone/test_f*.f'))\nX_test_ = pd.concat([\n                pd.read_feather(f) for f in tqdm(files_te, mininterval=60)\n               ], axis=1)\n\nX_test = pd.concat([X_test, X_test_], axis=1)\n\nsub = pd.read_pickle('../data/sub.p')\n\ngc.collect()\n\nlabel_name = 'TARGET'\n\nsub[label_name] = 0\nfor model in models:\n    y_pred = model.predict_proba(X_test)[:, 1]\n    sub[label_name] += pd.Series(y_pred).rank()\nsub[label_name] /= LOOP\nsub[label_name] /= sub[label_name].max()\nsub['SK_ID_CURR'] = sub['SK_ID_CURR'].map(int)\n\nsub.to_csv(SUBMIT_FILE_PATH, index=False, compression='gzip')\n\n# =============================================================================\n# submission\n# =============================================================================\nif EXE_SUBMIT:\n    print('submit')\n    utils.submit(SUBMIT_FILE_PATH, COMMENT)\n\n\n#==============================================================================\nutils.end(__file__)\n", "\nimport sys\nimport math\n\ndef main():\n    n = int(input())  # \u5165\u529b\n    s = input()  # \u5165\u529b\n    l = len(s)  # \u6587\u5b57\u5217\u306e\u9577\u3055\n    dp = [[0] * (n + 1) for i in range(l + 1)]  # DP\u30c6\u30fc\u30d6\u30eb\n    ans = 0  # \u7b54\u3048\n    for i in range(l):  # \u6700\u521d\u306e\u6587\u5b57\u304c(\u306a\u3089\u3070\n        if s[i] == '(':  # \u5de6\u7aef\u304c(\u306a\u3089\u3070\n            dp[i][0] = 1  # \u305d\u308c\u306f\u6709\u52b9\n    for i in range(l):  # \u6587\u5b57\u5217\u3092\u9806\u306b\u898b\u3066\u3044\u304f\n        for j in range(n):  # \u5de6\u7aef\u304b\u3089j\u500b\u306e(\u3092\u53d6\u3063\u3066\u3044\u308b\u72b6\u614b\n            if dp[i][j] == 0:  # 0\u306a\u3089\u3070\u6709\u52b9\u3067\u306f\u306a\u3044\u306e\u3067\u30b9\u30ad\u30c3\u30d7\n                continue  # \u30b9\u30ad\u30c3\u30d7\n            if s[i] == '(':  # (\u306a\u3089\u3070\n                dp[i + 1][j] += dp[i][j]  # \u6b21\u306e\u6587\u5b57\u5217\u3067j\u500b\u306e(\u3092\u53d6\u308b\n                dp[i + 1][j + 1] += dp[i][j]  # \u6b21\u306e\u6587\u5b57\u5217\u3067j+1\u500b\u306e(\u3092\u53d6\u308b\n            else:  # )\u306a\u3089\u3070\n                if j > 0:  # j\u304c0\u3067\u306a\u3044\u306a\u3089\u3070\n                    dp[i + 1][j - 1] += dp[i][j]  # \u6b21\u306e\u6587\u5b57\u5217\u3067j-1\u500b\u306e(\u3092\u53d6\u308b\n    for i in range(n + 1):  # \u5168\u3066\u306e\u6587\u5b57\u5217\u3067\n        ans += dp[l][i]  # \u5de6\u7aef\u304ci\u500b\u306e(\u3092\u53d6\u308b\u30d1\u30bf\u30fc\u30f3\u3092\u8db3\u3059\n    print(ans)  # \u8868\u793a\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nsys.setrecursionlimit(1000000)\n\nn = int(input())\ns = input()\n\nmemo = {}\n\ndef f(n, s):\n    # if s in memo:\n    #     return memo[s]\n    if len(s) == 2*n:\n        return 1\n    if len(s) > 2*n:\n        return 0\n    if len(s) == 0:\n        return 1\n    if len(s) == 1:\n        return 0\n    if s[0] == '(' and s[-1] == ')':\n        return f(n, s[1:-1])\n    if s[0] == ')':\n        return f(n, s[1:])\n    if s[-1] == '(':\n        return f(n, s[:-1])\n    return f(n, s[1:]) + f(n, s[:-1])\n\nprint(f(n, s) % 1000000007)\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(input())\n    s = input()\n    l = len(s)\n    dp = [[0] * (n+1) for _ in range(l+1)]\n    ans = 0\n    for i in range(l):\n        if s[i] == '(':\n            dp[i][0] = 1\n    for i in range(l):\n        for j in range(n):\n            if dp[i][j] == 0:\n                continue\n            if s[i] == '(':\n                dp[i+1][j] += dp[i][j]\n                dp[i+1][j+1] += dp[i][j]\n            else:\n                if j > 0:\n                    dp[i+1][j-1] += dp[i][j]\n    for i in range(n+1):\n        ans += dp[l][i]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(input())\n    s = input()\n    l = len(s)\n    dp = [[0] * (n + 1) for i in range(l + 1)]\n    ans = 0\n    for i in range(l):\n        if s[i] == '(':\n            dp[i][0] = 1\n    for i in range(l):\n        for j in range(n):\n            if dp[i][j] == 0:\n                continue\n            if s[i] == '(':\n                dp[i + 1][j] += dp[i][j]\n                dp[i + 1][j + 1] += dp[i][j]\n            else:\n                if j > 0:\n                    dp[i + 1][j - 1] += dp[i][j]\n    for i in range(n + 1):\n        ans += dp[l][i]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nn = int(input())\ns = input()\n\nmemo = {}\n\ndef f(n, s):\n    if s in memo:\n        return memo[s]\n    if len(s) == 2*n:\n        return 1\n    if len(s) > 2*n:\n        return 0\n    if len(s) == 0:\n        return 1\n    if len(s) == 1:\n        return 0\n    if s[0] == '(' and s[-1] == ')' and s.count('(') == s.count(')'):\n        return f(n, s[1:-1])\n    if s[0] == ')':\n        return f(n, s[1:])\n    if s[-1] == '(':\n        return f(n, s[:-1])\n    return f(n, s[1:]) + f(n, s[:-1])\n\nprint(f(n, s) % 1000000007)\n", "import sys\nimport math\n\ndef main():\n    n = int(input())\n    s = input()\n    l = len(s)\n    dp = [[0] * (n+1) for i in range(l+1)]\n    ans = 0\n    for i in range(l):\n        if s[i] == '(':\n            dp[i][0] = 1\n    for i in range(l):\n        for j in range(n):\n            if dp[i][j] == 0:\n                continue\n            if s[i] == '(':\n                dp[i+1][j] += dp[i][j]\n                dp[i+1][j+1] += dp[i][j]\n            else:\n                if j > 0:\n                    dp[i+1][j-1] += dp[i][j]\n    for i in range(n+1):\n        ans += dp[l][i]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "\nn = int(input())\ns = input()\n\nmemo = {}\n\ndef f(n, s):\n    if s in memo:\n        return memo[s]\n    if len(s) == 2*n:\n        return 1\n    if len(s) > 2*n:\n        return 0\n    if len(s) == 0:\n        return 1\n    if len(s) == 1:\n        return 0\n    if s[0] == '(' and s[-1] == ')':\n        return f(n, s[1:-1])\n    if s[0] == ')':\n        return f(n, s[1:])\n    if s[-1] == '(':\n        return f(n, s[:-1])\n    return f(n, s[1:]) + f(n, s[:-1])\n\nprint(f(n, s) % 1000000007)\n", "\n\nimport sys\nimport math\n\ndef main():\n    n = int(input())\n    s = input()\n    l = len(s)\n    dp = [[0] * (n+1) for i in range(l+1)]\n    mod = 10**9 + 7\n    ans = 0\n    for i in range(l):\n        if s[i] == '(':\n            dp[i][0] = 1\n    for i in range(l):\n        for j in range(n):\n            if dp[i][j] == 0:\n                continue\n            if s[i] == '(':\n                dp[i+1][j] += dp[i][j] % mod\n                dp[i+1][j+1] += dp[i][j] % mod\n            else:\n                if j > 0:\n                    dp[i+1][j-1] += dp[i][j] % mod\n    for i in range(n+1):\n        ans += dp[l][i]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "\nn = int(input())\ns = input()\n\nmemo = {'':1, '()':1}\n\ndef f(n, s):\n    if s in memo:\n        return memo[s]\n    if len(s) == 2*n:\n        return 1\n    if len(s) > 2*n:\n        return 0\n    if len(s) == 0:\n        return 1\n    if len(s) == 1:\n        return 0\n    if s[0] == s[-1]:\n        return f(n, s[1:-1])\n    if s[0] == ')': return f(n, s[1:])\n    if s[-1] == '(': return f(n, s[:-1])\n    return f(n, s[1:]) + f(n, s[:-1])\n\nprint(f(n, s) % 1000000007)\n", "\nimport sys\nimport math\n\ndef main():\n    n = int(input())\n    s = input()\n    l = len(s)\n    dp = [[0] * (n+1) for i in range(l+1)]\n    ans = 0\n    for i in range(l):\n        if s[i] == '(':\n            dp[i][0] = 1\n    for i in range(l):\n        for j in range(n):\n            if dp[i][j] == 0:\n                continue\n            if s[i] == '(':\n                dp[i+1][j] += dp[i][j]\n                dp[i+1][j+1] += dp[i][j]\n            else:\n                if j > 0:\n                    dp[i+1][j-1] += dp[i][j]\n    for i in range(n+1):\n        ans += dp[l][i]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "\nn = int(input())\ns = input()\n\n\ndef f(n, s):\n    if len(s) == 2 * n:\n        return 1\n    if len(s) > 2 * n:\n        return 0\n    if len(s) == 0:\n        return 1\n    if len(s) == 1:\n        return 0\n    if s[0] == '(' and s[-1] == ')':\n        return f(n, s[1:-1])\n    if s[0] == ')':\n        return f(n, s[1:])\n    if s[-1] == '(':\n        return f(n, s[:-1])\n    return f(n, s[1:]) + f(n, s[:-1])\n\nprint(f(n, s) % 1000000007)\n"]