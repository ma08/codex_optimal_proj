2022-04-19 04:40:31.201948 num operations 1
2022-04-19 04:40:31.201966 size on input set 1
2022-04-19 04:40:50.760821 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable([graph[c] for c in max_clique]))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "\nimport collections\nimport itertools\nimport sys\nimport typing\n\ndefaultdict = collections.defaultdict\nchain = itertools.chain\nstdin = sys.stdin\nstdout = sys.stdout\nList = typing.List\nDict = typing.Dict\nTuple = typing.Tuple\nSet = typing.Set\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & set(graph[v]), x & set(graph[v]))\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 3,
      "text": "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 2 * 10**5\nassert len(s) == n\nassert all(c in '01' for c in s)\n\ndef get_max_clique_size(s):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique_size\n        if len(p) == 0 and len(x) == 0:\n            max_clique_size = max(max_clique_size, len(r))\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    graph = defaultdict(set)\n    for i, c in enumerate(s):\n        graph[c].add(i)\n\n    max_clique_size = 0\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique_size\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\nmax_clique_size = get_max_clique_size(s)\n\nif max_clique_size <= 1 or is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join('0' if i < max_clique_size else '1' for i in range(n)))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 4,
      "text": "\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 5,
      "text": "\nfrom collections import defaultdict\nfrom itertools import chain\n\ndef read_input():\n    n = int(input())\n    s = input()\n    return n, s\n\ndef assert_valid(n, s):\n    assert 1 <= n <= 200\n    assert len(s) == n\n    assert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ndef main():\n    n, s = read_input()\n    assert_valid(n, s)\n    colors = get_colors(s)\n\n    if is_sorted_after_swap(s):\n        print(\"YES\")\n        print(''.join(colors))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650343231,
  "object": "edit"
}
2022-04-19 04:40:50.761185 fix syntax errors 6 ['\n\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable([graph[c] for c in max_clique]))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\nimport collections\nimport itertools\nimport sys\nimport typing\n\ndefaultdict = collections.defaultdict\nchain = itertools.chain\nstdin = sys.stdin\nstdout = sys.stdout\nList = typing.List\nDict = typing.Dict\nTuple = typing.Tuple\nSet = typing.Set\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & set(graph[v]), x & set(graph[v]))\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 2 * 10**5\nassert len(s) == n\nassert all(c in \'01\' for c in s)\n\ndef get_max_clique_size(s):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique_size\n        if len(p) == 0 and len(x) == 0:\n            max_clique_size = max(max_clique_size, len(r))\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    graph = defaultdict(set)\n    for i, c in enumerate(s):\n        graph[c].add(i)\n\n    max_clique_size = 0\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique_size\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\nmax_clique_size = get_max_clique_size(s)\n\nif max_clique_size <= 1 or is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(\'0\' if i < max_clique_size else \'1\' for i in range(n)))\nelse:\n    print("NO")\n', '\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\nfrom collections import defaultdict\nfrom itertools import chain\n\ndef read_input():\n    n = int(input())\n    s = input()\n    return n, s\n\ndef assert_valid(n, s):\n    assert 1 <= n <= 200\n    assert len(s) == n\n    assert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ndef main():\n    n, s = read_input()\n    assert_valid(n, s)\n    colors = get_colors(s)\n\n    if is_sorted_after_swap(s):\n        print("YES")\n        print(\'\'.join(colors))\n    else:\n        print("NO")\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-19 04:40:50.761301 size on output set 5
2022-04-19 04:40:50.761311 num operations 1
2022-04-19 04:40:50.761317 size on input set 1
2022-04-19 04:40:58.595006 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print ('YES')\n    print ('0' * n)\nelse:\n    print ('YES')\n    print (solve(s))\n"
    },
    {
      "index": 1,
      "text": "\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport math\na,b,c = map(int, input().split())\nprint(\"YES\" if math.sqrt((a-b)**2+(b-c)**2+(c-a)**2)==a+b+c else \"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print ('YES')\n    print ('0' * n)\nelse:\n    print ('YES')\n    print (solve(s))\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print(solve(s))\n"
    }
  ],
  "created": 1650343250,
  "object": "edit"
}
2022-04-19 04:40:58.595296 fix syntax errors 6 ["\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print ('YES')\n    print ('0' * n)\nelse:\n    print ('YES')\n    print (solve(s))\n", '\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport math\na,b,c = map(int, input().split())\nprint("YES" if math.sqrt((a-b)**2+(b-c)**2+(c-a)**2)==a+b+c else "NO")\n', "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print ('YES')\n    print ('0' * n)\nelse:\n    print ('YES')\n    print (solve(s))\n", "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print(solve(s))\n"]
2022-04-19 04:40:58.595338 size on output set 6
