2022-04-22 16:43:18.320262 num operations 2
2022-04-22 16:43:18.320272 size on input set 1
2022-04-22 16:43:18.320389 using api key jaanu
2022-04-22 16:43:28.613920 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                path_lengths = [0]*3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650645799,
  "object": "edit"
}
2022-04-22 16:43:28.614211 fix spelling mistakes 3 ['\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                path_lengths = [0]*3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-22 16:43:28.614344 size on output set 3
2022-04-22 16:43:28.614356 size on input set 3
2022-04-22 16:43:28.614496 using api key sunu
2022-04-22 16:43:45.372604 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l)) - 1\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans, sep=' ')\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650645809,
  "object": "edit"
}
2022-04-22 16:43:45.372970 fix syntax errors 3 ['\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l)) - 1\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans, sep=' ')\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n", '\n\ndef main():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0] * 3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-22 16:43:45.373362 using api key soukgp
2022-04-22 16:43:53.671852 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i, tree[i][j], tree[i][k]\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650645826,
  "object": "edit"
}
2022-04-22 16:43:53.672123 fix syntax errors 3 ['\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i, tree[i][j], tree[i][k]\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(paths))\n                if max_path == sum(paths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-22 16:43:53.672366 using api key derek
2022-04-22 16:44:09.594816 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                path_lengths = [0]*3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j + 1, len(tree[i])):\n                a, b, c = i + 1, tree[i][j] + 1, tree[i][k] + 1\n                path_lengths = [0] * 3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a - 1]\n    visited = [False] * len(tree)\n    visited[a - 1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b - 1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                path_lengths = [0]*3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650645834,
  "object": "edit"
}
2022-04-22 16:44:09.595222 fix syntax errors 3 ['\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                path_lengths = [0]*3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j + 1, len(tree[i])):\n                a, b, c = i + 1, tree[i][j] + 1, tree[i][k] + 1\n                path_lengths = [0] * 3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a - 1]\n    visited = [False] * len(tree)\n    visited[a - 1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b - 1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_path = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                path_lengths = [0]*3\n                for l in range(3):\n                    path_lengths[l] = len(path(tree, a, b, c, l))\n                max_path = max(max_path, sum(path_lengths))\n                if max_path == sum(path_lengths):\n                    ans = [a, b, c]\n    print(max_path)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-22 16:44:09.595288 size on output set 8
2022-04-22 16:44:09.595302 num operations 2
2022-04-22 16:44:09.595309 size on input set 1
2022-04-22 16:44:09.595450 using api key sunu
2022-04-22 16:44:15.583452 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    }
  ],
  "created": 1650645849,
  "object": "edit"
}
2022-04-22 16:44:15.583694 fix spelling mistakes 3 ['\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n']
2022-04-22 16:44:15.583841 size on output set 3
2022-04-22 16:44:15.583850 size on input set 3
2022-04-22 16:44:15.583990 using api key sunu
2022-04-22 16:44:23.824769 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "import sys\nsys.setrecursionlimit(2 * 10 ** 6)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())  # todo: read list\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)  # todo: rename\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10**5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + \\\n                    get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    }
  ],
  "created": 1650645855,
  "object": "edit"
}
2022-04-22 16:44:23.825016 fix syntax errors 3 ['import sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', 'import sys\nsys.setrecursionlimit(2 * 10 ** 6)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())  # todo: read list\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)  # todo: rename\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10**5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + \\\n                    get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n']
2022-04-22 16:44:23.825207 using api key jaanu
2022-04-22 16:44:54.562421 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\n\u0412 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0435 \u0435\u0441\u0442\u044c \u0442\u0440\u0438 \u0433\u043e\u0440\u043e\u0434\u0430: \u0410, \u0411, \u0412. \u0412 \u0433\u043e\u0440\u043e\u0434\u0435 \u0410 \u0436\u0438\u0432\u0435\u0442 \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442, \u0432 \u0433\u043e\u0440\u043e\u0434\u0435 \u0411 \u0432\u0442\u043e\u0440\u043e\u0439, \u0432 \u0433\u043e\u0440\u043e\u0434\u0435 \u0412 \u0442\u0440\u0435\u0442\u0438\u0439.\n\u041f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442\u044b \u043e\u0447\u0435\u043d\u044c \u043b\u044e\u0431\u044f\u0442 \u043f\u0443\u0442\u0435\u0448\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u043f\u043e \u0441\u0442\u0440\u0430\u043d\u0435 \u0438 \u043f\u043e\u0441\u0435\u0449\u0430\u0442\u044c \u0434\u0440\u0443\u0433 \u0434\u0440\u0443\u0433\u0430. \u041d\u043e \u043e\u043d\u0438 \u043d\u0435 \u043b\u044e\u0431\u044f\u0442 \u0432\u0438\u0434\u0435\u0442\u044c \u0434\u0440\u0443\u0433 \u0434\u0440\u0443\u0433\u0430 \u0432 \u043e\u0434\u043d\u043e\u043c \u0433\u043e\u0440\u043e\u0434\u0435.\n\u041a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442\u043e\u0432 \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u0441\u0435\u0449\u0430\u0442\u044c \u043b\u044e\u0431\u043e\u0439 \u0433\u043e\u0440\u043e\u0434 \u0432 \u043b\u044e\u0431\u043e\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u043d\u043e \u043e\u043d\u0438 \u043d\u0435 \u043c\u043e\u0433\u0443\u0442 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u0432 \u043e\u0434\u043d\u043e\u043c \u0433\u043e\u0440\u043e\u0434\u0435 \u0432 \u043e\u0434\u0438\u043d \u0438 \u0442\u043e\u0442 \u0436\u0435 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438.\n\u0421\u0442\u0440\u0430\u043d\u0430 \u043e\u0447\u0435\u043d\u044c \u0431\u043e\u0433\u0430\u0442\u0430\u044f, \u0442\u0430\u043a \u0447\u0442\u043e \u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442\u044b \u043d\u0435 \u0431\u0435\u0440\u0443\u0442 \u043d\u0430 \u0441\u0435\u0431\u044f \u0440\u0430\u0441\u0445\u043e\u0434\u044b \u043d\u0430 \u043f\u0443\u0442\u0435\u0448\u0435\u0441\u0442\u0432\u0438\u0435. \u041e\u0434\u043d\u0430\u043a\u043e \u043e\u043d\u0438 \u0431\u0435\u0440\u0443\u0442 \u043d\u0430 \u0441\u0435\u0431\u044f \u0440\u0430\u0441\u0445\u043e\u0434\u044b \u043d\u0430 \u043f\u043e\u0441\u0442\u0440\u043e\u0439\u043a\u0443 \u0434\u043e\u0440\u043e\u0433.\n\u0414\u043e\u0440\u043e\u0433\u0430 \u043c\u0435\u0436\u0434\u0443 \u0434\u0432\u0443\u043c\u044f \u0433\u043e\u0440\u043e\u0434\u0430\u043c\u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0430 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e \u043e\u0434\u043d\u043e\u043c\u0443 \u0440\u0430\u0437\u0443. \u041f\u043e\u0441\u043b\u0435 \u044d\u0442\u043e\u0433\u043e \u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442\u044b \u043c\u043e\u0433\u0443\u0442 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u043c\u0435\u0436\u0434\u0443 \u044d\u0442\u0438\u043c\u0438 \u0433\u043e\u0440\u043e\u0434\u0430\u043c\u0438 \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0443\u0433\u043e\u0434\u043d\u043e \u0440\u0430\u0437.\n\u0412\u0430\u043c \u0434\u0430\u043d\u0430 \u043a\u0430\u0440\u0442\u0430 \u0441\u0442\u0440\u0430\u043d\u044b. \u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u043e\u0440\u043e\u0433, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0441\u0442\u0440\u043e\u0438\u0442\u044c, \u0447\u0442\u043e\u0431\u044b \u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442\u044b \u043c\u043e\u0433\u043b\u0438 \u043f\u043e\u0441\u0435\u0449\u0430\u0442\u044c \u0434\u0440\u0443\u0433 \u0434\u0440\u0443\u0433\u0430 \u043a\u0430\u043a \u043c\u043e\u0436\u043d\u043e \u0447\u0430\u0449\u0435.\n\n\u0424\u043e\u0440\u043c\u0430\u0442 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\n\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0437\u0430\u043f\u0438\u0441\u0430\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n \u2014 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0433\u043e\u0440\u043e\u0434\u043e\u0432 (3\u2009\u2264\u2009n\u2009\u2264\u2009200\u2009000).\n\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 n\u2009-\u20091 \u0441\u0442\u0440\u043e\u043a\u0430\u0445 \u0437\u0430\u043f\u0438\u0441\u0430\u043d\u044b \u043f\u0430\u0440\u044b \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b ui,\u2009vi (1\u2009\u2264\u2009ui,\u2009vi\u2009\u2264\u2009n, ui\u2009\u2260\u2009vi), \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0442, \u0447\u0442\u043e \u043c\u0435\u0436\u0434\u0443 \u0433\u043e\u0440\u043e\u0434\u0430\u043c\u0438 ui \u0438 vi \u0435\u0441\u0442\u044c \u0434\u043e\u0440\u043e\u0433\u0430.\n\u0413\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442\u0441\u044f, \u0447\u0442\u043e \u043a\u0430\u0440\u0442\u0430 \u0441\u0442\u0440\u0430\u043d\u044b \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0441\u0432\u044f\u0437\u043d\u043e\u0439.\n\n\u0424\u043e\u0440\u043c\u0430\u0442 \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\n\u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u2014 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u043e\u0440\u043e\u0433, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0441\u0442\u0440\u043e\u0438\u0442\u044c.\n\n\u041f\u0440\u0438\u043c\u0435\u0440\u044b\n\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n3\n1 2\n2 3\n\n\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n3\n\"\"\"\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    }
  ],
  "created": 1650645864,
  "object": "edit"
}
2022-04-22 16:44:54.562805 fix syntax errors 3 ['\n\n"""\nВ некоторой стране есть три города: А, Б, В. В городе А живет первый президент, в городе Б второй, в городе В третий.\nПрезиденты очень любят путешествовать по стране и посещать друг друга. Но они не любят видеть друг друга в одном городе.\nКаждый из президентов может посещать любой город в любой момент времени, но они не могут находиться в одном городе в один и тот же момент времени.\nСтрана очень богатая, так что президенты не берут на себя расходы на путешествие. Однако они берут на себя расходы на постройку дорог.\nДорога между двумя городами может быть построена только по одному разу. После этого президенты могут перемещаться между этими городами сколько угодно раз.\nВам дана карта страны. Найдите максимальное количество дорог, которое можно построить, чтобы президенты могли посещать друг друга как можно чаще.\n\nФормат входных данных\nВ первой строке записано целое число n — количество городов (3\u2009≤\u2009n\u2009≤\u2009200\u2009000).\nВ следующих n\u2009-\u20091 строках записаны пары целых чисел ui,\u2009vi (1\u2009≤\u2009ui,\u2009vi\u2009≤\u2009n, ui\u2009≠\u2009vi), которые обозначают, что между городами ui и vi есть дорога.\nГарантируется, что карта страны является связной.\n\nФормат выходных данных\nВыведите единственное целое число — максимальное количество дорог, которое можно построить.\n\nПримеры\nВходные данные\n3\n1 2\n2 3\n\nВыходные данные\n3\n"""\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in sub-tree, count of edges in sub-tree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n']
2022-04-22 16:44:54.563045 using api key soukgp
2022-04-22 16:45:02.140767 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n + 1)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1].append(v2)\n    tree[v2].append(v1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(1, n + 1):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1, ans2, ans3)\n"
    }
  ],
  "created": 1650645894,
  "object": "edit"
}
2022-04-22 16:45:02.141091 fix syntax errors 3 ['import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', 'import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', 'import sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n + 1)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1].append(v2)\n    tree[v2].append(v1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(1, n + 1):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1, ans2, ans3)\n']
2022-04-22 16:45:02.141171 size on output set 8
