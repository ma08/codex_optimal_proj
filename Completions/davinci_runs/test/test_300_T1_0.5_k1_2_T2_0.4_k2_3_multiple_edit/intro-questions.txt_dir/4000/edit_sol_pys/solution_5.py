

"""
В некоторой стране есть три города: А, Б, В. В городе А живет первый президент, в городе Б второй, в городе В третий.
Президенты очень любят путешествовать по стране и посещать друг друга. Но они не любят видеть друг друга в одном городе.
Каждый из президентов может посещать любой город в любой момент времени, но они не могут находиться в одном городе в один и тот же момент времени.
Страна очень богатая, так что президенты не берут на себя расходы на путешествие. Однако они берут на себя расходы на постройку дорог.
Дорога между двумя городами может быть построена только по одному разу. После этого президенты могут перемещаться между этими городами сколько угодно раз.
Вам дана карта страны. Найдите максимальное количество дорог, которое можно построить, чтобы президенты могли посещать друг друга как можно чаще.

Формат входных данных
В первой строке записано целое число n — количество городов (3 ≤ n ≤ 200 000).
В следующих n - 1 строках записаны пары целых чисел ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi), которые обозначают, что между городами ui и vi есть дорога.
Гарантируется, что карта страны является связной.

Формат выходных данных
Выведите единственное целое число — максимальное количество дорог, которое можно построить.

Примеры
Входные данные
3
1 2
2 3

Выходные данные
3
"""

import sys

sys.setrecursionlimit(2 * 10 ** 5)

n = int(input())
tree = [[] for _ in range(n)]

for i in range(n - 1):
    v1, v2 = map(int, input().split())
    tree[v1 - 1].append(v2 - 1)
    tree[v2 - 1].append(v1 - 1)


def dfs(vertex, parent):
    # return (count of vertices in sub-tree, count of edges in sub-tree)
    cnt = 1
    edges = 0
    for child in tree[vertex]:
        if child != parent:
            child_cnt, child_edges = dfs(child, vertex)
            cnt += child_cnt
            edges += child_edges + child_cnt
    return cnt, edges


def get_max_edges(v1, v2):
    cnt1, edges1 = dfs(v1, -1)
    cnt2, edges2 = dfs(v2, -1)
    return edges1 + edges2 + cnt1 * cnt2


ans = 0
ans1, ans2, ans3 = 0, 0, 0
for v1 in range(n):
    for v2 in tree[v1]:
        for v3 in tree[v2]:
            if v1 != v3:
                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)
                if cur > ans:
                    ans = cur
                    ans1, ans2, ans3 = v1, v2, v3

print(ans)
print(ans1 + 1, ans2 + 1, ans3 + 1)
