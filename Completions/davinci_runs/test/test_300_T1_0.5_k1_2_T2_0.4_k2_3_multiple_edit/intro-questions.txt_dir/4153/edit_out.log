2022-04-22 19:19:30.228837 num operations 2
2022-04-22 19:19:30.228854 size on input set 1
2022-04-22 19:19:30.229021 using api key kouti
2022-04-22 19:19:43.760493 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeroes - zeroes_at_beginning_or_end\n"
    },
    {
      "index": 1,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeros - zeros_at_beginning_or_end\n"
    },
    {
      "index": 2,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeroes - zeroes_at_beginning_or_end\n"
    }
  ],
  "created": 1650655170,
  "object": "edit"
}
2022-04-22 19:19:43.760823 fix spelling mistakes 3 ['\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeroes - zeroes_at_beginning_or_end\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeros - zeros_at_beginning_or_end\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeroes - zeroes_at_beginning_or_end\n']
2022-04-22 19:19:43.760876 size on output set 3
2022-04-22 19:19:43.760884 size on input set 3
2022-04-22 19:19:43.761019 using api key soukgp
2022-04-22 19:19:49.181072 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 1,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    }
  ],
  "created": 1650655183,
  "object": "edit"
}
2022-04-22 19:19:49.181417 fix syntax errors 3 ['\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', '\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to one.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or at the end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or at the end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n']
2022-04-22 19:19:49.181623 using api key derek
2022-04-22 19:19:59.278617 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "S = raw_input()\n\nzeros = S.count(\"0\")\nzeros_at_beginning_and_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint zeros - zeros_at_beginning_and_end\n"
    },
    {
      "index": 1,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count('0')\nzeros_at_beginning_or_end = len(S) - len(S.lstrip('0').rstrip('0'))\nprint(zeros - zeros_at_beginning_or_end)\n"
    }
  ],
  "created": 1650655189,
  "object": "edit"
}
2022-04-22 19:19:59.278854 fix syntax errors 3 ['S = raw_input()\n\nzeros = S.count("0")\nzeros_at_beginning_and_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint zeros - zeros_at_beginning_and_end\n', '\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count("0")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeros - zeros_at_beginning_or_end)\n', "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count('0')\nzeros_at_beginning_or_end = len(S) - len(S.lstrip('0').rstrip('0'))\nprint(zeros - zeros_at_beginning_or_end)\n"]
2022-04-22 19:19:59.279040 using api key soukgp
2022-04-22 19:20:04.746804 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 1,
      "text": "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    },
    {
      "index": 2,
      "text": "S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count(\"0\")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeroes - zeroes_at_beginning_or_end)\n"
    }
  ],
  "created": 1650655199,
  "object": "edit"
}
2022-04-22 19:20:04.747137 fix syntax errors 3 ['\nS = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', '\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n', 'S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeroes that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(n) time.\n\n# The number of zeroes adjacent to ones is the number of zeroes minus the number of zeroes that are not adjacent to ones.\n# The number of zeroes that are not adjacent to ones is the number of zeroes that are adjacent to other zeroes.\n# The number of zeroes that are adjacent to other zeroes is the number of zeroes minus the number of zeroes that are not adjacent to other zeroes.\n# The number of zeroes that are not adjacent to other zeroes is the number of zeroes that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeroes minus the number of zeroes that are at the beginning or end of the string.\n\nzeroes = S.count("0")\nzeroes_at_beginning_or_end = len(S) - len(S.lstrip("0").rstrip("0"))\nprint(zeroes - zeroes_at_beginning_or_end)\n']
2022-04-22 19:20:04.747186 size on output set 8
2022-04-22 19:20:04.747199 num operations 2
2022-04-22 19:20:04.747204 size on input set 1
2022-04-22 19:20:04.747381 using api key kouti
2022-04-22 19:20:14.280187 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = math.inf\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650655204,
  "object": "edit"
}
2022-04-22 19:20:14.280460 fix spelling mistakes 3 ["\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = math.inf\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-22 19:20:14.280498 size on output set 3
2022-04-22 19:20:14.280506 size on input set 3
2022-04-22 19:20:14.280650 using api key sunu
2022-04-22 19:20:19.407228 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = float('inf')\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\nimport math\n\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = math.inf\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = float('inf')\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650655214,
  "object": "edit"
}
2022-04-22 19:20:19.407466 fix syntax errors 3 ["import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = float('inf')\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport math\n\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = math.inf\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline().rstrip())\n    a = list(map(int, sys.stdin.readline().rstrip().split()))\n    a.sort()\n    max_a = a[-1]\n    min_a = a[0]\n    ans = float('inf')\n    for i in range(min_a, max_a + 1):\n        cost = 0\n        for j in range(n):\n            cost += (a[j] - i) ** 2\n        ans = min(ans, cost)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-22 19:20:19.407723 using api key derek
2022-04-22 19:20:28.742106 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n\tif c == '0':\n\t    if len(stack) > 0 and stack[-1] == '1':\n\t\tstack.pop()\n\t\tans += 1\n\t\telse:\n\t\tstack.append(c)\n\telse:\n\t    stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650655219,
  "object": "edit"
}
2022-04-22 19:20:28.742415 fix syntax errors 3 ["import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n\tif c == '0':\n\t    if len(stack) > 0 and stack[-1] == '1':\n\t\tstack.pop()\n\t\tans += 1\n\t\telse:\n\t\tstack.append(c)\n\telse:\n\t    stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-22 19:20:28.742587 using api key sunu
2022-04-22 19:20:33.471315 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1650655229,
  "object": "edit"
}
2022-04-22 19:20:33.471587 fix syntax errors 3 ["\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip() # remove newline\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-22 19:20:33.471620 size on output set 6
