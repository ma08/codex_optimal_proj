["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return(list(map(int,f.readline().split())))\n\ndef inl():\n    return(list(map(int,f.readline().split())))\n\ndef ins():\n    return(input())\n\ndef inv():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = inv()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = inv()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef ins():\n    return(f.readline().split())\n\ndef inl():\n    return(list(map(int,f.readline().split())))\n\ndef inv():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = inv()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = inv()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "import os\n\nimport sys\nimport math\nimport random\nimport re\nimport sys\nimport bisect\nfrom operator import itemgetter\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom collections import OrderedDict\nfrom heapq import heappush, heappop\nfrom heapq import *\nfrom bisect import insort, bisect_left\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import product\nfrom itertools import combinations_with_replacement\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import product\nfrom functools import reduce\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom math import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial as fact\nfrom operator import mul\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom collections import Counter\nfrom math import pi\nfrom math import log10\nfrom itertools import product\nfrom itertools import combinations\nfrom itertools import combinations_with_replacement\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom itertools import\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return \n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\n    # if graph is acyclic and connected, then it is a tree (bfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (or tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            print(\"NO\")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (or forest)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return list(map(str,f.readline().split()))\n\ndef inl():\n    return list(map(int,f.readline().split()))\n\ndef ins():\n    return input()\n\ndef inv():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = inv()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = inv()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return list(map(int,f.readline().split()))\n\ndef inl():\n    return list(map(int,f.readline().split()))\n\ndef ins():\n    return input()\n\ndef inv():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = inv()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = inv()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (using bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if j in graph[i]:\n                print(\"0\", end=\" \")\n            else:\n                print(\"1\", end=\" \")\n        print(\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for nxt in graph[start]:\n        if not visited[nxt]:\n            dfs(graph, nxt, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (or tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (or forest)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (or tree)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return False\n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (or forest)\n    # therefore, it is possible to orient all edges\n    print(\"YES\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\" \")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\" \")\n\nif __name__ == \"__main__\":\n    solve()\n", "\nimport sys\nfrom collections import defaultdict\n\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (using bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            break\n\n            return\n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\n    # if graph is acyclic and connected, then it is a tree (bfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\n    # if graph is acyclic and connected, then it is a tree (bfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]