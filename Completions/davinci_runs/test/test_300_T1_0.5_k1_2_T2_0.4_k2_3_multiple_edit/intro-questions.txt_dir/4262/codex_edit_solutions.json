["\ndef swap(a, b):\n    temp = a\n    a = b\n    b = temp\n    return a, b\n\n\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = swap(P[i], P[j])\n                count += 1\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = swap(Q[i], Q[j])\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# My answer\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Making permutations of size N\npermutations = []\nfor i in range(1, N+1):\n    permutations.append(i)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i] #swap\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i] #swap\n\npermutation(N, N)\n\n# Counting the order of P and Q in permutations\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P:\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "\n\n# My answer\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Making permutations of size N\npermutations = []\nfor i in range(N):\n    permutations.append(i+1)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the orders of P and Q in permutations\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P: # P is a list\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "\n\n# My answer\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Making permutations of size N\npermutations = [0]\nfor i in range(N):\n    permutations.append(i+1)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the orders of P and Q\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P:\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "def swap(p, q):\n    temp = p\n    p = q\n    q = temp\n    return p, q\n\n\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = swap(P[i], P[j])\n                count += 1\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = swap(Q[i], Q[j])\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    count1 = 0\n    count2 = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = P[j], P[i]\n                count1 += 1\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = Q[j], Q[i]\n                count2 += 1\n    print(count1)\n    print(count2)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef swap(a, b):\n    return b, a\n\n\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = swap(P[i], P[j])\n                count += 1\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = swap(Q[i], Q[j])\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()\n", "\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Making permutations of size N\npermutations = []\nfor i in range(N):\n    permutations.append(i + 1)\n\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n - 1, -1, -1):\n        permutations[i], permutations[n - 1] = permutations[n - 1], permutations[i]\n        permutation(n - 1, r - 1)\n        permutations[i], permutations[n - 1] = permutations[n - 1], permutations[i]\n\npermutation(N, N)\n\n# Counting the orders of P and Q\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P:\n        P_order = i + 1\n    if permutations[i] == Q:\n        Q_order = i + 1\n\nprint(abs(P_order - Q_order))\n", "\n\n# My answer\n\nN = int(input())\nP = tuple(map(int, input().split()))\nQ = tuple(map(int, input().split()))\n\n# Making permutation of size N\npermutations = [i+1 for i in range(N)]\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the order of P and Q from permutation\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P:\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    count_p = 0\n    count_q = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = P[j], P[i]\n                count_p += 1\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = Q[j], Q[i]\n                count_q += 1\n    print(count_p - count_q)\n\n\nif __name__ == '__main__':\n    main()\n", "\nN = int(input())\nP = list(map(int, input().split()))\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\nQ = list(map(int, input().split()))\n\n# Making permutations of size N\npermutations = []\nfor i in range(N):\n    permutations.append(i+1)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the order of P and Q in permutations\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P:\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "\n# My answer (Not efficient)\n\nN = int(input())\nP = tuple(map(int, input().split()))\nQ = tuple(map(int, input().split()))\n\n# Making permutation of size N\npermutations = []\nfor i in range(N):\n    permutations.append(i+1)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the order of P and Q from permutation\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P:\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "\ndef main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = P[j], P[i]\n                count += 1\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = Q[j], Q[i]\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# My answer\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Making permutation of size N\npermutations = []\nfor i in range(N):\n    permutations.append(i+1)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the order of P and Q from permutation\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)):\n    if permutations[i] == P[:]:\n        P_order = i+1\n    if permutations[i] == Q[:]:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n", "def main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    for i in range(N):\n        for j in range(i+1, N):\n            if P[i] > P[j]:\n                P[i], P[j] = P[j], P[i]\n            if Q[i] > Q[j]:\n                Q[i], Q[j] = Q[j], Q[i]\n    print(P, Q)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# My answer\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Making permutations of size N\npermutations = []\nfor i in range(N):\n    permutations.append(i+1)\n\ndef permutation(n, r):\n    if r == 0:\n        return\n    for i in range(n-1, -1, -1):\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n        permutation(n-1, r-1)\n        permutations[i], permutations[n-1] = permutations[n-1], permutations[i]\n\npermutation(N, N)\n\n# Counting the order of P and Q in permutations\nP_order = 0\nQ_order = 0\nfor i in range(len(permutations)): # permutations is a list of lists\n    if permutations[i] == P: # permutations[i] is a list\n        P_order = i+1\n    if permutations[i] == Q:\n        Q_order = i+1\n\nprint(abs(P_order-Q_order))\n"]