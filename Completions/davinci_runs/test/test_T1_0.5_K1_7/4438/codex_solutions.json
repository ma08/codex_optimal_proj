["\n\nn = int(input())\n\npoints = []\nmin_x = 10**9\nmin_y = 10**9\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n    min_x = min(min_x, x)\n    min_y = min(min_y, y)\n\nx_points = []\ny_points = []\n\nfor x, y in points:\n    x_points.append(x - min_x)\n    y_points.append(y - min_y)\n\nx_points.sort()\ny_points.sort()\n\nres_x = 0\nres_y = 0\n\nfor i in range(1, n):\n    res_x += abs(x_points[i] - x_points[i-1])\n    res_y += abs(y_points[i] - y_points[i-1])\n\nres_x += abs(x_points[0])\nres_y += abs(y_points[0])\n\nres_x += abs(x_points[n-1])\nres_y += abs(y_points[n-1])\n\nres_x += (n-1)*2\nres_y += (n-1)*2\n\nprint(min(res_x, res_y))", "\n\nimport sys\n\n#sys.stdin = open('in.txt')\n#sys.stdout = open('out.txt', 'w')\n\nf = sys.stdin\no = sys.stdout\n\ndef main():\n    n = readInt()\n    points = []\n    for i in range(n):\n        points.append(readInts())\n    points.sort(key=lambda x: max(x[0], x[1]))\n    #print(points)\n    x, y = 0, 0\n    dist = 0\n    for p in points:\n        dist += abs(x - p[0]) + abs(y - p[1])\n        x, y = p[0], p[1]\n    print(dist)\n\ndef readInt():\n    return int(f.readline())\n\ndef readInts():\n    return [int(x) for x in f.readline().split()]\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n\tpass\n\nif __name__ == '__main__':\n\tmain()", "\n\n# SOLUTION\n# We can use a greedy approach. We can sort the input points by their level.\n# Then, we can sum the distances of the points in each level.\n# The total distance is the sum of all the distances.\n\n# This solution is O(N log N) because we sort the input.\n\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((max(x, y), x, y))\n\npoints.sort()\n\nans = 0\nfor i in range(n):\n    ans += abs(points[i][1] - points[0][1]) + abs(points[i][2] - points[0][2])\n\nprint(ans)", "\n\ndef main():\n    n = int(input())\n    points = []\n    for i in range(n):\n        points.append(tuple(map(int, input().split())))\n    points.sort(key=lambda x:x[0]+x[1])\n    print(points)\n    ans = 0\n    for i in range(n-1):\n        ans += abs(points[i][0]-points[i+1][0]) + abs(points[i][1]-points[i+1][1])\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\n#!/bin/python3\n\nimport os\nimport sys\nimport math\n\n#\n# Complete the solve function below.\n#\ndef solve(n, points):\n    #\n    # Write your code here.\n    #\n    points.sort(key=lambda x: max(x[0], x[1]))\n    # print(points)\n\n    # dp = [[-1 for _ in range(2)] for _ in range(n)]\n    # dp[0][0] = 0\n    # dp[0][1] = 0\n    # for i in range(1, n):\n    #     dp[i][0] = max(dp[i-1][0] + abs(points[i][0]-points[i-1][0]), dp[i-1][1] + abs(points[i][0]-points[i-1][1]))\n    #     dp[i][1] = max(dp[i-1][0] + abs(points[i][1]-points[i-1][0]), dp[i-1][1] + abs(points[i][1]-points[i-1][1]))\n    # print(dp)\n    # return max(dp[n-1][0], dp[n-1][1])\n\n    dp = [0 for _ in range(2)]\n    for i in range(1, n):\n        dp[0] = max(dp[0] + abs(points[i][0]-points[i-1][0]), dp[1] + abs(points[i][0]-points[i-1][1]))\n        dp[1] = max(dp[0] + abs(points[i][1]-points[i-1][0]), dp[1] + abs(points[i][1]-points[i-1][1]))\n    return max(dp[0], dp[1])\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    points = []\n\n    for _ in range(n):\n        points.append(list(map(int, input().rstrip().split())))\n\n    result = solve(n, points)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()", "\n\ndef main():\n    n = int(input())\n    key_points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        key_points.append((x, y))\n    key_points = sorted(key_points, key=lambda p: max(p[0], p[1]))\n    # print(key_points)\n    current_point = (0, 0)\n    distance = 0\n    for point in key_points:\n        distance += abs(point[0] - current_point[0]) + abs(point[1] - current_point[1])\n        current_point = point\n    print(distance)\n\nif __name__ == \"__main__\":\n    main()"]