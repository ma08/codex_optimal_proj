2022-04-13 18:37:49.432518 """
There is a rectangular grid of size $n \times m$. Each cell has a number written on it; the number on the cell ($i, j$) is $a_{i, j}$. Your task is to calculate the number of paths from the upper-left cell ($1, 1$) to the bottom-right cell ($n, m$) meeting the following constraints:

  You can move to the right or to the bottom only. Formally, from the cell ($i, j$) you may move to the cell ($i, j + 1$) or to the cell ($i + 1, j$). The target cell can't be outside of the grid.  The xor of all the numbers on the path from the cell ($1, 1$) to the cell ($n, m$) must be equal to $k$ (xor operation is the bitwise exclusive OR, it is represented as '^' in Java or C++ and "xor" in Pascal). 

Find the number of such paths in the given grid.


-----Input-----

The first line of the input contains three integers $n$, $m$ and $k$ ($1 \le n, m \le 20$, $0 \le k \le 10^{18}$) — the height and the width of the grid, and the number $k$.

The next $n$ lines contain $m$ integers each, the $j$-th element in the $i$-th line is $a_{i, j}$ ($0 \le a_{i, j} \le 10^{18}$).


-----Output-----

Print one integer — the number of paths from ($1, 1$) to ($n, m$) with xor sum equal to $k$.


-----Examples-----
Input
3 3 11
2 1 5
7 10 0
12 6 4

Output
3

Input
3 4 2
1 3 3 3
0 3 3 2
3 0 1 1

Output
5

Input
3 4 1000000000000000000
1 3 3 3
0 3 3 2
3 0 1 1

Output
0



-----Note-----

All the paths from the first example:   $(1, 1) \rightarrow (2, 1) \rightarrow (3, 1) \rightarrow (3, 2) \rightarrow (3, 3)$;  $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (3, 3)$;  $(1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (3, 2) \rightarrow (3, 3)$. 

All the paths from the second example:   $(1, 1) \rightarrow (2, 1) \rightarrow (3, 1) \rightarrow (3, 2) \rightarrow (3, 3) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (3, 2) \rightarrow (3, 3) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (3, 3) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (3, 3) \rightarrow (3, 4)$.
"""
2022-04-13 18:37:49.432536 --------------------------
2022-04-13 18:38:19.645275 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(x, y, xor_sum):\n    if x == n and y == m:\n        if xor_sum == k:\n            return 1\n        else:\n            return 0\n\n    if x >= n or y >= m:\n        return 0\n\n    if (x, y, xor_sum) in dp:\n        return dp[(x, y, xor_sum)]\n\n    dp[(x, y, xor_sum)] = dfs(x + 1, y, xor_sum ^ a[x][y]) + dfs(x, y + 1, xor_sum ^ a[x][y])\n    return dp[(x, y, xor_sum)]\n\nn, m, k = map(int, input().split())\na = [[0] * m for _ in range(n)]\ndp = {}\n\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n\nprint(dfs(0, 0, 0))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport numpy as np\n\ndef read_data(source):\n    n, m, k = [int(x) for x in source.readline().split()]\n    a = np.zeros((n, m), dtype=int)\n    for i in range(n):\n        a[i] = [int(x) for x in source.readline().split()]\n    return n, m, k, a\n\ndef solve(n, m, k, a):\n    dp = np.zeros((n, m, 64), dtype=int)\n    dp[0, 0, a[0, 0]] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i, j] += dp[i-1, j]\n            if j > 0:\n                dp[i, j] += dp[i, j-1]\n            dp[i, j] = dp[i, j] % 1000000007\n            if i > 0 or j > 0:\n                dp[i, j] = dp[i, j] - dp[i, j, a[i, j]] + 1000000007\n                dp[i, j, a[i, j]] = 0\n    return dp[n-1, m-1, k]\n\ndef main():\n    n, m, k, a = read_data(sys.stdin)\n    print(solve(n, m, k, a))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\nn, m, k = map(int, stdin.readline().split())\na = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[1][1] = 1\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if i == 1 and j == 1:\n            continue\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if i == 1 and j == 1:\n            continue\n        if a[i - 1][j - 1] ^ k == 0:\n            dp[i][j] -= 1\n\nprint(dp[n][m] % 1000000007)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef main():\n    n, m, k = read_ints()\n    a = []\n    for _ in range(n):\n        a.append(read_ints())\n\n    # dp[i][j] = # of paths from (1,1) to (i,j) with xor sum equal to k\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    dp[1][1] = 1\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            if a[i-1][j-1] ^ k == 0:\n                dp[i][j] -= 1\n    print(dp[n][m])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef xor_sum(x, y, k):\n    return (x ^ y ^ k) == 0\n\ndef dfs(n, m, k, grid, i, j):\n    if i < 0 or j < 0 or i >= n or j >= m or not xor_sum(grid[i][j], k, k):\n        return 0\n    if i == n-1 and j == m-1:\n        return 1\n    return dfs(n, m, k, grid, i+1, j) + dfs(n, m, k, grid, i, j+1)\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(int, input().split())))\n    print(dfs(n, m, k, grid, 0, 0))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn, m, k = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\ndef get_xor_sum(a, n, m):\n    ans = [[0 for i in range(m)] for j in range(n)]\n    ans[0][0] = a[0][0]\n    for i in range(1, n):\n        ans[i][0] = ans[i - 1][0] ^ a[i][0]\n    for j in range(1, m):\n        ans[0][j] = ans[0][j - 1] ^ a[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            ans[i][j] = ans[i - 1][j] ^ ans[i][j - 1] ^ a[i][j]\n    return ans\n\nans = get_xor_sum(a, n, m)\n\ndp = [[0 for i in range(m)] for j in range(n)]\ndp[0][0] = 1\nfor i in range(1, n):\n    if ans[i - 1][0] ^ ans[i][0] == k:\n        dp[i][0] = 1\n    else:\n        dp[i][0] = 0\nfor j in range(1, m):\n    if ans[0][j - 1] ^ ans[0][j] == k:\n        dp[0][j] = 1\n    else:\n        dp[0][j] = 0\nfor i in range(1, n):\n    for j in range(1, m):\n        if ans[i - 1][j] ^ ans[i][j] == k:\n            dp[i][j] += dp[i - 1][j]\n        if ans[i][j - 1] ^ ans[i][j] == k:\n            dp[i][j] += dp[i][j - 1]\n\nprint(dp[n - 1][m - 1])"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, m, k = map(int, input().split())\n\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\ndp = [[0 for j in range(m)] for i in range(n)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(m):\n        if i == 0 and j == 0:\n            continue\n        if i != 0:\n            dp[i][j] += dp[i-1][j]\n        if j != 0:\n            dp[i][j] += dp[i][j-1]\n\n# print(dp)\n\nans = 0\n\nfor i in range(n):\n    for j in range(m):\n        if i == 0 and j == 0:\n            continue\n        if i != 0 and j != 0:\n            if (a[i][j] ^ a[i-1][j] ^ a[i][j-1]) == k:\n                ans += dp[i-1][j-1]\n        elif i == 0:\n            if (a[i][j] ^ a[i][j-1]) == k:\n                ans += dp[i][j-1]\n        elif j == 0:\n            if (a[i][j] ^ a[i-1][j]) == k:\n                ans += dp[i-1][j]\n\nprint(ans)"
    }
  ],
  "created": 1649875069,
  "id": "cmpl-4wcA96id27BeXTiFegsV9VL5YmXnn",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 18:38:19.645648 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(x, y, xor_sum):\n    if x == n and y == m:\n        if xor_sum == k:\n            return 1\n        else:\n            return 0\n\n    if x >= n or y >= m:\n        return 0\n\n    if (x, y, xor_sum) in dp:\n        return dp[(x, y, xor_sum)]\n\n    dp[(x, y, xor_sum)] = dfs(x + 1, y, xor_sum ^ a[x][y]) + dfs(x, y + 1, xor_sum ^ a[x][y])\n    return dp[(x, y, xor_sum)]\n\nn, m, k = map(int, input().split())\na = [[0] * m for _ in range(n)]\ndp = {}\n\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n\nprint(dfs(0, 0, 0))"
}
2022-04-13 18:38:19.645688 REASON stop
2022-04-13 18:38:19.646090 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport numpy as np\n\ndef read_data(source):\n    n, m, k = [int(x) for x in source.readline().split()]\n    a = np.zeros((n, m), dtype=int)\n    for i in range(n):\n        a[i] = [int(x) for x in source.readline().split()]\n    return n, m, k, a\n\ndef solve(n, m, k, a):\n    dp = np.zeros((n, m, 64), dtype=int)\n    dp[0, 0, a[0, 0]] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i, j] += dp[i-1, j]\n            if j > 0:\n                dp[i, j] += dp[i, j-1]\n            dp[i, j] = dp[i, j] % 1000000007\n            if i > 0 or j > 0:\n                dp[i, j] = dp[i, j] - dp[i, j, a[i, j]] + 1000000007\n                dp[i, j, a[i, j]] = 0\n    return dp[n-1, m-1, k]\n\ndef main():\n    n, m, k, a = read_data(sys.stdin)\n    print(solve(n, m, k, a))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 18:38:19.646226 REASON stop
2022-04-13 18:38:19.646597 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\nn, m, k = map(int, stdin.readline().split())\na = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[1][1] = 1\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if i == 1 and j == 1:\n            continue\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if i == 1 and j == 1:\n            continue\n        if a[i - 1][j - 1] ^ k == 0:\n            dp[i][j] -= 1\n\nprint(dp[n][m] % 1000000007)"
}
2022-04-13 18:38:19.646647 REASON stop
2022-04-13 18:38:19.662274 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef main():\n    n, m, k = read_ints()\n    a = []\n    for _ in range(n):\n        a.append(read_ints())\n\n    # dp[i][j] = # of paths from (1,1) to (i,j) with xor sum equal to k\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    dp[1][1] = 1\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            if a[i-1][j-1] ^ k == 0:\n                dp[i][j] -= 1\n    print(dp[n][m])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 18:38:19.662374 REASON stop
2022-04-13 18:38:19.685511 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef xor_sum(x, y, k):\n    return (x ^ y ^ k) == 0\n\ndef dfs(n, m, k, grid, i, j):\n    if i < 0 or j < 0 or i >= n or j >= m or not xor_sum(grid[i][j], k, k):\n        return 0\n    if i == n-1 and j == m-1:\n        return 1\n    return dfs(n, m, k, grid, i+1, j) + dfs(n, m, k, grid, i, j+1)\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(int, input().split())))\n    print(dfs(n, m, k, grid, 0, 0))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 18:38:19.685629 REASON stop
2022-04-13 18:38:19.686436 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn, m, k = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\ndef get_xor_sum(a, n, m):\n    ans = [[0 for i in range(m)] for j in range(n)]\n    ans[0][0] = a[0][0]\n    for i in range(1, n):\n        ans[i][0] = ans[i - 1][0] ^ a[i][0]\n    for j in range(1, m):\n        ans[0][j] = ans[0][j - 1] ^ a[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            ans[i][j] = ans[i - 1][j] ^ ans[i][j - 1] ^ a[i][j]\n    return ans\n\nans = get_xor_sum(a, n, m)\n\ndp = [[0 for i in range(m)] for j in range(n)]\ndp[0][0] = 1\nfor i in range(1, n):\n    if ans[i - 1][0] ^ ans[i][0] == k:\n        dp[i][0] = 1\n    else:\n        dp[i][0] = 0\nfor j in range(1, m):\n    if ans[0][j - 1] ^ ans[0][j] == k:\n        dp[0][j] = 1\n    else:\n        dp[0][j] = 0\nfor i in range(1, n):\n    for j in range(1, m):\n        if ans[i - 1][j] ^ ans[i][j] == k:\n            dp[i][j] += dp[i - 1][j]\n        if ans[i][j - 1] ^ ans[i][j] == k:\n            dp[i][j] += dp[i][j - 1]\n\nprint(dp[n - 1][m - 1])"
}
2022-04-13 18:38:19.686536 REASON stop
2022-04-13 18:38:19.687293 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, m, k = map(int, input().split())\n\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\ndp = [[0 for j in range(m)] for i in range(n)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(m):\n        if i == 0 and j == 0:\n            continue\n        if i != 0:\n            dp[i][j] += dp[i-1][j]\n        if j != 0:\n            dp[i][j] += dp[i][j-1]\n\n# print(dp)\n\nans = 0\n\nfor i in range(n):\n    for j in range(m):\n        if i == 0 and j == 0:\n            continue\n        if i != 0 and j != 0:\n            if (a[i][j] ^ a[i-1][j] ^ a[i][j-1]) == k:\n                ans += dp[i-1][j-1]\n        elif i == 0:\n            if (a[i][j] ^ a[i][j-1]) == k:\n                ans += dp[i][j-1]\n        elif j == 0:\n            if (a[i][j] ^ a[i-1][j]) == k:\n                ans += dp[i-1][j]\n\nprint(ans)"
}
2022-04-13 18:38:19.687381 REASON stop
