["\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for i in range(n)]\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def BFS(self, s):\n        visited = [False] * self.n\n        queue = []\n\n        queue.append(s)\n        visited[s] = True\n\n        while queue:\n            s = queue.pop(0)\n            for i in self.graph[s]:\n                if visited[i] == False:\n                    queue.append(i)\n                    visited[i] = True\n\n        return visited\n\nn = int(input())\na = list(map(int, input().split()))\ng = Graph(n)\nfor i in range(n):\n    if i - a[i] > 0:\n        g.add_edge(i, i - a[i])\n    if i + a[i] < n:\n        g.add_edge(i, i + a[i])\n\nfor i in range(n):\n    if a[i] % 2 == 1:\n        visited = g.BFS(i)\n        for j in range(n):\n            if a[j] % 2 == 0 and visited[j] == True:\n                print(1, end=' ')\n                break\n        else:\n            print(-1, end=' ')\n    else:\n        visited = g.BFS(i)\n        for j in range(n):\n            if a[j] % 2 == 1 and visited[j] == True:\n                print(1, end=' ')\n                break\n        else:\n            print(-1, end=' ')", "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [-1 for i in range(n)]\n    for i in range(n):\n        if i + a[i] < n:\n            if a[i + a[i]] % 2 != a[i] % 2:\n                d[i] = 1\n        if i - a[i] >= 0:\n            if a[i - a[i]] % 2 != a[i] % 2:\n                d[i] = 1\n    for i in range(n):\n        if d[i] == -1:\n            continue\n        if i + a[i] < n and d[i + a[i]] == -1:\n            d[i + a[i]] = d[i] + 1\n        if i - a[i] >= 0 and d[i - a[i]] == -1:\n            d[i - a[i]] = d[i] + 1\n    print(*d)\n\nif __name__ == '__main__':\n    main()", "\nimport sys\nfrom collections import deque\n\ndef main():\n    # parse input\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    \n    # build graph\n    graph = {}\n    for i in range(n):\n        graph[i+1] = []\n        if i+1-a[i] >= 1:\n            graph[i+1] += [i+1-a[i]]\n        if i+1+a[i] <= n:\n            graph[i+1] += [i+1+a[i]]\n    \n    # find shortest path to reach opposite parity\n    d = [0]*(n+1)\n    for i in range(1, n+1):\n        # bfs\n        q = deque([i])\n        visited = [False]*(n+1)\n        visited[i] = True\n        found = False\n        while len(q) > 0:\n            curr = q.popleft()\n            for node in graph[curr]:\n                if visited[node]: continue\n                visited[node] = True\n                if a[node-1] % 2 != a[i-1] % 2:\n                    found = True\n                    break\n                q.append(node)\n            if found: break\n        if found:\n            d[i] = d[curr] + 1\n        else:\n            d[i] = -1\n    # print output\n    print(' '.join([str(x) for x in d[1:]]))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    visited = [False]*n\n    d = [-1]*n\n    for i in range(n):\n        if visited[i]:\n            continue\n        visited[i] = True\n        q = [i]\n        while q:\n            pos = q.pop(0)\n            if a[pos] % 2 == a[i] % 2:\n                d[i] = min(d[i], d[pos]) if d[i] != -1 else d[pos]\n            else:\n                d[i] = min(d[i], d[pos]+1) if d[i] != -1 else d[pos]+1\n            if pos - a[pos] >= 0 and not visited[pos-a[pos]]:\n                q.append(pos-a[pos])\n                visited[pos - a[pos]] = True\n            if pos + a[pos] < n and not visited[pos+a[pos]]:\n                q.append(pos+a[pos])\n                visited[pos + a[pos]] = True\n    print(' '.join(map(str, d)))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Parity of i-th element\nparity = [0] * n\n\n# Index of the elements with the same parity\nparity_idx = defaultdict(list)\n\nfor i in range(n):\n    parity[i] = a[i] % 2\n    parity_idx[parity[i]].append(i)\n\n# Graph\ngraph = []\nfor i in range(n):\n    graph.append([])\n    for j in range(n):\n        if i == j:\n            continue\n        if abs(i - j) == a[i]:\n            graph[i].append(j)\n\n# Shortest path from i to j\ndef shortest_path(graph, i, j):\n    # Visited nodes\n    visited = set()\n    # Queue\n    queue = []\n    # Distances from i to every node\n    dist = [math.inf] * n\n    # Init\n    dist[i] = 0\n    queue.append(i)\n    visited.add(i)\n    # BFS\n    while queue:\n        curr = queue.pop(0)\n        for adj in graph[curr]:\n            if adj not in visited:\n                visited.add(adj)\n                queue.append(adj)\n                dist[adj] = dist[curr] + 1\n    return dist[j]\n\n# Solve\nans = [0] * n\nfor i in range(n):\n    # Find the closest element with the opposite parity\n    min_dist = math.inf\n    for j in parity_idx[1 - parity[i]]:\n        min_dist = min(min_dist, shortest_path(graph, i, j))\n    if min_dist == math.inf:\n        ans[i] = -1\n    else:\n        ans[i] = min_dist\nprint(*ans)", "\n\nimport sys\n\ndef main():\n\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    d = [0]*n\n    visited = [False]*n\n    queue = []\n\n    for i in range(n):\n        if a[i] % 2 != 0:\n            queue.append(i)\n            visited[i] = True\n\n    while len(queue) > 0:\n        i = queue.pop(0)\n        if i - a[i] >= 0 and not visited[i - a[i]]:\n            d[i - a[i]] = d[i] + 1\n            visited[i - a[i]] = True\n            queue.append(i - a[i])\n        if i + a[i] < n and not visited[i + a[i]]:\n            d[i + a[i]] = d[i] + 1\n            visited[i + a[i]] = True\n            queue.append(i + a[i])\n\n    for i in range(n):\n        if a[i] % 2 == 0 and not visited[i]:\n            d[i] = -1\n\n    print(\" \".join(map(str, d)))\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n\nfrom collections import deque\n\nn = int(input())\na = list(map(int, input().split()))\n\n# build graph\ngraph = [[] for _ in range(n+1)]\nfor i in range(1, n+1):\n    if i - a[i-1] >= 1:\n        graph[i].append(i - a[i-1])\n    if i + a[i-1] <= n:\n        graph[i].append(i + a[i-1])\n\n# BFS\nbfs = deque()\nvisited = [False] * (n+1)\n\nfor i in range(1, n+1):\n    visited = [False] * (n+1)\n    bfs.append((i, 0))\n    while bfs:\n        v, d = bfs.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        if a[v-1] % 2 != a[i-1] % 2:\n            print(d)\n            break\n        for w in graph[v]:\n            bfs.append((w, d+1))\n    else:\n        print(-1)"]