2022-04-13 19:25:21.924590 """
You are given a set of $n$ segments on the axis $Ox$, each segment has integer endpoints between $1$ and $m$ inclusive. Segments may intersect, overlap or even coincide with each other. Each segment is characterized by two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le m$) — coordinates of the left and of the right endpoints. 

Consider all integer points between $1$ and $m$ inclusive. Your task is to print all such points that don't belong to any segment. The point $x$ belongs to the segment $[l; r]$ if and only if $l \le x \le r$.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 100$) — the number of segments and the upper bound for coordinates.

The next $n$ lines contain two integers each $l_i$ and $r_i$ ($1 \le l_i \le r_i \le m$) — the endpoints of the $i$-th segment. Segments may intersect, overlap or even coincide with each other. Note, it is possible that $l_i=r_i$, i.e. a segment can degenerate to a point.


-----Output-----

In the first line print one integer $k$ — the number of points that don't belong to any segment.

In the second line print exactly $k$ integers in any order — the points that don't belong to any segment. All points you print should be distinct.

If there are no such points at all, print a single integer $0$ in the first line and either leave the second line empty or do not print it at all.


-----Examples-----
Input
3 5
2 2
1 2
5 5

Output
2
3 4 

Input
1 7
1 7

Output
0




-----Note-----

In the first example the point $1$ belongs to the second segment, the point $2$ belongs to the first and the second segments and the point $5$ belongs to the third segment. The points $3$ and $4$ do not belong to any segment.

In the second example all the points from $1$ to $7$ belong to the first segment.
"""
2022-04-13 19:25:21.924603 --------------------------
2022-04-13 19:25:44.799969 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport collections\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    points = set(range(1, m+1))\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        points = points - set(range(l, r+1))\n    print(len(points))\n    print(*sorted(points))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef get_points(n, m):\n    points = set(range(1, m+1))\n    for i in range(n):\n        l, r = map(int, input().split())\n        points -= set(range(l, r+1))\n    return points\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    points = get_points(n, m)\n    print(len(points))\n    print(*points)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n\ndef find_points_not_in_segments(segments, m):\n    points = set(range(1, m+1))\n    for (l, r) in segments:\n        for p in range(l, r+1):\n            if p in points:\n                points.remove(p)\n    return len(points), sorted(points)\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    segments = []\n    for _ in range(n):\n        segments.append(tuple(map(int, input().split())))\n    k, points = find_points_not_in_segments(segments, m)\n    print(k)\n    print(*points)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef find_free_points(segments, m):\n    \"\"\"\n    >>> find_free_points([(2, 2), (1, 2), (5, 5)], 5)\n    [3, 4]\n    >>> find_free_points([(1, 7)], 7)\n    []\n    \"\"\"\n    free_points = []\n    if len(segments) == 1:\n        return free_points\n    for i in range(1, m + 1):\n        is_free = True\n        for segment in segments:\n            if i >= segment[0] and i <= segment[1]:\n                is_free = False\n                break\n        if is_free:\n            free_points.append(i)\n    return free_points\n\n\nif __name__ == \"__main__\":\n    n, m = [int(x) for x in input().split()]\n    segments = []\n    for i in range(n):\n        l, r = [int(x) for x in input().split()]\n        segments.append((l, r))\n    free_points = find_free_points(segments, m)\n    print(len(free_points))\n    print(\" \".join([str(x) for x in free_points]))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    points = set(range(1, m+1))\n    for i in range(n):\n        l, r = map(int, input().split())\n        points = points.difference(range(l, r+1))\n    print(len(points))\n    print(*points)\n\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1649877922,
  "id": "cmpl-4wcuAti9Cyub2rKcPamVapeQW40Fr",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 19:25:44.800294 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": ""
}
2022-04-13 19:25:44.800332 REASON stop
2022-04-13 19:25:44.800935 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": ""
}
2022-04-13 19:25:44.801072 REASON stop
2022-04-13 19:25:44.801547 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport collections\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    points = set(range(1, m+1))\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        points = points - set(range(l, r+1))\n    print(len(points))\n    print(*sorted(points))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 19:25:44.801606 REASON stop
2022-04-13 19:25:44.814528 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef get_points(n, m):\n    points = set(range(1, m+1))\n    for i in range(n):\n        l, r = map(int, input().split())\n        points -= set(range(l, r+1))\n    return points\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    points = get_points(n, m)\n    print(len(points))\n    print(*points)"
}
2022-04-13 19:25:44.814626 REASON stop
2022-04-13 19:25:44.834116 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n\ndef find_points_not_in_segments(segments, m):\n    points = set(range(1, m+1))\n    for (l, r) in segments:\n        for p in range(l, r+1):\n            if p in points:\n                points.remove(p)\n    return len(points), sorted(points)\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    segments = []\n    for _ in range(n):\n        segments.append(tuple(map(int, input().split())))\n    k, points = find_points_not_in_segments(segments, m)\n    print(k)\n    print(*points)"
}
2022-04-13 19:25:44.834228 REASON stop
2022-04-13 19:25:44.835009 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef find_free_points(segments, m):\n    \"\"\"\n    >>> find_free_points([(2, 2), (1, 2), (5, 5)], 5)\n    [3, 4]\n    >>> find_free_points([(1, 7)], 7)\n    []\n    \"\"\"\n    free_points = []\n    if len(segments) == 1:\n        return free_points\n    for i in range(1, m + 1):\n        is_free = True\n        for segment in segments:\n            if i >= segment[0] and i <= segment[1]:\n                is_free = False\n                break\n        if is_free:\n            free_points.append(i)\n    return free_points\n\n\nif __name__ == \"__main__\":\n    n, m = [int(x) for x in input().split()]\n    segments = []\n    for i in range(n):\n        l, r = [int(x) for x in input().split()]\n        segments.append((l, r))\n    free_points = find_free_points(segments, m)\n    print(len(free_points))\n    print(\" \".join([str(x) for x in free_points]))"
}
2022-04-13 19:25:44.835080 REASON stop
2022-04-13 19:25:44.835926 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    points = set(range(1, m+1))\n    for i in range(n):\n        l, r = map(int, input().split())\n        points = points.difference(range(l, r+1))\n    print(len(points))\n    print(*points)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:25:44.836047 REASON stop
