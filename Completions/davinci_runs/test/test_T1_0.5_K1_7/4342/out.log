2022-04-13 20:11:18.996604 """
You are given an undirected tree of $n$ vertices. 

Some vertices are colored blue, some are colored red and some are uncolored. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.

You choose an edge and remove it from the tree. Tree falls apart into two connected components. Let's call an edge nice if neither of the resulting components contain vertices of both red and blue colors.

How many nice edges are there in the given tree?


-----Input-----

The first line contains a single integer $n$ ($2 \le n \le 3 \cdot 10^5$) — the number of vertices in the tree.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($0 \le a_i \le 2$) — the colors of the vertices. $a_i = 1$ means that vertex $i$ is colored red, $a_i = 2$ means that vertex $i$ is colored blue and $a_i = 0$ means that vertex $i$ is uncolored.

The $i$-th of the next $n - 1$ lines contains two integers $v_i$ and $u_i$ ($1 \le v_i, u_i \le n$, $v_i \ne u_i$) — the edges of the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the tree contains at least one red vertex and at least one blue vertex.


-----Output-----

Print a single integer — the number of nice edges in the given tree.


-----Examples-----
Input
5
2 0 0 1 2
1 2
2 3
2 4
2 5

Output
1

Input
5
1 0 0 0 2
1 2
2 3
3 4
4 5

Output
4

Input
3
1 1 2
2 3
1 3

Output
0



-----Note-----

Here is the tree from the first example: [Image] 

The only nice edge is edge $(2, 4)$. Removing it makes the tree fall apart into components $\{4\}$ and $\{1, 2, 3, 5\}$. The first component only includes a red vertex and the second component includes blue vertices and uncolored vertices.

Here is the tree from the second example: [Image] 

Every edge is nice in it.

Here is the tree from the third example: [Image] 

Edge $(1, 3)$ splits the into components $\{1\}$ and $\{3, 2\}$, the latter one includes both red and blue vertex, thus the edge isn't nice. Edge $(2, 3)$ splits the into components $\{1, 3\}$ and $\{2\}$, the former one includes both red and blue vertex, thus the edge also isn't nice. So the answer is 0.
"""
2022-04-13 20:11:18.996622 --------------------------
2022-04-13 20:12:06.629494 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    colors = list(map(int, input().split()))\n    edges = []\n    for i in range(n-1):\n        edges.append(list(map(int, input().split())))\n    print(edges)\n    print(colors)\n\nif __name__ == '__main__':\n    sys.exit(main())"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    # read number of vertices\n    n = int(input())\n    # read color of vertices\n    a = list(map(int, input().split()))\n    # read edges\n    edges = []\n    for _ in range(n-1):\n        edges.append(tuple(map(int, input().split())))\n    # print(n, a, edges)\n    # build adjacency list\n    adj = [[] for _ in range(n+1)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    # print(adj)\n    # count nice edges\n    nice_edges = 0\n    for edge in edges:\n        # check if the edge is nice\n        # color of the vertex on the left side\n        color_l = a[edge[0]-1]\n        # color of the vertex on the right side\n        color_r = a[edge[1]-1]\n        # colors of vertices on the left side\n        colors_l = [color_l]\n        # colors of vertices on the right side\n        colors_r = [color_r]\n        # check colors of vertices on the left side\n        if color_l == 0:\n            colors_l = check_colors(adj, edge[0], colors_l)\n        # check colors of vertices on the right side\n        if color_r == 0:\n            colors_r = check_colors(adj, edge[1], colors_r)\n        # print(edge, colors_l, colors_r)\n        # check if the edge is nice\n        if (1 not in colors_l and 2 not in colors_r) or (1 not in colors_r and 2 not in colors_l):\n            nice_edges += 1\n    # print result\n    print(nice_edges)\n\n# check colors of vertices\ndef check_colors(adj, v, colors):\n    for u in adj[v]:\n        if a[u-1] != 0:\n            colors.append(a[u-1])\n        else:\n            colors = check_colors(adj, u, colors)\n    return colors\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\n#sys.stdin = open(\"in1.txt\")\n\ninput = sys.stdin.readline\n\nn = int(input())\nc = list(map(int, input().split()))\n\ng = defaultdict(list)\nfor i in range(n-1):\n    v, u = map(int, input().split())\n    g[v].append(u)\n    g[u].append(v)\n\n\ndef dfs(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs(u, v)\n    if c[v] == 1:\n        return 1 + cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return 0\n\n\ndef dfs2(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs2(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return 1 + cnt\n    else:\n        return 0\n\n\ndef dfs3(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs3(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return 1 + cnt\n\n\ndef dfs4(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs4(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return cnt\n\n\ndef dfs5(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs5(u, v)\n    if c[v] == 1:\n        return 1 + cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return cnt\n\n\ndef dfs6(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs6(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return 1 + cnt\n    else:\n        return cnt\n\n\nans = 0\nfor v in range(1, n+1):\n    for u in g[v]:\n        if dfs(v, u) == 0 or dfs2(u, v) == 0:\n            ans += 1\n        elif dfs3(v, u) == 0 or dfs4(u, v) == 0:\n            ans += 1\n        elif dfs5(v, u) == 0 or dfs6(u, v) == 0:\n            ans += 1\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    colors = map(int, input().split())\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n\n    def dfs(node, parent):\n        if colors[node - 1] == 0:\n            return False, False\n        elif colors[node - 1] == 1:\n            red = True\n        else:\n            blue = True\n        for child in tree[node]:\n            if child != parent:\n                child_red, child_blue = dfs(child, node)\n                red = red or child_red\n                blue = blue or child_blue\n        return red, blue\n\n    ans = 0\n    for node in range(1, n + 1):\n        for child in tree[node]:\n            red, blue = dfs(node, child)\n            red2, blue2 = dfs(child, node)\n            if (red and not blue2) or (red2 and not blue):\n                ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef find_parent(parent, a):\n    if parent[a] != a:\n        parent[a] = find_parent(parent, parent[a])\n    return parent[a]\n\ndef union(parent, a, b):\n    a = find_parent(parent, a)\n    b = find_parent(parent, b)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\ndef solution(n, a, edges):\n    parent = [0] * (n + 1)\n    for i in range(1, n + 1):\n        parent[i] = i\n    for v, u in edges:\n        union(parent, v, u)\n    count = [0] * (n + 1)\n    for i in range(1, n + 1):\n        count[find_parent(parent, i)] += 1\n    red = [0] * (n + 1)\n    blue = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if a[i - 1] == 1:\n            red[find_parent(parent, i)] += 1\n        elif a[i - 1] == 2:\n            blue[find_parent(parent, i)] += 1\n    ans = 0\n    for i in range(1, n + 1):\n        if red[i] == 0 or blue[i] == 0:\n            ans += count[i] - 1\n    return ans\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    edges = []\n    for i in range(n - 1):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n    print(solution(n, a, edges))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef get_input():\n    n = int(input())\n    colors = [int(x) for x in input().split()]\n    edges = []\n    for i in range(n-1):\n        edges.append([int(x) for x in input().split()])\n    return n, colors, edges\n\ndef main():\n    n, colors, edges = get_input()\n    print(n, colors, edges)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\n\ncolors = list(map(int, input().split()))\n\ntree = [ [] for _ in range(n) ]\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    tree[a - 1].append(b - 1)\n    tree[b - 1].append(a - 1)\n\nred = colors.count(1)\nblue = colors.count(2)\n\ndef dfs(v, p, c):\n    global colors, tree, red, blue\n    if colors[v] == c:\n        red -= 1\n        blue -= 1\n    for u in tree[v]:\n        if u == p:\n            continue\n        dfs(u, v, c)\n\ndef check_edge(v, p):\n    global colors, tree, red, blue\n    r = red\n    b = blue\n    dfs(v, p, 1)\n    r -= red\n    red = b\n    blue = b\n    dfs(v, p, 2)\n    b -= blue\n    return (r == 0 or b == 0)\n\nans = 0\n\nfor v in range(n):\n    for u in tree[v]:\n        if check_edge(u, v):\n            ans += 1\n\nprint(ans)"
    }
  ],
  "created": 1649880679,
  "id": "cmpl-4wdcd4p4QdqHLJcl237MolMD0VUjf",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:12:06.629861 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    colors = list(map(int, input().split()))\n    edges = []\n    for i in range(n-1):\n        edges.append(list(map(int, input().split())))\n    print(edges)\n    print(colors)\n\nif __name__ == '__main__':\n    sys.exit(main())"
}
2022-04-13 20:12:06.629904 REASON stop
2022-04-13 20:12:06.630277 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    # read number of vertices\n    n = int(input())\n    # read color of vertices\n    a = list(map(int, input().split()))\n    # read edges\n    edges = []\n    for _ in range(n-1):\n        edges.append(tuple(map(int, input().split())))\n    # print(n, a, edges)\n    # build adjacency list\n    adj = [[] for _ in range(n+1)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    # print(adj)\n    # count nice edges\n    nice_edges = 0\n    for edge in edges:\n        # check if the edge is nice\n        # color of the vertex on the left side\n        color_l = a[edge[0]-1]\n        # color of the vertex on the right side\n        color_r = a[edge[1]-1]\n        # colors of vertices on the left side\n        colors_l = [color_l]\n        # colors of vertices on the right side\n        colors_r = [color_r]\n        # check colors of vertices on the left side\n        if color_l == 0:\n            colors_l = check_colors(adj, edge[0], colors_l)\n        # check colors of vertices on the right side\n        if color_r == 0:\n            colors_r = check_colors(adj, edge[1], colors_r)\n        # print(edge, colors_l, colors_r)\n        # check if the edge is nice\n        if (1 not in colors_l and 2 not in colors_r) or (1 not in colors_r and 2 not in colors_l):\n            nice_edges += 1\n    # print result\n    print(nice_edges)\n\n# check colors of vertices\ndef check_colors(adj, v, colors):\n    for u in adj[v]:\n        if a[u-1] != 0:\n            colors.append(a[u-1])\n        else:\n            colors = check_colors(adj, u, colors)\n    return colors\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:12:06.630403 REASON stop
2022-04-13 20:12:06.630737 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\n#sys.stdin = open(\"in1.txt\")\n\ninput = sys.stdin.readline\n\nn = int(input())\nc = list(map(int, input().split()))\n\ng = defaultdict(list)\nfor i in range(n-1):\n    v, u = map(int, input().split())\n    g[v].append(u)\n    g[u].append(v)\n\n\ndef dfs(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs(u, v)\n    if c[v] == 1:\n        return 1 + cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return 0\n\n\ndef dfs2(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs2(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return 1 + cnt\n    else:\n        return 0\n\n\ndef dfs3(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs3(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return 1 + cnt\n\n\ndef dfs4(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs4(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return cnt\n\n\ndef dfs5(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs5(u, v)\n    if c[v] == 1:\n        return 1 + cnt\n    elif c[v] == 2:\n        return cnt\n    else:\n        return cnt\n\n\ndef dfs6(v, p):\n    cnt = 0\n    for u in g[v]:\n        if u == p: continue\n        cnt += dfs6(u, v)\n    if c[v] == 1:\n        return cnt\n    elif c[v] == 2:\n        return 1 + cnt\n    else:\n        return cnt\n\n\nans = 0\nfor v in range(1, n+1):\n    for u in g[v]:\n        if dfs(v, u) == 0 or dfs2(u, v) == 0:\n            ans += 1\n        elif dfs3(v, u) == 0 or dfs4(u, v) == 0:\n            ans += 1\n        elif dfs5(v, u) == 0 or dfs6(u, v) == 0:\n            ans += 1\nprint(ans)"
}
2022-04-13 20:12:06.630787 REASON stop
2022-04-13 20:12:06.655892 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    colors = map(int, input().split())\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n\n    def dfs(node, parent):\n        if colors[node - 1] == 0:\n            return False, False\n        elif colors[node - 1] == 1:\n            red = True\n        else:\n            blue = True\n        for child in tree[node]:\n            if child != parent:\n                child_red, child_blue = dfs(child, node)\n                red = red or child_red\n                blue = blue or child_blue\n        return red, blue\n\n    ans = 0\n    for node in range(1, n + 1):\n        for child in tree[node]:\n            red, blue = dfs(node, child)\n            red2, blue2 = dfs(child, node)\n            if (red and not blue2) or (red2 and not blue):\n                ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 20:12:06.655994 REASON stop
2022-04-13 20:12:06.664076 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef find_parent(parent, a):\n    if parent[a] != a:\n        parent[a] = find_parent(parent, parent[a])\n    return parent[a]\n\ndef union(parent, a, b):\n    a = find_parent(parent, a)\n    b = find_parent(parent, b)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\ndef solution(n, a, edges):\n    parent = [0] * (n + 1)\n    for i in range(1, n + 1):\n        parent[i] = i\n    for v, u in edges:\n        union(parent, v, u)\n    count = [0] * (n + 1)\n    for i in range(1, n + 1):\n        count[find_parent(parent, i)] += 1\n    red = [0] * (n + 1)\n    blue = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if a[i - 1] == 1:\n            red[find_parent(parent, i)] += 1\n        elif a[i - 1] == 2:\n            blue[find_parent(parent, i)] += 1\n    ans = 0\n    for i in range(1, n + 1):\n        if red[i] == 0 or blue[i] == 0:\n            ans += count[i] - 1\n    return ans\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    edges = []\n    for i in range(n - 1):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n    print(solution(n, a, edges))"
}
2022-04-13 20:12:06.664167 REASON stop
2022-04-13 20:12:06.665645 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef get_input():\n    n = int(input())\n    colors = [int(x) for x in input().split()]\n    edges = []\n    for i in range(n-1):\n        edges.append([int(x) for x in input().split()])\n    return n, colors, edges\n\ndef main():\n    n, colors, edges = get_input()\n    print(n, colors, edges)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 20:12:06.665720 REASON stop
2022-04-13 20:12:06.666357 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\n\ncolors = list(map(int, input().split()))\n\ntree = [ [] for _ in range(n) ]\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    tree[a - 1].append(b - 1)\n    tree[b - 1].append(a - 1)\n\nred = colors.count(1)\nblue = colors.count(2)\n\ndef dfs(v, p, c):\n    global colors, tree, red, blue\n    if colors[v] == c:\n        red -= 1\n        blue -= 1\n    for u in tree[v]:\n        if u == p:\n            continue\n        dfs(u, v, c)\n\ndef check_edge(v, p):\n    global colors, tree, red, blue\n    r = red\n    b = blue\n    dfs(v, p, 1)\n    r -= red\n    red = b\n    blue = b\n    dfs(v, p, 2)\n    b -= blue\n    return (r == 0 or b == 0)\n\nans = 0\n\nfor v in range(n):\n    for u in tree[v]:\n        if check_edge(u, v):\n            ans += 1\n\nprint(ans)"
}
2022-04-13 20:12:06.666465 REASON stop
