2022-04-13 21:08:03.409985 """
The only difference between easy and hard versions is the maximum value of $n$.

You are given a positive integer number $n$. You really love good numbers so you want to find the smallest good number greater than or equal to $n$.

The positive integer is called good if it can be represented as a sum of distinct powers of $3$ (i.e. no duplicates of powers of $3$ are allowed).

For example:

  $30$ is a good number: $30 = 3^3 + 3^1$,  $1$ is a good number: $1 = 3^0$,  $12$ is a good number: $12 = 3^2 + 3^1$,  but $2$ is not a good number: you can't represent it as a sum of distinct powers of $3$ ($2 = 3^0 + 3^0$),  $19$ is not a good number: you can't represent it as a sum of distinct powers of $3$ (for example, the representations $19 = 3^2 + 3^2 + 3^0 = 3^2 + 3^1 + 3^1 + 3^1 + 3^0$ are invalid),  $20$ is also not a good number: you can't represent it as a sum of distinct powers of $3$ (for example, the representation $20 = 3^2 + 3^2 + 3^0 + 3^0$ is invalid). 

Note, that there exist other representations of $19$ and $20$ as sums of powers of $3$ but none of them consists of distinct powers of $3$.

For the given positive integer $n$ find such smallest $m$ ($n \le m$) that $m$ is a good number.

You have to answer $q$ independent queries.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) â€” the number of queries. Then $q$ queries follow.

The only line of the query contains one integer $n$ ($1 \le n \le 10^{18}$).


-----Output-----

For each query, print such smallest integer $m$ (where $n \le m$) that $m$ is a good number.


-----Example-----
Input
8
1
2
6
13
14
3620
10000
1000000000000000000

Output
1
3
9
13
27
6561
19683
1350851717672992089
"""
2022-04-13 21:08:03.410008 --------------------------
2022-04-13 21:08:26.688796 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef get_good_number(n):\n    \"\"\"\n    This function takes an integer $n$ and returns the smallest good number \n    greater than or equal to $n$.\n    \"\"\"\n    good = 0\n    while n > good:\n        good = 3*good + 1\n    return good\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    print(get_good_number(n))\n\n# for line in sys.stdin:\n#     n = int(line)\n#     print(get_good_number(n))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"my code here\"\"\"\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        if n == 1:\n            print(1)\n        else:\n            print(calc(n))\n\n\ndef calc(n):\n    \"\"\"calculate the smallest good number greater than or equal to n\"\"\"\n    m = n\n    if n % 3 == 0:\n        m = n\n    elif n % 3 == 1:\n        m = n + 2\n    else:\n        m = n + 1\n    while not check_good(m):\n        m += 3\n    return m\n\n\ndef check_good(n):\n    \"\"\"check if n is a good number\"\"\"\n    if n == 1:\n        return True\n    m = n\n    while m % 3 == 0:\n        m = m // 3\n    if m == 1:\n        return True\n    return False\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    # get input\n    q = int(sys.stdin.readline())\n    for _ in range(q):\n        n = int(sys.stdin.readline())\n        # algorithm\n        # if n is a power of 3, then we're done\n        # if not, we want to find the next power of 3\n        # the next power of 3 is the power of 3 that is just larger than n\n        # if n is not a power of 3, then n + 1 is a power of 3\n        # if n is a power of 3, then n + 2 is a power of 3\n        if n == 1:\n            print(1)\n            continue\n        if n%3 == 0:\n            print(n)\n            continue\n        if n%3 == 1:\n            print(n+2)\n            continue\n        if n%3 == 2:\n            print(n+1)\n            continue\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef is_good(n):\n    if n == 1:\n        return True\n    else:\n        for i in range(1, int(math.log(n, 3)) + 1):\n            if n % 3**i == 0:\n                return is_good(n - 3**i)\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        while not is_good(n):\n            n += 1\n        print(n)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef is_good(n):\n    if n == 1:\n        return True\n    else:\n        return n % 3 != 0\n\ndef next_good(n):\n    if is_good(n):\n        return n\n    else:\n        return next_good(n + 1)\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        print(next_good(n))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# q = int(input())\n# for i in range(q):\n#     n = int(input())\n#     m = n\n#     while True:\n#         if m == 1:\n#             break\n#         m = (m - 1) / 3\n#         if m == int(m):\n#             break\n#         else:\n#             m = int(m) + 1\n#     print(int(m))\n\n# def is_good(n):\n#     while True:\n#         if n == 1:\n#             return True\n#         n = (n - 1) / 3\n#         if n == int(n):\n#             return True\n#         else:\n#             n = int(n) + 1\n#             if n == 1:\n#                 return False\n\n# q = int(input())\n# for i in range(q):\n#     n = int(input())\n#     m = n\n#     while True:\n#         if is_good(m):\n#             break\n#         m += 1\n#     print(m)\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    m = n\n    while True:\n        if m == 1:\n            break\n        m = (m - 1) / 3\n        if m == int(m):\n            break\n        else:\n            m = int(m) + 1\n    print(int(m))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport bisect\n\ndef find_good(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 3\n    if n == 3:\n        return 9\n\n    # We want to find the sum of the first i powers of 3 that is >= n.\n    # The powers of 3 are monotonically increasing, so we can use bisect to\n    # find the first i such that 3^i >= n.\n    i = bisect.bisect_left(powers_of_3, n)\n    if powers_of_3[i] == n:\n        return n\n\n    # Now we want to find the sum of the first i-1 powers of 3 that is >= n.\n    # The sum of the first i-1 powers of 3 is the sum of the first i powers of\n    # 3 minus the i-th power of 3.\n    return powers_of_3[i] + find_good(n - powers_of_3[i-1])\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        print(find_good(n))\n\nif __name__ == '__main__':\n    powers_of_3 = [3**i for i in range(61)]\n    main()"
    }
  ],
  "created": 1649884083,
  "id": "cmpl-4weVXjPeRyqjkEGwc3s8r31wYdpDe",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:08:26.689112 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef get_good_number(n):\n    \"\"\"\n    This function takes an integer $n$ and returns the smallest good number \n    greater than or equal to $n$.\n    \"\"\"\n    good = 0\n    while n > good:\n        good = 3*good + 1\n    return good\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    print(get_good_number(n))\n\n# for line in sys.stdin:\n#     n = int(line)\n#     print(get_good_number(n))"
}
2022-04-13 21:08:26.689149 REASON stop
2022-04-13 21:08:26.689641 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"my code here\"\"\"\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        if n == 1:\n            print(1)\n        else:\n            print(calc(n))\n\n\ndef calc(n):\n    \"\"\"calculate the smallest good number greater than or equal to n\"\"\"\n    m = n\n    if n % 3 == 0:\n        m = n\n    elif n % 3 == 1:\n        m = n + 2\n    else:\n        m = n + 1\n    while not check_good(m):\n        m += 3\n    return m\n\n\ndef check_good(n):\n    \"\"\"check if n is a good number\"\"\"\n    if n == 1:\n        return True\n    m = n\n    while m % 3 == 0:\n        m = m // 3\n    if m == 1:\n        return True\n    return False\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:08:26.689784 REASON stop
2022-04-13 21:08:26.690164 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    # get input\n    q = int(sys.stdin.readline())\n    for _ in range(q):\n        n = int(sys.stdin.readline())\n        # algorithm\n        # if n is a power of 3, then we're done\n        # if not, we want to find the next power of 3\n        # the next power of 3 is the power of 3 that is just larger than n\n        # if n is not a power of 3, then n + 1 is a power of 3\n        # if n is a power of 3, then n + 2 is a power of 3\n        if n == 1:\n            print(1)\n            continue\n        if n%3 == 0:\n            print(n)\n            continue\n        if n%3 == 1:\n            print(n+2)\n            continue\n        if n%3 == 2:\n            print(n+1)\n            continue\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:08:26.690212 REASON stop
2022-04-13 21:08:26.709040 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef is_good(n):\n    if n == 1:\n        return True\n    else:\n        for i in range(1, int(math.log(n, 3)) + 1):\n            if n % 3**i == 0:\n                return is_good(n - 3**i)\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        while not is_good(n):\n            n += 1\n        print(n)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:08:26.709109 REASON stop
2022-04-13 21:08:26.736657 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef is_good(n):\n    if n == 1:\n        return True\n    else:\n        return n % 3 != 0\n\ndef next_good(n):\n    if is_good(n):\n        return n\n    else:\n        return next_good(n + 1)\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        print(next_good(n))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:08:26.736751 REASON stop
2022-04-13 21:08:26.737560 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# q = int(input())\n# for i in range(q):\n#     n = int(input())\n#     m = n\n#     while True:\n#         if m == 1:\n#             break\n#         m = (m - 1) / 3\n#         if m == int(m):\n#             break\n#         else:\n#             m = int(m) + 1\n#     print(int(m))\n\n# def is_good(n):\n#     while True:\n#         if n == 1:\n#             return True\n#         n = (n - 1) / 3\n#         if n == int(n):\n#             return True\n#         else:\n#             n = int(n) + 1\n#             if n == 1:\n#                 return False\n\n# q = int(input())\n# for i in range(q):\n#     n = int(input())\n#     m = n\n#     while True:\n#         if is_good(m):\n#             break\n#         m += 1\n#     print(m)\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    m = n\n    while True:\n        if m == 1:\n            break\n        m = (m - 1) / 3\n        if m == int(m):\n            break\n        else:\n            m = int(m) + 1\n    print(int(m))"
}
2022-04-13 21:08:26.737630 REASON stop
2022-04-13 21:08:26.738411 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport bisect\n\ndef find_good(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 3\n    if n == 3:\n        return 9\n\n    # We want to find the sum of the first i powers of 3 that is >= n.\n    # The powers of 3 are monotonically increasing, so we can use bisect to\n    # find the first i such that 3^i >= n.\n    i = bisect.bisect_left(powers_of_3, n)\n    if powers_of_3[i] == n:\n        return n\n\n    # Now we want to find the sum of the first i-1 powers of 3 that is >= n.\n    # The sum of the first i-1 powers of 3 is the sum of the first i powers of\n    # 3 minus the i-th power of 3.\n    return powers_of_3[i] + find_good(n - powers_of_3[i-1])\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        print(find_good(n))\n\nif __name__ == '__main__':\n    powers_of_3 = [3**i for i in range(61)]\n    main()"
}
2022-04-13 21:08:26.738482 REASON stop
