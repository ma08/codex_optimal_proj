["\n\nimport sys\n\nclass Edge:\n    def __init__(self, to, cost):\n        self.to = to\n        self.cost = cost\n\nclass Vertex:\n    def __init__(self, cost):\n        self.cost = cost\n        self.edges = []\n\ndef find(x):\n    if x != parent[x]:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef merge(x, y):\n    x = find(x)\n    y = find(y)\n    if x != y:\n        parent[x] = y\n\ndef kruskal(n):\n    global parent\n    parent = [i for i in range(n)]\n    cost = 0\n    for edge in edges:\n        if find(edge.to[0]) != find(edge.to[1]):\n            cost += edge.cost\n            merge(edge.to[0], edge.to[1])\n    return cost\n\nn, m = map(int, sys.stdin.readline().split())\nvertices = [Vertex(cost) for cost in map(int, sys.stdin.readline().split())]\nedges = []\nfor _ in range(m):\n    x, y, w = map(int, sys.stdin.readline().split())\n    edges.append(Edge((x - 1, y - 1), w))\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        edges.append(Edge((i, j), vertices[i].cost + vertices[j].cost))\n\nedges.sort(key=lambda edge: edge.cost)\nprint(kruskal(n))", "\n\nimport sys\n\ndef main():\n    global n, m, a, d, s, p, t\n    line = sys.stdin.readline()\n    n, m = [int(x) for x in line.split()]\n    line = sys.stdin.readline()\n    a = [int(x) for x in line.split()]\n    d = [[0] * n for i in range(n)]\n    for i in range(n):\n        d[i][i] = a[i]\n    for i in range(m):\n        line = sys.stdin.readline()\n        x, y, w = [int(x) for x in line.split()]\n        d[x - 1][y - 1] = w\n        d[y - 1][x - 1] = w\n    s = [0] * n\n    p = [0] * n\n    t = 0\n    for i in range(n):\n        if s[i] == 0:\n            dfs(i)\n    ans = 0\n    for i in range(n):\n        ans += d[i][p[i]]\n    print(ans)\n\ndef dfs(v):\n    global n, m, a, d, s, p, t\n    s[v] = 1\n    for i in range(n):\n        if d[v][i] != 0 and s[i] == 0:\n            p[i] = v\n            dfs(i)\n    t += 1\n    s[v] = t\n\nif __name__ == '__main__':\n    main()", "\n\n# SOLUTION\n# The solution is to find the minimum spanning tree of the graph, and then add the edges that are not in the MST.\n# The MST can be found using Prim's algorithm, which can be done in $O(E \\log V)$ time.\n# Then, it can be done in $O(N^2)$ time to find the edges that are not in the MST.\n# The total time complexity is $O(N^2)$.\n\n# This solution is not fast enough to pass the time limit.\n\nfrom collections import defaultdict\n\n# V - number of vertices\n# E - number of edges\nV, E = map(int, input().split())\n# a - list of values on each vertex\na = list(map(int, input().split()))\n\n# graph - dictionary of edges, where each vertex is a key, and the value is a list of tuples (vertex, weight)\ngraph = defaultdict(list)\n\n# add edges to the graph\nfor _ in range(E):\n    x, y, w = map(int, input().split())\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# visited - list of visited vertices\n# s - list of vertices to be visited\nvisited = [False] * (V + 1)\ns = [1]\n\n# mst - list of edges in the MST\nmst = []\n\nwhile s:\n    # current - the vertex to be visited\n    current = s.pop()\n    visited[current] = True\n\n    # add edges to the MST\n    for n, w in graph[current]:\n        if not visited[n]:\n            s.append(n)\n            mst.append((current, n, w))\n\n# edges - list of edges not in the MST\nedges = []\n\n# add edges not in the MST\nfor i in range(1, V + 1):\n    for j in range(i + 1, V + 1):\n        if (i, j) not in [(x, y) for x, y, _ in mst] and (j, i) not in [(x, y) for x, y, _ in mst]:\n            edges.append((i, j, a[i - 1] + a[j - 1]))\n\n# add the edges not in the MST to the MST\nmst += edges\n\n# print the sum of all the weights\nprint(sum(w for _, _, w in mst))", "\nimport heapq\n\nclass DisjointSet(object):\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0] * n\n        self.count = n\n\n    def find(self, x):\n        while x != self.parent[x]:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.parent[y_root] = x_root\n        else:\n            self.parent[y_root] = x_root\n            self.rank[x_root] += 1\n        self.count -= 1\n\n    def get_count(self):\n        return self.count\n\n\nclass Solution(object):\n    def minCostToConnectAllNodes(self, n, edges, special_edges):\n        ds = DisjointSet(n)\n        normal_edges = []\n        for edge in edges:\n            if ds.find(edge[0]) != ds.find(edge[1]):\n                ds.union(edge[0], edge[1])\n                normal_edges.append(edge)\n        if ds.get_count() == 1:\n            return 0\n        heapq.heapify(special_edges)\n        total_cost = 0\n        while special_edges:\n            cost, start, end = heapq.heappop(special_edges)\n            if ds.find(start) != ds.find(end):\n                ds.union(start, end)\n                total_cost += cost\n                if ds.get_count() == 1:\n                    return total_cost\n        for edge in normal_edges:\n            if ds.find(edge[0]) != ds.find(edge[1]):\n                ds.union(edge[0], edge[1])\n                total_cost += edge[2]\n                if ds.get_count() == 1:\n                    return total_cost\n        return total_cost\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    costs = list(map(int, input().split()))\n    edges = []\n    special_edges = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        special_edges.append((w, x - 1, y - 1))\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((costs[i] + costs[j], i, j))\n    print(Solution().minCostToConnectAllNodes(n, edges, special_edges))", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offer = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        offer.append([x - 1, y - 1, w])\n    offer = sorted(offer, key=lambda x: x[2])\n    ans = 0\n    father = [i for i in range(n)]\n    size = [1] * n\n    for i in range(m):\n        x, y, w = offer[i]\n        if find(x, father) != find(y, father):\n            ans += w\n            union(x, y, father, size)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if find(i, father) != find(j, father):\n                ans += a[i] + a[j]\n                union(i, j, father, size)\n    print(ans)\n\n\ndef find(x, father):\n    if father[x] == x:\n        return x\n    else:\n        father[x] = find(father[x], father)\n        return father[x]\n\n\ndef union(x, y, father, size):\n    fx = find(x, father)\n    fy = find(y, father)\n    if size[fx] > size[fy]:\n        father[fy] = fx\n        size[fx] += size[fy]\n    else:\n        father[fx] = fy\n        size[fy] += size[fx]\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()", "\n\n#O(N**2)\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\np = [i for i in range(n)]\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef union(x, y):\n    p[find(x)] = find(y)\n\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    x -= 1\n    y -= 1\n    if w < a[x] + a[y]:\n        union(x, y)\n\nans = 0\nfor i in range(n):\n    if i != find(i):\n        ans += a[i]\nprint(ans)"]