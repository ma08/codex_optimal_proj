2022-04-13 18:22:06.368247 """
The only difference between easy and hard versions is the constraints.

Vova likes pictures with kittens. The news feed in the social network he uses can be represented as an array of $n$ consecutive pictures (with kittens, of course). Vova likes all these pictures, but some are more beautiful than the others: the $i$-th picture has beauty $a_i$.

Vova wants to repost exactly $x$ pictures in such a way that:   each segment of the news feed of at least $k$ consecutive pictures has at least one picture reposted by Vova;  the sum of beauty values of reposted pictures is maximum possible. 

For example, if $k=1$ then Vova has to repost all the pictures in the news feed. If $k=2$ then Vova can skip some pictures, but between every pair of consecutive pictures Vova has to repost at least one of them.

Your task is to calculate the maximum possible sum of values of reposted pictures if Vova follows conditions described above, or say that there is no way to satisfy all conditions.


-----Input-----

The first line of the input contains three integers $n, k$ and $x$ ($1 \le k, x \le n \le 5000$) — the number of pictures in the news feed, the minimum length of segment with at least one repost in it and the number of pictures Vova is ready to repost.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$), where $a_i$ is the beauty of the $i$-th picture.


-----Output-----

Print -1 if there is no way to repost some pictures to satisfy all the conditions in the problem statement.

Otherwise print one integer — the maximum sum of values of reposted pictures if Vova follows conditions described in the problem statement.


-----Examples-----
Input
5 2 3
5 1 3 10 1

Output
18

Input
6 1 5
10 30 30 70 10 10

Output
-1

Input
4 3 1
1 100 1 1

Output
100
"""
2022-04-13 18:22:06.368263 --------------------------
2022-04-13 18:22:53.663337 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k, x = [int(x) for x in sys.stdin.readline().split()]\n    a = [int(x) for x in sys.stdin.readline().split()]\n    \n    if x < n - k + 1:\n        print(-1)\n        return\n    \n    # dp[i][j] = maximum sum of the first i items\n    #            if there are j items in the last k items\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    \n    # Initialize\n    dp[0][0] = a[0]\n    \n    # The first k items\n    for i in range(1, k):\n        dp[i][i] = dp[i - 1][i - 1] + a[i]\n    \n    # The rest\n    for i in range(k, n):\n        for j in range(k):\n            dp[i][j] = max(dp[i - 1][j] + a[i], dp[i - 1][(j + 1) % k])\n    \n    print(dp[n - 1][(k - (n - x)) % k])\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0 for _ in range(x+1)] for _ in range(n+1)]\n\nfor i in range(n):\n    for j in range(1, x+1):\n        dp[i+1][j] = max(dp[i][j], dp[i+1][j-1])\n        if i-k+1 >= 0:\n            dp[i+1][j] = max(dp[i+1][j], dp[i-k+1][j-1]+sum(a[i-k+1:i+1]))\n\nprint(dp[n][x] if dp[n][x] else -1)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# print(n, k, x)\n# print(a)\n\nif x < k:\n    print(-1)\n    exit()\n\n# set up a prefix sum array\nprefix_sum = [a[0]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + a[i])\n\n# print(prefix_sum)\n\n# set up a DP array, where the index is the number of pictures to repost,\n# and the value is the maximum possible sum of reposted pictures\ndp = [0] * (x + 1)\n\n# set up the maximum possible sum of reposted pictures for x = k\nfor i in range(1, k + 1):\n    dp[i] = prefix_sum[i - 1]\n\n# print(dp)\n\n# set up the maximum possible sum of reposted pictures for x > k\nfor i in range(k + 1, x + 1):\n    for j in range(1, k):\n        dp[i] = max(dp[i], dp[i - j] + prefix_sum[i - 1] - prefix_sum[i - j - 1])\n    dp[i] = max(dp[i], dp[i - k] + prefix_sum[i - 1] - prefix_sum[i - k - 1])\n\nprint(dp[-1])"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn, k, x = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nif x < k:\n    print(-1)\n    exit()\n\ndp = [[0 for j in range(x+1)] for i in range(n+1)]\n\nfor i in range(1, n+1):\n    for j in range(1, x+1):\n        if i < k:\n            dp[i][j] = max(dp[i-1][j], a[i-1])\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i-k][j-1] + a[i-1])\n\nprint(dp[n][x])"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0] * (x + 1) for _ in range(n)]\n\nfor i in range(n):\n    dp[i][1] = a[i]\n\nfor i in range(2, n):\n    for j in range(2, x + 1):\n        for p in range(max(0, i - k), i):\n            dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i])\n\nif max(dp[-1]) == 0:\n    print(-1)\nelse:\n    print(max(dp[-1]))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef max_beauty(n, k, x, a):\n    \"\"\"\n    >>> max_beauty(5, 2, 3, [5, 1, 3, 10, 1])\n    18\n    >>> max_beauty(6, 1, 5, [10, 30, 30, 70, 10, 10])\n    -1\n    >>> max_beauty(4, 3, 1, [1, 100, 1, 1])\n    100\n    \"\"\"\n    if x < n - k + 1:\n        return -1\n    return sum(sorted(a)[-x:])\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\n\ndef _print():\n    n, k, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(max_beauty(n, k, x, a))\n\n\nif __name__ == '__main__':\n    _test()\n    _print()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# Solution\n\n\"\"\"\nSolution idea:\n\nWe are going to use dynamic programming to solve this problem.\n\nFirst of all, let's think of the subproblems.\n\nLet's fix $i$ and $j$ ($i \\le j$). Let's denote by $dp[i][j][0]$ the maximum possible sum of values of reposted pictures, if Vova has to repost at least one picture in the segment $[i; j]$ and has already reposted $x$ pictures. Let's denote by $dp[i][j][1]$ the maximum possible sum of values of reposted pictures, if Vova doesn't have to repost any pictures in the segment $[i; j]$ and has already reposted $x$ pictures.\n\nThe answer to the problem is $dp[1][n][0]$.\n\nLet's try to find $dp[i][j][0]$. If $j - i + 1 < k$, then $dp[i][j][0] = -1$. Otherwise, Vova can repost the $i$-th picture. In this case, $dp[i][j][0] = a_i + dp[i + 1][j][1]$. Vova can also not repost the $i$-th picture. In this case, $dp[i][j][0] = dp[i + 1][j][0]$. Thus, $dp[i][j][0] = \\max(a_i + dp[i + 1][j][1], dp[i + 1][j][0])$.\n\nNow let's find $dp[i][j][1]$. If $j - i + 1 < k$, then $dp[i][j][1] = -1$. Otherwise, Vova can repost the $j$-th picture. In this case, $dp[i][j][1] = a_j + dp[i][j - 1][0]$. Vova can also not repost the $j$-th picture. In this case, $dp[i][j][1] = dp[i][j - 1][1]$. Thus, $dp[i][j][1] = \\max(a_j + dp[i][j - 1][0], dp[i][j - 1][1])$.\n\nLet's think about the order in which we want to find $dp[i][j][0]$ and $dp[i][j][1]$. It's easy to see that the answer will not change if we find $dp[i][j][0]$ and $dp[i][j][1]$ in any order, as long as we find them for all $i, j$ in increasing order of $j - i + 1$.\n\nThus, we can solve this problem in $O(n^2)$ time.\n\"\"\"\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[[-1 for _ in range(2)] for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    dp[i][i][0] = a[i - 1]\n    dp[i][i][1] = 0\n\nfor len in range(2, n + 1):\n    for i in range(1, n - len + 2):\n        j = i + len - 1\n        if j - i + 1 < k:\n            dp[i][j][0] = -1\n            dp[i][j][1] = -1\n        else:\n            dp[i][j][0] = max(a[i - 1] + dp[i + 1][j][1], dp[i + 1][j][0])\n            dp[i][j][1] = max(a[j - 1] + dp[i][j - 1][0], dp[i][j - 1][1])\n\nprint(dp[1][n][0])"
    }
  ],
  "created": 1649874126,
  "id": "cmpl-4wbuw8vQJUkRC0VHartFP3W0xrgSw",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 18:22:53.663665 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k, x = [int(x) for x in sys.stdin.readline().split()]\n    a = [int(x) for x in sys.stdin.readline().split()]\n    \n    if x < n - k + 1:\n        print(-1)\n        return\n    \n    # dp[i][j] = maximum sum of the first i items\n    #            if there are j items in the last k items\n    dp = [[0 for _ in range(k)] for _ in range(n)]\n    \n    # Initialize\n    dp[0][0] = a[0]\n    \n    # The first k items\n    for i in range(1, k):\n        dp[i][i] = dp[i - 1][i - 1] + a[i]\n    \n    # The rest\n    for i in range(k, n):\n        for j in range(k):\n            dp[i][j] = max(dp[i - 1][j] + a[i], dp[i - 1][(j + 1) % k])\n    \n    print(dp[n - 1][(k - (n - x)) % k])\n\nmain()"
}
2022-04-13 18:22:53.663707 REASON stop
2022-04-13 18:22:53.664130 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0 for _ in range(x+1)] for _ in range(n+1)]\n\nfor i in range(n):\n    for j in range(1, x+1):\n        dp[i+1][j] = max(dp[i][j], dp[i+1][j-1])\n        if i-k+1 >= 0:\n            dp[i+1][j] = max(dp[i+1][j], dp[i-k+1][j-1]+sum(a[i-k+1:i+1]))\n\nprint(dp[n][x] if dp[n][x] else -1)"
}
2022-04-13 18:22:53.664238 REASON stop
2022-04-13 18:22:53.664570 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# print(n, k, x)\n# print(a)\n\nif x < k:\n    print(-1)\n    exit()\n\n# set up a prefix sum array\nprefix_sum = [a[0]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + a[i])\n\n# print(prefix_sum)\n\n# set up a DP array, where the index is the number of pictures to repost,\n# and the value is the maximum possible sum of reposted pictures\ndp = [0] * (x + 1)\n\n# set up the maximum possible sum of reposted pictures for x = k\nfor i in range(1, k + 1):\n    dp[i] = prefix_sum[i - 1]\n\n# print(dp)\n\n# set up the maximum possible sum of reposted pictures for x > k\nfor i in range(k + 1, x + 1):\n    for j in range(1, k):\n        dp[i] = max(dp[i], dp[i - j] + prefix_sum[i - 1] - prefix_sum[i - j - 1])\n    dp[i] = max(dp[i], dp[i - k] + prefix_sum[i - 1] - prefix_sum[i - k - 1])\n\nprint(dp[-1])"
}
2022-04-13 18:22:53.664620 REASON stop
2022-04-13 18:22:53.691369 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn, k, x = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nif x < k:\n    print(-1)\n    exit()\n\ndp = [[0 for j in range(x+1)] for i in range(n+1)]\n\nfor i in range(1, n+1):\n    for j in range(1, x+1):\n        if i < k:\n            dp[i][j] = max(dp[i-1][j], a[i-1])\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i-k][j-1] + a[i-1])\n\nprint(dp[n][x])"
}
2022-04-13 18:22:53.691478 REASON stop
2022-04-13 18:22:53.692196 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0] * (x + 1) for _ in range(n)]\n\nfor i in range(n):\n    dp[i][1] = a[i]\n\nfor i in range(2, n):\n    for j in range(2, x + 1):\n        for p in range(max(0, i - k), i):\n            dp[i][j] = max(dp[i][j], dp[p][j - 1] + a[i])\n\nif max(dp[-1]) == 0:\n    print(-1)\nelse:\n    print(max(dp[-1]))"
}
2022-04-13 18:22:53.692276 REASON stop
2022-04-13 18:22:53.712329 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef max_beauty(n, k, x, a):\n    \"\"\"\n    >>> max_beauty(5, 2, 3, [5, 1, 3, 10, 1])\n    18\n    >>> max_beauty(6, 1, 5, [10, 30, 30, 70, 10, 10])\n    -1\n    >>> max_beauty(4, 3, 1, [1, 100, 1, 1])\n    100\n    \"\"\"\n    if x < n - k + 1:\n        return -1\n    return sum(sorted(a)[-x:])\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\n\ndef _print():\n    n, k, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(max_beauty(n, k, x, a))\n\n\nif __name__ == '__main__':\n    _test()\n    _print()"
}
2022-04-13 18:22:53.712430 REASON stop
2022-04-13 18:22:53.735689 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# Solution\n\n\"\"\"\nSolution idea:\n\nWe are going to use dynamic programming to solve this problem.\n\nFirst of all, let's think of the subproblems.\n\nLet's fix $i$ and $j$ ($i \\le j$). Let's denote by $dp[i][j][0]$ the maximum possible sum of values of reposted pictures, if Vova has to repost at least one picture in the segment $[i; j]$ and has already reposted $x$ pictures. Let's denote by $dp[i][j][1]$ the maximum possible sum of values of reposted pictures, if Vova doesn't have to repost any pictures in the segment $[i; j]$ and has already reposted $x$ pictures.\n\nThe answer to the problem is $dp[1][n][0]$.\n\nLet's try to find $dp[i][j][0]$. If $j - i + 1 < k$, then $dp[i][j][0] = -1$. Otherwise, Vova can repost the $i$-th picture. In this case, $dp[i][j][0] = a_i + dp[i + 1][j][1]$. Vova can also not repost the $i$-th picture. In this case, $dp[i][j][0] = dp[i + 1][j][0]$. Thus, $dp[i][j][0] = \\max(a_i + dp[i + 1][j][1], dp[i + 1][j][0])$.\n\nNow let's find $dp[i][j][1]$. If $j - i + 1 < k$, then $dp[i][j][1] = -1$. Otherwise, Vova can repost the $j$-th picture. In this case, $dp[i][j][1] = a_j + dp[i][j - 1][0]$. Vova can also not repost the $j$-th picture. In this case, $dp[i][j][1] = dp[i][j - 1][1]$. Thus, $dp[i][j][1] = \\max(a_j + dp[i][j - 1][0], dp[i][j - 1][1])$.\n\nLet's think about the order in which we want to find $dp[i][j][0]$ and $dp[i][j][1]$. It's easy to see that the answer will not change if we find $dp[i][j][0]$ and $dp[i][j][1]$ in any order, as long as we find them for all $i, j$ in increasing order of $j - i + 1$.\n\nThus, we can solve this problem in $O(n^2)$ time.\n\"\"\"\n\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[[-1 for _ in range(2)] for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    dp[i][i][0] = a[i - 1]\n    dp[i][i][1] = 0\n\nfor len in range(2, n + 1):\n    for i in range(1, n - len + 2):\n        j = i + len - 1\n        if j - i + 1 < k:\n            dp[i][j][0] = -1\n            dp[i][j][1] = -1\n        else:\n            dp[i][j][0] = max(a[i - 1] + dp[i + 1][j][1], dp[i + 1][j][0])\n            dp[i][j][1] = max(a[j - 1] + dp[i][j - 1][0], dp[i][j - 1][1])\n\nprint(dp[1][n][0])"
}
2022-04-13 18:22:53.735805 REASON stop
