2022-04-13 21:42:29.070513 """
You are given an integer sequence of length N, a_1,a_2,...,a_N.
For each 1≤i≤N, you have three choices: add 1 to a_i, subtract 1 from a_i or do nothing.
After these operations, you select an integer X and count the number of i such that a_i=X.
Maximize this count by making optimal choices.

-----Constraints-----
 - 1≤N≤10^5
 - 0≤a_i<10^5 (1≤i≤N)
 - a_i is an integer.

-----Input-----
The input is given from Standard Input in the following format:
N
a_1 a_2 .. a_N

-----Output-----
Print the maximum possible number of i such that a_i=X.

-----Sample Input-----
7
3 1 4 1 5 9 2

-----Sample Output-----
4

For example, turn the sequence into 2,2,3,2,6,9,2 and select X=2 to obtain 4, the maximum possible count.
"""
2022-04-13 21:42:29.070522 --------------------------
2022-04-13 21:42:54.241702 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\n# \u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\nmin_a = min(a)\n# \u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\nmax_a = max(a)\n\nans = 0\nfor i in range(min_a, max_a + 1):\n    cnt = 0\n    for j in range(n):\n        if a[j] == i:\n            cnt += 1\n    ans = max(ans, cnt)\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nfrom collections import Counter\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = Counter(a)\n    max_v = max(c.values())\n    print(max_v)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN = int(input())\nA = list(map(int, input().split()))\n\nmax_num = max(A)\nmin_num = min(A)\n\nif max_num - min_num <= 1:\n    print(N)\n    sys.exit()\n\nmax_num_count = A.count(max_num)\nmin_num_count = A.count(min_num)\n\nif max_num_count == min_num_count:\n    print(max_num_count + min_num_count)\nelse:\n    print(min(max_num_count, min_num_count) + (N - max_num_count - min_num_count) // 2 + 1)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    max_val = a[-1]\n    min_val = a[0]\n    ans = 0\n    for i in range(min_val, max_val+1):\n        cnt = 0\n        for j in range(n):\n            if a[j] == i:\n                cnt += 1\n        ans = max(ans, cnt)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nN = int(input())\na = list(map(int, input().split()))\n\n# initialize\nc = [0] * (10 ** 5 + 1)\nfor i in a:\n    c[i] += 1\n\n# process\nfor i in range(10 ** 5 + 1):\n    if c[i] > 0:\n        c[i + 1] += c[i] // 2\n        c[i] %= 2\n\n# output\nprint(sum(c))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nN = int(input())\nA = list(map(int, input().split()))\n\n# \u30bd\u30fc\u30c8\u3057\u3066\u3001\u4e2d\u592e\u5024\u3092X\u3068\u3059\u308b\nA.sort()\nX = A[N//2]\n\n# X\u3068\u540c\u3058\u6570\u306e\u6570\u3092\u6570\u3048\u308b\nans = 0\nfor a in A:\n    if a == X:\n        ans += 1\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nN = int(input())\nA = list(map(int,input().split()))\n\n# Count the number of times each value occurs in the original sequence.\n# This is the maximum number of times each value can occur in the modified sequence.\nmax_counts = [0] * 100001\nfor a in A:\n    max_counts[a] += 1\n\n# For each value, determine the number of operations needed to make the value equal to X.\n# We can make a value equal to X by either incrementing it or decrementing it.\n# If we increment it, the number of operations needed is equal to the number of times the value\n# occurs in the original sequence minus the number of times it occurs in the modified sequence.\n# Similarly, if we decrement it, the number of operations needed is equal to the number of times\n# the value minus 1 occurs in the original sequence minus the number of times it occurs in the modified sequence.\n# We can then determine the number of operations needed to make a value equal to X by taking the minimum\n# of the two previous results.\n# We can then determine the number of times a value is equal to X by subtracting the number of operations\n# needed to make the value equal to X from the maximum number of times the value can occur in the modified sequence.\ncounts = [0] * 100001\nfor i in range(100001):\n    counts[i] = min(max_counts[i] - max_counts[i-1], max_counts[i] - max_counts[i+1])\n\n# The answer is the maximum number of times a value is equal to X.\nprint(max(counts))"
    }
  ],
  "created": 1649886149,
  "id": "cmpl-4wf2rcaZ6A7Pm27cngK04mC5E64Um",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:42:54.241978 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\nn = int(input())\na = list(map(int, input().split()))\n\n# \u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\nmin_a = min(a)\n# \u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\nmax_a = max(a)\n\nans = 0\nfor i in range(min_a, max_a + 1):\n    cnt = 0\n    for j in range(n):\n        if a[j] == i:\n            cnt += 1\n    ans = max(ans, cnt)\n\nprint(ans)"
}
2022-04-13 21:42:54.242018 REASON stop
2022-04-13 21:42:54.242487 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nfrom collections import Counter\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = Counter(a)\n    max_v = max(c.values())\n    print(max_v)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:42:54.242603 REASON stop
2022-04-13 21:42:54.242994 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN = int(input())\nA = list(map(int, input().split()))\n\nmax_num = max(A)\nmin_num = min(A)\n\nif max_num - min_num <= 1:\n    print(N)\n    sys.exit()\n\nmax_num_count = A.count(max_num)\nmin_num_count = A.count(min_num)\n\nif max_num_count == min_num_count:\n    print(max_num_count + min_num_count)\nelse:\n    print(min(max_num_count, min_num_count) + (N - max_num_count - min_num_count) // 2 + 1)"
}
2022-04-13 21:42:54.243040 REASON stop
2022-04-13 21:42:54.255043 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    max_val = a[-1]\n    min_val = a[0]\n    ans = 0\n    for i in range(min_val, max_val+1):\n        cnt = 0\n        for j in range(n):\n            if a[j] == i:\n                cnt += 1\n        ans = max(ans, cnt)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:42:54.255107 REASON stop
2022-04-13 21:42:54.271097 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nN = int(input())\na = list(map(int, input().split()))\n\n# initialize\nc = [0] * (10 ** 5 + 1)\nfor i in a:\n    c[i] += 1\n\n# process\nfor i in range(10 ** 5 + 1):\n    if c[i] > 0:\n        c[i + 1] += c[i] // 2\n        c[i] %= 2\n\n# output\nprint(sum(c))"
}
2022-04-13 21:42:54.271181 REASON stop
2022-04-13 21:42:54.274284 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nN = int(input())\nA = list(map(int, input().split()))\n\n# \u30bd\u30fc\u30c8\u3057\u3066\u3001\u4e2d\u592e\u5024\u3092X\u3068\u3059\u308b\nA.sort()\nX = A[N//2]\n\n# X\u3068\u540c\u3058\u6570\u306e\u6570\u3092\u6570\u3048\u308b\nans = 0\nfor a in A:\n    if a == X:\n        ans += 1\n\nprint(ans)"
}
2022-04-13 21:42:54.274353 REASON stop
2022-04-13 21:42:54.275381 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nN = int(input())\nA = list(map(int,input().split()))\n\n# Count the number of times each value occurs in the original sequence.\n# This is the maximum number of times each value can occur in the modified sequence.\nmax_counts = [0] * 100001\nfor a in A:\n    max_counts[a] += 1\n\n# For each value, determine the number of operations needed to make the value equal to X.\n# We can make a value equal to X by either incrementing it or decrementing it.\n# If we increment it, the number of operations needed is equal to the number of times the value\n# occurs in the original sequence minus the number of times it occurs in the modified sequence.\n# Similarly, if we decrement it, the number of operations needed is equal to the number of times\n# the value minus 1 occurs in the original sequence minus the number of times it occurs in the modified sequence.\n# We can then determine the number of operations needed to make a value equal to X by taking the minimum\n# of the two previous results.\n# We can then determine the number of times a value is equal to X by subtracting the number of operations\n# needed to make the value equal to X from the maximum number of times the value can occur in the modified sequence.\ncounts = [0] * 100001\nfor i in range(100001):\n    counts[i] = min(max_counts[i] - max_counts[i-1], max_counts[i] - max_counts[i+1])\n\n# The answer is the maximum number of times a value is equal to X.\nprint(max(counts))"
}
2022-04-13 21:42:54.275469 REASON stop
