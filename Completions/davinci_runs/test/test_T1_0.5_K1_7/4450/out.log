2022-04-13 20:58:06.056446 """
You are given a connected undirected weighted graph consisting of $n$ vertices and $m$ edges.

You need to print the $k$-th smallest shortest path in this graph (paths from the vertex to itself are not counted, paths from $i$ to $j$ and from $j$ to $i$ are counted as one).

More formally, if $d$ is the matrix of shortest paths, where $d_{i, j}$ is the length of the shortest path between vertices $i$ and $j$ ($1 \le i < j \le n$), then you need to print the $k$-th element in the sorted array consisting of all $d_{i, j}$, where $1 \le i < j \le n$.


-----Input-----

The first line of the input contains three integers $n, m$ and $k$ ($2 \le n \le 2 \cdot 10^5$, $n - 1 \le m \le \min\Big(\frac{n(n-1)}{2}, 2 \cdot 10^5\Big)$, $1 \le k \le \min\Big(\frac{n(n-1)}{2}, 400\Big)$ — the number of vertices in the graph, the number of edges in the graph and the value of $k$, correspondingly.

Then $m$ lines follow, each containing three integers $x$, $y$ and $w$ ($1 \le x, y \le n$, $1 \le w \le 10^9$, $x \ne y$) denoting an edge between vertices $x$ and $y$ of weight $w$.

It is guaranteed that the given graph is connected (there is a path between any pair of vertices), there are no self-loops (edges connecting the vertex with itself) and multiple edges (for each pair of vertices $x$ and $y$, there is at most one edge between this pair of vertices in the graph).


-----Output-----

Print one integer — the length of the $k$-th smallest shortest path in the given graph (paths from the vertex to itself are not counted, paths from $i$ to $j$ and from $j$ to $i$ are counted as one).


-----Examples-----
Input
6 10 5
2 5 1
5 3 9
6 2 2
1 3 1
5 1 8
6 5 10
1 6 5
6 4 6
3 6 2
3 4 5

Output
3

Input
7 15 18
2 6 3
5 7 4
6 5 4
3 6 9
6 7 7
1 6 4
7 1 6
7 2 1
4 3 2
3 2 8
5 3 6
2 5 5
3 7 9
4 1 8
2 1 1

Output
9
"""
2022-04-13 20:58:06.056457 --------------------------
2022-04-13 20:58:48.780038 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.graph = [[] for _ in range(n)]\n\t\n\tdef addEdge(self, u, v, w):\n\t\tself.graph[u].append((v, w))\n\t\tself.graph[v].append((u, w))\n\t\n\tdef dijkstra(self, src):\n\t\tdist = [sys.maxsize] * self.n\n\t\tdist[src] = 0\n\t\t\n\t\theap = [(0, src)]\n\t\twhile heap:\n\t\t\td, u = heapq.heappop(heap)\n\t\t\tif d > dist[u]:\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tfor v, w in self.graph[u]:\n\t\t\t\tif dist[u] + w < dist[v]:\n\t\t\t\t\tdist[v] = dist[u] + w\n\t\t\t\t\theapq.heappush(heap, (dist[v], v))\n\t\t\n\t\treturn dist\n\t\n\tdef kthShortestPath(self, k):\n\t\tdist = self.dijkstra(0)\n\t\tdist = sorted(dist[1:])\n\t\treturn dist[k-1]\n\ndef main():\n\tn, m, k = map(int, input().split())\n\tg = Graph(n)\n\t\n\tfor _ in range(m):\n\t\tu, v, w = map(int, input().split())\n\t\tg.addEdge(u-1, v-1, w)\n\t\n\tprint(g.kthShortestPath(k))\n\n\nif __name__ == \"__main__\":\n\tmain()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def findShortestPaths(self, s):\n        dist = [math.inf] * self.V\n        dist[s] = 0\n        self.shortestPaths = []\n        self.traverse(s, dist)\n        self.shortestPaths.sort()\n\n    def traverse(self, s, dist):\n        for v, w in self.graph[s]:\n            if dist[v] > dist[s] + w:\n                dist[v] = dist[s] + w\n                self.traverse(v, dist)\n        for i in range(self.V):\n            if i != s:\n                self.shortestPaths.append(dist[i])\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    g = Graph(n)\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        g.addEdge(u - 1, v - 1, w)\n    g.findShortestPaths(0)\n    print(g.shortestPaths[k - 1])"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport heapq\n\ndef dijkstra(graph, start, end):\n    \"\"\"\n    Function to find the shortest path between two nodes in a graph using Dijkstra's algorithm\n    :param graph: a dictionary of dictionaries representing the graph\n    :param start: the starting node\n    :param end: the ending node\n    :return: a tuple of the shortest distance and the path\n    \"\"\"\n    # Create a priority queue to be used in the algorithm\n    queue = [(0, start)]\n\n    # Create a dictionary to store the shortest distance to each node\n    dist = {start: 0}\n\n    # Create a dictionary to store the previous node in the shortest path to each node\n    prev = {start: None}\n\n    # Create a dictionary to store if a node has been visited\n    visited = {start: False}\n\n    # While the queue is not empty\n    while queue:\n        # Pop the first node in the queue\n        dist_u, u = heapq.heappop(queue)\n\n        # If the node has not been visited\n        if not visited[u]:\n            # Mark the node as visited\n            visited[u] = True\n\n            # For each of the adjacent nodes\n            for v, dist_uv in graph[u].items():\n                # If the node has not been visited\n                if not visited[v]:\n                    # If the distance to the node is less than the shortest distance to the node\n                    if dist_u + dist_uv < dist.get(v, float('inf')):\n                        # Update the shortest distance to the node and the previous node\n                        dist[v] = dist_u + dist_uv\n                        prev[v] = u\n                        # Push the node onto the queue\n                        heapq.heappush(queue, (dist[v], v))\n\n    # Create a list to store the path\n    path = []\n\n    # Set the current node to the end node\n    u = end\n\n    # While the current node is not the start node\n    while prev[u]:\n        # Add the current node to the path\n        path.append(u)\n\n        # Set the current node to the previous node\n        u = prev[u]\n\n    # Add the start node to the path\n    path.append(start)\n\n    # Return the shortest distance and the path\n    return dist[end], path[::-1]\n\n\ndef main():\n    # Get the input\n    n, m, k = [int(x) for x in input().split()]\n\n    # Create a dictionary to store the graph\n    graph = {}\n\n    # For each of the edges\n    for _ in range(m):\n        # Get the edge\n        x, y, w = [int(x) for x in input().split()]\n\n        # If the edge is not in the graph\n        if x not in graph:\n            # Add the edge to the graph\n            graph[x] = {y: w}\n        else:\n            # Update the edge in the graph\n            graph[x][y] = w\n\n        # If the edge is not in the graph\n        if y not in graph:\n            # Add the edge to the graph\n            graph[y] = {x: w}\n        else:\n            # Update the edge in the graph\n            graph[y][x] = w\n\n    # Create a list to store the shortest paths\n    shortest_paths = []\n\n    # For each of the nodes\n    for i in range(1, n + 1):\n        # For each of the other nodes\n        for j in range(i + 1, n + 1):\n            # If the nodes are not the same\n            if i != j:\n                # Get the shortest path between the nodes\n                shortest_path, _ = dijkstra(graph, i, j)\n\n                # Add the shortest path to the list\n                shortest_paths.append(shortest_path)\n\n    # Sort the shortest paths\n    shortest_paths.sort()\n\n    # Print the kth shortest path\n    print(shortest_paths[k - 1])\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.V = len(vertices)\n        self.adj = [[] for i in range(self.V)]\n        \n    def addEdge(self, u, v, w):\n        self.adj[u].append((v, w))\n        self.adj[v].append((u, w))\n        \n    def dijkstra(self, s):\n        dist = [sys.maxsize]*self.V\n        dist[s] = 0\n        pq = []\n        heapq.heappush(pq, (0, s))\n        \n        while pq:\n            u = heapq.heappop(pq)\n            for v, w in self.adj[u[1]]:\n                if dist[u[1]] + w < dist[v]:\n                    dist[v] = dist[u[1]] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n    \n    def kthSmallest(self, k):\n        dist = []\n        for i in range(self.V):\n            dist.extend(self.dijkstra(i))\n        dist.sort()\n        return dist[k-1]\n        \nn, m, k = map(int, input().split())\nvertices = [i for i in range(n)]\ng = Graph(vertices)\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    g.addEdge(u-1, v-1, w)\n    \nprint(g.kthSmallest(k))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport heapq\n\nclass Solution(object):\n    def solve(self, n, m, k, edges):\n        graph = [[] for _ in range(n+1)]\n        for edge in edges:\n            x, y, w = edge\n            graph[x].append((y, w))\n            graph[y].append((x, w))\n\n        dist = [float('inf')] * (n+1)\n        dist[1] = 0\n        pq = [(0, 1)]\n        heapq.heapify(pq)\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if d + w < dist[v]:\n                    dist[v] = d + w\n                    heapq.heappush(pq, (d+w, v))\n\n        dist = sorted(dist[1:])\n        return dist[k-1]\n\nif __name__ == \"__main__\":\n    n, m, k = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        x, y, w = [int(x) for x in input().split()]\n        edges.append((x, y, w))\n    print(Solution().solve(n, m, k, edges))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nn, m, k = map(int, input().split())\n\nedges = defaultdict(list)\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    edges[x].append((w, y))\n    edges[y].append((w, x))\n\ndistances = defaultdict(lambda: float('inf'))\ndistances[1] = 0\n\nheap = [(0, 1)]\nvisited = set()\n\nwhile heap:\n    d, v = heappop(heap)\n    if v in visited:\n        continue\n    visited.add(v)\n    for w, u in edges[v]:\n        if u not in visited and distances[u] > d + w:\n            distances[u] = d + w\n            heappush(heap, (d + w, u))\n\ndistances = sorted(distances.values())[1:]\nprint(distances[k - 1])"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\nimport heapq\ndef dijkstra(s, n, graph):\n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    h = [(0, s)]\n    while h:\n        d, u = heapq.heappop(h)\n        if d > dist[u]: continue\n        for v, w in graph[u]:\n            if w + d < dist[v]:\n                dist[v] = w + d\n                heapq.heappush(h, (w + d, v))\n    return dist\n\n\ndef solve(n, m, k, graph):\n    dist = []\n    for i in range(1, n + 1):\n        dist += dijkstra(i, n, graph)[1:]\n    return sorted(dist)[k - 1]\n\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(m):\n        u, v, w = map(int, input().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    print(solve(n, m, k, graph))"
    }
  ],
  "created": 1649883486,
  "id": "cmpl-4weLuuP42ivnmBmOGWsVQmwc233At",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:58:48.780445 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.graph = [[] for _ in range(n)]\n\t\n\tdef addEdge(self, u, v, w):\n\t\tself.graph[u].append((v, w))\n\t\tself.graph[v].append((u, w))\n\t\n\tdef dijkstra(self, src):\n\t\tdist = [sys.maxsize] * self.n\n\t\tdist[src] = 0\n\t\t\n\t\theap = [(0, src)]\n\t\twhile heap:\n\t\t\td, u = heapq.heappop(heap)\n\t\t\tif d > dist[u]:\n\t\t\t\tcontinue\n\t\t\t\n\t\t\tfor v, w in self.graph[u]:\n\t\t\t\tif dist[u] + w < dist[v]:\n\t\t\t\t\tdist[v] = dist[u] + w\n\t\t\t\t\theapq.heappush(heap, (dist[v], v))\n\t\t\n\t\treturn dist\n\t\n\tdef kthShortestPath(self, k):\n\t\tdist = self.dijkstra(0)\n\t\tdist = sorted(dist[1:])\n\t\treturn dist[k-1]\n\ndef main():\n\tn, m, k = map(int, input().split())\n\tg = Graph(n)\n\t\n\tfor _ in range(m):\n\t\tu, v, w = map(int, input().split())\n\t\tg.addEdge(u-1, v-1, w)\n\t\n\tprint(g.kthShortestPath(k))\n\n\nif __name__ == \"__main__\":\n\tmain()"
}
2022-04-13 20:58:48.780510 REASON stop
2022-04-13 20:58:48.780889 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n\n    def findShortestPaths(self, s):\n        dist = [math.inf] * self.V\n        dist[s] = 0\n        self.shortestPaths = []\n        self.traverse(s, dist)\n        self.shortestPaths.sort()\n\n    def traverse(self, s, dist):\n        for v, w in self.graph[s]:\n            if dist[v] > dist[s] + w:\n                dist[v] = dist[s] + w\n                self.traverse(v, dist)\n        for i in range(self.V):\n            if i != s:\n                self.shortestPaths.append(dist[i])\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    g = Graph(n)\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        g.addEdge(u - 1, v - 1, w)\n    g.findShortestPaths(0)\n    print(g.shortestPaths[k - 1])"
}
2022-04-13 20:58:48.780992 REASON stop
2022-04-13 20:58:48.781347 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport heapq\n\ndef dijkstra(graph, start, end):\n    \"\"\"\n    Function to find the shortest path between two nodes in a graph using Dijkstra's algorithm\n    :param graph: a dictionary of dictionaries representing the graph\n    :param start: the starting node\n    :param end: the ending node\n    :return: a tuple of the shortest distance and the path\n    \"\"\"\n    # Create a priority queue to be used in the algorithm\n    queue = [(0, start)]\n\n    # Create a dictionary to store the shortest distance to each node\n    dist = {start: 0}\n\n    # Create a dictionary to store the previous node in the shortest path to each node\n    prev = {start: None}\n\n    # Create a dictionary to store if a node has been visited\n    visited = {start: False}\n\n    # While the queue is not empty\n    while queue:\n        # Pop the first node in the queue\n        dist_u, u = heapq.heappop(queue)\n\n        # If the node has not been visited\n        if not visited[u]:\n            # Mark the node as visited\n            visited[u] = True\n\n            # For each of the adjacent nodes\n            for v, dist_uv in graph[u].items():\n                # If the node has not been visited\n                if not visited[v]:\n                    # If the distance to the node is less than the shortest distance to the node\n                    if dist_u + dist_uv < dist.get(v, float('inf')):\n                        # Update the shortest distance to the node and the previous node\n                        dist[v] = dist_u + dist_uv\n                        prev[v] = u\n                        # Push the node onto the queue\n                        heapq.heappush(queue, (dist[v], v))\n\n    # Create a list to store the path\n    path = []\n\n    # Set the current node to the end node\n    u = end\n\n    # While the current node is not the start node\n    while prev[u]:\n        # Add the current node to the path\n        path.append(u)\n\n        # Set the current node to the previous node\n        u = prev[u]\n\n    # Add the start node to the path\n    path.append(start)\n\n    # Return the shortest distance and the path\n    return dist[end], path[::-1]\n\n\ndef main():\n    # Get the input\n    n, m, k = [int(x) for x in input().split()]\n\n    # Create a dictionary to store the graph\n    graph = {}\n\n    # For each of the edges\n    for _ in range(m):\n        # Get the edge\n        x, y, w = [int(x) for x in input().split()]\n\n        # If the edge is not in the graph\n        if x not in graph:\n            # Add the edge to the graph\n            graph[x] = {y: w}\n        else:\n            # Update the edge in the graph\n            graph[x][y] = w\n\n        # If the edge is not in the graph\n        if y not in graph:\n            # Add the edge to the graph\n            graph[y] = {x: w}\n        else:\n            # Update the edge in the graph\n            graph[y][x] = w\n\n    # Create a list to store the shortest paths\n    shortest_paths = []\n\n    # For each of the nodes\n    for i in range(1, n + 1):\n        # For each of the other nodes\n        for j in range(i + 1, n + 1):\n            # If the nodes are not the same\n            if i != j:\n                # Get the shortest path between the nodes\n                shortest_path, _ = dijkstra(graph, i, j)\n\n                # Add the shortest path to the list\n                shortest_paths.append(shortest_path)\n\n    # Sort the shortest paths\n    shortest_paths.sort()\n\n    # Print the kth shortest path\n    print(shortest_paths[k - 1])\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:58:48.781451 REASON stop
2022-04-13 20:58:48.803072 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.V = len(vertices)\n        self.adj = [[] for i in range(self.V)]\n        \n    def addEdge(self, u, v, w):\n        self.adj[u].append((v, w))\n        self.adj[v].append((u, w))\n        \n    def dijkstra(self, s):\n        dist = [sys.maxsize]*self.V\n        dist[s] = 0\n        pq = []\n        heapq.heappush(pq, (0, s))\n        \n        while pq:\n            u = heapq.heappop(pq)\n            for v, w in self.adj[u[1]]:\n                if dist[u[1]] + w < dist[v]:\n                    dist[v] = dist[u[1]] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n    \n    def kthSmallest(self, k):\n        dist = []\n        for i in range(self.V):\n            dist.extend(self.dijkstra(i))\n        dist.sort()\n        return dist[k-1]\n        \nn, m, k = map(int, input().split())\nvertices = [i for i in range(n)]\ng = Graph(vertices)\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    g.addEdge(u-1, v-1, w)\n    \nprint(g.kthSmallest(k))"
}
2022-04-13 20:58:48.803170 REASON stop
2022-04-13 20:58:48.823816 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport heapq\n\nclass Solution(object):\n    def solve(self, n, m, k, edges):\n        graph = [[] for _ in range(n+1)]\n        for edge in edges:\n            x, y, w = edge\n            graph[x].append((y, w))\n            graph[y].append((x, w))\n\n        dist = [float('inf')] * (n+1)\n        dist[1] = 0\n        pq = [(0, 1)]\n        heapq.heapify(pq)\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if d + w < dist[v]:\n                    dist[v] = d + w\n                    heapq.heappush(pq, (d+w, v))\n\n        dist = sorted(dist[1:])\n        return dist[k-1]\n\nif __name__ == \"__main__\":\n    n, m, k = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        x, y, w = [int(x) for x in input().split()]\n        edges.append((x, y, w))\n    print(Solution().solve(n, m, k, edges))"
}
2022-04-13 20:58:48.823976 REASON stop
2022-04-13 20:58:48.824626 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nn, m, k = map(int, input().split())\n\nedges = defaultdict(list)\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    edges[x].append((w, y))\n    edges[y].append((w, x))\n\ndistances = defaultdict(lambda: float('inf'))\ndistances[1] = 0\n\nheap = [(0, 1)]\nvisited = set()\n\nwhile heap:\n    d, v = heappop(heap)\n    if v in visited:\n        continue\n    visited.add(v)\n    for w, u in edges[v]:\n        if u not in visited and distances[u] > d + w:\n            distances[u] = d + w\n            heappush(heap, (d + w, u))\n\ndistances = sorted(distances.values())[1:]\nprint(distances[k - 1])"
}
2022-04-13 20:58:48.824700 REASON stop
2022-04-13 20:58:48.825426 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\nimport heapq\ndef dijkstra(s, n, graph):\n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    h = [(0, s)]\n    while h:\n        d, u = heapq.heappop(h)\n        if d > dist[u]: continue\n        for v, w in graph[u]:\n            if w + d < dist[v]:\n                dist[v] = w + d\n                heapq.heappush(h, (w + d, v))\n    return dist\n\n\ndef solve(n, m, k, graph):\n    dist = []\n    for i in range(1, n + 1):\n        dist += dijkstra(i, n, graph)[1:]\n    return sorted(dist)[k - 1]\n\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(m):\n        u, v, w = map(int, input().split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    print(solve(n, m, k, graph))"
}
2022-04-13 20:58:48.825488 REASON stop
