["\n\nN = int(input())\nW = [int(i) for i in input().split(\" \")]\n\n# brute-force\nsmallest = 100000\nfor i in range(1, N):\n    S1 = sum(W[:i])\n    S2 = sum(W[i:])\n    smallest = min(smallest, abs(S1 - S2))\nprint(smallest)", "\nimport sys\n\ninput = sys.stdin.readline().split()\nN = int(input[0])\nweights = [int(i) for i in input[1:]]\n\ntotal = sum(weights)\n\n# the minimum possible absolute difference of S_1 and S_2 is 0 if and only if\n# the minimum sum of the weights in the first group is equal to the maximum sum of the weights in the second group\n# the minimum sum of the weights in the first group is the minimum sum of the first N/2 weights\n# the maximum sum of the weights in the second group is the maximum sum of the last N/2 weights\n\n# the minimum sum of the weights in the first group can be found by dynamic programming\n# the maximum sum of the weights in the second group can be found by dynamic programming\n# the minimum possible absolute difference of S_1 and S_2 is the minimum difference between the sums in the two dynamic programming arrays\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming", "\n\nN = input()\nW = input()\n\nW = W.split()\nW = [int(i) for i in W]\n\nW_1 = []\nW_2 = []\n\nfor i in range(len(W)):\n    if i < N//2:\n        W_1.append(W[i])\n    else:\n        W_2.append(W[i])\n\nS_1 = sum(W_1)\nS_2 = sum(W_2)\n\ndiff = abs(S_1 - S_2)\n\nprint(diff)", "\n\ndef main():\n    n = int(input())\n    weights = list(map(int, input().split()))\n    min_diff = sum(weights)\n    for i in range(n):\n        diff = sum(weights[:i]) - sum(weights[i:])\n        if abs(diff) < min_diff:\n            min_diff = abs(diff)\n    print(min_diff)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n = int(input())\n    w = list(map(int, input().split()))\n    s1 = [sum(w[:i+1]) for i in range(n)]\n    s2 = [sum(w[i+1:]) for i in range(n)]\n    ans = min([abs(s1[i] - s2[i]) for i in range(n)])\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nN = int(input())\nW = list(map(int, input().split()))\nsum_w = sum(W)\n\nans = float('inf')\n\nfor i in range(1, N):\n    ans = min(ans, abs(sum_w - 2*sum(W[:i])))\n\nprint(ans)", "\n\nN = int(input())\nW = list(map(int, input().split()))\n\ndp = [[0] * (N+1) for i in range(N+1)]\n\nfor i in range(N+1):\n    for j in range(N+1):\n        if i == 0 or j == 0:\n            dp[i][j] = 0\n        elif i < j:\n            dp[i][j] = dp[i][i]\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + W[i-1])\n\nprint(dp[N//2][N] - dp[N//2][N//2])"]