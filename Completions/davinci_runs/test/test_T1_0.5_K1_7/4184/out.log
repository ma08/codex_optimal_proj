2022-04-13 19:04:04.331811 """
We have N weights indexed 1 to N. The mass of the weight indexed i is W_i.
We will divide these weights into two groups: the weights with indices not greater than T, and those with indices greater than T, for some integer 1 \leq T < N. Let S_1 be the sum of the masses of the weights in the former group, and S_2 be the sum of the masses of the weights in the latter group.
Consider all possible such divisions and find the minimum possible absolute difference of S_1 and S_2.

-----Constraints-----
 - 2 \leq N \leq 100
 - 1 \leq W_i \leq 100
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N
W_1 W_2 ... W_{N-1} W_N

-----Output-----
Print the minimum possible absolute difference of S_1 and S_2.

-----Sample Input-----
3
1 2 3

-----Sample Output-----
0

If T = 2, S_1 = 1 + 2 = 3 and S_2 = 3, with the absolute difference of 0.
"""
2022-04-13 19:04:04.331829 --------------------------
2022-04-13 19:04:49.180504 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nN = int(input())\nW = list(map(int, input().split()))\nsum_w = sum(W)\n\nans = float('inf')\n\nfor i in range(1, N):\n    ans = min(ans, abs(sum_w - 2*sum(W[:i])))\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nN = input()\nW = input()\n\nW = W.split()\nW = [int(i) for i in W]\n\nW_1 = []\nW_2 = []\n\nfor i in range(len(W)):\n    if i < N//2:\n        W_1.append(W[i])\n    else:\n        W_2.append(W[i])\n\nS_1 = sum(W_1)\nS_2 = sum(W_2)\n\ndiff = abs(S_1 - S_2)\n\nprint(diff)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    w = list(map(int, input().split()))\n    s1 = [sum(w[:i+1]) for i in range(n)]\n    s2 = [sum(w[i+1:]) for i in range(n)]\n    ans = min([abs(s1[i] - s2[i]) for i in range(n)])\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\nimport sys\n\ninput = sys.stdin.readline().split()\nN = int(input[0])\nweights = [int(i) for i in input[1:]]\n\ntotal = sum(weights)\n\n# the minimum possible absolute difference of S_1 and S_2 is 0 if and only if\n# the minimum sum of the weights in the first group is equal to the maximum sum of the weights in the second group\n# the minimum sum of the weights in the first group is the minimum sum of the first N/2 weights\n# the maximum sum of the weights in the second group is the maximum sum of the last N/2 weights\n\n# the minimum sum of the weights in the first group can be found by dynamic programming\n# the maximum sum of the weights in the second group can be found by dynamic programming\n# the minimum possible absolute difference of S_1 and S_2 is the minimum difference between the sums in the two dynamic programming arrays\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nN = int(input())\nW = [int(i) for i in input().split(\" \")]\n\n# brute-force\nsmallest = 100000\nfor i in range(1, N):\n    S1 = sum(W[:i])\n    S2 = sum(W[i:])\n    smallest = min(smallest, abs(S1 - S2))\nprint(smallest)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nN = int(input())\nW = list(map(int, input().split()))\n\ndp = [[0] * (N+1) for i in range(N+1)]\n\nfor i in range(N+1):\n    for j in range(N+1):\n        if i == 0 or j == 0:\n            dp[i][j] = 0\n        elif i < j:\n            dp[i][j] = dp[i][i]\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + W[i-1])\n\nprint(dp[N//2][N] - dp[N//2][N//2])"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    weights = list(map(int, input().split()))\n    min_diff = sum(weights)\n    for i in range(n):\n        diff = sum(weights[:i]) - sum(weights[i:])\n        if abs(diff) < min_diff:\n            min_diff = abs(diff)\n    print(min_diff)\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1649876644,
  "id": "cmpl-4wcZYgvCzLnDRlWgPKTDMtgg2VYEu",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 19:04:49.180779 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nN = int(input())\nW = list(map(int, input().split()))\nsum_w = sum(W)\n\nans = float('inf')\n\nfor i in range(1, N):\n    ans = min(ans, abs(sum_w - 2*sum(W[:i])))\n\nprint(ans)"
}
2022-04-13 19:04:49.180878 REASON stop
2022-04-13 19:04:49.181297 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nN = input()\nW = input()\n\nW = W.split()\nW = [int(i) for i in W]\n\nW_1 = []\nW_2 = []\n\nfor i in range(len(W)):\n    if i < N//2:\n        W_1.append(W[i])\n    else:\n        W_2.append(W[i])\n\nS_1 = sum(W_1)\nS_2 = sum(W_2)\n\ndiff = abs(S_1 - S_2)\n\nprint(diff)"
}
2022-04-13 19:04:49.181483 REASON stop
2022-04-13 19:04:49.181881 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    w = list(map(int, input().split()))\n    s1 = [sum(w[:i+1]) for i in range(n)]\n    s2 = [sum(w[i+1:]) for i in range(n)]\n    ans = min([abs(s1[i] - s2[i]) for i in range(n)])\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:04:49.181926 REASON stop
2022-04-13 19:04:49.194751 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\nimport sys\n\ninput = sys.stdin.readline().split()\nN = int(input[0])\nweights = [int(i) for i in input[1:]]\n\ntotal = sum(weights)\n\n# the minimum possible absolute difference of S_1 and S_2 is 0 if and only if\n# the minimum sum of the weights in the first group is equal to the maximum sum of the weights in the second group\n# the minimum sum of the weights in the first group is the minimum sum of the first N/2 weights\n# the maximum sum of the weights in the second group is the maximum sum of the last N/2 weights\n\n# the minimum sum of the weights in the first group can be found by dynamic programming\n# the maximum sum of the weights in the second group can be found by dynamic programming\n# the minimum possible absolute difference of S_1 and S_2 is the minimum difference between the sums in the two dynamic programming arrays\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming\n\n# the minimum sum of the first N/2 weights can be found by dynamic programming\n# the maximum sum of the last N/2 weights can be found by dynamic programming"
}
2022-04-13 19:04:49.194843 REASON stop
2022-04-13 19:04:49.221475 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nN = int(input())\nW = [int(i) for i in input().split(\" \")]\n\n# brute-force\nsmallest = 100000\nfor i in range(1, N):\n    S1 = sum(W[:i])\n    S2 = sum(W[i:])\n    smallest = min(smallest, abs(S1 - S2))\nprint(smallest)"
}
2022-04-13 19:04:49.221573 REASON stop
2022-04-13 19:04:49.222636 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nN = int(input())\nW = list(map(int, input().split()))\n\ndp = [[0] * (N+1) for i in range(N+1)]\n\nfor i in range(N+1):\n    for j in range(N+1):\n        if i == 0 or j == 0:\n            dp[i][j] = 0\n        elif i < j:\n            dp[i][j] = dp[i][i]\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + W[i-1])\n\nprint(dp[N//2][N] - dp[N//2][N//2])"
}
2022-04-13 19:04:49.222696 REASON stop
2022-04-13 19:04:49.224317 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    weights = list(map(int, input().split()))\n    min_diff = sum(weights)\n    for i in range(n):\n        diff = sum(weights[:i]) - sum(weights[i:])\n        if abs(diff) < min_diff:\n            min_diff = abs(diff)\n    print(min_diff)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 19:04:49.224378 REASON stop
