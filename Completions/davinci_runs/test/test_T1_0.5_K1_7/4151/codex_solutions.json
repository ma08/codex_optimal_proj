["\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a_set = set(a)\n    a_map = {x:i for i,x in enumerate(sorted(a_set))}\n    a_inv = {i:x for i,x in enumerate(sorted(a_set))}\n\n    #print(a_map)\n    #print(a_inv)\n\n    b = [a_map[x] for x in a]\n    #print(b)\n\n    #print(a_inv)\n\n    dp = [[0,0] for _ in range(n)]\n    dp[0][0] = 1\n    dp[0][1] = 1\n\n    for i in range(1,n):\n        if b[i] == b[i-1]:\n            dp[i][0] = (dp[i-1][0] + dp[i-1][1])%998244353\n            dp[i][1] = dp[i-1][1]\n        else:\n            dp[i][0] = dp[i-1][0]\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1])%998244353\n\n    ans = (dp[-1][0] + dp[-1][1])%998244353\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\n# a = [1, 2, 1, 2, 3]\n# a = [100, 1]\n# a = [1, 3, 3, 7]\n\nm = max(a)\nc = [0] * (m + 1)\nfor i in range(n):\n    c[a[i]] += 1\n\nf = [0] * (m + 1)\nf[0] = 1\nf[1] = 1\nfor i in range(2, m + 1):\n    f[i] = (f[i - 1] + f[i - 2]) % 998244353\n\nans = 1\nfor i in range(1, m + 1):\n    ans *= f[c[i]]\n    ans %= 998244353\n\nprint(ans)", "\n\nn = int(input())\na = list(map(int, input().split()))\n\n# 1. Find the number of distinct values in the array.\n# 2. For each distinct value, count the number of ways of renumbering it.\n# 3. Multiply these values together and print the result.\n\n# 1. Find the number of distinct values in the array.\ndistinct_values = []\nfor i in range(n):\n    if a[i] not in distinct_values:\n        distinct_values.append(a[i])\n\n# 2. For each distinct value, count the number of ways of renumbering it.\n# This is a dynamic programming problem.\n# The number of ways of renumbering a single value is 1.\n# The number of ways of renumbering a sequence of two values is 2.\n# The number of ways of renumbering a sequence of three values is the sum of the number of ways of renumbering the first two values and the number of ways of renumbering the last two values.\n# The number of ways of renumbering a sequence of four values is the sum of the number of ways of renumbering the first three values and the number of ways of renumbering the last three values.\n# The number of ways of renumbering a sequence of five values is the sum of the number of ways of renumbering the first four values and the number of ways of renumbering the last four values.\n# ...\n# The number of ways of renumbering a sequence of n values is the sum of the number of ways of renumbering the first n-1 values and the number of ways of renumbering the last n-1 values.\n# The base cases are the number of ways of renumbering a single value (1) and the number of ways of renumbering a sequence of two values (2).\n\n# 3. Multiply these values together and print the result.\n\n# Initialize the number of ways of renumbering the sequence of a single value to 1.\nnum_ways = [1]\n\n# Initialize the number of ways of renumbering the sequence of two values to 2.\n# This is the base case for the dynamic programming algorithm.\nnum_ways.append(2)\n\n# Find the number of ways of renumbering the sequence of three values.\nnum_ways.append(num_ways[1] + num_ways[0])\n\n# Find the number of ways of renumbering the sequence of four values.\nnum_ways.append(num_ways[2] + num_ways[1])\n\n# Find the number of ways of renumbering the sequence of five values.\nnum_ways.append(num_ways[3] + num_ways[2])\n\n# Find the number of ways of renumbering the sequence of n values.\nfor i in range(5, n):\n    num_ways.append(num_ways[i-1] + num_ways[i-2])\n\n# The number of ways of renumbering a sequence of n values is the sum of the number of ways of renumbering the first n-1 values and the number of ways of renumbering the last n-1 values.\n# The base cases are the number of ways of renumbering a single value (1) and the number of ways of renumbering a sequence of two values (2).\n\n# Multiply these values together and print the result.\nresult = 1\nfor i in range(len(distinct_values)):\n    result *= num_ways[a.count(distinct_values[i])]\n\nprint(result % 998244353)", "\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = 1\n    for i in range(1, n):\n        if a[i] != a[i-1]:\n            cnt += 1\n    print(2 ** cnt % 998244353)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef main():\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    d = {}\n    for i in a:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n    num = 1\n    for i in d:\n        num *= factorial(d[i])\n        num = num % 998244353\n    den = factorial(n)\n    den = den % 998244353\n    num_renum = den * modinv(num, 998244353)\n    print(num_renum % 998244353)\n\nif __name__ == \"__main__\":\n    main()", "\n\n# Solution\n\nimport sys\nimport math\n\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef modInv(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if (m == 1):\n        return 0\n    while (a > 1):\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if (x < 0):\n        x = x + m0\n    return x\n\ndef modDiv(a, b, m):\n    a = a % m\n    inv = modInv(b, m)\n    return (inv * a) % m\n\ndef modMul(a, b, m):\n    return (a * b) % m\n\nmod = 998244353\n\ncnt = [0] * n\ncnt[0] = 1\n\nfor i in range(1, n):\n    if a[i] == a[i - 1]:\n        cnt[i] = cnt[i - 1]\n    else:\n        cnt[i] = modMul(cnt[i - 1], 2, mod)\n\nprint(cnt[n - 1])"]