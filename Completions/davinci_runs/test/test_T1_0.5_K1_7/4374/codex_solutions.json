["", "\n\nimport sys\n\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    edges = []\n    for i in range(m):\n        edges.append([int(x) for x in sys.stdin.readline().split()])\n    print(1)\n    print(1, n)\n\n\nif __name__ == '__main__':\n    main()", "\n\nfrom typing import List\n\n\ndef solve(n: int, edges: List[List[int]]) -> List[List[int]]:\n    # TODO\n    pass\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    result = solve(n, edges)\n    print(len(result))\n    for edge in result:\n        print(edge[0], edge[1])", "\n\nfrom collections import defaultdict\nfrom sys import stdin\nfrom typing import List, Tuple\n\ndef main():\n    n, m = [int(x) for x in stdin.readline().split()]\n    edges = [tuple(int(x) for x in stdin.readline().split()) for _ in range(m)]\n    print(minimal_tree_diameter(n, m, edges))\n\ndef minimal_tree_diameter(n: int, m: int, edges: List[Tuple[int, int]]) -> int:\n    tree = defaultdict(set)\n    for edge in edges:\n        tree[edge[0]].add(edge[1])\n        tree[edge[1]].add(edge[0])\n    diameter_tree = defaultdict(set)\n    for i in range(1, n + 1):\n        diameter_tree[i] = tree[i]\n        for j in tree[i]:\n            diameter_tree[i].update(tree[j])\n        diameter_tree[i].remove(i)\n    diameter = max(len(diameter_tree[i]) for i in range(1, n + 1))\n    if diameter == n - 1:\n        return diameter\n    added_edges = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if j in diameter_tree[i]:\n                continue\n            tree[i].add(j)\n            tree[j].add(i)\n            diameter_tree[i].add(j)\n            diameter_tree[j].add(i)\n            new_diameter = max(len(diameter_tree[k]) for k in range(1, n + 1))\n            if new_diameter == diameter:\n                added_edges.append((i, j))\n                diameter = new_diameter\n                break\n            tree[i].remove(j)\n            tree[j].remove(i)\n            diameter_tree[i].remove(j)\n            diameter_tree[j].remove(i)\n    return '\\n'.join([str(diameter)] + list(map(lambda x: ' '.join(map(str, x)), added_edges)))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport os\nimport heapq\n\ndef solve(n, m, edges):\n    if m == n - 1:\n        return 0\n    else:\n        graph = [[] for i in range(n + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        visited = [False] * (n + 1)\n        q = [(0, 1)]\n        while q:\n            d, v = heapq.heappop(q)\n            if visited[v]:\n                continue\n            visited[v] = True\n            for u in graph[v]:\n                if not visited[u]:\n                    heapq.heappush(q, (d + 1, u))\n\n        return d\n\n\nif __name__ == \"__main__\":\n    #sys.stdin = open(\"input.txt\", \"r\")\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for i in range(m)]\n    print(solve(n, m, edges))", "\n\nfrom collections import deque\n\n\ndef diameter(graph, n):\n    queue = deque([0])\n    visited = [False] * n\n    visited[0] = True\n    distances = [0] * n\n\n    while queue:\n        current = queue.popleft()\n\n        for neighbour in graph[current]:\n            if not visited[neighbour]:\n                visited[neighbour] = True\n                distances[neighbour] = distances[current] + 1\n                queue.append(neighbour)\n\n    return max(distances)\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        v, u = map(int, input().split())\n        graph[v - 1].append(u - 1)\n        graph[u - 1].append(v - 1)\n\n    print(diameter(graph, n))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\nclass Edge:\n    def __init__(self, v1, v2, weight):\n        self.v1 = v1\n        self.v2 = v2\n        self.weight = weight\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.adj = [[] for i in range(n)]\n\n    def add_edge(self, v1, v2, weight):\n        self.adj[v1].append(Edge(v1, v2, weight))\n        self.adj[v2].append(Edge(v2, v1, weight))\n\n    def find_min_edge(self, visited):\n        min_edge = None\n        for v in range(self.n):\n            if not visited[v]:\n                for edge in self.adj[v]:\n                    if not visited[edge.v2]:\n                        if not min_edge or edge.weight < min_edge.weight:\n                            min_edge = edge\n        return min_edge\n\n    def prim(self):\n        visited = [False] * self.n\n        mst = Graph(self.n)\n        visited[0] = True\n        for i in range(self.n - 1):\n            min_edge = self.find_min_edge(visited)\n            visited[min_edge.v2] = True\n            mst.add_edge(min_edge.v1, min_edge.v2, min_edge.weight)\n        return mst\n\n\nclass Node:\n    def __init__(self, v):\n        self.v = v\n        self.parent = None\n        self.children = []\n        self.height = 0\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n        self.update_height()\n\n    def update_height(self):\n        max_height = -1\n        for child in self.children:\n            if child.height > max_height:\n                max_height = child.height\n        self.height = max_height + 1\n\n    def update_all_heights(self):\n        self.update_height()\n        if self.parent:\n            self.parent.update_all_heights()\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.nodes = [Node(i) for i in range(n)]\n\n    def add_edge(self, v1, v2):\n        self.nodes[v1].add_child(self.nodes[v2])\n\n    def get_diameter(self):\n        max_height = -1\n        for node in self.nodes:\n            if node.height > max_height:\n                max_height = node.height\n        return max_height\n\n    def get_height(self, v):\n        return self.nodes[v].height\n\n\ndef get_input():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = Graph(n)\n    for i in range(m):\n        v1, v2 = map(int, sys.stdin.readline().split())\n        graph.add_edge(v1 - 1, v2 - 1, 1)\n    return graph\n\ndef main():\n    graph = get_input()\n    mst = graph.prim()\n    tree = Tree(graph.n)\n    for v in range(graph.n):\n        for edge in mst.adj[v]:\n            tree.add_edge(edge.v1, edge.v2)\n    diameter = tree.get_diameter()\n    print(diameter)\n    for v in range(graph.n):\n        for edge in graph.adj[v]:\n            if tree.get_height(edge.v1) + tree.get_height(edge.v2) + 1 == diameter:\n                print(edge.v1 + 1, edge.v2 + 1)\n                break\n\nif __name__ == '__main__':\n    main()"]