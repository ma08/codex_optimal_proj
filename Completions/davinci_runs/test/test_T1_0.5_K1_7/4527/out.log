2022-04-13 21:35:27.485388 """
You are given $n$ segments on a coordinate axis $OX$. The $i$-th segment has borders $[l_i; r_i]$. All points $x$, for which $l_i \le x \le r_i$ holds, belong to the $i$-th segment.

Your task is to choose the maximum by size (the number of segments) subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.

Two segments $[l_i; r_i]$ and $[l_j; r_j]$ are non-intersecting if they have no common points. For example, segments $[1; 2]$ and $[3; 4]$, $[1; 3]$ and $[5; 5]$ are non-intersecting, while segments $[1; 2]$ and $[2; 3]$, $[1; 2]$ and $[2; 2]$ are intersecting.

The segment $[l_i; r_i]$ lies inside the segment $[l_j; r_j]$ if $l_j \le l_i$ and $r_i \le r_j$. For example, segments $[2; 2]$, $[2, 3]$, $[3; 4]$ and $[2; 4]$ lie inside the segment $[2; 4]$, while $[2; 5]$ and $[1; 4]$ are not.

You have to answer $t$ independent test cases.


-----Input-----

The first line of the input contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases. Then $t$ test cases follow.

The first line of the test case contains one integer $n$ ($1 \le n \le 3000$) — the number of segments. The next $n$ lines describe segments. The $i$-th segment is given as two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le 2 \cdot 10^5$), where $l_i$ is the left border of the $i$-th segment and $r_i$ is the right border of the $i$-th segment.

Additional constraint on the input: there are no duplicates in the list of segments.

It is guaranteed that the sum of $n$ does not exceed $3000$ ($\sum n \le 3000$).


-----Output-----

For each test case, print the answer: the maximum possible size of the subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.


-----Example-----
Input
4
4
1 5
2 4
2 3
3 4
5
1 5
2 3
2 5
3 5
2 2
3
1 3
2 4
2 3
7
1 10
2 8
2 5
3 4
4 4
6 8
7 7

Output
3
4
2
7
"""
2022-04-13 21:35:27.485405 --------------------------
2022-04-13 21:35:54.180405 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n#Solution:\n\nimport sys\n\ndef solve(n, segments):\n    segments.sort(key=lambda x: x[1])\n    last = segments[0][1]\n    count = 1\n    for i in range(1, n):\n        if segments[i][0] > last:\n            count += 1\n            last = segments[i][1]\n    return count\n\nif __name__ == '__main__':\n    t = int(sys.stdin.readline())\n    for i in range(t):\n        n = int(sys.stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = map(int, sys.stdin.readline().split())\n            segments.append([l, r])\n        print(solve(n, segments))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        segments.sort(key=lambda x: x[1])\n        curr_right = segments[0][1]\n        ans = 1\n        for l, r in segments[1:]:\n            if l > curr_right:\n                ans += 1\n                curr_right = r\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n# We will use a greedy approach, sorting the segments and then taking the maximum segment that doesn't intersect with the previous one.\n\n# We sort the segments by their left coordinate and then we iterate through them.\n# We will keep a variable curr_max that will be the maximum segment that we have chosen so far.\n# We will keep a variable ans that will be our final answer.\n\n# If the current segment doesn't intersect with curr_max, we update curr_max to be the current segment.\n# Otherwise, we will only update curr_max if the current segment is bigger than curr_max.\n# In either case, we will update our answer by adding 1.\n\n# See the code below for a more formal implementation.\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n    segments = sorted(segments, key=lambda x: x[0])\n    ans = 0\n    curr_max = segments[0]\n    for l, r in segments:\n        if l > curr_max[1]:\n            curr_max = (l, r)\n        else:\n            curr_max = max(curr_max, (l, r), key=lambda x: x[1])\n        ans += 1\n    print(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\n#from sys import stdin\n#from collections import namedtuple\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    segments = []\n    for _ in range(N):\n        segments.append(list(map(int, input().split())))\n    segments.sort(key=lambda x: x[0])\n    dp = [1]*N\n    for i in range(1,N):\n        for j in range(i):\n            if segments[i][0]>=segments[j][1]:\n                dp[i] = max(dp[i], dp[j]+1)\n    print(max(dp))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        yield segments\n\ndef solve(segments):\n    segments = sorted(segments)\n    result = [segments[0]]\n    for l, r in segments[1:]:\n        if l <= result[-1][1]:\n            result[-1] = (result[-1][0], max(result[-1][1], r))\n        else:\n            result.append((l, r))\n    return len(result)\n\nif __name__ == '__main__':\n    for segments in get_input():\n        print(solve(segments))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n\ndef segment_intersection(segments):\n    segments.sort(key=lambda x: x[1])\n    result = []\n    current = segments[0]\n    for segment in segments[1:]:\n        if segment[0] > current[1]:\n            result.append(current)\n            current = segment\n    result.append(current)\n    return result\n\n\ndef solve(segments):\n    return len(segment_intersection(segments))\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        print(solve(segments))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef max_subset(segments):\n    # sort segments by left border\n    segments.sort(key=lambda s: s[0])\n    # add right border of the first segment to right_borders\n    right_borders = [segments[0][1]]\n    for segment in segments[1:]:\n        # if the segment lies inside one of the segments in right_borders,\n        # then continue\n        if segment[1] <= right_borders[-1]:\n            continue\n        # if the segment is non-intersecting with all segments in right_borders,\n        # then add it to right_borders\n        if segment[0] > right_borders[-1]:\n            right_borders.append(segment[1])\n        # if the segment is intersecting with at least one segment in right_borders,\n        # then replace the right border of the last segment in right_borders\n        # with the right border of the segment\n        else:\n            right_borders[-1] = segment[1]\n    return len(right_borders)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        print(max_subset(segments))\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1649885727,
  "id": "cmpl-4wew39XXYZb07G6SShQWAHAdysdwg",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:35:54.180731 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n#Solution:\n\nimport sys\n\ndef solve(n, segments):\n    segments.sort(key=lambda x: x[1])\n    last = segments[0][1]\n    count = 1\n    for i in range(1, n):\n        if segments[i][0] > last:\n            count += 1\n            last = segments[i][1]\n    return count\n\nif __name__ == '__main__':\n    t = int(sys.stdin.readline())\n    for i in range(t):\n        n = int(sys.stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = map(int, sys.stdin.readline().split())\n            segments.append([l, r])\n        print(solve(n, segments))"
}
2022-04-13 21:35:54.180781 REASON stop
2022-04-13 21:35:54.181166 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        segments.sort(key=lambda x: x[1])\n        curr_right = segments[0][1]\n        ans = 1\n        for l, r in segments[1:]:\n            if l > curr_right:\n                ans += 1\n                curr_right = r\n        print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:35:54.181271 REASON stop
2022-04-13 21:35:54.181704 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n# We will use a greedy approach, sorting the segments and then taking the maximum segment that doesn't intersect with the previous one.\n\n# We sort the segments by their left coordinate and then we iterate through them.\n# We will keep a variable curr_max that will be the maximum segment that we have chosen so far.\n# We will keep a variable ans that will be our final answer.\n\n# If the current segment doesn't intersect with curr_max, we update curr_max to be the current segment.\n# Otherwise, we will only update curr_max if the current segment is bigger than curr_max.\n# In either case, we will update our answer by adding 1.\n\n# See the code below for a more formal implementation.\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n    segments = sorted(segments, key=lambda x: x[0])\n    ans = 0\n    curr_max = segments[0]\n    for l, r in segments:\n        if l > curr_max[1]:\n            curr_max = (l, r)\n        else:\n            curr_max = max(curr_max, (l, r), key=lambda x: x[1])\n        ans += 1\n    print(ans)"
}
2022-04-13 21:35:54.181759 REASON stop
2022-04-13 21:35:54.208080 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\n#from sys import stdin\n#from collections import namedtuple\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    segments = []\n    for _ in range(N):\n        segments.append(list(map(int, input().split())))\n    segments.sort(key=lambda x: x[0])\n    dp = [1]*N\n    for i in range(1,N):\n        for j in range(i):\n            if segments[i][0]>=segments[j][1]:\n                dp[i] = max(dp[i], dp[j]+1)\n    print(max(dp))"
}
2022-04-13 21:35:54.208179 REASON stop
2022-04-13 21:35:54.218008 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        yield segments\n\ndef solve(segments):\n    segments = sorted(segments)\n    result = [segments[0]]\n    for l, r in segments[1:]:\n        if l <= result[-1][1]:\n            result[-1] = (result[-1][0], max(result[-1][1], r))\n        else:\n            result.append((l, r))\n    return len(result)\n\nif __name__ == '__main__':\n    for segments in get_input():\n        print(solve(segments))"
}
2022-04-13 21:35:54.218106 REASON stop
2022-04-13 21:35:54.219510 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n\ndef segment_intersection(segments):\n    segments.sort(key=lambda x: x[1])\n    result = []\n    current = segments[0]\n    for segment in segments[1:]:\n        if segment[0] > current[1]:\n            result.append(current)\n            current = segment\n    result.append(current)\n    return result\n\n\ndef solve(segments):\n    return len(segment_intersection(segments))\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        print(solve(segments))"
}
2022-04-13 21:35:54.219573 REASON stop
2022-04-13 21:35:54.220444 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef max_subset(segments):\n    # sort segments by left border\n    segments.sort(key=lambda s: s[0])\n    # add right border of the first segment to right_borders\n    right_borders = [segments[0][1]]\n    for segment in segments[1:]:\n        # if the segment lies inside one of the segments in right_borders,\n        # then continue\n        if segment[1] <= right_borders[-1]:\n            continue\n        # if the segment is non-intersecting with all segments in right_borders,\n        # then add it to right_borders\n        if segment[0] > right_borders[-1]:\n            right_borders.append(segment[1])\n        # if the segment is intersecting with at least one segment in right_borders,\n        # then replace the right border of the last segment in right_borders\n        # with the right border of the segment\n        else:\n            right_borders[-1] = segment[1]\n    return len(right_borders)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, input().split())\n            segments.append((l, r))\n        print(max_subset(segments))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:35:54.220506 REASON stop
