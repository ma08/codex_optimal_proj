["", "\n\ndef main():\n    \"\"\"\n    This problem is actually the same as the problem of finding the most optimal way to split a string into substrings of a given length.\n    \"\"\"\n    n, k = map(int, input().split())\n    s = input()\n    if k > n:\n        print(-1)\n        return\n    # Split the string into substrings of length k\n    # The cost for each substring is k - 1\n    print((n - k) * (k - 1))\n\nmain()", "\n\nn,k = [int(x) for x in input().split()]\ns = input()\n\ndef subseqs(s):\n    if len(s) == 0:\n        return [\"\"]\n    else:\n        sub = subseqs(s[1:])\n        return [s[0] + x for x in sub] + sub\n\nsubs = subseqs(s)\n\nif len(subs) < k:\n    print(-1)\nelse:\n    subs = sorted(subs, key=len)\n    print(sum(len(s) for s in subs[:k]))", "\n\nfrom sys import stdin\n\nn, k = map(int, stdin.readline().split())\ns = stdin.readline().strip()\n\nif k > 2**n:\n    print(-1)\n    exit()\n\n# Each index represents a possible subsequence\n# The value is the cost of that subsequence\ncosts = [0] + [n]*(2**n)\n\nfor i in range(2**n):\n    for j in range(n):\n        if i & (1<<j):\n            # If j is in the subsequence, calculate the cost\n            costs[i] = min(costs[i], costs[i & ~(1<<j)] + 1)\n\nprint(costs[-k])", "\n\n#SOLUTION\n\nn,k = map(int,input().split())\ns = input()\n\nif n<k:\n    print(-1)\nelse:\n    print(n*(k-1))", "\n\nn, k = list(map(int, input().split()))\ns = input()\n\nif k > n*(n+1)//2:\n    print(-1)\nelse:\n    print(n*(n+1)//2 - k)"]