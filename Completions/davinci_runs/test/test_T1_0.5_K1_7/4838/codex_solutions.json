["\n\ndef main():\n    n = int(input())\n    times = []\n    for i in range(n):\n        times.append(int(input()))\n    # print(times)\n    if n == 0:\n        print(\"still running\")\n    else:\n        print(times[-1])\n\nif __name__ == \"__main__\":\n    main()", "\n\n# The idea is to use a counter to keep track of the number of button presses, and a variable to keep track of the last time it was pressed.\n# If the counter is even, the stopwatch is stopped, so we just update the last time it was pressed.\n# If the counter is odd, the stopwatch is running, so we add the current time - the last time it was pressed to the total running time of the stopwatch.\n# We then update the last time it was pressed.\n# If the counter is equal to N, then we know that the stopwatch is still running.\n\nimport sys\n\ndef stopwatch():\n    N = int(sys.stdin.readline().strip())\n    presses = []\n    for i in range(N):\n        presses.append(int(sys.stdin.readline().strip()))\n    counter = 0\n    last_press = 0\n    time = 0\n    for press in presses:\n        if counter % 2 == 0:\n            last_press = press\n            counter += 1\n        else:\n            time += press - last_press\n            last_press = press\n            counter += 1\n    if counter == N:\n        print(\"still running\")\n    else:\n        print(time)\n\nstopwatch()", "\n\nn = int(input())\ntimes = []\nfor i in range(n):\n    times.append(int(input()))\n\ntime = 0\nfor i in range(n):\n    if i == 0:\n        time += times[0]\n    else:\n        time += (times[i] - times[i-1])\n\nif time % 2 == 0:\n    print(time // 2)\nelse:\n    print(\"still running\")", "\n\nimport sys\n\ndef main():\n    num_presses = int(sys.stdin.readline())\n    times = []\n    for i in range(num_presses):\n        times.append(int(sys.stdin.readline()))\n    if len(times) == 1:\n        print times[0]\n        return\n    state = 'stopped'\n    start_time = times[0]\n    end_time = 0\n    for i in range(1, len(times)):\n        if state == 'stopped':\n            state = 'running'\n            start_time = times[i]\n        else:\n            state = 'stopped'\n            end_time = times[i]\n            break\n    if state == 'stopped':\n        print end_time - start_time\n    else:\n        print 'still running'\n\nif __name__ == '__main__':\n    main()", "\n\nN = int(input())\n\ntimes = []\n\nfor i in range(N):\n    times.append(int(input()))\n\ntimer = 0\n\nfor i in range(N):\n    if i == 0:\n        timer = times[i]\n    else:\n        if times[i] - times[i-1] == 1:\n            timer += 1\n        else:\n            break\n\nif timer < times[-1]:\n    print(\"still running\")\nelse:\n    print(timer)", "\n\nN = int(input())\ntimes = [int(input()) for i in range(N)]\n\n# Find the longest run of times\n# If the last time is even, then the timer is still running\n# Otherwise, the timer is stopped and the last time is the total\n\nstart = 0\nend = 0\nmax_start = 0\nmax_end = 0\n\nfor i in range(len(times)):\n    if i == 0:\n        start = times[i]\n        max_start = times[i]\n        end = times[i]\n        max_end = times[i]\n    elif times[i] == times[i-1] + 1:\n        end = times[i]\n        if end - start > max_end - max_start:\n            max_start = start\n            max_end = end\n    else:\n        start = times[i]\n        end = times[i]\n\nif times[-1] % 2 == 0:\n    print(\"still running\")\nelse:\n    print(max_end - max_start + 1)", "\n\nN = int(input())\ntimes = []\nfor i in range(N):\n    times.append(int(input()))\n\nif len(times) % 2 == 0:\n    print(\"still running\")\nelse:\n    print(times[-1] - times[0])"]