["\n\nimport heapq\n\n[n, m, k] = [int(x) for x in input().split(' ')]\na = [int(x) for x in input().split(' ')]\n\na.sort()\n\noffers = []\nfor i in range(m):\n    offers.append([int(x) for x in input().split(' ')])\n\nheapq.heapify(offers)\n\nres = 0\n\nfor i in range(k):\n    if len(offers) > 0 and offers[0][0] == i:\n        offer = heapq.heappop(offers)\n        offer[0] += offer[1]\n        if offer[0] > k:\n            offer[0] = k\n        heapq.heappush(offers, offer)\n    res += a[i]\n\nprint(res)", "\n\nimport sys\nimport heapq\n\n# read data for n sequences\nn, m, k = map(int, raw_input().split())\na = map(int, raw_input().split())\n\n# sort the shovels by their prices\na.sort()\n\n# init the offer heap\noffers = []\nfor i in range(m):\n    x, y = map(int, raw_input().split())\n    heapq.heappush(offers, (x, y))\n\n# calculate the minimum cost\ncost = 0\nfor i in range(k):\n    # check if there are offers\n    if len(offers) > 0:\n        x, y = heapq.heappop(offers)\n        # if there are enough shovels\n        if x > i:\n            # if there are enough free shovels\n            if y >= x - i:\n                # add the remaining shovels to the cost\n                cost += sum(a[i:x])\n                # update the offers\n                if x - i > 1:\n                    heapq.heappush(offers, (x - i, y - (x - i)))\n            # if there are not enough free shovels\n            else:\n                # add the remaining shovels to the cost\n                cost += sum(a[i:i+y])\n                # update the offers\n                heapq.heappush(offers, (i+y, 0))\n        # if there are not enough shovels\n        else:\n            # add the remaining shovels to the cost\n            cost += sum(a[i:x])\n            # update the offers\n            if x - i > 1:\n                heapq.heappush(offers, (x - i, y - (x - i)))\n    else:\n        # if there are no offers left just add the remaining shovels to the cost\n        cost += sum(a[i:k])\nprint cost", "\n\nn, m, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\noffers = []\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    offers.append((x, y))\n\na.sort()  # sort the costs from low to high\n\n# calculate the cost of buying x shovels\ndef cost(x):\n    if x == 0:\n        return 0\n    # first, try to use an offer\n    for offer in offers:\n        if x == offer[0]:\n            return cost(x - offer[1])\n    # otherwise, buy the cheapest shovels\n    return cost(x - 1) + a[x - 1]\n\nprint(cost(k))", "\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef read_int():\n    return read_ints()[0]\n\ndef read_int_line():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef read_int_lines(n):\n    return [read_int_line() for i in range(n)]\n\ndef solve(n, m, k, a, offers):\n    a.sort()\n    offers.sort(key=lambda x: x[0])\n\n    dp = [[sys.maxsize] * (k + 1) for i in range(n)]\n    dp[0][1] = a[0]\n    for i in range(1, n):\n        dp[i][1] = min(dp[i-1][1], a[i])\n\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            dp[i-1][j] = min(dp[i-1][j], dp[i-2][j] + a[i-1])\n            for offer in offers:\n                if offer[0] == i and offer[1] <= j:\n                    dp[i-1][j] = min(dp[i-1][j], dp[i-offer[0]][j-offer[1]])\n\n    return dp[n-1][k]\n\nif __name__ == '__main__':\n    n, m, k = read_ints()\n    a = read_ints()\n    offers = read_int_lines(m)\n    print(solve(n, m, k, a, offers))", "\n\nfrom math import inf\nfrom typing import List, Tuple\n\n\ndef read_list() -> List[int]:\n    return [int(x) for x in input().split()]\n\n\ndef read_tuple() -> Tuple[int, int]:\n    return tuple(read_list())\n\n\ndef read_tuple_list(n: int) -> List[Tuple[int, int]]:\n    return [read_tuple() for _ in range(n)]\n\n\ndef min_cost(n: int, m: int, k: int, prices: List[int], offers: List[Tuple[int, int]]) -> int:\n    if k <= m:\n        return sum(sorted(prices)[:k])\n\n    total_cost = 0\n    for i in range(k):\n        total_cost += prices[i]\n\n    for _ in range(m):\n        offer = offers.pop()\n        if offer[0] > k:\n            continue\n\n        min_prices = sorted(prices[:offer[0]])[:offer[1]]\n        total_cost -= sum(min_prices)\n\n    return total_cost\n\n\ndef main():\n    n, m, k = read_list()\n    prices = read_list()\n    offers = read_tuple_list(m)\n\n    print(min_cost(n, m, k, prices, offers))\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport heapq\n\nn, m, k = [int(x) for x in input().split()]\nshovels = [int(x) for x in input().split()]\n\noffers = []\n\nfor i in range(m):\n    offers.append([int(x) for x in input().split()])\n\noffers.sort(key=lambda x: x[1])\n\nshovels.sort()\n\ncost = 0\nfor i in range(k):\n    cost += shovels[i]\n\nfor offer in offers:\n    if k <= offer[0]:\n        cost -= (offer[1] * (shovels[offer[0]-1] - shovels[offer[0]-1-offer[1]]))\n        break\n\nprint(cost)"]