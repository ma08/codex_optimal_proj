["\n\n# SOLUTION\n\nimport math\n\ndef check(lst):\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            if i != j:\n                if lst[i] + lst[j] == 2**math.floor(math.log(lst[i] + lst[j], 2)):\n                    return True\n    return False\n\ndef remove(lst):\n    if check(lst):\n        return 0\n    else:\n        for i in range(len(lst)):\n            lst.pop(i)\n            if check(lst):\n                return 1 + remove(lst)\n            lst.insert(i, lst[i])\n        return len(lst)\n            \n\nn = int(input())\nlst = list(map(int, input().split()))\nprint(remove(lst))", "\n\nfrom collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\n\n# if a number is a power of 2\n# then it has only one bit set to 1\n# and all other bits are 0\n# we can check if a number is a power of 2\n# by ANDing it with its previous number\n# if the result is 0, then it is a power of 2\ndef is_power_of_2(x):\n    return x != 0 and ((x & (x - 1)) == 0)\n\n# if a number is a power of 2\n# then its binary representation is of the form\n# 1 followed by all 0s\n# so the number of 0s is the exponent of the power of 2\ndef count_zeros(x):\n    return bin(x).count(\"0\") - 1\n\n# we need to delete all numbers\n# whose sum with all other numbers is not a power of 2\n# we can count the number of zeros in all sums of two numbers\n# and we need to delete all numbers whose sum with all other numbers\n# has the maximum number of zeros\n# because that means that the sum is a power of 2\n# and all other numbers whose sum with all other numbers\n# has a number of zeros less than the maximum number of zeros\n# will be deleted\ncounter = Counter()\nfor i in range(n):\n    for j in range(i + 1, n):\n        counter[count_zeros(a[i] + a[j])] += 1\n\n# if the maximum number of zeros is 0, then we need to delete all numbers\n# because the sum of any two numbers is not a power of 2\nif counter[max(counter.keys())] == 0:\n    print(n)\n# otherwise, we need to delete all numbers whose sum with all other numbers\n# has a number of zeros less than the maximum number of zeros\nelse:\n    print(n - counter[max(counter.keys())])", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    Count the number of occurences of each number and\n    if the number of occurences is odd, then it can't be part\n    of a pair.\n    \"\"\"\n\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n\n    d = {}\n\n    for num in a:\n        d[num] = d.get(num, 0) + 1\n\n    count = 0\n    for num, occurences in d.items():\n        if occurences % 2 == 1:\n            count += 1\n\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\narr = list(map(int, input().split()))\n\nfor i in range(n):\n    if arr[i] not in arr[:i] + arr[i+1:]:\n        print(n-1)\n        break\nelse:\n    print(n)", "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\nif n == 1:\n    print(1)\n    exit()\n\npowers = [2**i for i in range(1, 31)]\n\na = set(a)\n\ndef get_power(x):\n    for p in powers:\n        if p == x:\n            return True\n    return False\n\ndef get_sum(x):\n    for i in a:\n        if i != x and get_power(x+i):\n            return True\n    return False\n\nans = 0\nfor i in a:\n    if not get_sum(i):\n        ans += 1\n\nprint(ans)", "\n\na = [4, 7, 1, 5, 4, 9]\n\nprint(a)\n\n# for i in range(0, len(a)):\n#     if (a[i] + a[i]) in a:\n#         a.pop(i)\n#         break\n\nfor i in range(0, len(a)):\n    for j in range(0, len(a)):\n        if i != j:\n            if a[i] + a[j] in a:\n                a.pop(i)\n                break\n\nprint(a)"]