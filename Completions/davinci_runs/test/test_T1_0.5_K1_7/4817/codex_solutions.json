["\n\nimport sys\n\ndef next_permutation(arr):\n    # Find non-increasing suffix\n    i = len(arr) - 1\n    while i > 0 and arr[i - 1] >= arr[i]:\n        i -= 1\n    if i <= 0:\n        return False\n    \n    # Find successor to pivot\n    j = len(arr) - 1\n    while arr[j] <= arr[i - 1]:\n        j -= 1\n    arr[i - 1], arr[j] = arr[j], arr[i - 1]\n    \n    # Reverse suffix\n    arr[i : ] = arr[len(arr) - 1 : i - 1 : -1]\n    return True\n\nn = list(sys.stdin.readline().strip())\nif next_permutation(n):\n    print(\"\".join(n))\nelse:\n    print(0)", "\n\nfrom sys import stdin\n\ndef next_permutation(a):\n\t\"\"\"\n\tGenerates the lexicographically next permutation of a list in-place.\n\t\"\"\"\n\t# Find longest non-increasing suffix\n\ti = len(a) - 1\n\twhile i > 0 and a[i - 1] >= a[i]:\n\t\ti -= 1\n\tif i <= 0:\n\t\treturn False\n\t\n\t# Find successor to pivot\n\tj = len(a) - 1\n\twhile a[j] <= a[i - 1]:\n\t\tj -= 1\n\ta[i - 1], a[j] = a[j], a[i - 1]\n\t\n\t# Reverse suffix\n\ta[i : ] = a[len(a) - 1 : i - 1 : -1]\n\treturn True\n\ndef main():\n\tx = stdin.readline().strip()\n\tif not next_permutation(list(x)):\n\t\tprint(0)\n\telse:\n\t\tprint(\"\".join(x))\n\nmain()", "\n\ndef main():\n    num = input()\n    num = list(num)\n    num = [int(i) for i in num]\n\n    if num == sorted(num, reverse=True):\n        print(0)\n    else:\n        for i in range(1, len(num)):\n            if num[-i] < num[-i-1]:\n                for j in range(i, len(num)):\n                    if num[-i-1] < num[-j]:\n                        num[-i-1], num[-j] = num[-j], num[-i-1]\n                        break\n                num = num[:-i] + sorted(num[-i:])\n                break\n\n        print(''.join([str(i) for i in num]))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef next_permutation(num):\n\t\"\"\"\n\tReturns the next permutation of the number provided.\n\t\"\"\"\n\t# Find longest non-increasing suffix\n\ti = len(num) - 1\n\twhile i > 0 and num[i - 1] >= num[i]:\n\t\ti -= 1\n\tif i <= 0:\n\t\treturn 0\n\t\n\t# Find successor to pivot\n\tj = len(num) - 1\n\twhile num[j] <= num[i - 1]:\n\t\tj -= 1\n\tnum[i - 1], num[j] = num[j], num[i - 1]\n\t\n\t# Reverse suffix\n\tnum[i : ] = num[len(num) - 1 : i - 1 : -1]\n\treturn int(''.join(num))\n\ndef main():\n\tfor line in sys.stdin:\n\t\tprint(next_permutation(list(line.strip())))\n\nif __name__ == '__main__':\n\tmain()", "\n\ndef nextPermutation(arr):\n    # Find non-increasing suffix\n    i = len(arr) - 1\n    while i > 0 and arr[i - 1] >= arr[i]:\n        i -= 1\n    if i <= 0:\n        return False\n    \n    # Find successor to pivot\n    j = len(arr) - 1\n    while arr[j] <= arr[i - 1]:\n        j -= 1\n    arr[i - 1], arr[j] = arr[j], arr[i - 1]\n    \n    # Reverse suffix\n    arr[i : ] = arr[len(arr) - 1 : i - 1 : -1]\n    return True\n\ndef main():\n    num = input()\n    num = [int(x) for x in str(num)]\n    if not nextPermutation(num):\n        print(0)\n    else:\n        print(\"\".join(map(str, num)))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\n\ndef get_next_perm(N):\n    N_str = str(N)\n    N_len = len(N_str)\n    i = N_len - 2\n    while i >= 0:\n        if N_str[i] < N_str[i+1]:\n            break\n        i -= 1\n    if i < 0:\n        return 0\n    j = N_len - 1\n    while j >= 0:\n        if N_str[i] < N_str[j]:\n            break\n        j -= 1\n    N_str = list(N_str)\n    N_str[i], N_str[j] = N_str[j], N_str[i]\n    N_str = ''.join(N_str)\n    N_str = N_str[:i+1] + N_str[i+1:][::-1]\n    return int(N_str)\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    print(get_next_perm(N))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    x = int(sys.stdin.readline().strip())\n\n    # Create a list of the digits of x\n    digits = [int(i) for i in str(x)]\n\n    # Find the first digit in the list that is larger than the digit to its right\n    for i in range(len(digits)-1):\n        if digits[i] > digits[i+1]:\n            break\n    else:\n        print(0)\n        return\n\n    # Find the smallest digit to the right of the digit found above\n    min_digit = min(digits[i+1:])\n    min_index = digits[i+1:].index(min_digit) + i + 1\n\n    # Swap the two digits\n    digits[i], digits[min_index] = digits[min_index], digits[i]\n\n    # Sort the digits to the right of digit i\n    digits[i+1:] = sorted(digits[i+1:])\n\n    # Output the result\n    print(int(''.join([str(i) for i in digits])))\n\nif __name__ == '__main__':\n    main()"]