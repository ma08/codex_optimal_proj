2022-04-13 20:33:16.302424 """
Polycarp has $n$ coins, the value of the $i$-th coin is $a_i$. It is guaranteed that all the values are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

Polycarp wants to know answers on $q$ queries. The $j$-th query is described as integer number $b_j$. The answer to the query is the minimum number of coins that is necessary to obtain the value $b_j$ using some subset of coins (Polycarp can use only coins he has). If Polycarp can't obtain the value $b_j$, the answer to the $j$-th query is -1.

The queries are independent (the answer on the query doesn't affect Polycarp's coins).


-----Input-----

The first line of the input contains two integers $n$ and $q$ ($1 \le n, q \le 2 \cdot 10^5$) — the number of coins and the number of queries.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ — values of coins ($1 \le a_i \le 2 \cdot 10^9$). It is guaranteed that all $a_i$ are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

The next $q$ lines contain one integer each. The $j$-th line contains one integer $b_j$ — the value of the $j$-th query ($1 \le b_j \le 10^9$).


-----Output-----

Print $q$ integers $ans_j$. The $j$-th integer must be equal to the answer on the $j$-th query. If Polycarp can't obtain the value $b_j$ the answer to the $j$-th query is -1.


-----Example-----
Input
5 4
2 4 8 2 4
8
5
14
10

Output
1
-1
3
2
"""
2022-04-13 20:33:16.302437 --------------------------
2022-04-13 20:34:10.787622 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\nqueries = []\nfor _ in range(q):\n    queries.append(int(input()))\n\n# print(coins, queries)\n\n# for each query, find the number of coins that can be added up to the query.\n# if not possible, print -1\n\n# for each query, check if the coin is a factor of the query.\n# if yes, check if the coin is already used.\n# if not, add the coin to the list of used coins and divide the query by the coin.\n# if not, move on to the next coin.\n# if all coins are exhausted, print -1\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\nfor query in queries:\n    used_coins = []\n    while query > 0:\n        # print(query, used_coins)\n        if query % 2 == 0:\n            if 2 in coins:\n                query = query // 2\n                used_coins.append(2)\n            else:\n                print(-1)\n                break\n        else:\n            if query % 2 == 1:\n                print(-1)\n                break\n    if query == 0:\n        print(len(used_coins))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef solve(n, q, a, b):\n    a.sort()\n    for i in range(q):\n        ans = 0\n        for j in range(n-1, -1, -1):\n            if b[i] == 0:\n                break\n            if a[j] <= b[i]:\n                ans += 1\n                b[i] -= a[j]\n        if b[i] > 0:\n            ans = -1\n        print(ans)\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nb = []\nfor i in range(q):\n    b.append(int(input()))\nsolve(n, q, a, b)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# Solution\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nb = [int(input()) for _ in range(q)]\n\ndef answer(x):\n    if x == 0:\n        return 0\n    if x in a:\n        return 1\n    for i in a:\n        if x % i == 0:\n            return 1 + answer(x // i)\n    return -1\n\nfor i in b:\n    print(answer(i))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\"\"\"\n----Solution----\n\nThe idea is to solve this problem using dynamic programming. We will create a table of size $2^n$ where $n$ is the number of coins. We will fill this table using the following rule:\n\nThe value of the $i$-th cell is the minimum number of coins necessary to get the value $i$.\n\nLet's look at the example of table filling for $n = 5$ coins:\n\n$a_1 = 2$, $a_2 = 4$, $a_3 = 8$, $a_4 = 2$, $a_5 = 4$\n\nThe table will be filled as follows:\n\n$0$\n$1$\n$2$\n$3$\n$4$\n$5$\n$6$\n$7$\n$8$\n$9$\n$10$\n$11$\n$12$\n$13$\n$14$\n$15$\n\n$1$\n$1$\n$1$\n$2$\n$1$\n$2$\n$2$\n$3$\n$1$\n$2$\n$2$\n$3$\n$2$\n$3$\n$3$\n$4$\n\nSo, the answer to the first query is $1$, the answer to the second query is $2$, the answer to the third query is $3$ and the answer to the fourth query is $2$.\n\nNow let's look at the algorithm.\n\nWe will iterate over all the coins. At each step we will iterate over all the cells of our table from the least to the greatest. If the value of the current coin is less than or equal to the value of the current cell and the current cell can be obtained using the least number of coins (the value of the current cell is equal to the value of the previous cell plus the value of the current coin), then we will set the value of the current cell to be equal to the value of the previous cell plus the value of the current coin.\n\nThe time complexity of this solution is $O(n \\cdot 2^n)$.\n\"\"\"\n\n\"\"\"\n----Solution----\n\nThe idea is to solve this problem using dynamic programming. We will create a table of size $2^n$ where $n$ is the number of coins. We will fill this table using the following rule:\n\nThe value of the $i$-th cell is the minimum number of coins necessary to get the value $i$.\n\nLet's look at the example of table filling for $n = 5$ coins:\n\n$a_1 = 2$, $a_2 = 4$, $a_3 = 8$, $a_4 = 2$, $a_5 = 4$\n\nThe table will be filled as follows:\n\n$0$\n$1$\n$2$\n$3$\n$4$\n$5$\n$6$\n$7$\n$8$\n$9$\n$10$\n$11$\n$12$\n$13$\n$14$\n$15$\n\n$1$\n$1$\n$1$\n$2$\n$1$\n$2$\n$2$\n$3$\n$1$\n$2$\n$2$\n$3$\n$2$\n$3$\n$3$\n$4$\n\nSo, the answer to the first query is $1$, the answer to the second query is $2$, the answer to the third query is $3$ and the answer to the fourth query is $2$.\n\nNow let's look at the algorithm.\n\nWe will iterate over all the coins. At each step we will iterate over all the cells of our table from the least to the greatest. If the value of the current coin is less than or equal to the value of the current cell and the current cell can be obtained using the least number of coins (the value of the current cell is equal to the value of the previous cell plus the value of the current coin), then we will set the value of the current cell to be equal to the value of the previous cell plus the value of the current coin.\n\nThe time complexity of this solution is $O(n \\cdot 2^n)$.\n\"\"\"\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\ntable = [0] * (2 ** n)\nfor i in range(n):\n    for j in range(2 ** n):\n        if coins[i] <= j and table[j] == table[j - coins[i]] + coins[i]:\n            table[j] = table[j - coins[i]] + coins[i]\nfor i in range(q):\n    query = int(input())\n    if table[query] == query:\n        print(1)\n    else:\n        print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef get_number_of_coins(coins, sum_to_obtain):\n    if sum_to_obtain == 0:\n        return 0\n    if sum_to_obtain in coins:\n        return 1\n    if sum_to_obtain < min(coins):\n        return -1\n\n    # find the largest coin that is smaller than the sum to obtain\n    largest_smaller_coin = 0\n    for coin in coins:\n        if coin < sum_to_obtain:\n            largest_smaller_coin = coin\n        else:\n            break\n\n    # calculate the number of coins needed to obtain the sum to obtain\n    number_of_coins = get_number_of_coins(coins, sum_to_obtain - largest_smaller_coin)\n    if number_of_coins == -1:\n        return -1\n    else:\n        return number_of_coins + 1\n\n\ndef get_number_of_queries(queries):\n    number_of_queries = input()\n    for _ in range(int(number_of_queries)):\n        queries.append(int(input()))\n    return queries\n\n\ndef get_coins(coins):\n    number_of_coins = int(input())\n    coin_values = input().split()\n    for i in range(number_of_coins):\n        coins.append(int(math.pow(2, int(coin_values[i]))))\n    return coins\n\n\ndef main():\n    coins = []\n    queries = []\n    coins = get_coins(coins)\n    queries = get_number_of_queries(queries)\n    for query in queries:\n        print(get_number_of_coins(coins, query))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef solve(n, q, a, b):\n    a.sort()\n    res = []\n    for i in range(q):\n        res.append(solve_one(n, a, b[i]))\n    return res\n\ndef solve_one(n, a, b):\n    if b in a:\n        return 1\n    if b == 0:\n        return 0\n    if b > a[-1] * 2:\n        return -1\n    if b % 2 == 0:\n        return solve_one(n, a, b // 2) + 1\n    for i in range(n):\n        if a[i] * 2 > b:\n            break\n    return solve_one(n, a, b - a[i]) + 1\n\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(q):\n        b.append(int(input()))\n    res = solve(n, q, a, b)\n    for i in range(q):\n        print(res[i])"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\n\nfor _ in range(q):\n    query = int(input())\n    if query in coins:\n        print(1)\n    else:\n        possible_answers = []\n\n        for coin in coins:\n            if coin < query:\n                possible_answers.append(query - coin)\n        if len(possible_answers) == 0:\n            print(-1)\n        else:\n            possible_answers.sort()\n            print(possible_answers[0])"
    }
  ],
  "created": 1649881996,
  "id": "cmpl-4wdxsxP3NSUXDeBtfcJfLcnroI3kH",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:34:10.787988 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\nqueries = []\nfor _ in range(q):\n    queries.append(int(input()))\n\n# print(coins, queries)\n\n# for each query, find the number of coins that can be added up to the query.\n# if not possible, print -1\n\n# for each query, check if the coin is a factor of the query.\n# if yes, check if the coin is already used.\n# if not, add the coin to the list of used coins and divide the query by the coin.\n# if not, move on to the next coin.\n# if all coins are exhausted, print -1\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\n# for each query, find the highest power of 2 that can be subtracted from the query\n# if the power of 2 is not in the list of coins, print -1\n# if the power of 2 is in the list of coins, subtract the power of 2 from the query\n# if the query is 0, print the number of used coins\n# if the query is not 0, repeat the process\n\nfor query in queries:\n    used_coins = []\n    while query > 0:\n        # print(query, used_coins)\n        if query % 2 == 0:\n            if 2 in coins:\n                query = query // 2\n                used_coins.append(2)\n            else:\n                print(-1)\n                break\n        else:\n            if query % 2 == 1:\n                print(-1)\n                break\n    if query == 0:\n        print(len(used_coins))"
}
2022-04-13 20:34:10.788037 REASON stop
2022-04-13 20:34:10.788460 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef solve(n, q, a, b):\n    a.sort()\n    for i in range(q):\n        ans = 0\n        for j in range(n-1, -1, -1):\n            if b[i] == 0:\n                break\n            if a[j] <= b[i]:\n                ans += 1\n                b[i] -= a[j]\n        if b[i] > 0:\n            ans = -1\n        print(ans)\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nb = []\nfor i in range(q):\n    b.append(int(input()))\nsolve(n, q, a, b)"
}
2022-04-13 20:34:10.788557 REASON stop
2022-04-13 20:34:10.788888 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# Solution\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nb = [int(input()) for _ in range(q)]\n\ndef answer(x):\n    if x == 0:\n        return 0\n    if x in a:\n        return 1\n    for i in a:\n        if x % i == 0:\n            return 1 + answer(x // i)\n    return -1\n\nfor i in b:\n    print(answer(i))"
}
2022-04-13 20:34:10.788927 REASON stop
2022-04-13 20:34:10.807229 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\"\"\"\n----Solution----\n\nThe idea is to solve this problem using dynamic programming. We will create a table of size $2^n$ where $n$ is the number of coins. We will fill this table using the following rule:\n\nThe value of the $i$-th cell is the minimum number of coins necessary to get the value $i$.\n\nLet's look at the example of table filling for $n = 5$ coins:\n\n$a_1 = 2$, $a_2 = 4$, $a_3 = 8$, $a_4 = 2$, $a_5 = 4$\n\nThe table will be filled as follows:\n\n$0$\n$1$\n$2$\n$3$\n$4$\n$5$\n$6$\n$7$\n$8$\n$9$\n$10$\n$11$\n$12$\n$13$\n$14$\n$15$\n\n$1$\n$1$\n$1$\n$2$\n$1$\n$2$\n$2$\n$3$\n$1$\n$2$\n$2$\n$3$\n$2$\n$3$\n$3$\n$4$\n\nSo, the answer to the first query is $1$, the answer to the second query is $2$, the answer to the third query is $3$ and the answer to the fourth query is $2$.\n\nNow let's look at the algorithm.\n\nWe will iterate over all the coins. At each step we will iterate over all the cells of our table from the least to the greatest. If the value of the current coin is less than or equal to the value of the current cell and the current cell can be obtained using the least number of coins (the value of the current cell is equal to the value of the previous cell plus the value of the current coin), then we will set the value of the current cell to be equal to the value of the previous cell plus the value of the current coin.\n\nThe time complexity of this solution is $O(n \\cdot 2^n)$.\n\"\"\"\n\n\"\"\"\n----Solution----\n\nThe idea is to solve this problem using dynamic programming. We will create a table of size $2^n$ where $n$ is the number of coins. We will fill this table using the following rule:\n\nThe value of the $i$-th cell is the minimum number of coins necessary to get the value $i$.\n\nLet's look at the example of table filling for $n = 5$ coins:\n\n$a_1 = 2$, $a_2 = 4$, $a_3 = 8$, $a_4 = 2$, $a_5 = 4$\n\nThe table will be filled as follows:\n\n$0$\n$1$\n$2$\n$3$\n$4$\n$5$\n$6$\n$7$\n$8$\n$9$\n$10$\n$11$\n$12$\n$13$\n$14$\n$15$\n\n$1$\n$1$\n$1$\n$2$\n$1$\n$2$\n$2$\n$3$\n$1$\n$2$\n$2$\n$3$\n$2$\n$3$\n$3$\n$4$\n\nSo, the answer to the first query is $1$, the answer to the second query is $2$, the answer to the third query is $3$ and the answer to the fourth query is $2$.\n\nNow let's look at the algorithm.\n\nWe will iterate over all the coins. At each step we will iterate over all the cells of our table from the least to the greatest. If the value of the current coin is less than or equal to the value of the current cell and the current cell can be obtained using the least number of coins (the value of the current cell is equal to the value of the previous cell plus the value of the current coin), then we will set the value of the current cell to be equal to the value of the previous cell plus the value of the current coin.\n\nThe time complexity of this solution is $O(n \\cdot 2^n)$.\n\"\"\"\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\ntable = [0] * (2 ** n)\nfor i in range(n):\n    for j in range(2 ** n):\n        if coins[i] <= j and table[j] == table[j - coins[i]] + coins[i]:\n            table[j] = table[j - coins[i]] + coins[i]\nfor i in range(q):\n    query = int(input())\n    if table[query] == query:\n        print(1)\n    else:\n        print(-1)"
}
2022-04-13 20:34:10.807335 REASON stop
2022-04-13 20:34:10.826957 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef get_number_of_coins(coins, sum_to_obtain):\n    if sum_to_obtain == 0:\n        return 0\n    if sum_to_obtain in coins:\n        return 1\n    if sum_to_obtain < min(coins):\n        return -1\n\n    # find the largest coin that is smaller than the sum to obtain\n    largest_smaller_coin = 0\n    for coin in coins:\n        if coin < sum_to_obtain:\n            largest_smaller_coin = coin\n        else:\n            break\n\n    # calculate the number of coins needed to obtain the sum to obtain\n    number_of_coins = get_number_of_coins(coins, sum_to_obtain - largest_smaller_coin)\n    if number_of_coins == -1:\n        return -1\n    else:\n        return number_of_coins + 1\n\n\ndef get_number_of_queries(queries):\n    number_of_queries = input()\n    for _ in range(int(number_of_queries)):\n        queries.append(int(input()))\n    return queries\n\n\ndef get_coins(coins):\n    number_of_coins = int(input())\n    coin_values = input().split()\n    for i in range(number_of_coins):\n        coins.append(int(math.pow(2, int(coin_values[i]))))\n    return coins\n\n\ndef main():\n    coins = []\n    queries = []\n    coins = get_coins(coins)\n    queries = get_number_of_queries(queries)\n    for query in queries:\n        print(get_number_of_coins(coins, query))\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 20:34:10.827093 REASON stop
2022-04-13 20:34:10.827660 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef solve(n, q, a, b):\n    a.sort()\n    res = []\n    for i in range(q):\n        res.append(solve_one(n, a, b[i]))\n    return res\n\ndef solve_one(n, a, b):\n    if b in a:\n        return 1\n    if b == 0:\n        return 0\n    if b > a[-1] * 2:\n        return -1\n    if b % 2 == 0:\n        return solve_one(n, a, b // 2) + 1\n    for i in range(n):\n        if a[i] * 2 > b:\n            break\n    return solve_one(n, a, b - a[i]) + 1\n\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(q):\n        b.append(int(input()))\n    res = solve(n, q, a, b)\n    for i in range(q):\n        print(res[i])"
}
2022-04-13 20:34:10.827720 REASON stop
2022-04-13 20:34:10.828449 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, q = map(int, input().split())\ncoins = list(map(int, input().split()))\n\nfor _ in range(q):\n    query = int(input())\n    if query in coins:\n        print(1)\n    else:\n        possible_answers = []\n\n        for coin in coins:\n            if coin < query:\n                possible_answers.append(query - coin)\n        if len(possible_answers) == 0:\n            print(-1)\n        else:\n            possible_answers.sort()\n            print(possible_answers[0])"
}
2022-04-13 20:34:10.828513 REASON stop
