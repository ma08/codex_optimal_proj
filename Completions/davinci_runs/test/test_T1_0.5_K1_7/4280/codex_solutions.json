["\n\nimport sys\nfrom collections import defaultdict\n\nn, k = map(int, sys.stdin.readline().split())\nedges = [list(map(int, sys.stdin.readline().split())) for _ in range(n-1)]\n\n# build graph\ng = defaultdict(list)\nfor x, y in edges:\n    g[x].append(y)\n    g[y].append(x)\n\n# dfs coloring\ncolor = defaultdict(int)\ncolor[1] = 1\nstack = [1]\nwhile stack:\n    cur = stack.pop()\n    for nxt in g[cur]:\n        if color[nxt] == 0:\n            color[nxt] = color[cur]\n            stack.append(nxt)\n\n# count the number of companies\ncnt = defaultdict(int)\nfor i in range(1, n+1):\n    cnt[color[i]] += 1\n\n# count the number of cities with two or more roads of one company\ncities = defaultdict(int)\nfor x, y in edges:\n    if color[x] == color[y]:\n        cities[x] += 1\n        cities[y] += 1\n\n# output\nif len(cities) > k:\n    print(0)\nelse:\n    print(len(cnt))\n    for x, y in edges:\n        print(color[x], end=' ')\n    print()", "\n\nfrom collections import defaultdict\n\ndef dfs(u, p):\n    size[u] = 1\n    for v in tree[u]:\n        if v != p:\n            dfs(v, u)\n            size[u] += size[v]\n\ndef dfs2(u, p, keep):\n    mx = -1\n    bigChild = -1\n    for v in tree[u]:\n        if v != p and size[v] > mx:\n            mx = size[v]\n            bigChild = v\n    for v in tree[u]:\n        if v != p and v != bigChild:\n            dfs2(v, u, False)\n    if bigChild != -1:\n        dfs2(bigChild, u, True)\n        bigTree[bigChild] = True\n    add(u, 1)\n    if not keep:\n        bigTree[u] = False\n        cnt[ color[u] ] = 0\n\ndef add(u, val):\n    cnt[ color[u] ] += val\n    if cnt[ color[u] ] == 1:\n        ans[0] += 1\n    elif cnt[ color[u] ] == 2:\n        ans[0] -= 1\n\ndef paint(u, p, c):\n    color[u] = c\n    for v in tree[u]:\n        if v != p and not bigTree[v]:\n            paint(v, u, c)\n\nn, k = map(int, input().split())\ntree = defaultdict(list)\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    tree[x].append(y)\n    tree[y].append(x)\n\nsize = [0] * (n + 1)\ndfs(1, -1)\n\ncolor = [0] * (n + 1)\ncnt = [0] * (n + 1)\nbigTree = [False] * (n + 1)\nans = [0]\ndfs2(1, -1, True)\n\nprint(ans[0])\nprint(*color[2:])", "\n\nimport sys\n#sys.stdin = open('C:\\\\Users\\\\user\\\\Downloads\\\\input.txt')\n\nn, k = map(int, input().split())\n\nroads = [list(map(int, input().split())) for _ in range(n-1)]\n\n#print(n, k)\n#print(roads)\n\ndef find_root(x, parent):\n    if parent[x] == x:\n        return x\n    return find_root(parent[x], parent)\n\ndef union(x, y, parent, rank):\n    x_root = find_root(x, parent)\n    y_root = find_root(y, parent)\n\n    if x_root == y_root:\n        return\n\n    if rank[x_root] < rank[y_root]:\n        parent[x_root] = y_root\n    elif rank[x_root] > rank[y_root]:\n        parent[y_root] = x_root\n    else:\n        parent[y_root] = x_root\n        rank[x_root] += 1\n\nparent = list(range(n+1))\nrank = [0]*(n+1)\n\n#print(parent)\n#print(rank)\n\nfor road in roads:\n    union(road[0], road[1], parent, rank)\n\n#print(parent)\n#print(rank)\n\ncomponents = {}\nfor i in range(1, n+1):\n    root = find_root(i, parent)\n    if root not in components:\n        components[root] = []\n    components[root].append(i)\n\n#print(components)\n\ncomponents = list(components.values())\n\n#print(components)\n\nans = 0\nfor component in components:\n    if len(component) > 1:\n        ans += 1\n\nans = min(ans, k)\n\nprint(ans)\n\nfor i in range(n-1):\n    print(i%(ans+1)+1, end=' ')", "\n\ndef get_root(v):\n    if v == parents[v]:\n        return v\n    parents[v] = get_root(parents[v])\n    return parents[v]\n\ndef union(a, b):\n    a = get_root(a)\n    b = get_root(b)\n    if a != b:\n        if sizes[a] < sizes[b]:\n            a, b = b, a\n        parents[b] = a\n        sizes[a] += sizes[b]\n\nn, k = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(n-1)]\n\nparents = [i for i in range(n+1)]\nsizes = [1 for _ in range(n+1)]\n\nfor u, v in edges:\n    if get_root(u) != get_root(v):\n        union(u, v)\n\ngroups = set()\nfor i in range(1, n+1):\n    groups.add(get_root(i))\n\nif len(groups) <= k + 1:\n    print(len(groups))\n    for u, v in edges:\n        if get_root(u) != get_root(v):\n            union(u, v)\n            print(len(groups))\n        else:\n            print(len(groups)-1)\nelse:\n    print(-1)", "\n\nimport sys\n\ndef find_root(parent, x):\n    # find representative of x\n    if parent[x] != x:\n        parent[x] = find_root(parent, parent[x])\n    return parent[x]\n\ndef union_set(parent, rank, x, y):\n    # union by rank\n    xroot = find_root(parent, x)\n    yroot = find_root(parent, y)\n    # x and y are already in same set\n    if xroot == yroot:\n        return\n    # x and y are not in same set, so we merge them\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else :\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal(parent, rank, graph):\n    mst = []\n    for x, y, w in graph:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        # x and y are already in same set\n        if xroot == yroot:\n            continue\n        # x and y are not in same set, so we merge them\n        mst.append((x, y, w))\n        union_set(parent, rank, xroot, yroot)\n    return mst\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = []\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n    for _ in range(n-1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph.append((x, y, 0))\n    mst = kruskal(parent, rank, graph)\n    color = 1\n    parent = [i for i in range(n+1)]\n    rank = [0] * (n+1)\n    for x, y, _ in mst:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        # x and y are already in same set\n        if xroot == yroot:\n            color += 1\n            continue\n        # x and y are not in same set, so we merge them\n        union_set(parent, rank, xroot, yroot)\n    print(color)\n    for x, y, _ in mst:\n        xroot = find_root(parent, x)\n        yroot = find_root(parent, y)\n        if xroot == yroot:\n            print(color, end=' ')\n            color -= 1\n        else:\n            print(1, end=' ')\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nsys.setrecursionlimit(100000)\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n        self.parent = None\n        self.color = 0\n        self.num_children = 0\n\ndef dfs(node, color):\n    node.color = color\n    for child in node.children:\n        dfs(child, color)\n\ndef solve(nodes, k):\n    if k == 0:\n        return 1\n    if len(nodes) <= k:\n        return len(nodes)\n    nodes = sorted(nodes, key=lambda node: node.num_children)\n    node = nodes.pop()\n    color = node.color\n    dfs(node, color + 1)\n    return solve(nodes, k - 1)\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    nodes = [Node(i + 1) for i in range(n)]\n    for i in range(n - 1):\n        x, y = [int(i) for i in sys.stdin.readline().split()]\n        node_x = nodes[x - 1]\n        node_y = nodes[y - 1]\n        node_x.children.append(node_y)\n        node_y.children.append(node_x)\n        node_x.num_children += 1\n        node_y.num_children += 1\n    for node in nodes:\n        if len(node.children) == 1:\n            node.parent = node.children[0]\n    root = [node for node in nodes if node.parent is None][0]\n    dfs(root, 1)\n    r = solve(nodes, k)\n    print(r)\n    for node in nodes:\n        print(node.color, end=' ')\n\nif __name__ == '__main__':\n    main()"]