2022-04-13 22:05:39.098559 """
Takahashi has N balls. Initially, an integer A_i is written on the i-th ball.
He would like to rewrite the integer on some balls so that there are at most K different integers written on the N balls.
Find the minimum number of balls that Takahashi needs to rewrite the integers on them.

-----Constraints-----
 - 1 \leq K \leq N \leq 200000
 - 1 \leq A_i \leq N
 - All input values are integers.

-----Input-----
Input is given from Standard Input in the following format:
N K
A_1 A_2 ... A_N

-----Output-----
Print the minimum number of balls that Takahashi needs to rewrite the integers on them.

-----Sample Input-----
5 2
1 1 2 2 5

-----Sample Output-----
1

For example, if we rewrite the integer on the fifth ball to 2, there are two different integers written on the balls: 1 and 2.
On the other hand, it is not possible to rewrite the integers on zero balls so that there are at most two different integers written on the balls, so we should print 1.
"""
2022-04-13 22:05:39.098566 --------------------------
2022-04-13 22:06:06.924737 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# \u73fe\u5728\u306e\u30dc\u30fc\u30eb\u306e\u500b\u6570\u3092\u7ba1\u7406\u3059\u308b\nball_counter = [0] * N\nfor a in A:\n    ball_counter[a-1] += 1\n\n# \u500b\u6570\u304c\u591a\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\nball_counter.sort(reverse=True)\n\ncount = 0\nfor i in range(K, N):\n    count += ball_counter[i]\n\nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\nfrom collections import Counter\n\ndef min_rewrite(N, K, A):\n    count = Counter(A)\n    if len(count) <= K:\n        return 0\n    else:\n        heap = []\n        # count.most_common() returns the list of tuples (num, count) in descending order.\n        # heapq.nlargest(K, count.most_common(), key=lambda x: x[1]) returns the list of K tuples with the highest count.\n        for i in heapq.nlargest(K, count.most_common(), key=lambda x: x[1]):\n            heapq.heappush(heap, -i[1])\n        # heapq.nlargest(K, count.most_common(), key=lambda x: x[1]) returns the list of K tuples with the highest count.\n        # heapq.heappush(heap, -i[1]) pushes the negative of the count to the heap.\n        # We want the highest count, so we push the negative of the count to the heap.\n        for i in heapq.nsmallest(len(count) - K, count.most_common(), key=lambda x: x[1]):\n            if i[1] < -heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, -i[1])\n            else:\n                return sum(heap) + i[1]\n        return sum(heap)\n\ndef main():\n    N, K = list(map(int, sys.stdin.readline().split()))\n    A = list(map(int, sys.stdin.readline().split()))\n    print(min_rewrite(N, K, A))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    ball_nums = list(map(int, input().split()))\n    ball_nums.sort()\n    ball_nums.append(0)\n    count = 0\n    for i in range(n):\n        if ball_nums[i] == ball_nums[i+1]:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nN, K = map(int, input().split())\nballs = list(map(int, input().split()))\n\n# Create a list of the number of balls with a given number written on them\nballs_written = [0] * N\nfor i in range(N):\n    balls_written[balls[i]-1] += 1\n\n# Sort the list of the number of balls with a given number written on them\nballs_written.sort()\n\n# Calculate the minimum number of balls that need to be rewritten\n# by subtracting the number of balls with the lowest number of balls with a given number written on them\n# from the number of balls with the highest number of balls with a given number written on them\nmin_rewritten = balls_written[-1] - balls_written[0]\n\nprint(min_rewritten)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a_list = list(map(int, input().split()))\n    a_list.sort()\n    a_list_count = []\n    count = 0\n    for i in range(n):\n        if i == 0:\n            count += 1\n        elif a_list[i] == a_list[i - 1]:\n            count += 1\n        else:\n            a_list_count.append(count)\n            count = 1\n    a_list_count.append(count)\n    a_list_count.sort(reverse=True)\n    print(n - sum(a_list_count[:k]))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\nnums = list(map(int, input().split()))\n\ndef main():\n    # \u4eca\u56de\u306f\u9ad8\u901f\u5316\u304c\u5fc5\u8981\u306a\u3044\u305f\u3081\u3001\n    # \u901a\u5e38\u306e\u8f9e\u66f8\u306b\u5024\u3092\u683c\u7d0d\u3057\u3066\u3044\u304f\n    dic = {}\n    count = 0\n\n    # \u8f9e\u66f8\u306b\u5024\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408\u306fcount\u306b1\u52a0\u7b97\n    for i in range(n):\n        if dic.get(nums[i]):\n            dic[nums[i]] += 1\n        else:\n            dic[nums[i]] = 1\n            count += 1\n\n    # \u8f9e\u66f8\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u5024\u304ck\u3092\u8d85\u3048\u305f\u5834\u5408\u306f1\u5f15\u304f\n    if count > k:\n        print(count - k)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN, K = map(int, sys.stdin.readline().strip().split())\n\nball = list(map(int, sys.stdin.readline().strip().split()))\n\nball.sort()\n\ncnt = 0\n\nfor i in range(N - 1):\n    if ball[i] == ball[i + 1]:\n        cnt += 1\n\nprint(min(cnt, K))"
    }
  ],
  "created": 1649887539,
  "id": "cmpl-4wfPHL5FWEKppyA0Jw0QC4Na781C8",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 22:06:06.925001 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# \u73fe\u5728\u306e\u30dc\u30fc\u30eb\u306e\u500b\u6570\u3092\u7ba1\u7406\u3059\u308b\nball_counter = [0] * N\nfor a in A:\n    ball_counter[a-1] += 1\n\n# \u500b\u6570\u304c\u591a\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\nball_counter.sort(reverse=True)\n\ncount = 0\nfor i in range(K, N):\n    count += ball_counter[i]\n\nprint(count)"
}
2022-04-13 22:06:06.925033 REASON stop
2022-04-13 22:06:06.925566 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\nfrom collections import Counter\n\ndef min_rewrite(N, K, A):\n    count = Counter(A)\n    if len(count) <= K:\n        return 0\n    else:\n        heap = []\n        # count.most_common() returns the list of tuples (num, count) in descending order.\n        # heapq.nlargest(K, count.most_common(), key=lambda x: x[1]) returns the list of K tuples with the highest count.\n        for i in heapq.nlargest(K, count.most_common(), key=lambda x: x[1]):\n            heapq.heappush(heap, -i[1])\n        # heapq.nlargest(K, count.most_common(), key=lambda x: x[1]) returns the list of K tuples with the highest count.\n        # heapq.heappush(heap, -i[1]) pushes the negative of the count to the heap.\n        # We want the highest count, so we push the negative of the count to the heap.\n        for i in heapq.nsmallest(len(count) - K, count.most_common(), key=lambda x: x[1]):\n            if i[1] < -heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, -i[1])\n            else:\n                return sum(heap) + i[1]\n        return sum(heap)\n\ndef main():\n    N, K = list(map(int, sys.stdin.readline().split()))\n    A = list(map(int, sys.stdin.readline().split()))\n    print(min_rewrite(N, K, A))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 22:06:06.925715 REASON stop
2022-04-13 22:06:06.926074 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    ball_nums = list(map(int, input().split()))\n    ball_nums.sort()\n    ball_nums.append(0)\n    count = 0\n    for i in range(n):\n        if ball_nums[i] == ball_nums[i+1]:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 22:06:06.926119 REASON stop
2022-04-13 22:06:06.939473 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nN, K = map(int, input().split())\nballs = list(map(int, input().split()))\n\n# Create a list of the number of balls with a given number written on them\nballs_written = [0] * N\nfor i in range(N):\n    balls_written[balls[i]-1] += 1\n\n# Sort the list of the number of balls with a given number written on them\nballs_written.sort()\n\n# Calculate the minimum number of balls that need to be rewritten\n# by subtracting the number of balls with the lowest number of balls with a given number written on them\n# from the number of balls with the highest number of balls with a given number written on them\nmin_rewritten = balls_written[-1] - balls_written[0]\n\nprint(min_rewritten)"
}
2022-04-13 22:06:06.939544 REASON stop
2022-04-13 22:06:06.968168 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a_list = list(map(int, input().split()))\n    a_list.sort()\n    a_list_count = []\n    count = 0\n    for i in range(n):\n        if i == 0:\n            count += 1\n        elif a_list[i] == a_list[i - 1]:\n            count += 1\n        else:\n            a_list_count.append(count)\n            count = 1\n    a_list_count.append(count)\n    a_list_count.sort(reverse=True)\n    print(n - sum(a_list_count[:k]))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 22:06:06.968277 REASON stop
2022-04-13 22:06:06.968822 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\nnums = list(map(int, input().split()))\n\ndef main():\n    # \u4eca\u56de\u306f\u9ad8\u901f\u5316\u304c\u5fc5\u8981\u306a\u3044\u305f\u3081\u3001\n    # \u901a\u5e38\u306e\u8f9e\u66f8\u306b\u5024\u3092\u683c\u7d0d\u3057\u3066\u3044\u304f\n    dic = {}\n    count = 0\n\n    # \u8f9e\u66f8\u306b\u5024\u304c\u683c\u7d0d\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408\u306fcount\u306b1\u52a0\u7b97\n    for i in range(n):\n        if dic.get(nums[i]):\n            dic[nums[i]] += 1\n        else:\n            dic[nums[i]] = 1\n            count += 1\n\n    # \u8f9e\u66f8\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u5024\u304ck\u3092\u8d85\u3048\u305f\u5834\u5408\u306f1\u5f15\u304f\n    if count > k:\n        print(count - k)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:06:06.968884 REASON stop
2022-04-13 22:06:06.969760 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN, K = map(int, sys.stdin.readline().strip().split())\n\nball = list(map(int, sys.stdin.readline().strip().split()))\n\nball.sort()\n\ncnt = 0\n\nfor i in range(N - 1):\n    if ball[i] == ball[i + 1]:\n        cnt += 1\n\nprint(min(cnt, K))"
}
2022-04-13 22:06:06.969823 REASON stop
