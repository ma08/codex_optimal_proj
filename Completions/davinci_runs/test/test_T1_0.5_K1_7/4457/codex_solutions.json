["\n\nimport sys\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().strip().split(' ')))\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef read_str():\n    return sys.stdin.readline().strip()\n\ndef read_strs():\n    return sys.stdin.readline().strip().split(' ')\n\ndef main():\n    n = read_int()\n    a = read_ints()\n    a.sort()\n    cans = [(a[i], i+1) for i in range(n)]\n    cans.sort(reverse=True)\n    ans = 0\n    for i in range(n):\n        ans += (i+1)*cans[i][0]\n    print(ans)\n    print(' '.join([str(c[1]) for c in cans]))\n\nif __name__ == '__main__':\n    main()", "\n\n# Solution\n\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [0] * n\ndp[0] = a[0]\n\nfor i in range(1, n):\n    dp[i] = a[i] * (i + 1) + 1\n\nfor i in range(n):\n    for j in range(i):\n        dp[i] = min(dp[i], dp[j] + a[i] * (i - j) + 1)\n\nprint(dp[n - 1])\n\nans = [0] * n\nans[0] = 1\n\nfor i in range(1, n):\n    for j in range(i):\n        if dp[i] == dp[j] + a[i] * (i - j) + 1:\n            ans[i] = j + 1\n            break\n\nprint(*ans)", "\n\nimport sys\n\n\ndef main():\n    f = sys.stdin\n    n = int(f.readline())\n    cans = [int(x) for x in f.readline().split()]\n    cans = sorted(enumerate(cans), key=lambda x: x[1])\n\n    ans = 0\n    order = []\n    for i in range(n):\n        ans += cans[i][1] * i + 1\n        order.append(cans[i][0] + 1)\n\n    print(ans)\n    print(' '.join(map(str, order)))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nN = int(input())\ndur = list(map(int, input().split()))\n\nans = [0] * N\n\n# first, find the can with the smallest durability\nmin_dur = min(dur)\n\n# the largest number of shots required is the sum of the durabilities\nmax_shots = sum(dur)\n\n# now, we can iterate through the cans, starting with the smallest\n# and calculate the number of shots required for each can\nfor i in range(N):\n    # if the can is the smallest, we only need 1 shot\n    if dur[i] == min_dur:\n        ans[i] = 1\n        continue\n\n    # otherwise, we need to add the number of shots required to knock down\n    # the previous can to the number of shots required to knock down\n    # the current can\n    ans[i] = ans[i - 1] + dur[i]\n\n# now, we can iterate through the cans, starting with the largest\n# and calculate the number of shots required for each can\nfor i in range(N - 1, -1, -1):\n    # if the can is the largest, we only need 1 shot\n    if dur[i] == max_shots:\n        ans[i] = 1\n        continue\n\n    # otherwise, we need to add the number of shots required to knock down\n    # the next can to the number of shots required to knock down\n    # the current can\n    ans[i] = ans[i + 1] + dur[i]\n\n# now, we can iterate through the cans and find the minimum number of shots\n# required to knock down each can\nmin_shots = min(ans)\n\n# now, we can iterate through the cans and find the order that minimizes\n# the number of shots\norder = []\nfor i in range(N):\n    if ans[i] == min_shots:\n        order.append(i + 1)\n        min_shots += dur[i]\n\nprint(min_shots - 1)\nprint(*order)", "\n\nimport sys\n\ndef main():\n\tn = int(raw_input())\n\ta = map(int, raw_input().split())\n\tprint solve(n, a)\n\ndef solve(n, a):\n\tshots = 0\n\torder = []\n\tfor i in xrange(n):\n\t\tif i == 0:\n\t\t\torder.append(a.index(min(a))+1)\n\t\t\tdel a[a.index(min(a))]\n\t\telse:\n\t\t\torder.append(a.index(min(a))+1)\n\t\t\tdel a[a.index(min(a))]\n\t\t\tshots += a[order[-2]-1]*(i)\n\t\t\t#print shots\n\t\t\t#print a\n\t\t\t#print order\n\tshots += a[order[-1]-1]*(n-1)\n\treturn str(shots+n) + '\\n' + ' '.join(map(str, order))\n\nif __name__ == '__main__':\n\tmain()", "\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    assert all(1 <= x <= 1000 for x in a)\n\n    total = 0\n    output = []\n    for i in range(n):\n        min_value = min(a)\n        min_index = a.index(min_value)\n        output.append(min_index + 1)\n        total += (min_value * i) + 1\n        a[min_index] = 1000\n\n    print(total)\n    print(*output)\n\n\nmain()", "\n\ndef main():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    a.sort()\n    dp = [a[0] + 1] * n\n    for i in range(1, n):\n        dp[i] = a[i] * (i + 1) + 1\n        for j in range(i):\n            dp[i] = min(dp[i], max(dp[j], a[i] * (i - j) + 1))\n    print(dp[n - 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dp[j] == max(dp[i], a[j] * (j - i) + 1):\n                print(j + 1, end = ' ')\n                break\n    for i in range(n - 1, -1, -1):\n        if dp[i] == a[i] * (i + 1) + 1:\n            print(i + 1, end = ' ')\n\nif __name__ == '__main__':\n    main()"]