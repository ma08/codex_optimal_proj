["\n\nimport sys\n\ndef solve(m, n, grid):\n    min_length = 0\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                grid[i][j] += grid[i][j - 1]\n            elif j == 0:\n                grid[i][j] += grid[i - 1][j]\n            else:\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    return grid[m - 1][n - 1]\n\ndef main():\n    lines = sys.stdin.readlines()\n    m, n = [int(x) for x in lines[0].split()]\n    grid = []\n    for i in range(1, len(lines)):\n        grid.append([int(x) for x in lines[i].split()])\n    print(solve(m, n, grid))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    # Read the input\n    M, N = [int(i) for i in sys.stdin.readline().split()]\n    grid = []\n    for i in range(M):\n        grid.append([int(i) for i in sys.stdin.readline().split()])\n    # Initialize the DP table\n    dp = [[0 for i in range(N)] for j in range(M)]\n    # Fill in the DP table\n    for i in range(M-1, -1, -1):\n        for j in range(N-1, -1, -1):\n            # If we are at the bottom right corner, we are done\n            if (i == M-1) and (j == N-1):\n                break\n            # If we are at the bottom, then we can only go right\n            elif i == M-1:\n                dp[i][j] = max(dp[i][j+1], grid[i][j+1] - grid[i][j])\n            # If we are at the right, then we can only go down\n            elif j == N-1:\n                dp[i][j] = max(dp[i+1][j], grid[i+1][j] - grid[i][j])\n            # Otherwise we can go either way\n            else:\n                dp[i][j] = max(\n                    max(dp[i][j+1], grid[i][j+1] - grid[i][j]),\n                    max(dp[i+1][j], grid[i+1][j] - grid[i][j])\n                )\n    # Print the output\n    print(dp[0][0])\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    M, N = map(int, input().split())\n    heights = [list(map(int, input().split())) for _ in range(M)]\n    \n    # BFS\n    # Start from the coin to be found (bottom right)\n    # Keep track of the minimum height required to reach each point\n    # We'll need a ladder of this height\n    # In the end, the minimum height required to reach the starting point\n    # is the minimum ladder height required\n    \n    queue = [(M-1,N-1)]\n    min_heights = [[0]*N for _ in range(M)]\n    min_heights[M-1][N-1] = heights[M-1][N-1]\n    \n    while queue:\n        x, y = queue.pop(0)\n        for dx, dy in [(0,1),(1,0),(0,-1),(-1,0)]:\n            if 0 <= x+dx < M and 0 <= y+dy < N:\n                min_height = max(min_heights[x][y], heights[x+dx][y+dy])\n                if min_height < min_heights[x+dx][y+dy]:\n                    min_heights[x+dx][y+dy] = min_height\n                    queue.append((x+dx,y+dy))\n    \n    print(min_heights[0][0])\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    M, N = [int(x) for x in input().split()]\n    heights = []\n    for i in range(M):\n        heights.append([int(x) for x in input().split()])\n    #print(M,N)\n    #print(heights)\n\n    #print(len(heights),len(heights[0]))\n\n    #min_height = heights[0][0]\n    #for i in range(M):\n    #    for j in range(N):\n    #        if heights[i][j] < min_height:\n    #            min_height = heights[i][j]\n    #print(min_height)\n\n    #for i in range(M-1,-1,-1):\n    #    for j in range(N-1,-1,-1):\n    #        if i == M-1 and j == N-1:\n    #            continue\n    #        if i == M-1:\n    #            heights[i][j] = min(heights[i][j], heights[i][j+1])\n    #        elif j == N-1:\n    #            heights[i][j] = min(heights[i][j], heights[i+1][j])\n    #        else:\n    #            heights[i][j] = min(heights[i][j], heights[i+1][j], heights[i][j+1])\n    #print(heights)\n\n    #print(heights[0][0] - heights[M-1][N-1])\n\n    #for i in range(M-1,-1,-1):\n    #    for j in range(N-1,-1,-1):\n    #        if i == M-1 and j == N-1:\n    #            continue\n    #        if i == M-1:\n    #            heights[i][j] = max(heights[i][j], heights[i][j+1])\n    #        elif j == N-1:\n    #            heights[i][j] = max(heights[i][j], heights[i+1][j])\n    #        else:\n    #            heights[i][j] = max(heights[i][j], heights[i+1][j], heights[i][j+1])\n    #print(heights)\n\n    #print(heights[M-1][N-1] - heights[0][0])\n\n    min_height = heights[0][0]\n    for i in range(M):\n        for j in range(N):\n            if heights[i][j] < min_height:\n                min_height = heights[i][j]\n    #print(min_height)\n\n    for i in range(M):\n        for j in range(N):\n            heights[i][j] -= min_height\n\n    for i in range(M-1,-1,-1):\n        for j in range(N-1,-1,-1):\n            if i == M-1 and j == N-1:\n                continue\n            if i == M-1:\n                heights[i][j] = max(heights[i][j], heights[i][j+1])\n            elif j == N-1:\n                heights[i][j] = max(heights[i][j], heights[i+1][j])\n            else:\n                heights[i][j] = max(heights[i][j], heights[i+1][j], heights[i][j+1])\n    #print(heights)\n\n    #print(heights[M-1][N-1])\n\n    for i in range(M):\n        for j in range(N):\n            heights[i][j] += min_height\n\n    #print(heights)\n\n    print(heights[M-1][N-1] - heights[0][0])\n\nmain()", "\n\nimport sys\n\ndef main():\n    # Read input\n    m, n = [int(i) for i in sys.stdin.readline().split()]\n    heights = [[int(i) for i in sys.stdin.readline().split()] for _ in range(m)]\n\n    # Initialise DP table\n    dp = [[0] * n for _ in range(m)]\n\n    # Compute DP table\n    for i in range(m):\n        for j in range(n):\n            # Initialise\n            if i == 0 and j == 0:\n                dp[i][j] = heights[i][j]\n            # First row\n            elif i == 0:\n                dp[i][j] = max(dp[i][j - 1], heights[i][j])\n            # First column\n            elif j == 0:\n                dp[i][j] = max(dp[i - 1][j], heights[i][j])\n            # Rest of table\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j], heights[i][j])\n\n    # Compute result\n    result = dp[-1][-1] - heights[-1][-1]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    \"\"\"main\"\"\"\n    num_1, num_2 = map(int, input().split())\n    height = []\n    for _ in range(num_1):\n        height.append(list(map(int, input().split())))\n    height.reverse()\n    count = 0\n    for i in range(num_2-1, -1, -1):\n        if height[0][i] > count:\n            count = height[0][i]\n    for i in range(1, num_1):\n        for j in range(num_2-1, -1, -1):\n            if height[i][j] > count:\n                count = height[i][j]\n            height[i][j] = min(height[i-1][j], height[i][j+1]) + 1\n            if height[i][j] > count:\n                count = height[i][j]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    heights = []\n    for i in range(m):\n        heights.append(list(map(int, sys.stdin.readline().split())))\n\n    min_heights = [[0 for j in range(n)] for i in range(m)]\n    min_heights[0][0] = heights[0][0]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                min_heights[i][j] = min_heights[i][j-1] + heights[i][j] - heights[i][j-1]\n            elif j == 0:\n                min_heights[i][j] = min_heights[i-1][j] + heights[i][j] - heights[i-1][j]\n            else:\n                min_heights[i][j] = min(min_heights[i-1][j] + heights[i][j] - heights[i-1][j], min_heights[i][j-1] + heights[i][j] - heights[i][j-1])\n\n    print(max(0, heights[m-1][n-1] - min_heights[m-1][n-1]))\n\nif __name__ == '__main__':\n    main()"]