["\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10**7) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def __init__(self):\n        self.visited = set()\n        self.answers = []\n\n    def traverse(self, node, target):\n        if node is None:\n            return False\n\n        if node in self.visited:\n            return False\n\n        self.visited.add(node)\n\n        if node == target:\n            return True\n\n        for child in node.children:\n            if self.traverse(child, target):\n                return True\n\n        return False\n\n    def traverse_tree(self, node):\n        if node is None:\n            return False\n\n        self.visited.add(node)\n\n        for child in node.children:\n            if not self.traverse_tree(child):\n                return False\n\n        return True\n\n    def bfs(self, node, target):\n        if node is None:\n            return False\n\n        queue = [node]\n\n        while queue:\n            curr = queue.pop(0)\n            if curr == target:\n                return True\n\n            for child in curr.children:\n                queue.append(child)\n\n        return False\n\n    def is_connected(self, node):\n        if node is None:\n            return False\n\n        self.visited.clear()\n        return self.traverse_tree(node)\n\n    def check_path(self, node, targets):\n        for target in targets:\n            if not self.traverse(node, target):\n                return False\n\n        return True\n\n    def solve(self, node):\n        if node is None:\n            return False\n\n        answer = self.is_connected(node)\n\n        for target in self.targets:\n            if not self.bfs(node, target):\n                answer = False\n                break\n\n        self.answers.append(answer)\n\n    def check_all_paths(self, node, targets):\n        self.targets = targets\n        self.answers = []\n\n        for target in targets:\n            if not self.traverse(node, target):\n                self.answers.append(False)\n                return self.answers\n\n        self.answers.append(True)\n        return self.answers\n\n    def traverse_tree_multi(self, node, targets):\n        if node is None:\n            return False\n\n        self.visited.add(node)\n\n        for child in node.children:\n            if not self.traverse_tree_multi(child, targets):\n                return False\n\n        if not self.check_all_paths(node, targets):\n            return False\n\n        return True\n\n    def solve_multi(self, node, targets):\n        if node is None:\n            return False\n\n        answer = self.is_connected(node)\n        if not answer:\n            return False\n\n        self.visited.clear()\n        return self.traverse_tree_multi(node, targets)\n\n\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\ndef main():\n    nodes = [TreeNode(i) for i in range(1, int(sys.stdin.readline()) + 1)]\n    for _ in range(len(nodes) - 1):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        nodes[u - 1].add_child(nodes[v - 1])\n        nodes[v - 1].add_child(nodes[u - 1])\n\n    solver = Solution()\n    for _ in range(int(sys.stdin.readline())):\n        targets = map(int, sys.stdin.readline().strip().split())\n        targets = [nodes[target - 1] for target in targets]\n        if solver.solve_multi(nodes[0], targets):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nthreading.Thread(target=main).start()", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n    for _ in range(m):\n        k = int(input())\n        query = set(map(int, input().split()))\n        if k == 1:\n            print(\"YES\")\n            continue\n        if query.pop() != 1:\n            print(\"NO\")\n            continue\n        visited = [False] * n\n        visited[0] = True\n        q = [[0, 1]]\n        for _ in range(k - 2):\n            u, dist = q.pop(0)\n            for v in adj_list[u]:\n                if not visited[v]:\n                    if v + 1 in query:\n                        if dist > 1:\n                            print(\"YES\")\n                            break\n                    else:\n                        q.append([v, dist + 1])\n                    visited[v] = True\n            else:\n                continue\n            break\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom collections import defaultdict\n\ndef dfs(node, adj, visited):\n    visited[node] = True\n    for n in adj[node]:\n        if not visited[n]:\n            dfs(n, adj, visited)\n\ndef solve(n, adj, k, query):\n    visited = [False] * (n + 1)\n    dfs(1, adj, visited)\n    for v in query:\n        if visited[v]:\n            return True\n        for n in adj[v]:\n            if visited[n]:\n                return True\n    return False\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    for _ in range(m):\n        k = int(input())\n        query = [int(x) for x in input().split()]\n        ans = \"YES\" if solve(n, adj, k, query) else \"NO\"\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\nfrom sys import stdin\nfrom collections import defaultdict\nfrom collections import deque\n\nn, m = [int(x) for x in stdin.readline().split()]\n\nedges = defaultdict(list)\n\nfor _ in range(n-1):\n    u, v = [int(x) for x in stdin.readline().split()]\n    edges[u].append(v)\n    edges[v].append(u)\n\nfor _ in range(m):\n    k = int(stdin.readline())\n    query = [int(x) for x in stdin.readline().split()]\n    visited = [False] * (n+1)\n    queue = deque([1])\n    visited[1] = True\n    while queue:\n        v = queue.popleft()\n        for u in edges[v]:\n            if not visited[u]:\n                visited[u] = True\n                queue.append(u)\n    if all([visited[x] for x in query]):\n        print('YES')\n    else:\n        print('NO')", "\n\nfrom collections import defaultdict\n\nn, m = map(int, input().split())\ntree = defaultdict(list)\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\n\nfor _ in range(m):\n    k = int(input())\n    v = list(map(int, input().split()))\n    q = [v[0]]\n    seen = [False] * (n+1)\n    seen[v[0]] = True\n    while q:\n        e = q.pop(0)\n        for ne in tree[e]:\n            if seen[ne]:\n                continue\n            if ne in v:\n                v.remove(ne)\n            q.append(ne)\n            seen[ne] = True\n    print('YES' if len(v) == 0 else 'NO')", "\n\nimport sys\n\ndef main():\n    sys.setrecursionlimit(2147483647)\n    n, m = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    for i in range(m):\n        k = int(input())\n        vertices = set(map(int, input().split()))\n        print(\"YES\" if dfs(graph, vertices, 1, 0) else \"NO\")\n\ndef dfs(graph, vertices, cur, depth):\n    if cur in vertices:\n        vertices.remove(cur)\n\n    if len(vertices) == 0:\n        return True\n\n    for v in graph[cur]:\n        if depth == 1 and v in vertices:\n            vertices.remove(v)\n            if len(vertices) == 0:\n                return True\n        elif depth < 2:\n            if dfs(graph, vertices, v, depth + 1):\n                return True\n\n    return False\n\nmain()"]