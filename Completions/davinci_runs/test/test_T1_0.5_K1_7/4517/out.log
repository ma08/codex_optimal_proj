2022-04-13 21:24:58.194443 """
You are given a rooted tree consisting of $n$ vertices numbered from $1$ to $n$. The root of the tree is a vertex number $1$.

A tree is a connected undirected graph with $n-1$ edges.

You are given $m$ queries. The $i$-th query consists of the set of $k_i$ distinct vertices $v_i[1], v_i[2], \dots, v_i[k_i]$. Your task is to say if there is a path from the root to some vertex $u$ such that each of the given $k$ vertices is either belongs to this path or has the distance $1$ to some vertex of this path.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($2 \le n \le 2 \cdot 10^5$, $1 \le m \le 2 \cdot 10^5$) — the number of vertices in the tree and the number of queries.

Each of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1 \le u_i, v_i \le n, u_i \ne v_i$).

It is guaranteed that the given edges form a tree.

The next $m$ lines describe queries. The $i$-th line describes the $i$-th query and starts with the integer $k_i$ ($1 \le k_i \le n$) — the number of vertices in the current query. Then $k_i$ integers follow: $v_i[1], v_i[2], \dots, v_i[k_i]$ ($1 \le v_i[j] \le n$), where $v_i[j]$ is the $j$-th vertex of the $i$-th query.

It is guaranteed that all vertices in a single query are distinct.

It is guaranteed that the sum of $k_i$ does not exceed $2 \cdot 10^5$ ($\sum\limits_{i=1}^{m} k_i \le 2 \cdot 10^5$).


-----Output-----

For each query, print the answer — "YES", if there is a path from the root to some vertex $u$ such that each of the given $k$ vertices is either belongs to this path or has the distance $1$ to some vertex of this path and "NO" otherwise.


-----Example-----
Input
10 6
1 2
1 3
1 4
2 5
2 6
3 7
7 8
7 9
9 10
4 3 8 9 10
3 2 4 6
3 2 1 5
3 4 8 2
2 6 10
3 5 4 7

Output
YES
YES
YES
YES
NO
NO



-----Note-----

The picture corresponding to the example:

[Image]

Consider the queries.

The first query is $[3, 8, 9, 10]$. The answer is "YES" as you can choose the path from the root $1$ to the vertex $u=10$. Then vertices $[3, 9, 10]$ belong to the path from $1$ to $10$ and the vertex $8$ has distance $1$ to the vertex $7$ which also belongs to this path.

The second query is $[2, 4, 6]$. The answer is "YES" as you can choose the path to the vertex $u=2$. Then the vertex $4$ has distance $1$ to the vertex $1$ which belongs to this path and the vertex $6$ has distance $1$ to the vertex $2$ which belongs to this path.

The third query is $[2, 1, 5]$. The answer is "YES" as you can choose the path to the vertex $u=5$ and all vertices of the query belong to this path.

The fourth query is $[4, 8, 2]$. The answer is "YES" as you can choose the path to the vertex $u=9$ so vertices $2$ and $4$ both have distance $1$ to the vertex $1$ which belongs to this path and the vertex $8$ has distance $1$ to the vertex $7$ which belongs to this path.

The fifth and the sixth queries both have answer "NO" because you cannot choose suitable vertex $u$.
"""
2022-04-13 21:24:58.194469 --------------------------
2022-04-13 21:26:55.649155 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n, m = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n    for _ in range(m):\n        k = int(input())\n        query = set(map(int, input().split()))\n        if k == 1:\n            print(\"YES\")\n            continue\n        if query.pop() != 1:\n            print(\"NO\")\n            continue\n        visited = [False] * n\n        visited[0] = True\n        q = [[0, 1]]\n        for _ in range(k - 2):\n            u, dist = q.pop(0)\n            for v in adj_list[u]:\n                if not visited[v]:\n                    if v + 1 in query:\n                        if dist > 1:\n                            print(\"YES\")\n                            break\n                    else:\n                        q.append([v, dist + 1])\n                    visited[v] = True\n            else:\n                continue\n            break\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    sys.setrecursionlimit(2147483647)\n    n, m = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    for i in range(m):\n        k = int(input())\n        vertices = set(map(int, input().split()))\n        print(\"YES\" if dfs(graph, vertices, 1, 0) else \"NO\")\n\ndef dfs(graph, vertices, cur, depth):\n    if cur in vertices:\n        vertices.remove(cur)\n\n    if len(vertices) == 0:\n        return True\n\n    for v in graph[cur]:\n        if depth == 1 and v in vertices:\n            vertices.remove(v)\n            if len(vertices) == 0:\n                return True\n        elif depth < 2:\n            if dfs(graph, vertices, v, depth + 1):\n                return True\n\n    return False\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\nfrom sys import stdin\nfrom collections import defaultdict\nfrom collections import deque\n\nn, m = [int(x) for x in stdin.readline().split()]\n\nedges = defaultdict(list)\n\nfor _ in range(n-1):\n    u, v = [int(x) for x in stdin.readline().split()]\n    edges[u].append(v)\n    edges[v].append(u)\n\nfor _ in range(m):\n    k = int(stdin.readline())\n    query = [int(x) for x in stdin.readline().split()]\n    visited = [False] * (n+1)\n    queue = deque([1])\n    visited[1] = True\n    while queue:\n        v = queue.popleft()\n        for u in edges[v]:\n            if not visited[u]:\n                visited[u] = True\n                queue.append(u)\n    if all([visited[x] for x in query]):\n        print('YES')\n    else:\n        print('NO')"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10**7) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def __init__(self):\n        self.visited = set()\n        self.answers = []\n\n    def traverse(self, node, target):\n        if node is None:\n            return False\n\n        if node in self.visited:\n            return False\n\n        self.visited.add(node)\n\n        if node == target:\n            return True\n\n        for child in node.children:\n            if self.traverse(child, target):\n                return True\n\n        return False\n\n    def traverse_tree(self, node):\n        if node is None:\n            return False\n\n        self.visited.add(node)\n\n        for child in node.children:\n            if not self.traverse_tree(child):\n                return False\n\n        return True\n\n    def bfs(self, node, target):\n        if node is None:\n            return False\n\n        queue = [node]\n\n        while queue:\n            curr = queue.pop(0)\n            if curr == target:\n                return True\n\n            for child in curr.children:\n                queue.append(child)\n\n        return False\n\n    def is_connected(self, node):\n        if node is None:\n            return False\n\n        self.visited.clear()\n        return self.traverse_tree(node)\n\n    def check_path(self, node, targets):\n        for target in targets:\n            if not self.traverse(node, target):\n                return False\n\n        return True\n\n    def solve(self, node):\n        if node is None:\n            return False\n\n        answer = self.is_connected(node)\n\n        for target in self.targets:\n            if not self.bfs(node, target):\n                answer = False\n                break\n\n        self.answers.append(answer)\n\n    def check_all_paths(self, node, targets):\n        self.targets = targets\n        self.answers = []\n\n        for target in targets:\n            if not self.traverse(node, target):\n                self.answers.append(False)\n                return self.answers\n\n        self.answers.append(True)\n        return self.answers\n\n    def traverse_tree_multi(self, node, targets):\n        if node is None:\n            return False\n\n        self.visited.add(node)\n\n        for child in node.children:\n            if not self.traverse_tree_multi(child, targets):\n                return False\n\n        if not self.check_all_paths(node, targets):\n            return False\n\n        return True\n\n    def solve_multi(self, node, targets):\n        if node is None:\n            return False\n\n        answer = self.is_connected(node)\n        if not answer:\n            return False\n\n        self.visited.clear()\n        return self.traverse_tree_multi(node, targets)\n\n\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\ndef main():\n    nodes = [TreeNode(i) for i in range(1, int(sys.stdin.readline()) + 1)]\n    for _ in range(len(nodes) - 1):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        nodes[u - 1].add_child(nodes[v - 1])\n        nodes[v - 1].add_child(nodes[u - 1])\n\n    solver = Solution()\n    for _ in range(int(sys.stdin.readline())):\n        targets = map(int, sys.stdin.readline().strip().split())\n        targets = [nodes[target - 1] for target in targets]\n        if solver.solve_multi(nodes[0], targets):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nthreading.Thread(target=main).start()"
    },
    {
      "finish_reason": "length",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# The idea is to use the fact that the given edges form a tree.\n# So we can use DFS to find the path from the root to the vertex $u$.\n# Let's store for each vertex the list of its children.\n# Then for each query we can use DFS to find the path from the root to some vertex $u$ such that all given vertices are either belongs to this path or have distance $1$ to some vertex of this path.\n\n# Let's store for each vertex the list of its children.\nchildren = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    children[u].append(v)\n    children[v].append(u)\n\n# Let's store for each vertex the list of its parents.\nparents = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    parents[u].append(v)\n    parents[v].append(u)\n\n# Let's store for each vertex the set of its neighbors.\nneighbors = [set() for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    neighbors[u].add(v)\n    neighbors[v].add(u)\n\n# Let's store for each vertex the list of its ancestors.\nancestors = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    ancestors[u].append(v)\n    ancestors[v].append(u)\n\n# Let's store for each vertex the list of its descendants.\ndescendants = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    descendants[u].append(v)\n    descendants[v].append(u)\n\n# Let's store for each vertex the list of its children which are not leaves.\nnotLeaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    notLeaves[u].append(v)\n    notLeaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are not leaves.\nnotLeaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    notLeaves[u].append(v)\n    notLeaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are not leaves.\nnotLeaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    notLeaves[u].append(v)\n    notLeaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n   "
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\nn, m = map(int, input().split())\ntree = defaultdict(list)\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\n\nfor _ in range(m):\n    k = int(input())\n    v = list(map(int, input().split()))\n    q = [v[0]]\n    seen = [False] * (n+1)\n    seen[v[0]] = True\n    while q:\n        e = q.pop(0)\n        for ne in tree[e]:\n            if seen[ne]:\n                continue\n            if ne in v:\n                v.remove(ne)\n            q.append(ne)\n            seen[ne] = True\n    print('YES' if len(v) == 0 else 'NO')"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\ndef dfs(node, adj, visited):\n    visited[node] = True\n    for n in adj[node]:\n        if not visited[n]:\n            dfs(n, adj, visited)\n\ndef solve(n, adj, k, query):\n    visited = [False] * (n + 1)\n    dfs(1, adj, visited)\n    for v in query:\n        if visited[v]:\n            return True\n        for n in adj[v]:\n            if visited[n]:\n                return True\n    return False\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    for _ in range(m):\n        k = int(input())\n        query = [int(x) for x in input().split()]\n        ans = \"YES\" if solve(n, adj, k, query) else \"NO\"\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649885098,
  "id": "cmpl-4weludBcS0bb2iseA2JMwxbXi0Jb8",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:26:55.649646 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n, m = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n    for _ in range(m):\n        k = int(input())\n        query = set(map(int, input().split()))\n        if k == 1:\n            print(\"YES\")\n            continue\n        if query.pop() != 1:\n            print(\"NO\")\n            continue\n        visited = [False] * n\n        visited[0] = True\n        q = [[0, 1]]\n        for _ in range(k - 2):\n            u, dist = q.pop(0)\n            for v in adj_list[u]:\n                if not visited[v]:\n                    if v + 1 in query:\n                        if dist > 1:\n                            print(\"YES\")\n                            break\n                    else:\n                        q.append([v, dist + 1])\n                    visited[v] = True\n            else:\n                continue\n            break\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:26:55.649711 REASON stop
2022-04-13 21:26:55.650074 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    sys.setrecursionlimit(2147483647)\n    n, m = map(int, input().split())\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    for i in range(m):\n        k = int(input())\n        vertices = set(map(int, input().split()))\n        print(\"YES\" if dfs(graph, vertices, 1, 0) else \"NO\")\n\ndef dfs(graph, vertices, cur, depth):\n    if cur in vertices:\n        vertices.remove(cur)\n\n    if len(vertices) == 0:\n        return True\n\n    for v in graph[cur]:\n        if depth == 1 and v in vertices:\n            vertices.remove(v)\n            if len(vertices) == 0:\n                return True\n        elif depth < 2:\n            if dfs(graph, vertices, v, depth + 1):\n                return True\n\n    return False\n\nmain()"
}
2022-04-13 21:26:55.650180 REASON stop
2022-04-13 21:26:55.650532 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\nfrom sys import stdin\nfrom collections import defaultdict\nfrom collections import deque\n\nn, m = [int(x) for x in stdin.readline().split()]\n\nedges = defaultdict(list)\n\nfor _ in range(n-1):\n    u, v = [int(x) for x in stdin.readline().split()]\n    edges[u].append(v)\n    edges[v].append(u)\n\nfor _ in range(m):\n    k = int(stdin.readline())\n    query = [int(x) for x in stdin.readline().split()]\n    visited = [False] * (n+1)\n    queue = deque([1])\n    visited[1] = True\n    while queue:\n        v = queue.popleft()\n        for u in edges[v]:\n            if not visited[u]:\n                visited[u] = True\n                queue.append(u)\n    if all([visited[x] for x in query]):\n        print('YES')\n    else:\n        print('NO')"
}
2022-04-13 21:26:55.650578 REASON stop
2022-04-13 21:26:55.678495 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nimport threading\n\nsys.setrecursionlimit(10**7) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def __init__(self):\n        self.visited = set()\n        self.answers = []\n\n    def traverse(self, node, target):\n        if node is None:\n            return False\n\n        if node in self.visited:\n            return False\n\n        self.visited.add(node)\n\n        if node == target:\n            return True\n\n        for child in node.children:\n            if self.traverse(child, target):\n                return True\n\n        return False\n\n    def traverse_tree(self, node):\n        if node is None:\n            return False\n\n        self.visited.add(node)\n\n        for child in node.children:\n            if not self.traverse_tree(child):\n                return False\n\n        return True\n\n    def bfs(self, node, target):\n        if node is None:\n            return False\n\n        queue = [node]\n\n        while queue:\n            curr = queue.pop(0)\n            if curr == target:\n                return True\n\n            for child in curr.children:\n                queue.append(child)\n\n        return False\n\n    def is_connected(self, node):\n        if node is None:\n            return False\n\n        self.visited.clear()\n        return self.traverse_tree(node)\n\n    def check_path(self, node, targets):\n        for target in targets:\n            if not self.traverse(node, target):\n                return False\n\n        return True\n\n    def solve(self, node):\n        if node is None:\n            return False\n\n        answer = self.is_connected(node)\n\n        for target in self.targets:\n            if not self.bfs(node, target):\n                answer = False\n                break\n\n        self.answers.append(answer)\n\n    def check_all_paths(self, node, targets):\n        self.targets = targets\n        self.answers = []\n\n        for target in targets:\n            if not self.traverse(node, target):\n                self.answers.append(False)\n                return self.answers\n\n        self.answers.append(True)\n        return self.answers\n\n    def traverse_tree_multi(self, node, targets):\n        if node is None:\n            return False\n\n        self.visited.add(node)\n\n        for child in node.children:\n            if not self.traverse_tree_multi(child, targets):\n                return False\n\n        if not self.check_all_paths(node, targets):\n            return False\n\n        return True\n\n    def solve_multi(self, node, targets):\n        if node is None:\n            return False\n\n        answer = self.is_connected(node)\n        if not answer:\n            return False\n\n        self.visited.clear()\n        return self.traverse_tree_multi(node, targets)\n\n\nclass TreeNode(object):\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\ndef main():\n    nodes = [TreeNode(i) for i in range(1, int(sys.stdin.readline()) + 1)]\n    for _ in range(len(nodes) - 1):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        nodes[u - 1].add_child(nodes[v - 1])\n        nodes[v - 1].add_child(nodes[u - 1])\n\n    solver = Solution()\n    for _ in range(int(sys.stdin.readline())):\n        targets = map(int, sys.stdin.readline().strip().split())\n        targets = [nodes[target - 1] for target in targets]\n        if solver.solve_multi(nodes[0], targets):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nthreading.Thread(target=main).start()"
}
2022-04-13 21:26:55.678611 REASON stop
2022-04-13 21:26:55.681500 4 {
  "finish_reason": "length",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# The idea is to use the fact that the given edges form a tree.\n# So we can use DFS to find the path from the root to the vertex $u$.\n# Let's store for each vertex the list of its children.\n# Then for each query we can use DFS to find the path from the root to some vertex $u$ such that all given vertices are either belongs to this path or have distance $1$ to some vertex of this path.\n\n# Let's store for each vertex the list of its children.\nchildren = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    children[u].append(v)\n    children[v].append(u)\n\n# Let's store for each vertex the list of its parents.\nparents = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    parents[u].append(v)\n    parents[v].append(u)\n\n# Let's store for each vertex the set of its neighbors.\nneighbors = [set() for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    neighbors[u].add(v)\n    neighbors[v].add(u)\n\n# Let's store for each vertex the list of its ancestors.\nancestors = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    ancestors[u].append(v)\n    ancestors[v].append(u)\n\n# Let's store for each vertex the list of its descendants.\ndescendants = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    descendants[u].append(v)\n    descendants[v].append(u)\n\n# Let's store for each vertex the list of its children which are not leaves.\nnotLeaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    notLeaves[u].append(v)\n    notLeaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are not leaves.\nnotLeaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    notLeaves[u].append(v)\n    notLeaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are not leaves.\nnotLeaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    notLeaves[u].append(v)\n    notLeaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    leaves[u].append(v)\n    leaves[v].append(u)\n\n# Let's store for each vertex the list of its children which are leaves.\nleaves = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n   "
}
2022-04-13 21:26:55.681661 REASON length
2022-04-13 21:26:55.681669 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\nn, m = map(int, input().split())\ntree = defaultdict(list)\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\n\nfor _ in range(m):\n    k = int(input())\n    v = list(map(int, input().split()))\n    q = [v[0]]\n    seen = [False] * (n+1)\n    seen[v[0]] = True\n    while q:\n        e = q.pop(0)\n        for ne in tree[e]:\n            if seen[ne]:\n                continue\n            if ne in v:\n                v.remove(ne)\n            q.append(ne)\n            seen[ne] = True\n    print('YES' if len(v) == 0 else 'NO')"
}
2022-04-13 21:26:55.681703 REASON stop
2022-04-13 21:26:55.705055 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\ndef dfs(node, adj, visited):\n    visited[node] = True\n    for n in adj[node]:\n        if not visited[n]:\n            dfs(n, adj, visited)\n\ndef solve(n, adj, k, query):\n    visited = [False] * (n + 1)\n    dfs(1, adj, visited)\n    for v in query:\n        if visited[v]:\n            return True\n        for n in adj[v]:\n            if visited[n]:\n                return True\n    return False\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    for _ in range(m):\n        k = int(input())\n        query = [int(x) for x in input().split()]\n        ans = \"YES\" if solve(n, adj, k, query) else \"NO\"\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:26:55.705174 REASON stop
