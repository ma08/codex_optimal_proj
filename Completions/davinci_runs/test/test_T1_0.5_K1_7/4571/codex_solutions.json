["\n\ndef main():\n    \"\"\"main function\"\"\"\n    n, m = map(int, input().split())\n    if n == 1:\n        print(3800)\n    else:\n        print(int(1900 * (1/2 + 1/4 + 1/8 + 1/16 + 1/32)))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\n\ntotal = 0\nfor i in range(N):\n    if i < M:\n        total += (1/2) * (1900 * (2 ** i))\n    else:\n        total += 100 * (2 ** (N-i))\n\nprint(int(total))", "\n\nn, m = map(int, input().split())\n\ndef get_total_expectation(n, m):\n    \"\"\"\n    :param n: total number of cases\n    :param m: number of cases that pass with 1/2 probability\n    :return: expected value of the total execution time of the code\n    \"\"\"\n    # init\n    p = 1/2\n    expectation = 0\n    for i in range(1, n+1):\n        if i <= m:\n            expectation += (i*1900)*p\n        else:\n            expectation += (i*100)*p\n        p /= 2\n    return expectation\n\nprint(int(get_total_expectation(n, m)))", "\n\nfrom math import factorial\nfrom decimal import Decimal, getcontext\nfrom operator import mul\nfrom fractions import Fraction\n\ndef nCk(n,k):\n    return int(factorial(n) / (factorial(k) * factorial(n-k)))\n\ndef nPk(n,k):\n    return int(factorial(n) / factorial(n-k))\n\ndef solve(n,m):\n    getcontext().prec = 6\n    a = Decimal(1900)\n    b = Decimal(100)\n    p = Decimal(1/2)\n    q = Decimal(1-p)\n    ans = Decimal(0)\n    for i in range(m):\n        ans += Decimal(nPk(m,i)) * Decimal(p**i) * Decimal(q**(m-i)) * Decimal(a*i + b*(n-m))\n    return int(ans)\n\ndef main():\n    n,m = map(int,input().split())\n    print(solve(n,m))\n\nif __name__ == '__main__':\n    main()", "\n\nN, M = map(int, input().split())\n\nif M == 0:\n    print(100*N)\nelse:\n    prob_fail = M/N\n    prob_success = 1-prob_fail\n    prob_fail_n = prob_fail\n    prob_success_n = prob_success\n\n    prob_success_1 = prob_success_n*(prob_success**(N-1))\n    prob_fail_1 = prob_fail_n*(prob_success**(N-1))\n    prob_fail_2 = prob_fail_n*(prob_fail**(N-1))*prob_success\n    prob_fail_3 = prob_fail_n*(prob_fail**(N-1))*prob_fail\n\n    # print(prob_success_1, prob_fail_1, prob_fail_2, prob_fail_3)\n    print(100*prob_success_1 + (100+1900)*prob_fail_1 + (100+1900*2)*prob_fail_2 + (100+1900*3)*prob_fail_3)", "\n\nn, m = map(int, input().split())\n\nprint(1900 * m * 2**m + 100 * (n - m))", "\n\ndef main():\n    N, M = map(int, input().split())\n    case_times = [100] * (N-M) + [1900] * M\n    total_time = 0\n    for case_time in case_times:\n        total_time += case_time\n    print(total_time)\n\nif __name__ == '__main__':\n    main()"]