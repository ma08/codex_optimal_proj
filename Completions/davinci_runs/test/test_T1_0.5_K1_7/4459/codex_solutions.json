["\n\nn = int(input())\na = list(map(int, input().split()))\n\ncnt = [0]*(10**5+1)\nfor i in a:\n    cnt[i] += 1\n\nans = 0\nfor i in range(1, 10**5+1):\n    if cnt[i] < i:\n        ans += cnt[i]\n    else:\n        ans += cnt[i]-i\n\nprint(ans)", "\n\nN = int(input())\na = list(map(int, input().split()))\n\n# Generate a list of counts of each unique number\nunique_numbers = list(set(a))\nunique_numbers.sort()\ncounts = []\nfor i in unique_numbers:\n    counts.append(a.count(i))\n\n# Remove numbers that occur more than the number of times they appear\nremove = 0\nfor i in range(len(counts)):\n    if unique_numbers[i] < counts[i]:\n        remove += counts[i] - unique_numbers[i]\n    elif unique_numbers[i] > counts[i]:\n        remove += counts[i]\n\nprint(remove)", "\n\n# Source: https://qiita.com/drken/items/a5e6fe22863b7992efdb#%E5%95%8F%E9%A1%8C-10-abc-086-c-traveling\n# The answer is the number of elements that are greater than the number of remaining elements.\n# The following is a proof.\n#\n# Let n be the number of remaining elements.\n# If there is an element a_i that is greater than n,\n# there is no way to make it a good sequence by removing the remaining elements.\n#\n# On the other hand, if there is no element a_i that is greater than n,\n# let b = (b_1, b_2, ..., b_n) be the sequence of the remaining elements.\n# Then, b is a good sequence.\n# (This is because each element b_i is less than or equal to n,\n# and there are exactly b_i elements of b_i in b.)\n#\n# Therefore, the number of elements that are greater than n is the minimum number of elements to be removed.\n\nn = int(input())\na = list(map(int, input().split()))\n\n# The number of elements that are greater than n.\n# The minimum number of elements to be removed is the minimum of this value.\nans = n\n\n# The number of remaining elements.\nn -= 1\nfor i in range(len(a)):\n    if a[i] > n:\n        ans -= 1\n    else:\n        n -= 1\n\nprint(ans)", "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\nnum_dict = {}\nfor num in a:\n    if num in num_dict:\n        num_dict[num] += 1\n    else:\n        num_dict[num] = 1\n\nnum_list = sorted(num_dict.items(), key=lambda x: x[0])\n\nremoved_count = 0\nfor num, count in num_list:\n    if count > num:\n        removed_count += count - num\n    elif count < num:\n        removed_count += count\n\nprint(removed_count)", "\n\nimport sys\n\ndef main():\n    N = int(input())\n    a = list(map(int, input().split()))\n    num_to_remove = 0\n    for i in range(1, N+1):\n        num_to_remove += abs(a.count(i) - i)\n    print(num_to_remove // 2)\n\nif __name__ == '__main__':\n    main()", "\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 0\nfor i in range(n-1, -1, -1):\n    if a[i] == a[i-1]:\n        count += 1\n    else:\n        break\nprint(count)", "\n\n# input\nn = int(input())\na = list(map(int, input().split()))\n\n# create a dictionary to count the occurence of each number\noccurence = {}\nfor i in range(n):\n    if a[i] in occurence:\n        occurence[a[i]] += 1\n    else:\n        occurence[a[i]] = 1\n\n# create a list to store the number of occurence\n# if a number's occurence is more than the number itself, then it will be deleted\n# otherwise, the number will be added to the list\nlst = []\nfor key, val in occurence.items():\n    if key < val:\n        lst.append(val - key)\n    else:\n        lst.append(0)\n\n# if the list is empty, then the answer is 0\n# otherwise, the answer is the sum of the list\nif len(lst) == 0:\n    print(0)\nelse:\n    print(sum(lst))"]