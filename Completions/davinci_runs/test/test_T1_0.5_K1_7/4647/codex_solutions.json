["\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    g = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    res = [0] * n\n    stack = [1]\n    while stack:\n        v = stack.pop()\n        cnt_w = a[v - 1]\n        cnt_b = 1 - a[v - 1]\n        for u in g[v]:\n            if u != parent[v]:\n                stack.append(u)\n                cnt_w += cnt_w_arr[u]\n                cnt_b += cnt_b_arr[u]\n        cnt_w_arr[v] = cnt_w\n        cnt_b_arr[v] = cnt_b\n        res[v - 1] = cnt_w - cnt_b\n    print(*res)\n\n\nif __name__ == '__main__':\n    main()", "\n\nfrom collections import deque\n\ndef dfs(v, parent):\n    global white, black, w, b\n    w = 0\n    b = 0\n    if white[v]:\n        w += 1\n    else:\n        b += 1\n    for u in tree[v]:\n        if u == parent:\n            continue\n        dfs(u, v)\n        w += white[u]\n        b += black[u]\n    white[v] = w\n    black[v] = b\n\n\ndef main():\n    global white, black, w, b, tree\n    n = int(input())\n    tree = [[] for _ in range(n+1)]\n    white = [0] * (n+1)\n    black = [0] * (n+1)\n    for i in map(int, input().split()):\n        if i:\n            white[i] = 1\n        else:\n            black[i] = 1\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    dfs(1, 0)\n    for i in range(1, n+1):\n        print(white[i] - black[i], end=' ')\n    print()\n\nmain()", "\n\nfrom collections import defaultdict\nfrom sys import stdin, stdout\n\ndef process(v, p, d):\n    global cnt\n    cnt[v][0] = cnt[v][1] = 0\n    for u in g[v]:\n        if u == p:\n            continue\n        process(u, v, d+1)\n        cnt[v][0] += cnt[u][0]\n        cnt[v][1] += cnt[u][1]\n    cnt[v][a[v]] += 1\n\ndef dfs(v, p, mx):\n    global ans\n    ans = max(ans, mx + cnt[v][1] - cnt[v][0])\n    for u in g[v]:\n        if u == p:\n            continue\n        dfs(u, v, max(mx + cnt[v][1] - cnt[v][0] - cnt[u][1] + cnt[u][0], mx + cnt[1-a[v]][1] - cnt[1-a[v]][0]))\n\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\ng = defaultdict(list)\nfor i in range(n-1):\n    u, v = map(int, stdin.readline().split())\n    g[u].append(v)\n    g[v].append(u)\ncnt = [[0, 0] for i in range(n)]\nprocess(1, 0, 0)\nans = 0\ndfs(1, 0, 0)\nstdout.write(' '.join(map(str, [ans - cnt[i][a[i]] + cnt[i][1-a[i]] for i in range(1, n+1)])))", "\n\nfrom sys import stdin\nfrom collections import defaultdict, deque\n\ndef read_ints():\n    return [int(x) for x in stdin.readline().split()]\n\ndef read_tree():\n    n = read_ints()[0]\n    colors = read_ints()\n    tree = defaultdict(list)\n    for _ in range(n-1):\n        u, v = read_ints()\n        tree[u].append(v)\n        tree[v].append(u)\n    return n, colors, tree\n\ndef dfs(v, parent, colors, tree):\n    white = colors[v-1]\n    black = 1 - white\n    for u in tree[v]:\n        if u != parent:\n            w, b = dfs(u, v, colors, tree)\n            white += w\n            black += b\n    return white, black\n\ndef bfs(v, colors, tree):\n    n = len(colors)\n    white = [0] * (n+1)\n    black = [0] * (n+1)\n    queue = deque([v])\n    while queue:\n        v = queue.popleft()\n        white[v] = colors[v-1]\n        black[v] = 1 - colors[v-1]\n        for u in tree[v]:\n            queue.append(u)\n            white[v] += white[u]\n            black[v] += black[u]\n    return white, black\n\ndef solve():\n    n, colors, tree = read_tree()\n    white, black = bfs(1, colors, tree)\n    for i in range(n):\n        print(white[i+1] - black[i+1], end=' ')\n    print()\n\nsolve()", "\n\nfrom collections import deque\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(2 * 10 ** 5)\n\n\nclass Vertex:\n    def __init__(self, index):\n        self.index = index\n        self.color = None\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def get_child(self, child_index):\n        for child in self.children:\n            if child.index == child_index:\n                return child\n        return None\n\n\nclass Tree:\n    def __init__(self, n):\n        self.root = None\n        self.vertices = [Vertex(i) for i in range(1, n + 1)]\n\n    def add_edge(self, u, v):\n        self.vertices[u - 1].add_child(self.vertices[v - 1])\n        self.vertices[v - 1].add_child(self.vertices[u - 1])\n\n    def set_root(self, index):\n        self.root = self.vertices[index - 1]\n\n    def get_vertex(self, index):\n        return self.vertices[index - 1]\n\n\ndef white_black_count_for_subtree(vertex, tree):\n    if not vertex.children:\n        return vertex.color, 0\n\n    white_count = vertex.color\n    black_count = 0\n    for child in vertex.children:\n        child_white_count, child_black_count = white_black_count_for_subtree(child, tree)\n        white_count += child_white_count\n        black_count += child_black_count\n\n    return white_count, black_count\n\n\ndef max_white_black_difference_for_subtree(vertex, tree):\n    if not vertex.children:\n        return 0\n\n    max_difference = 0\n    for child in vertex.children:\n        child_white_count, child_black_count = white_black_count_for_subtree(child, tree)\n        max_difference = max(max_difference, child_white_count - child_black_count)\n\n    return max_difference\n\n\ndef bfs(tree):\n    queue = deque()\n    queue.append(tree.root)\n    while queue:\n        vertex = queue.popleft()\n        for child in vertex.children:\n            queue.append(child)\n            child.color = vertex.color\n            if child.color == 1:\n                child.color = 0\n            else:\n                child.color = 1\n\n\ndef main():\n    n = int(input())\n    colors = list(map(int, input().split()))\n\n    tree = Tree(n)\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        tree.add_edge(u, v)\n    tree.set_root(1)\n\n    bfs(tree)\n\n    for i in range(n):\n        tree.vertices[i].color = colors[i]\n\n    print(*[max_white_black_difference_for_subtree(tree.get_vertex(i + 1), tree) for i in range(n)])\n\n\nif __name__ == '__main__':\n    main()", "\n\nfrom collections import defaultdict\nfrom sys import stdin\n\n#n = int(input())\n#a = [int(x) for x in input().split()]\n#edges = [[int(x) for x in input().split()] for _ in range(n - 1)]\n\n#n = 9\n#a = [0, 1, 1, 1, 0, 0, 0, 0, 1]\n#edges = [[1, 2], [1, 3], [3, 4], [3, 5], [2, 6], [4, 7], [6, 8], [5, 9]]\n\n#n = 4\n#a = [0, 0, 1, 0]\n#edges = [[1, 2], [1, 3], [1, 4]]\n\nn = int(stdin.readline())\na = [int(x) for x in stdin.readline().split()]\nedges = [[int(x) for x in stdin.readline().split()] for _ in range(n - 1)]\n\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\ndef dfs(v):\n    color = [0, 0]\n    for u in tree[v]:\n        if u != p[v]:\n            p[u] = v\n            c = dfs(u)\n            color[0] += c[0]\n            color[1] += c[1]\n    color[a[v]] += 1\n    return color\n\np = [0] * (n + 1)\np[1] = -1\ndfs(1)\n\ndef dfs2(v):\n    color = [0, 0]\n    for u in tree[v]:\n        if u != p[v]:\n            p[u] = v\n            c = dfs2(u)\n            color[0] += c[0]\n            color[1] += c[1]\n    color[a[v]] += 1\n    res[v] = max(res[v], abs(color[0] - color[1]))\n    return color\n\nres = [0] * (n + 1)\np = [0] * (n + 1)\np[1] = -1\ndfs2(1)\n\nprint(*res[1:])", "\n\n#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\nimport sys\nimport math\nimport queue\nimport copy\n\ndef read_data():\n    n = int(sys.stdin.readline())\n    colors = list(map(int, sys.stdin.readline().split()))\n    edges = []\n    for _ in range(n - 1):\n        edge = list(map(int, sys.stdin.readline().split()))\n        edges.append(edge)\n    return (n, colors, edges)\n\ndef get_neighbors(edges):\n    neighbors = {}\n    for edge in edges:\n        u, v = edge[0], edge[1]\n        if u in neighbors:\n            neighbors[u].append(v)\n        else:\n            neighbors[u] = [v]\n        if v in neighbors:\n            neighbors[v].append(u)\n        else:\n            neighbors[v] = [u]\n    return neighbors\n\ndef bfs(n, colors, neighbors):\n    res = [0] * n\n    for v in range(n):\n        q = queue.Queue()\n        q.put(v)\n        visited = [False] * n\n        visited[v] = True\n        cnt = [0] * 2\n        cnt[colors[v]] += 1\n        while not q.empty():\n            u = q.get()\n            for neighbor in neighbors[u]:\n                if not visited[neighbor]:\n                    q.put(neighbor)\n                    visited[neighbor] = True\n                    cnt[colors[neighbor]] += 1\n        res[v] = cnt[1] - cnt[0]\n    return res\n\ndef solve(n, colors, edges):\n    neighbors = get_neighbors(edges)\n    return bfs(n, colors, neighbors)\n\ndef main():\n    n, colors, edges = read_data()\n    res = solve(n, colors, edges)\n    print(\" \".join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()"]