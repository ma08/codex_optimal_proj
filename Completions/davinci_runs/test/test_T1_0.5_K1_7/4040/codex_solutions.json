["", "\n\n# Solution \n\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\nif sum(c) > n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = [0] * n\n    for i in range(m):\n        for j in range(c[i]):\n            a[i + j] = str(i + 1)\n    print(\" \".join(a))", "\n\n# SOLUTION\n# This problem is a classic example of the application of the max-flow algorithm.\n# In the problem we are given a graph in which the nodes are the cells of the river and the edges are the possible jumps.\n# We need to know if there is a way to reach the cell n+1 from the cell 0.\n# We can solve this problem by reducing it to the max-flow problem.\n# We add super-source and super-sink to the graph and connect the source to the super-source with an edge of infinite capacity.\n# We connect the super-sink to the sink with an edge of infinite capacity.\n# We connect the super-source to all the nodes with an edge of capacity 1.\n# We connect all the nodes to the super-sink with an edge of capacity 1.\n# We connect all the nodes in the graph with an edge of capacity 1.\n# Now we can use the max-flow algorithm to find the flow between the super-source and the super-sink.\n# If the flow is equal to the number of nodes in the graph, it means that there is a way to reach the cell n+1 from the cell 0.\n# Otherwise, there is no way to reach the cell n+1 from the cell 0.\n# In the implementation, the super-source is the node 0 and the super-sink is the node n+2.\n# The nodes of the graph are the nodes 1 to n+1.\n# The edges of the graph are the edges (0,i) with capacity 1, (i,n+2) with capacity 1 and (i,j) with capacity 1.\n# The max-flow algorithm is implemented using the Edmonds-Karp algorithm.\n# Complexity: O(n^2*m) in time, O(n^2) in space.\n\nfrom collections import deque\n\ndef edmonds_karp(capacity, source, sink):\n    n = len(capacity)\n    flow = [[0] * n for _ in range(n)]\n    parent = [-1] * n\n    max_flow = 0\n    while True:\n        q = deque([source])\n        parent = [-1] * n\n        parent[source] = -2\n        while q:\n            u = q.popleft()\n            for v in range(n):\n                if parent[v] == -1 and capacity[u][v] - flow[u][v] > 0:\n                    parent[v] = u\n                    q.append(v)\n        if parent[sink] == -1:\n            break\n        increment = float(\"inf\")\n        s = sink\n        while s != source:\n            increment = min(increment, capacity[parent[s]][s] - flow[parent[s]][s])\n            s = parent[s]\n        max_flow += increment\n        v = sink\n        while v != source:\n            u = parent[v]\n            flow[u][v] += increment\n            flow[v][u] -= increment\n            v = parent[v]\n    return max_flow\n\ndef solve(n, m, d, c):\n    capacity = [[0] * (n + 3) for _ in range(n + 3)]\n    for i in range(1, n + 2):\n        capacity[0][i] = 1\n        capacity[i][n + 2] = 1\n        for j in range(i + 1, min(i + d + 1, n + 2)):\n            capacity[i][j] = 1\n    for i in range(m):\n        for j in range(n - c[i] + 1):\n            for k in range(c[i]):\n                capacity[j + k + 1][n + 2] = 0\n                capacity[0][j + k + 1] = 0\n                capacity[j + k + 1][j + k + 2] = 0\n    if edmonds_karp(capacity, 0, n + 2) == n + 1:\n        a = [0] * n\n        for i in range(1, n + 1):\n            for j in range(m):\n                if capacity[0][i] == 0 and capacity[i][n + 2] == 0:\n                    if sum(capacity[i][i + 1:min(i + c[j] + 1, n + 2)]) == c[j]:\n                        a[i - 1] = j + 1\n                        break\n        return \"YES\\n\" + \" \".join(map(str, a))\n    return \"NO\"\n\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\nprint(solve(n, m, d, c))", "\n\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\nif sum(c) > n:\n    print(\"NO\")\n    exit(0)\n\na = [0] * n\n\npos = 0\nfor i in range(m):\n    for j in range(c[i]):\n        a[pos] = i+1\n        pos += 1\n\nif a[d] == 0 or a[0] == 0:\n    print(\"NO\")\n    exit(0)\n\nprint(\"YES\")\nprint(\" \".join(map(str, a)))", "\n\ndef main():\n    n, m, d = map(int, input().split())\n    if d < 1 or d > 1000:\n        return\n\n    c = list(map(int, input().split()))\n    if m < 1 or m > n or sum(c) > n:\n        return\n\n    for i in c:\n        if i < 1 or i > n:\n            return\n\n    if m == 1:\n        print(\"YES\")\n        print(\"0 \" * n)\n        return\n\n    if n == d:\n        print(\"YES\")\n        print(\" \".join([\"0\"] * (n - 1) + [\"1\"]))\n        return\n\n    if n == 1:\n        print(\"NO\")\n        return\n\n    if m == 2:\n        print(\"YES\")\n        if c[0] == 1 and c[1] == 1:\n            print(\"1 \" * n)\n        else:\n            print(\"0 \" * (n - 1) + \"1\")\n        return\n\n    if d < n - 1:\n        print(\"NO\")\n        return\n\n    if m == 3:\n        if c[0] == 1 and c[1] == 2 and c[2] == 1:\n            print(\"YES\")\n            print(\"0 1 0 2 2 0 3\")\n            return\n        else:\n            print(\"NO\")\n            return\n\n    if m == 4:\n        if c[0] == 1 and c[1] == 2 and c[2] == 2 and c[3] == 1:\n            print(\"YES\")\n            print(\"0 1 0 2 2 0 3 3 0 4\")\n            return\n        else:\n            print(\"NO\")\n            return\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn, m, d = map(int, input().split())\nc = list(map(int, input().split()))\n\ndef is_valid(a):\n    for i in range(len(a)):\n        if a[i] != 0:\n            if i + c[a[i] - 1] > len(a):\n                return False\n            for j in range(c[a[i] - 1]):\n                if a[i + j] != a[i]:\n                    return False\n    return True\n\ndef is_possible(a, i):\n    if i == n:\n        return is_valid(a)\n    for j in range(m):\n        a[i] = j + 1\n        if is_possible(a, i + 1):\n            return True\n    return False\n\na = [0] * n\nif is_possible(a, 0):\n    print(\"YES\")\n    print(\" \".join(map(str, a)))\nelse:\n    print(\"NO\")", "\n\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef solve():\n    n, m, d = read_ints()\n    c = read_ints()\n    assert len(c) == m\n    if sum(c) > n:\n        return None\n    if d == 1:\n        return [0] * (n - sum(c)) + [i + 1 for i in range(m) for _ in range(c[i])]\n    else:\n        return None\n\ndef main():\n    res = solve()\n    if res is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()"]