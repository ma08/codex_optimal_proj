["", "\n\nfrom collections import defaultdict\n\ndef dfs(node, graph, visited, parent=None):\n    visited[node] = True\n    \n    for child in graph[node]:\n        if child != parent:\n            if visited[child]:\n                return True\n            else:\n                if dfs(child, graph, visited, node):\n                    return True\n    \n    return False\n\ndef main():\n    n, m = map(int, input().split())\n    \n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * (n+1)\n    count = 0\n    for node in range(1, n+1):\n        if not visited[node]:\n            if dfs(node, graph, visited):\n                count += 1\n    \n    print(count)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, input().split())))\n    graph = {}\n    for i in range(1, n+1):\n        graph[i] = []\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n    visited = set()\n    ans = 0\n    for i in range(1, n+1):\n        if i in visited:\n            continue\n        stack = [i]\n        visited.add(i)\n        while stack:\n            v = stack.pop()\n            for nei in graph[v]:\n                if nei not in visited:\n                    visited.add(nei)\n                    stack.append(nei)\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n\tn, m = map(int, sys.stdin.readline().split())\n\tedges = []\n\tfor i in range(m):\n\t\tv, u = map(int, sys.stdin.readline().split())\n\t\tedges.append((v, u))\n\tadj_list = [[] for i in range(n+1)]\n\tfor edge in edges:\n\t\tadj_list[edge[0]].append(edge[1])\n\t\tadj_list[edge[1]].append(edge[0])\n\tvisited = [False for i in range(n+1)]\n\tnum_cycles = 0\n\tfor i in range(1, n+1):\n\t\tif not visited[i]:\n\t\t\tvisited[i] = True\n\t\t\tstack = [i]\n\t\t\tcycle = False\n\t\t\twhile stack:\n\t\t\t\tv = stack.pop()\n\t\t\t\tfor u in adj_list[v]:\n\t\t\t\t\tif visited[u]:\n\t\t\t\t\t\tcycle = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tvisited[u] = True\n\t\t\t\t\t\tstack.append(u)\n\t\t\tif cycle:\n\t\t\t\tnum_cycles += 1\n\tprint(num_cycles)\n\nif __name__ == '__main__':\n\tmain()", "\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    edges = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges[u].append(v)\n        edges[v].append(u)\n    visited = set()\n    def dfs(v):\n        visited.add(v)\n        for u in edges[v]:\n            if u not in visited:\n                dfs(u)\n    ans = 0\n    for v in range(1, n + 1):\n        if v not in visited:\n            dfs(v)\n            ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\ndef dfs(graph, start):\n    visited, stack = set(), [start]\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            stack.extend(graph[vertex] - visited)\n    return visited\n\ndef connected_components(graph):\n    return [dfs(graph, vertex) for vertex in graph]\n\ndef is_cycle(graph, component):\n    if len(component) < 3:\n        return False\n    for vertex in component:\n        if len(graph[vertex]) != 2:\n            return False\n    return True\n\ndef number_of_cycles(graph):\n    cycles = 0\n    for component in connected_components(graph):\n        if is_cycle(graph, component):\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, input().split())\n    graph = {i:set() for i in range(1, n+1)}\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].add(v)\n        graph[v].add(u)\n    print(number_of_cycles(graph))\n\nif __name__ == '__main__':\n    main()", "\n\n# Solution\n\nimport sys\n\ndef find_set(x, parent):\n    if x != parent[x]:\n        parent[x] = find_set(parent[x], parent)\n    return parent[x]\n\ndef union_set(x, y, parent, rank):\n    x = find_set(x, parent)\n    y = find_set(y, parent)\n    if x != y:\n        if rank[x] < rank[y]:\n            x, y = y, x\n        parent[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        union_set(a, b, parent, rank)\n    c = 0\n    for i in range(1, n + 1):\n        if find_set(i, parent) == i:\n            c += 1\n    print(c)\n\nif __name__ == '__main__':\n    main()"]