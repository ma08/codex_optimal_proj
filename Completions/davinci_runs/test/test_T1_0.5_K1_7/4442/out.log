2022-04-13 20:50:47.197636 """
Given are 1-digit positive integers a and b. Consider these two strings: the concatenation of b copies of the digit a, and the concatenation of a copies of the digit b. Which of these is lexicographically smaller?

-----Constraints-----
 - 1 \leq a \leq 9
 - 1 \leq b \leq 9
 - a and b are integers.

-----Input-----
Input is given from Standard Input in the following format:
a b

-----Output-----
Print the lexicographically smaller of the two strings. (If the two strings are equal, print one of them.)

-----Sample Input-----
4 3

-----Sample Output-----
3333

We have two strings 444 and 3333. Between them, 3333 is the lexicographically smaller.
"""
2022-04-13 20:50:47.197643 --------------------------
2022-04-13 20:50:58.702879 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\na, b = map(int, input().split())\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\na, b = map(int, input().split())\n\nif a == b:\n  print(a*b)\nelif a < b:\n  print(a*a)\nelif b < a:\n  print(b*b)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a)*b)\nelse:\n    print(str(b)*a)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\na, b = map(int, input().split())\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
    }
  ],
  "created": 1649883047,
  "id": "cmpl-4weEpllhXEHMiSJPnoERGuizNgwuv",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 20:50:58.703147 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
}
2022-04-13 20:50:58.703179 REASON stop
2022-04-13 20:50:58.703619 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\na, b = map(int, input().split())\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
}
2022-04-13 20:50:58.703729 REASON stop
2022-04-13 20:50:58.704148 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
}
2022-04-13 20:50:58.704195 REASON stop
2022-04-13 20:50:58.718444 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\na, b = map(int, input().split())\n\nif a == b:\n  print(a*b)\nelif a < b:\n  print(a*a)\nelif b < a:\n  print(b*b)"
}
2022-04-13 20:50:58.718527 REASON stop
2022-04-13 20:50:58.743305 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a)*b)\nelse:\n    print(str(b)*a)"
}
2022-04-13 20:50:58.743410 REASON stop
2022-04-13 20:50:58.744103 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\na, b = map(int, input().split())\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
}
2022-04-13 20:50:58.744169 REASON stop
2022-04-13 20:50:58.744822 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\na, b = map(int, input().split())\n\nif a < b:\n    print(str(a) * b)\nelse:\n    print(str(b) * a)"
}
2022-04-13 20:50:58.744996 REASON stop
