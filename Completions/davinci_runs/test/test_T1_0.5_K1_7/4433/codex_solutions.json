["\n\n\ndef solution(n, m, edges):\n    # Write your code here\n    # Return the edges of the spanning tree as an array of arrays.\n    pass\n\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    edges = solution(n, m, edges)\n    for edge in edges:\n        print(*edge)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(100000)\n\ndef dfs(v, p, g, used, ans):\n    used[v] = True\n    for u in g[v]:\n        if u == p:\n            continue\n        if not used[u]:\n            ans.append((v, u))\n            dfs(u, v, g, used, ans)\n        else:\n            ans.append((v, u))\n            ans.append((u, v))\n\n\ndef main():\n    n, m = map(int, input().split())\n    g = defaultdict(list)\n    for i in range(m):\n        v, u = map(int, input().split())\n        g[v].append(u)\n        g[u].append(v)\n    used = [False for i in range(n + 1)]\n    ans = []\n    dfs(1, -1, g, used, ans)\n    for v, u in ans:\n        print(v, u)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    print(n - 1)\n    print(\"2 1\")\n    for i in range(2, n):\n        print(\"1\", i)\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        g[u-1].append(v-1)\n        g[v-1].append(u-1)\n    # print(n, m, g)\n    ans = []\n    seen = [False] * n\n    queue = [0]\n    while queue:\n        curr = queue.pop(0)\n        seen[curr] = True\n        for next in g[curr]:\n            if not seen[next]:\n                queue.append(next)\n                ans.append([curr+1, next+1])\n    print(\"\\n\".join(\" \".join(map(str, x)) for x in ans))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    ans = []\n    degree = [0] * n\n    for i in range(m):\n        u, v = edges[i]\n        if degree[u - 1] == 0 and degree[v - 1] == 0:\n            ans.append((u, v))\n            degree[u - 1] += 1\n            degree[v - 1] += 1\n    for i in range(m):\n        u, v = edges[i]\n        if degree[u - 1] == 0 and degree[v - 1] == 1:\n            ans.append((u, v))\n            degree[u - 1] += 1\n            degree[v - 1] += 1\n    for i in range(m):\n        u, v = edges[i]\n        if degree[u - 1] == 1 and degree[v - 1] == 0:\n            ans.append((u, v))\n            degree[u - 1] += 1\n            degree[v - 1] += 1\n    for i in range(m):\n        u, v = edges[i]\n        if degree[u - 1] == 1 and degree[v - 1] == 1:\n            ans.append((u, v))\n            degree[u - 1] += 1\n            degree[v - 1] += 1\n    for u, v in ans:\n        print(u, v)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    print('\\n'.join(map(lambda x: '{} {}'.format(x[0], x[1]), edges)))\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        graph[v - 1].append(u - 1)\n        graph[u - 1].append(v - 1)\n\n    result = []\n    stack = [0]\n    visited = [False] * n\n    visited[0] = True\n    while stack:\n        v = stack[-1]\n        for u in graph[v]:\n            if not visited[u]:\n                stack.append(u)\n                visited[u] = True\n                result.append((v + 1, u + 1))\n                break\n        else:\n            stack.pop()\n\n    print('\\n'.join(map(lambda x: ' '.join(map(str, x)), result)))\n\n\nif __name__ == '__main__':\n    main()"]