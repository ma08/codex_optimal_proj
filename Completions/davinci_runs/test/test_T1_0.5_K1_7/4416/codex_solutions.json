["\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    books = []\n    for i in range(n):\n        books.append(list(map(int, sys.stdin.readline().split())))\n    books.sort()\n    a_count, b_count = 0, 0\n    a_books, b_books = [], []\n    for i in range(n):\n        a_books.append(books[i][1])\n        b_books.append(books[i][2])\n        a_count += books[i][1]\n        b_count += books[i][2]\n        if a_count >= k and b_count >= k:\n            break\n    if a_count < k or b_count < k:\n        print(-1)\n    else:\n        a_count, b_count, t = 0, 0, 0\n        for i in range(n):\n            if a_count < k and a_books[i] == 1:\n                a_count += 1\n                t += books[i][0]\n            elif b_count < k and b_books[i] == 1:\n                b_count += 1\n                t += books[i][0]\n            elif a_count >= k and b_count >= k:\n                break\n        print(t)\n\nif __name__ == \"__main__\":\n    main()", "\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    n, k = map(int, input().split())\n    t = []\n    a = []\n    b = []\n    for i in range(n):\n        tt, aa, bb = map(int, input().split())\n        t.append(tt)\n        a.append(aa)\n        b.append(bb)\n\n    # a_b = [(a[i], b[i], t[i]) for i in range(n)]\n    # a_b.sort(key=lambda x: x[2])\n    # print(a_b)\n\n    ta = [0] * n\n    tb = [0] * n\n    ta[0] = a[0]\n    tb[0] = b[0]\n    for i in range(1, n):\n        ta[i] = ta[i-1] + a[i]\n        tb[i] = tb[i-1] + b[i]\n    # print(ta)\n    # print(tb)\n\n    ta_tb = [(ta[i], tb[i], t[i]) for i in range(n)]\n    ta_tb.sort()\n    # print(ta_tb)\n\n    ans = float('inf')\n    for i in range(n):\n        if ta_tb[i][0] >= k:\n            j = i\n            while j < n and ta_tb[j][0] == ta_tb[i][0]:\n                j += 1\n            # print(i, j)\n            for x in range(i, j):\n                if ta_tb[x][1] >= k:\n                    ans = min(ans, ta_tb[x][2])\n                    break\n            else:\n                for x in range(i, j):\n                    if ta_tb[x][1] + ta_tb[i][0] - k >= k:\n                        ans = min(ans, ta_tb[x][2])\n                        break\n                else:\n                    ans = -1\n                    break\n        else:\n            ans = -1\n            break\n    print(ans)\n\n\nmain()", "\n\n# Solution\n\nimport sys\nimport heapq\n\nclass Node:\n    def __init__(self, time, alice, bob):\n        self.time = time\n        self.alice = alice\n        self.bob = bob\n\ndef solve(n, k, books):\n    heap = []\n    heapq.heapify(heap)\n    heapq.heappush(heap, (0, Node(0, 0, 0)))\n    best = []\n    for _ in range(k + 1):\n        best.append(None)\n    while len(heap) > 0:\n        time, node = heapq.heappop(heap)\n        if node.alice >= k and node.bob >= k:\n            if best[node.alice] is None or best[node.alice] > node.time:\n                best[node.alice] = node.time\n            continue\n        if node.alice >= n or node.bob >= n:\n            continue\n        heapq.heappush(heap, (node.time + books[node.alice].time, Node(node.time + books[node.alice].time, node.alice + 1, node.bob)))\n        heapq.heappush(heap, (node.time + books[node.bob].time, Node(node.time + books[node.bob].time, node.alice, node.bob + 1)))\n    if best[k] is None:\n        print(-1)\n    else:\n        print(best[k])\n\nn, k = map(int, input().split())\nbooks = []\nfor _ in range(n):\n    books.append(Node(*map(int, input().split())))\nbooks.sort(key=lambda x: x.time)\nsolve(n, k, books)", "\n\ndef books():\n    n, k = map(int, input().split())\n    t = []\n    a = []\n    b = []\n    for _ in range(n):\n        ta, aa, ba = map(int, input().split())\n        t.append(ta)\n        a.append(aa)\n        b.append(ba)\n    a_sum = [0] * (n + 1)\n    b_sum = [0] * (n + 1)\n    for i in range(n):\n        a_sum[i + 1] = a_sum[i] + a[i]\n        b_sum[i + 1] = b_sum[i] + b[i]\n    if a_sum[n] < k or b_sum[n] < k:\n        return -1\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            if a_sum[i] - a_sum[j] >= k and b_sum[i] - b_sum[j] >= k:\n                dp[i] = min(dp[i], dp[j] + sum(t[j:i]))\n    return dp[n]\n\nprint(books())", "\n\nfirst_line = input().split(\" \")\nn = int(first_line[0])\nk = int(first_line[1])\n\nbooks = []\nfor i in range(n):\n    line = input().split(\" \")\n    t = int(line[0])\n    a = int(line[1])\n    b = int(line[2])\n    books.append((t, a, b))\n\nbooks_by_a = sorted(books, key=lambda book: book[1])\nbooks_by_b = sorted(books, key=lambda book: book[2])\n\n#print(\"books_by_a\", books_by_a)\n#print(\"books_by_b\", books_by_b)\n\na_books = []\nb_books = []\n\nfor i in range(k):\n    a_books.append(books_by_a[i])\n    b_books.append(books_by_b[i])\n\nif a_books == b_books:\n    print(sum([book[0] for book in a_books]))\n    exit(0)\n\na_books.sort(key=lambda book: book[0])\nb_books.sort(key=lambda book: book[0])\n\n#print(\"a_books\", a_books)\n#print(\"b_books\", b_books)\n\na_books_set = set(a_books)\nb_books_set = set(b_books)\n\nif a_books_set.intersection(b_books_set):\n    print(sum([book[0] for book in a_books]))\n    exit(0)\n\na_books_set = set(a_books)\nb_books_set = set(b_books)\n\nfor i in range(k):\n    a_books_set.remove(a_books[i])\n    b_books_set.remove(b_books[i])\n\na_books_set = list(a_books_set)\nb_books_set = list(b_books_set)\n\n#print(\"a_books_set\", a_books_set)\n#print(\"b_books_set\", b_books_set)\n\na_books_set.sort(key=lambda book: book[0])\nb_books_set.sort(key=lambda book: book[0])\n\n#print(\"a_books_set\", a_books_set)\n#print(\"b_books_set\", b_books_set)\n\na_books_set_set = set(a_books_set)\nb_books_set_set = set(b_books_set)\n\nif a_books_set_set.intersection(b_books_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] + a_books_set[0][0])\n    exit(0)\n\nif a_books_set_set.intersection(b_books_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] + a_books_set[0][0])\n    exit(0)\n\na_books_set_set = set(a_books_set)\nb_books_set_set = set(b_books_set)\n\nfor i in range(k):\n    a_books_set_set.remove(a_books_set[i])\n    b_books_set_set.remove(b_books_set[i])\n\na_books_set_set = list(a_books_set_set)\nb_books_set_set = list(b_books_set_set)\n\na_books_set_set.sort(key=lambda book: book[0])\nb_books_set_set.sort(key=lambda book: book[0])\n\n#print(\"a_books_set_set\", a_books_set_set)\n#print(\"b_books_set_set\", b_books_set_set)\n\na_books_set_set_set = set(a_books_set_set)\nb_books_set_set_set = set(b_books_set_set)\n\nif a_books_set_set_set.intersection(b_books_set_set_set):\n    print(sum([book[0] for book in a_books]) - a_books[k-1][0] - a_books_set[k-1][0] + a_books_set_set[k-1][0] + a_books_set_set[0][0])\n    exit(0)\n\nprint(-1)", "\n\nimport sys, math\n\ndef main():\n    # read input\n    num_books, num_likes = [int(x) for x in sys.stdin.readline().split()]\n    books = [[int(x) for x in sys.stdin.readline().split()] for _ in range(num_books)]\n    # sort by time\n    books.sort(key=lambda x: x[0])\n    # check if possible\n    if num_likes > sum(x[1] for x in books) or num_likes > sum(x[2] for x in books):\n        print(-1)\n        return\n    # find the best solution\n    likes_a, likes_b = 0, 0\n    time = 0\n    for book in books:\n        if likes_a < num_likes and likes_b < num_likes:\n            if book[1] == 1 and book[2] == 1:\n                likes_a += 1\n                likes_b += 1\n                time += book[0]\n            elif likes_a < num_likes and book[1] == 1:\n                likes_a += 1\n                time += book[0]\n            elif likes_b < num_likes and book[2] == 1:\n                likes_b += 1\n                time += book[0]\n        elif likes_a < num_likes and book[1] == 1:\n            likes_a += 1\n            time += book[0]\n        elif likes_b < num_likes and book[2] == 1:\n            likes_b += 1\n            time += book[0]\n    print(time)\n\nif __name__ == \"__main__\":\n    main()"]