2022-04-13 17:30:03.397055 """
You are given a bracket sequence $s$ (not necessarily a regular one). A bracket sequence is a string containing only characters '(' and ')'.

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)"), and ")(", "(" and ")" are not.

Your problem is to calculate the number of regular bracket sequences of length $2n$ containing the given bracket sequence $s$ as a substring (consecutive sequence of characters) modulo $10^9+7$ ($1000000007$).


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 100$) — the half-length of the resulting regular bracket sequences (the resulting sequences must have length equal to $2n$).

The second line of the input contains one string $s$ ($1 \le |s| \le 200$) — the string $s$ that should be a substring in each of the resulting regular bracket sequences ($|s|$ is the length of $s$).


-----Output-----

Print only one integer — the number of regular bracket sequences containing the given bracket sequence $s$ as a substring. Since this number can be huge, print it modulo $10^9+7$ ($1000000007$).


-----Examples-----
Input
5
()))()

Output
5

Input
3
(()

Output
4

Input
2
(((

Output
0



-----Note-----

All regular bracket sequences satisfying the conditions above for the first example:   "(((()))())";  "((()()))()";  "((()))()()";  "(()(()))()";  "()((()))()". 

All regular bracket sequences satisfying the conditions above for the second example:   "((()))";  "(()())";  "(())()";  "()(())". 

And there is no regular bracket sequences of length $4$ containing "(((" as a substring in the third example.
"""
2022-04-13 17:30:03.397076 --------------------------
2022-04-13 17:30:46.267158 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n\ndef solve(n, s):\n    MOD = 1000000007\n    dp = [[0 for _ in range(2*n + 1)] for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(2*i+1):\n            if s[j] == '(':\n                dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD\n            if s[j] == ')':\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n                if j > 0:\n                    dp[i+1][j-1] = (dp[i+1][j-1] + dp[i][j]) % MOD\n    return dp[n][0]\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef solve(n, s):\n    \"\"\"\n    >>> solve(5, '()))()')\n    5\n    >>> solve(3, '(()')\n    4\n    >>> solve(2, '(((')\n    0\n    \"\"\"\n    return 0\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport numpy as np\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    dp = np.zeros((len(s)+1, n+1, n+1), dtype=int)\n    dp[0, 0, 0] = 1\n\n    for i in range(len(s)):\n        for j in range(n+1):\n            for k in range(n+1):\n                if s[i] == '(':\n                    if j > 0 and k < n:\n                        dp[i+1, j, k+1] += dp[i, j-1, k]\n                    if k > 0:\n                        dp[i+1, j, k-1] += dp[i, j, k]\n                else:\n                    if j > 0:\n                        dp[i+1, j-1, k] += dp[i, j, k]\n                    if j < n and k > 0:\n                        dp[i+1, j+1, k-1] += dp[i, j, k]\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    res = dp[len(s), 0, 0]\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    # and have no open brackets to the right of s and no closed brackets to the left of s\n    dp = np.zeros((len(s)+1, n+1, n+1), dtype=int)\n    dp[0, 0, 0] = 1\n\n    for i in range(len(s)):\n        for j in range(n+1):\n            for k in range(n+1):\n                if s[i] == '(':\n                    if j > 0:\n                        dp[i+1, j-1, k] += dp[i, j, k]\n                    if j < n and k > 0:\n                        dp[i+1, j+1, k-1] += dp[i, j, k]\n                else:\n                    if j > 0 and k < n:\n                        dp[i+1, j-1, k+1] += dp[i, j, k]\n                    if k > 0:\n                        dp[i+1, j, k-1] += dp[i, j, k]\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    # and have no open brackets to the right of s and no closed brackets to the left of s\n    res -= dp[len(s), 0, 0]\n\n    res = (res + 2**(2*n-len(s))) % 1000000007\n\n    print(res)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\ndef is_substring(substring, string):\n    if substring in string:\n        return True\n    else:\n        return False\n\ndef generate_brackets(n):\n    if n == 0:\n        return [\"\"]\n    elif n == 1:\n        return [\"()\"]\n    else:\n        result = []\n        for i in range(1, n):\n            for left in generate_brackets(i):\n                for right in generate_brackets(n-i):\n                    result.append(left + right)\n        return result\n\ndef is_regular(string):\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n\ndef is_substring_regular(substring, string):\n    i = 0\n    while i < len(string):\n        if is_substring(substring, string[i:i+len(substring)]):\n            if is_regular(string[i:i+len(substring)]):\n                return True\n        i = i + 1\n    return False\n\ndef count_substring_regular(substring, string):\n    i = 0\n    count = 0\n    while i < len(string):\n        if is_substring(substring, string[i:i+len(substring)]):\n            if is_regular(string[i:i+len(substring)]):\n                count = count + 1\n        i = i + 1\n    return count\n\ndef count_substring_regular_in_list(substring, list):\n    count = 0\n    for string in list:\n        if is_substring_regular(substring, string):\n            count = count + 1\n    return count\n\nprint(count_substring_regular_in_list(s, generate_brackets(n)))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n#Solution\n\nn=int(input())\ns=input()\ndp=[0 for i in range(n+1)]\ndp[0]=1\nfor i in range(1,n+1):\n    for j in range(i):\n        if s[j]=='(' and s[i+j]==')':\n            dp[i]+=dp[j]*dp[i-j-1]\nprint(dp[n]%(10**9+7))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n\ndef solution(n, s):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j < i:\n                dp[i][j] += dp[i - 1][j + 1]\n            dp[i][j] %= 1000000007\n    return dp[n][s.count('(') - s.count(')')]\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input()\n    print(solution(n, s))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n#Solution\n\nn = int(input())\ns = input()\n\ndp = [0] * (2 * n + 1)\ndp[0] = 1\n\nfor i in range(1, 2 * n + 1):\n    dp[i] = dp[i - 1] * 2\n    dp[i] %= 1000000007\n    if i >= len(s):\n        if s[0] == ')' and i - len(s) > 0:\n            dp[i] -= dp[i - len(s) - 1]\n        elif s[0] == '(' and i - len(s) > 0:\n            dp[i] -= dp[i - len(s) - 1]\n            dp[i] += dp[i - len(s) - 2]\n        dp[i] %= 1000000007\n\nprint(dp[2 * n])"
    }
  ],
  "created": 1649871003,
  "id": "cmpl-4wb6ZIXvwajVuU1sQka58wI57EUkf",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 17:30:46.267559 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n\ndef solve(n, s):\n    MOD = 1000000007\n    dp = [[0 for _ in range(2*n + 1)] for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(2*i+1):\n            if s[j] == '(':\n                dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD\n            if s[j] == ')':\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n                if j > 0:\n                    dp[i+1][j-1] = (dp[i+1][j-1] + dp[i][j]) % MOD\n    return dp[n][0]\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 17:30:46.267601 REASON stop
2022-04-13 17:30:46.267995 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef solve(n, s):\n    \"\"\"\n    >>> solve(5, '()))()')\n    5\n    >>> solve(3, '(()')\n    4\n    >>> solve(2, '(((')\n    0\n    \"\"\"\n    return 0\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
}
2022-04-13 17:30:46.268106 REASON stop
2022-04-13 17:30:46.268460 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport numpy as np\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    dp = np.zeros((len(s)+1, n+1, n+1), dtype=int)\n    dp[0, 0, 0] = 1\n\n    for i in range(len(s)):\n        for j in range(n+1):\n            for k in range(n+1):\n                if s[i] == '(':\n                    if j > 0 and k < n:\n                        dp[i+1, j, k+1] += dp[i, j-1, k]\n                    if k > 0:\n                        dp[i+1, j, k-1] += dp[i, j, k]\n                else:\n                    if j > 0:\n                        dp[i+1, j-1, k] += dp[i, j, k]\n                    if j < n and k > 0:\n                        dp[i+1, j+1, k-1] += dp[i, j, k]\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    res = dp[len(s), 0, 0]\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    # and have no open brackets to the right of s and no closed brackets to the left of s\n    dp = np.zeros((len(s)+1, n+1, n+1), dtype=int)\n    dp[0, 0, 0] = 1\n\n    for i in range(len(s)):\n        for j in range(n+1):\n            for k in range(n+1):\n                if s[i] == '(':\n                    if j > 0:\n                        dp[i+1, j-1, k] += dp[i, j, k]\n                    if j < n and k > 0:\n                        dp[i+1, j+1, k-1] += dp[i, j, k]\n                else:\n                    if j > 0 and k < n:\n                        dp[i+1, j-1, k+1] += dp[i, j, k]\n                    if k > 0:\n                        dp[i+1, j, k-1] += dp[i, j, k]\n\n    # the number of sequences which have s as a substring\n    # and have n open brackets and n closed brackets\n    # and have open brackets to the left of s and closed brackets to the right of s\n    # and have no open brackets to the right of s and no closed brackets to the left of s\n    res -= dp[len(s), 0, 0]\n\n    res = (res + 2**(2*n-len(s))) % 1000000007\n\n    print(res)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 17:30:46.268513 REASON stop
2022-04-13 17:30:46.269847 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\ndef is_substring(substring, string):\n    if substring in string:\n        return True\n    else:\n        return False\n\ndef generate_brackets(n):\n    if n == 0:\n        return [\"\"]\n    elif n == 1:\n        return [\"()\"]\n    else:\n        result = []\n        for i in range(1, n):\n            for left in generate_brackets(i):\n                for right in generate_brackets(n-i):\n                    result.append(left + right)\n        return result\n\ndef is_regular(string):\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n\ndef is_substring_regular(substring, string):\n    i = 0\n    while i < len(string):\n        if is_substring(substring, string[i:i+len(substring)]):\n            if is_regular(string[i:i+len(substring)]):\n                return True\n        i = i + 1\n    return False\n\ndef count_substring_regular(substring, string):\n    i = 0\n    count = 0\n    while i < len(string):\n        if is_substring(substring, string[i:i+len(substring)]):\n            if is_regular(string[i:i+len(substring)]):\n                count = count + 1\n        i = i + 1\n    return count\n\ndef count_substring_regular_in_list(substring, list):\n    count = 0\n    for string in list:\n        if is_substring_regular(substring, string):\n            count = count + 1\n    return count\n\nprint(count_substring_regular_in_list(s, generate_brackets(n)))"
}
2022-04-13 17:30:46.269920 REASON stop
2022-04-13 17:30:46.293509 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n#Solution\n\nn=int(input())\ns=input()\ndp=[0 for i in range(n+1)]\ndp[0]=1\nfor i in range(1,n+1):\n    for j in range(i):\n        if s[j]=='(' and s[i+j]==')':\n            dp[i]+=dp[j]*dp[i-j-1]\nprint(dp[n]%(10**9+7))"
}
2022-04-13 17:30:46.293628 REASON stop
2022-04-13 17:30:46.294368 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n\ndef solution(n, s):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j < i:\n                dp[i][j] += dp[i - 1][j + 1]\n            dp[i][j] %= 1000000007\n    return dp[n][s.count('(') - s.count(')')]\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input()\n    print(solution(n, s))"
}
2022-04-13 17:30:46.294443 REASON stop
2022-04-13 17:30:46.305247 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n#Solution\n\nn = int(input())\ns = input()\n\ndp = [0] * (2 * n + 1)\ndp[0] = 1\n\nfor i in range(1, 2 * n + 1):\n    dp[i] = dp[i - 1] * 2\n    dp[i] %= 1000000007\n    if i >= len(s):\n        if s[0] == ')' and i - len(s) > 0:\n            dp[i] -= dp[i - len(s) - 1]\n        elif s[0] == '(' and i - len(s) > 0:\n            dp[i] -= dp[i - len(s) - 1]\n            dp[i] += dp[i - len(s) - 2]\n        dp[i] %= 1000000007\n\nprint(dp[2 * n])"
}
2022-04-13 17:30:46.305354 REASON stop
