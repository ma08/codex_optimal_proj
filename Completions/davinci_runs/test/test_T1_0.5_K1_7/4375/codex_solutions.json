["\nimport sys\nsys.setrecursionlimit(20000)\n\ndef dfs(v, parent = -1):\n    global graph, k, max_weight, weights\n    max_weight[v] = weights[v]\n    for i in graph[v]:\n        if i == parent:\n            continue\n        dfs(i, v)\n        max_weight[v] += max_weight[i]\n\ndef dfs_2(v, parent = -1):\n    global graph, k, max_weight, weights, ans\n    ans = max(ans, max_weight[v])\n    for i in graph[v]:\n        if i == parent:\n            continue\n        max_weight[v] -= max_weight[i]\n        max_weight[i] += max_weight[v]\n        dfs_2(i, v)\n        max_weight[i] -= max_weight[v]\n        max_weight[v] += max_weight[i]\n\nn, k = map(int, input().split())\nweights = list(map(int, input().split()))\ngraph = [[] for i in range(n)]\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u - 1].append(v - 1)\n    graph[v - 1].append(u - 1)\n\nmax_weight = [0] * n\ndfs(0)\nans = 0\ndfs_2(0)\nprint(ans)", "\n\nimport sys\nsys.setrecursionlimit(2000)\n\ndef read_integers():\n    return [int(z) for z in sys.stdin.readline().strip().split()]\n\ndef read_tree(n):\n    edges = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = read_integers()\n        u -= 1\n        v -= 1\n        edges[u].append(v)\n        edges[v].append(u)\n    return edges\n\ndef dfs(v, parent, edges, weights, k, ans, memo):\n    if memo[v] is not None:\n        return memo[v]\n    best = 0\n    for u in edges[v]:\n        if u != parent:\n            best = max(best, dfs(u, v, edges, weights, k, ans, memo))\n    for u in edges[v]:\n        if u != parent:\n            for w in edges[u]:\n                if w != v and w != parent:\n                    best = max(best, dfs(w, u, edges, weights, k, ans, memo))\n    ans[0] = max(ans[0], best + weights[v])\n    memo[v] = best + weights[v]\n    return memo[v]\n\ndef solve(n, edges, weights, k):\n    ans = [0]\n    memo = [None] * n\n    dfs(0, -1, edges, weights, k, ans, memo)\n    return ans[0]\n\nif __name__ == \"__main__\":\n    n, k = read_integers()\n    weights = read_integers()\n    edges = read_tree(n)\n    print(solve(n, edges, weights, k))", "\n\nfrom collections import defaultdict\n\ndef dfs(u, parent, dist, d):\n    for v in d[u]:\n        if v == parent:\n            continue\n        dist[v] = dist[u] + 1\n        dfs(v, u, dist, d)\n\ndef max_subset(n, k, a, d):\n    dist = [0] * (n + 1)\n    dfs(1, 0, dist, d)\n    # print(dist)\n    # print(d)\n    max_weight = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if dist[i] + dist[j] <= k:\n                max_weight = max(max_weight, a[i - 1] + a[j - 1])\n    return sum(a) - max_weight\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        d[u].append(v)\n        d[v].append(u)\n\n    print(max_subset(n, k, a, d))", "\n\nfrom sys import stdin\nfrom collections import defaultdict\n\ndef dfs(u, p):\n    global dp, dist\n    dp[u] = a[u]\n    for v in adj[u]:\n        if v != p:\n            dfs(v, u)\n            dp[u] += dp[v]\n            dist[v] = dist[u] + 1\n\ndef calc_ans(u, p):\n    global dp, ans\n    ans = max(ans, dp[u])\n    for v in adj[u]:\n        if v != p:\n            dp[u] -= dp[v]\n            dp[v] += dp[u]\n            calc_ans(v, u)\n            dp[v] -= dp[u]\n            dp[u] += dp[v]\n\ndef main():\n    global adj, a, dp, ans, dist\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    dp = [0] * (n + 1)\n    dist = [0] * (n + 1)\n    dfs(1, -1)\n    ans = 0\n    calc_ans(1, -1)\n    print(ans)\n\nmain()", "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, k = [int(x) for x in sys.stdin.readline().split()]\n    weights = [int(x) for x in sys.stdin.readline().split()]\n    edges = defaultdict(set)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        edges[u].add(v)\n        edges[v].add(u)\n    \n    max_weight = 0\n    for i in range(1, n + 1):\n        weight = weights[i - 1]\n        visited = {i}\n        queue = [i]\n        while queue:\n            node = queue.pop(0)\n            for child in edges[node]:\n                if child not in visited:\n                    weight += weights[child - 1]\n                    visited.add(child)\n                    queue.append(child)\n        if weight > max_weight:\n            max_weight = weight\n    print(max_weight)\n\nif __name__ == '__main__':\n    main()", "\n\nfrom queue import Queue\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\n\n# BFS to find the maximum weight of subtree rooted at each node\nmax_wt = [0] * (n + 1)\nq = Queue()\nq.put(1)\nwhile not q.empty():\n    u = q.get()\n    max_wt[u] = a[u - 1]\n    for v in adj[u]:\n        if max_wt[v] == 0:\n            q.put(v)\n            max_wt[u] += max_wt[v]\n\n# DFS to find the maximum weight of the subset\nans = 0\nvisited = [0] * (n + 1)\nstack = [1]\nwhile stack:\n    u = stack.pop()\n    visited[u] = 1\n    wt = max_wt[u]\n    for v in adj[u]:\n        if visited[v] == 0:\n            stack.append(v)\n            wt = max(wt, max_wt[v])\n    ans = max(ans, wt)\n    for v in adj[u]:\n        if visited[v] == 2:\n            ans = max(ans, max_wt[u] + max_wt[v])\n    visited[u] = 2\n\nprint(ans)\n\n\n\"\"\"\n# DFS to find the maximum weight of subtree rooted at each node\nmax_wt = [0] * (n + 1)\nvisited = [0] * (n + 1)\ndef dfs(u):\n    visited[u] = 1\n    wt = a[u - 1]\n    for v in adj[u]:\n        if visited[v] == 0:\n            wt += dfs(v)\n    max_wt[u] = wt\n    visited[u] = 2\n    return wt\ndfs(1)\n\n# DFS to find the maximum weight of the subset\nans = 0\nvisited = [0] * (n + 1)\ndef dfs(u):\n    visited[u] = 1\n    wt = max_wt[u]\n    for v in adj[u]:\n        if visited[v] == 0:\n            wt = max(wt, dfs(v))\n    ans = max(ans, wt)\n    for v in adj[u]:\n        if visited[v] == 2:\n            ans = max(ans, max_wt[u] + max_wt[v])\n    visited[u] = 2\n    return wt\ndfs(1)\n\"\"\""]