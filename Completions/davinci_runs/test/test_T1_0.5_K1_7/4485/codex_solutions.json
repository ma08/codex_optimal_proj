["", "\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = [0] * m\n    b = [0] * m\n    for i in range(m):\n        a[i], b[i] = map(int, sys.stdin.readline().split())\n    if (1 in a and n in b) or (1 in b and n in a):\n        print(\"POSSIBLE\")\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\n#read data\nn, m = map(int, sys.stdin.readline().rstrip().split())\n\n#make a dictionary of islands\nislands = {}\nfor i in range(1, n+1):\n    islands[i] = []\n\n#add services to the dictionary\nfor i in range(m):\n    a, b = map(int, sys.stdin.readline().rstrip().split())\n    islands[a].append(b)\n    islands[b].append(a)\n\n#check if it is possible\nif n in islands[1] or 1 in islands[n]:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "\n\n# N = int(input())\n# M = int(input())\n#\n#\n# def solve(N, M):\n#     graph = [[] for _ in range(N)]\n#     for _ in range(M):\n#         a, b = map(int, input().split())\n#         graph[a-1].append(b-1)\n#     visited = [False for _ in range(N)]\n#     queue = []\n#     queue.append(0)\n#     visited[0] = True\n#     while queue:\n#         s = queue.pop(0)\n#         for i in graph[s]:\n#             if not visited[i]:\n#                 queue.append(i)\n#                 visited[i] = True\n#     return visited[-1]\n#\n#\n# if solve(N, M):\n#     print(\"POSSIBLE\")\n# else:\n#     print(\"IMPOSSIBLE\")\n\nN, M = map(int, input().split())\n\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n\nvisited = [False for _ in range(N)]\nqueue = []\nqueue.append(0)\nvisited[0] = True\nwhile queue:\n    s = queue.pop(0)\n    for i in graph[s]:\n        if not visited[i]:\n            queue.append(i)\n            visited[i] = True\n\nif visited[-1]:\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "\n\n# Get input\nn, m = map(int, input().split())\na_b = [list(map(int, input().split())) for i in range(m)]\n\n# Check if a path exists\nif all([[a, b] in a_b for a, b in [[1, n-1], [2, n-1], [1, n-2]]]):\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "\n\nfrom collections import defaultdict\nfrom collections import deque\n\nN, M = map(int, input().split())\n\n# \u5165\u529b\u53d7\u3051\u53d6\u308a\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n# \u30b0\u30e9\u30d5\u4f5c\u6210\ngraph = defaultdict(list)\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n\ndef dfs(graph, start, goal):\n    # \u521d\u671f\u5316\n    visited = [False] * (N + 1)\n    stack = deque([start])\n\n    # \u63a2\u7d22\n    while stack:\n        v = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            stack.extend(graph[v])\n            if v == goal:\n                return True\n    return False\n\n\nif dfs(graph, 1, N):\n    print(\"POSSIBLE\")\nelse:\n    print(\"IMPOSSIBLE\")", "\n\ndef is_possible(n, m, a, b):\n    # Make a graph\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        graph[a[i] - 1].append(b[i] - 1)\n        graph[b[i] - 1].append(a[i] - 1)\n\n    # Check if 1 and N are connected by two services\n    visited = [False for i in range(n)]\n    visited[0] = True\n    queue = [[0, 0]] # [position, depth]\n    while len(queue) > 0:\n        pos, depth = queue.pop(0)\n        if depth == 2 and pos == n - 1:\n            return \"POSSIBLE\"\n        for next_pos in graph[pos]:\n            if not visited[next_pos]:\n                queue.append([next_pos, depth + 1])\n                visited[next_pos] = True\n    return \"IMPOSSIBLE\"\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = []\n    b = []\n    for i in range(m):\n        a_i, b_i = map(int, input().split())\n        a.append(a_i)\n        b.append(b_i)\n    print(is_possible(n, m, a, b))"]