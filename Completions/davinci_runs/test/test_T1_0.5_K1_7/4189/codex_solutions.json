["\n\ndef main():\n    n = int(input())\n    cheese = {}\n    for _ in range(n):\n        name, kind = input().split()\n        if kind not in cheese:\n            cheese[kind] = []\n        cheese[kind].append(name)\n    print(len(cheese))\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n\n#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(input())\n    cheeses = []\n    for i in range(n):\n        cheeses.append(input().split())\n    soft = 0\n    hard = 0\n    for c in cheeses:\n        if c[1] == \"soft\":\n            soft += 1\n        else:\n            hard += 1\n    print(min(soft, hard))\n\nif __name__ == '__main__':\n    main()", "\n\n\"\"\"\n-----Solution-----\n\nWe can think of this problem as a bipartite graph. Each vertex is either a cheese type or a cheese name. There is an edge between a cheese type and a cheese name if the name is of the type.\n\nWe can use a simple bipartite matching algorithm to solve this.\n\"\"\"\n\nimport sys\n\ndef get_cheeses():\n    n = int(sys.stdin.readline().strip())\n    cheeses = dict()\n    for _ in range(n):\n        name, type = sys.stdin.readline().strip().split()\n        if type in cheeses:\n            cheeses[type].append(name)\n        else:\n            cheeses[type] = [name]\n    return cheeses\n\ndef bipartite_matching(cheeses):\n    # convert to adjacency list\n    adj_list = dict()\n    for type in cheeses:\n        adj_list[type] = cheeses[type]\n        for cheese in cheeses[type]:\n            adj_list[cheese] = [type]\n    \n    # perform matching\n    matches = dict()\n    for type in cheeses:\n        matches[type] = []\n\n    for cheese in cheeses['soft']:\n        if cheese not in matches:\n            matches[cheese] = 'soft'\n            matches['soft'].append(cheese)\n            break\n\n    for cheese in cheeses['hard']:\n        if cheese not in matches:\n            matches[cheese] = 'hard'\n            matches['hard'].append(cheese)\n            break\n\n    return matches\n\ndef main():\n    cheeses = get_cheeses()\n    matches = bipartite_matching(cheeses)\n    print(len(matches['soft']) + len(matches['hard']))\n\nif __name__ == '__main__':\n    main()", "\n\n#-----Solution-----\n\n#-----Function-----\n\n#-----Main-----\n\n#-----Input-----\n\n#-----Output-----\n\n#-----Examples-----", "\n\n#-----main-----\nn = int(input())\n\ncheeses = {}\n\nfor i in range(n):\n    cheese = input().split()\n    cheeses[cheese[0]] = cheese[1]\n\nnum_of_hard = 0\nnum_of_soft = 0\n\nfor cheese in cheeses:\n    if cheeses[cheese] == 'hard':\n        num_of_hard += 1\n    else:\n        num_of_soft += 1\n\nif num_of_hard > num_of_soft:\n    print(num_of_soft)\nelse:\n    print(num_of_hard)", "\n\n# SOLUTION\nn = int(input())\n\nsoft = []\nhard = []\n\nfor i in range(n):\n    cheese, type = input().split()\n    if type == 'soft':\n        soft.append(cheese)\n    else:\n        hard.append(cheese)\n\nprint(min(len(soft), len(hard)))", "\n\ndef classify(cheeses):\n    soft = []\n    hard = []\n    for cheese in cheeses:\n        if cheese[1] == \"soft\":\n            soft.append(cheese[0])\n        else:\n            hard.append(cheese[0])\n    return (soft, hard)\n\ndef main():\n    numCheeses = int(input())\n    cheeses = []\n    for i in range(numCheeses):\n        cheeses.append(input().split())\n    cheeses = classify(cheeses)\n    print(len(cheeses[0])+len(cheeses[1])-1)\n\nmain()"]