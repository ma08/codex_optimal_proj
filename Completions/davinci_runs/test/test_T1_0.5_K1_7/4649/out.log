2022-04-13 22:27:29.303482 """
The only difference between easy and hard versions is the size of the input.

You are given a string $s$ consisting of $n$ characters, each character is 'R', 'G' or 'B'.

You are also given an integer $k$. Your task is to change the minimum number of characters in the initial string $s$ so that after the changes there will be a string of length $k$ that is a substring of $s$, and is also a substring of the infinite string "RGBRGBRGB ...".

A string $a$ is a substring of string $b$ if there exists a positive integer $i$ such that $a_1 = b_i$, $a_2 = b_{i + 1}$, $a_3 = b_{i + 2}$, ..., $a_{|a|} = b_{i + |a| - 1}$. For example, strings "GBRG", "B", "BR" are substrings of the infinite string "RGBRGBRGB ..." while "GR", "RGR" and "GGG" are not.

You have to answer $q$ independent queries.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 2000$) — the number of queries. Then $q$ queries follow.

The first line of the query contains two integers $n$ and $k$ ($1 \le k \le n \le 2000$) — the length of the string $s$ and the length of the substring.

The second line of the query contains a string $s$ consisting of $n$ characters 'R', 'G' and 'B'.

It is guaranteed that the sum of $n$ over all queries does not exceed $2000$ ($\sum n \le 2000$).


-----Output-----

For each query print one integer — the minimum number of characters you need to change in the initial string $s$ so that after changing there will be a substring of length $k$ in $s$ that is also a substring of the infinite string "RGBRGBRGB ...".


-----Example-----
Input
3
5 2
BGGGG
5 3
RBRGR
5 5
BBBRR

Output
1
0
3



-----Note-----

In the first example, you can change the first character to 'R' and obtain the substring "RG", or change the second character to 'R' and obtain "BR", or change the third, fourth or fifth character to 'B' and obtain "GB".

In the second example, the substring is "BRG".
"""
2022-04-13 22:27:29.303493 --------------------------
2022-04-13 22:28:31.443314 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef solve(n, k, s):\n    if n < k:\n        return -1\n    if k == 1:\n        return 0\n    if k == 2:\n        if s[0] == s[1]:\n            return 1\n        return 0\n    if n == k:\n        if s[0] == s[1] == s[2]:\n            return 2\n        return 0\n    if k == 3:\n        if s[0] == s[1] == s[2]:\n            return 2\n        if s[0] == s[1] or s[0] == s[2] or s[1] == s[2]:\n            return 1\n        return 0\n    if k == 4:\n        if s[0] == s[1] == s[2] == s[3]:\n            return 3\n        if s[0] == s[1] == s[2] or s[0] == s[1] == s[3] or s[0] == s[2] == s[3] or s[1] == s[2] == s[3]:\n            return 2\n        return 0\n    if k == 5:\n        if s[0] == s[1] == s[2] == s[3] == s[4]:\n            return 4\n        if s[0] == s[1] == s[2] == s[3] or s[0] == s[1] == s[2] == s[4] or s[0] == s[1] == s[3] == s[4] or s[0] == s[2] == s[3] == s[4] or s[1] == s[2] == s[3] == s[4]:\n            return 3\n        if s[0] == s[1] == s[2] or s[0] == s[1] == s[3] or s[0] == s[1] == s[4] or s[0] == s[2] == s[3] or s[0] == s[2] == s[4] or s[0] == s[3] == s[4] or s[1] == s[2] == s[3] or s[1] == s[2] == s[4] or s[1] == s[3] == s[4] or s[2] == s[3] == s[4]:\n            return 2\n        return 0\n    if k == 6:\n        if s[0] == s[1] == s[2] == s[3] == s[4] == s[5]:\n            return 5\n        if s[0] == s[1] == s[2] == s[3] == s[4] or s[0] == s[1] == s[2] == s[3] == s[5] or s[0] == s[1] == s[2] == s[4] == s[5] or s[0] == s[1] == s[3] == s[4] == s[5] or s[0] == s[2] == s[3] == s[4] == s[5] or s[1] == s[2] == s[3] == s[4] == s[5]:\n            return 4\n        if s[0] == s[1] == s[2] == s[3] or s[0] == s[1] == s[2] == s[4] or s[0] == s[1] == s[2] == s[5] or s[0] == s[1] == s[3] == s[4] or s[0] == s[1] == s[3] == s[5] or s[0] == s[1] == s[4] == s[5] or s[0] == s[2] == s[3] == s[4] or s[0] == s[2] == s[3] == s[5] or s[0] == s[2] == s[4] == s[5] or s[0] == s[3] == s[4] == s[5] or s[1] == s[2] == s[3] == s[4] or s[1] == s[2] == s[3] == s[5] or s[1] == s[2] == s[4] == s[5] or s[1] == s[3] == s[4] == s[5] or s[2] == s[3] == s[4] == s[5]:\n            return 3\n        if s[0] == s[1] == s[2] or s[0] == s[1] == s[3] or s[0] == s[1] == s[4] or s[0] == s[1] == s[5] or s[0] == s[2] == s[3] or s[0] == s[2] == s[4] or s[0] == s[2] == s[5] or s[0] == s[3] == s[4] or s[0] == s[3] == s[5] or s[0] == s[4] == s[5] or s[1] == s[2] == s[3] or s[1] == s[2] == s[4] or s[1] == s[2] == s[5] or s[1] == s[3] == s[4] or s[1] == s[3] == s[5] or s[1] == s[4] == s[5] or s[2] == s[3] == s[4] or s[2] == s[3] == s[5] or s[2] == s[4] == s[5] or s[3] == s[4] == s[5]:\n            return 2\n        return 0\n    return -1\n\ndef main():\n    q = int(sys.stdin.readline().strip())\n    for _ in range(q):\n        n, k = map(int, sys.stdin.readline().strip().split())\n        s = sys.stdin.readline().strip()\n        print(solve(n, k, s))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# Solution 1\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))\n\n\n# Solution 2\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))\n\n# Solution 3\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))\n\n# Solution 4\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        print(solve(n, k, s))\n\ndef solve(n, k, s):\n    \"\"\"\n    Solve the problem.\n\n    :param n: the length of the string s\n    :param k: the length of the substring\n    :param s: the string s\n    :return: the minimum number of characters you need to change in the initial string s so that after changing there will be a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    \"\"\"\n    if k == 1:\n        return 0\n    if n == k:\n        return solve_k_equals_n(n, s)\n    else:\n        return solve_k_not_equals_n(n, k, s)\n\ndef solve_k_equals_n(n, s):\n    \"\"\"\n    Solve the problem when k equals n.\n\n    :param n: the length of the string s\n    :param s: the string s\n    :return: the minimum number of characters you need to change in the initial string s so that after changing there will be a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if s[i] != \"RGB\"[i % 3]:\n            count += 1\n    return count\n\ndef solve_k_not_equals_n(n, k, s):\n    \"\"\"\n    Solve the problem when k does not equal n.\n\n    :param n: the length of the string s\n    :param k: the length of the substring\n    :param s: the string s\n    :return: the minimum number of characters you need to change in the initial string s so that after changing there will be a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    \"\"\"\n    # suppose there is a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most 1\n    # suppose the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is 1\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most 2\n    # suppose the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is 2\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most 3\n    # ...\n    # suppose the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is k - 1\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most k\n    # the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most k\n    # so we can change the characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" to the corresponding characters in the infinite string \"RGBRGBRGB ...\"\n    # then there is a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    count = k\n    for i in range(k):\n        if s[i] != \"RGB\"[i % 3]:\n            count -= 1\n    result = count\n    for i in range(k, n):\n        if s[i - k] != \"RGB\"[(i - k) % 3]:\n            count += 1\n        if s[i] != \"RGB\"[i % 3]:\n            count -= 1\n        result = min(result, count)\n    return result\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\n#This function returns the minimum number of characters to be changed in the string s so that\n#it contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\"\ndef min_chars_needed_to_change(s, k):\n    #Initialize variables\n    n = len(s)\n    #If the string s already contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\",\n    #no characters need to be changed, so return 0\n    if is_substring(s, k):\n        return 0\n    #Else, initialize the variable answer to n (the length of s)\n    answer = n\n    #For each character in s, remove it and check if the new string contains a substring of length k\n    #that is also a substring of the infinite string \"RGBRGBRGB...\"\n    for i in range(n):\n        #If it does, update the answer variable\n        if is_substring(s[:i] + s[i + 1:], k):\n            answer = min(answer, 1)\n    #For each pair of characters in s, remove them and check if the new string contains a substring of length k\n    #that is also a substring of the infinite string \"RGBRGBRGB...\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            #If it does, update the answer variable\n            if is_substring(s[:i] + s[i + 1:j] + s[j + 1:], k):\n                answer = min(answer, 2)\n    #For each triplet of characters in s, remove them and check if the new string contains a substring of length k\n    #that is also a substring of the infinite string \"RGBRGBRGB...\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                #If it does, update the answer variable\n                if is_substring(s[:i] + s[i + 1:j] + s[j + 1:k] + s[k + 1:], k):\n                    answer = min(answer, 3)\n    #Return the answer variable\n    return answer\n\n#This function returns whether the string s contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\"\ndef is_substring(s, k):\n    #Initialize variables\n    n = len(s)\n    #If the length of the string s is less than k, it cannot contain a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\", so return False\n    if n < k:\n        return False\n    #Else, initialize the variables answer, count and i to False, 0 and 0 respectively\n    answer = False\n    count = 0\n    i = 0\n    #While the answer variable is False and i is less than n\n    while not answer and i < n:\n        #If the character at index i in s is 'R', increment count by 1\n        if s[i] == 'R':\n            count += 1\n        #If the character at index i in s is 'G', increment count by 2\n        if s[i] == 'G':\n            count += 2\n        #If the character at index i in s is 'B', increment count by 3\n        if s[i] == 'B':\n            count += 3\n        #If count is divisible by 3, set answer to True\n        if count % 3 == 0:\n            answer = True\n        #Increment i by 1\n        i += 1\n    #Return the answer variable\n    return answer\n\n#The number of queries\nq = int(input())\n#For each query\nfor _ in range(q):\n    #Read the length of the string s and the length of the substring\n    n, k = map(int, input().split())\n    #Read the string s\n    s = input()\n    #Print the minimum number of characters needed to be changed in the string s so that it contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\"\n    print(min_chars_needed_to_change(s, k))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        if n < k:\n            print(-1)\n        else:\n            print(min_changes(s, k))\n\ndef min_changes(s, k):\n    \"\"\"Return the minimum number of characters to change in s so that it contains\n    a substring of length k that is also a substring of \"RGBRGBRGB...\".\n    \"\"\"\n    # If k = 1, then the answer is always 0.\n    if k == 1:\n        return 0\n    # If k = 2, then the answer is the number of characters in s that don't match\n    # the first character of s.\n    if k == 2:\n        return s.count(s[0])\n\n    # If k = 3, then we can only change characters in s to create a substring of\n    # length 3 that is also a substring of \"RGBRGBRGB...\" if the first three\n    # characters of s are either \"RGB\", \"RBG\", \"BRG\", \"BGR\", \"GBR\", or \"GRB\".\n    if k == 3:\n        return min(s.count(c) for c in \"RGB\")\n\n    # If k >= 4, then we can always create a substring of length k that is also a\n    # substring of \"RGBRGBRGB...\" by repeating the first three characters of s\n    # (e.g. \"RGBRGBRGB...\", \"RBGRBGRBG...\", \"BRGBRGBRG...\", \"BGRBGRBGR...\").\n    return 0\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        print(min_changes(s, k))\n\n\ndef min_changes(s, k):\n    if k == 1:\n        return 0\n    if k == 2:\n        return 1\n    if k == 3:\n        return min(s.count('R'), s.count('G'), s.count('B'))\n    return len(s) - k\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649888849,
  "id": "cmpl-4wfkPCHXzmXTsd4psPTRHgw5VMj3i",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 22:28:31.443724 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef solve(n, k, s):\n    if n < k:\n        return -1\n    if k == 1:\n        return 0\n    if k == 2:\n        if s[0] == s[1]:\n            return 1\n        return 0\n    if n == k:\n        if s[0] == s[1] == s[2]:\n            return 2\n        return 0\n    if k == 3:\n        if s[0] == s[1] == s[2]:\n            return 2\n        if s[0] == s[1] or s[0] == s[2] or s[1] == s[2]:\n            return 1\n        return 0\n    if k == 4:\n        if s[0] == s[1] == s[2] == s[3]:\n            return 3\n        if s[0] == s[1] == s[2] or s[0] == s[1] == s[3] or s[0] == s[2] == s[3] or s[1] == s[2] == s[3]:\n            return 2\n        return 0\n    if k == 5:\n        if s[0] == s[1] == s[2] == s[3] == s[4]:\n            return 4\n        if s[0] == s[1] == s[2] == s[3] or s[0] == s[1] == s[2] == s[4] or s[0] == s[1] == s[3] == s[4] or s[0] == s[2] == s[3] == s[4] or s[1] == s[2] == s[3] == s[4]:\n            return 3\n        if s[0] == s[1] == s[2] or s[0] == s[1] == s[3] or s[0] == s[1] == s[4] or s[0] == s[2] == s[3] or s[0] == s[2] == s[4] or s[0] == s[3] == s[4] or s[1] == s[2] == s[3] or s[1] == s[2] == s[4] or s[1] == s[3] == s[4] or s[2] == s[3] == s[4]:\n            return 2\n        return 0\n    if k == 6:\n        if s[0] == s[1] == s[2] == s[3] == s[4] == s[5]:\n            return 5\n        if s[0] == s[1] == s[2] == s[3] == s[4] or s[0] == s[1] == s[2] == s[3] == s[5] or s[0] == s[1] == s[2] == s[4] == s[5] or s[0] == s[1] == s[3] == s[4] == s[5] or s[0] == s[2] == s[3] == s[4] == s[5] or s[1] == s[2] == s[3] == s[4] == s[5]:\n            return 4\n        if s[0] == s[1] == s[2] == s[3] or s[0] == s[1] == s[2] == s[4] or s[0] == s[1] == s[2] == s[5] or s[0] == s[1] == s[3] == s[4] or s[0] == s[1] == s[3] == s[5] or s[0] == s[1] == s[4] == s[5] or s[0] == s[2] == s[3] == s[4] or s[0] == s[2] == s[3] == s[5] or s[0] == s[2] == s[4] == s[5] or s[0] == s[3] == s[4] == s[5] or s[1] == s[2] == s[3] == s[4] or s[1] == s[2] == s[3] == s[5] or s[1] == s[2] == s[4] == s[5] or s[1] == s[3] == s[4] == s[5] or s[2] == s[3] == s[4] == s[5]:\n            return 3\n        if s[0] == s[1] == s[2] or s[0] == s[1] == s[3] or s[0] == s[1] == s[4] or s[0] == s[1] == s[5] or s[0] == s[2] == s[3] or s[0] == s[2] == s[4] or s[0] == s[2] == s[5] or s[0] == s[3] == s[4] or s[0] == s[3] == s[5] or s[0] == s[4] == s[5] or s[1] == s[2] == s[3] or s[1] == s[2] == s[4] or s[1] == s[2] == s[5] or s[1] == s[3] == s[4] or s[1] == s[3] == s[5] or s[1] == s[4] == s[5] or s[2] == s[3] == s[4] or s[2] == s[3] == s[5] or s[2] == s[4] == s[5] or s[3] == s[4] == s[5]:\n            return 2\n        return 0\n    return -1\n\ndef main():\n    q = int(sys.stdin.readline().strip())\n    for _ in range(q):\n        n, k = map(int, sys.stdin.readline().strip().split())\n        s = sys.stdin.readline().strip()\n        print(solve(n, k, s))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:28:31.443775 REASON stop
2022-04-13 22:28:31.444209 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# Solution 1\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))\n\n\n# Solution 2\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))\n\n# Solution 3\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))\n\n# Solution 4\n\nq = int(input())\n\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    s = s[:k]\n    if len(s) < k:\n        print(k - len(s))\n        continue\n    if len(set(s)) == 1:\n        print(k)\n        continue\n    print(k - s.count(s[0]))"
}
2022-04-13 22:28:31.444348 REASON stop
2022-04-13 22:28:31.444708 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        print(solve(n, k, s))\n\ndef solve(n, k, s):\n    \"\"\"\n    Solve the problem.\n\n    :param n: the length of the string s\n    :param k: the length of the substring\n    :param s: the string s\n    :return: the minimum number of characters you need to change in the initial string s so that after changing there will be a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    \"\"\"\n    if k == 1:\n        return 0\n    if n == k:\n        return solve_k_equals_n(n, s)\n    else:\n        return solve_k_not_equals_n(n, k, s)\n\ndef solve_k_equals_n(n, s):\n    \"\"\"\n    Solve the problem when k equals n.\n\n    :param n: the length of the string s\n    :param s: the string s\n    :return: the minimum number of characters you need to change in the initial string s so that after changing there will be a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if s[i] != \"RGB\"[i % 3]:\n            count += 1\n    return count\n\ndef solve_k_not_equals_n(n, k, s):\n    \"\"\"\n    Solve the problem when k does not equal n.\n\n    :param n: the length of the string s\n    :param k: the length of the substring\n    :param s: the string s\n    :return: the minimum number of characters you need to change in the initial string s so that after changing there will be a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    \"\"\"\n    # suppose there is a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most 1\n    # suppose the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is 1\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most 2\n    # suppose the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is 2\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most 3\n    # ...\n    # suppose the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is k - 1\n    # then the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most k\n    # the number of characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" is at most k\n    # so we can change the characters in the substring that are different from the corresponding characters in the infinite string \"RGBRGBRGB ...\" to the corresponding characters in the infinite string \"RGBRGBRGB ...\"\n    # then there is a substring of length k in s that is also a substring of the infinite string \"RGBRGBRGB ...\"\n    count = k\n    for i in range(k):\n        if s[i] != \"RGB\"[i % 3]:\n            count -= 1\n    result = count\n    for i in range(k, n):\n        if s[i - k] != \"RGB\"[(i - k) % 3]:\n            count += 1\n        if s[i] != \"RGB\"[i % 3]:\n            count -= 1\n        result = min(result, count)\n    return result\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:28:31.444783 REASON stop
2022-04-13 22:28:31.459963 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:28:31.460051 REASON stop
2022-04-13 22:28:31.478896 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\n#This function returns the minimum number of characters to be changed in the string s so that\n#it contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\"\ndef min_chars_needed_to_change(s, k):\n    #Initialize variables\n    n = len(s)\n    #If the string s already contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\",\n    #no characters need to be changed, so return 0\n    if is_substring(s, k):\n        return 0\n    #Else, initialize the variable answer to n (the length of s)\n    answer = n\n    #For each character in s, remove it and check if the new string contains a substring of length k\n    #that is also a substring of the infinite string \"RGBRGBRGB...\"\n    for i in range(n):\n        #If it does, update the answer variable\n        if is_substring(s[:i] + s[i + 1:], k):\n            answer = min(answer, 1)\n    #For each pair of characters in s, remove them and check if the new string contains a substring of length k\n    #that is also a substring of the infinite string \"RGBRGBRGB...\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            #If it does, update the answer variable\n            if is_substring(s[:i] + s[i + 1:j] + s[j + 1:], k):\n                answer = min(answer, 2)\n    #For each triplet of characters in s, remove them and check if the new string contains a substring of length k\n    #that is also a substring of the infinite string \"RGBRGBRGB...\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                #If it does, update the answer variable\n                if is_substring(s[:i] + s[i + 1:j] + s[j + 1:k] + s[k + 1:], k):\n                    answer = min(answer, 3)\n    #Return the answer variable\n    return answer\n\n#This function returns whether the string s contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\"\ndef is_substring(s, k):\n    #Initialize variables\n    n = len(s)\n    #If the length of the string s is less than k, it cannot contain a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\", so return False\n    if n < k:\n        return False\n    #Else, initialize the variables answer, count and i to False, 0 and 0 respectively\n    answer = False\n    count = 0\n    i = 0\n    #While the answer variable is False and i is less than n\n    while not answer and i < n:\n        #If the character at index i in s is 'R', increment count by 1\n        if s[i] == 'R':\n            count += 1\n        #If the character at index i in s is 'G', increment count by 2\n        if s[i] == 'G':\n            count += 2\n        #If the character at index i in s is 'B', increment count by 3\n        if s[i] == 'B':\n            count += 3\n        #If count is divisible by 3, set answer to True\n        if count % 3 == 0:\n            answer = True\n        #Increment i by 1\n        i += 1\n    #Return the answer variable\n    return answer\n\n#The number of queries\nq = int(input())\n#For each query\nfor _ in range(q):\n    #Read the length of the string s and the length of the substring\n    n, k = map(int, input().split())\n    #Read the string s\n    s = input()\n    #Print the minimum number of characters needed to be changed in the string s so that it contains a substring of length k that is also a substring of the infinite string \"RGBRGBRGB...\"\n    print(min_chars_needed_to_change(s, k))"
}
2022-04-13 22:28:31.479009 REASON stop
2022-04-13 22:28:31.479994 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        if n < k:\n            print(-1)\n        else:\n            print(min_changes(s, k))\n\ndef min_changes(s, k):\n    \"\"\"Return the minimum number of characters to change in s so that it contains\n    a substring of length k that is also a substring of \"RGBRGBRGB...\".\n    \"\"\"\n    # If k = 1, then the answer is always 0.\n    if k == 1:\n        return 0\n    # If k = 2, then the answer is the number of characters in s that don't match\n    # the first character of s.\n    if k == 2:\n        return s.count(s[0])\n\n    # If k = 3, then we can only change characters in s to create a substring of\n    # length 3 that is also a substring of \"RGBRGBRGB...\" if the first three\n    # characters of s are either \"RGB\", \"RBG\", \"BRG\", \"BGR\", \"GBR\", or \"GRB\".\n    if k == 3:\n        return min(s.count(c) for c in \"RGB\")\n\n    # If k >= 4, then we can always create a substring of length k that is also a\n    # substring of \"RGBRGBRGB...\" by repeating the first three characters of s\n    # (e.g. \"RGBRGBRGB...\", \"RBGRBGRBG...\", \"BRGBRGBRG...\", \"BGRBGRBGR...\").\n    return 0\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:28:31.480060 REASON stop
2022-04-13 22:28:31.480899 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        print(min_changes(s, k))\n\n\ndef min_changes(s, k):\n    if k == 1:\n        return 0\n    if k == 2:\n        return 1\n    if k == 3:\n        return min(s.count('R'), s.count('G'), s.count('B'))\n    return len(s) - k\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:28:31.480953 REASON stop
