2022-04-13 21:29:19.330703 """
The only difference between easy and hard versions is constraints.

You are given $n$ segments on the coordinate axis $OX$. Segments can intersect, lie inside each other and even coincide. The $i$-th segment is $[l_i; r_i]$ ($l_i \le r_i$) and it covers all integer points $j$ such that $l_i \le j \le r_i$.

The integer point is called bad if it is covered by strictly more than $k$ segments.

Your task is to remove the minimum number of segments so that there are no bad points at all.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 200$) — the number of segments and the maximum number of segments by which each integer point can be covered.

The next $n$ lines contain segments. The $i$-th line contains two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le 200$) — the endpoints of the $i$-th segment.


-----Output-----

In the first line print one integer $m$ ($0 \le m \le n$) — the minimum number of segments you need to remove so that there are no bad points.

In the second line print $m$ distinct integers $p_1, p_2, \dots, p_m$ ($1 \le p_i \le n$) — indices of segments you remove in any order. If there are multiple answers, you can print any of them.


-----Examples-----
Input
7 2
11 11
9 11
7 8
8 9
7 8
9 11
7 9

Output
3
1 4 7 

Input
5 1
29 30
30 30
29 29
28 30
30 30

Output
3
1 2 4 

Input
6 1
2 3
3 3
2 3
2 2
2 3
2 3

Output
4
1 3 5 6
"""
2022-04-13 21:29:19.330716 --------------------------
2022-04-13 21:31:16.015374 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n\ndef solve(n, k, l, r):\n    # print(n, k, l, r)\n    if n <= 0:\n        return 0, []\n    if k <= 0:\n        return n, list(range(1, n + 1))\n    if k == 1:\n        # print(n, k, l, r)\n        m = 0\n        p = []\n        for i in range(1, n + 1):\n            if l[i] == r[i]:\n                m += 1\n                p.append(i)\n        return m, p\n    m = n\n    p = []\n    for i in range(1, n + 1):\n        if l[i] != r[i]:\n            l1 = l[1: i] + l[i + 1: n + 1]\n            r1 = r[1: i] + r[i + 1: n + 1]\n            m1, p1 = solve(n - 1, k, l1, r1)\n            if m1 + 1 < m:\n                m = m1 + 1\n                p = [i] + p1\n    return m, p\n\n\nn, k = map(int, input().split())\nl = [0]\nr = [0]\nfor i in range(n):\n    l1, r1 = map(int, input().split())\n    l.append(l1)\n    r.append(r1)\nm, p = solve(n, k, l, r)\nprint(m)\nprint(*p)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(tuple(map(int, input().split())))\n\ndef calc_bad_points(segments, k):\n    # O(n^2)\n    # return [i for i in range(1, 201) if len([1 for s in segments if i in range(s[0], s[1]+1)]) > k]\n    # O(nlogn)\n    points = set()\n    for s in segments:\n        for i in range(s[0], s[1]+1):\n            points.add(i)\n    bad_points = set()\n    for p in points:\n        if len([1 for s in segments if p in range(s[0], s[1]+1)]) > k:\n            bad_points.add(p)\n    return bad_points\n\ndef segments_to_remove(segments, k):\n    # O(n^3)\n    # return [i+1 for i in range(len(segments)) if calc_bad_points(segments[:i]+segments[i+1:], k) == set()]\n    # O(n^2)\n    bad_points = calc_bad_points(segments, k)\n    # print(bad_points)\n    segments_to_remove = []\n    for i in range(len(segments)):\n        for p in range(segments[i][0], segments[i][1]+1):\n            if p in bad_points:\n                segments_to_remove.append(i+1)\n                break\n    return segments_to_remove\n\nprint(len(segments_to_remove(segments, k)))\nprint(*segments_to_remove(segments, k))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef solution(n, k, segments):\n\tif k == 1:\n\t\treturn [i for i in range(1, n+1)]\n\n\t# sort the segments by the start point\n\tsegments.sort(key=lambda x: x[0])\n\n\t# initialize the minimum number of segments to remove\n\tmin_num_segments = len(segments)\n\n\t# initialize the start and end points of the first segment\n\tstart = segments[0][0]\n\tend = segments[0][1]\n\n\t# initialize the list of segments to remove\n\tsegments_to_remove = []\n\n\t# for each segment\n\tfor i in range(1, n):\n\t\t# if the current segment is covered by the previous segment(s)\n\t\tif segments[i][0] <= end:\n\t\t\t# if the current segment is completely covered by the previous segment(s)\n\t\t\tif segments[i][1] <= end:\n\t\t\t\t# add the current segment to the list of segments to remove\n\t\t\t\tsegments_to_remove.append(i+1)\n\n\t\t\t# if the current segment is not completely covered by the previous segment(s)\n\t\t\telse:\n\t\t\t\t# update the end point of the previous segment(s)\n\t\t\t\tend = segments[i][1]\n\n\t\t# if the current segment is not covered by the previous segment(s)\n\t\telse:\n\t\t\t# if the number of segments to remove is less than the current minimum number of segments to remove\n\t\t\tif len(segments_to_remove) < min_num_segments:\n\t\t\t\t# update the minimum number of segments to remove\n\t\t\t\tmin_num_segments = len(segments_to_remove)\n\n\t\t\t# reset the start and end points of the previous segment(s)\n\t\t\tstart = segments[i][0]\n\t\t\tend = segments[i][1]\n\n\t\t\t# reset the list of segments to remove\n\t\t\tsegments_to_remove = []\n\n\t# if the number of segments to remove is less than the current minimum number of segments to remove\n\tif len(segments_to_remove) < min_num_segments:\n\t\t# update the minimum number of segments to remove\n\t\tmin_num_segments = len(segments_to_remove)\n\n\treturn segments_to_remove\n\nif __name__ == \"__main__\":\n\tn, k = map(int, sys.stdin.readline().split())\n\tsegments = []\n\tfor i in range(n):\n\t\tsegments.append(tuple(map(int, sys.stdin.readline().split())))\n\n\tsegments_to_remove = solution(n, k, segments)\n\tprint(len(segments_to_remove))\n\tprint(\" \".join(map(str, segments_to_remove)))"
    },
    {
      "finish_reason": "length",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\nn, k = list(map(int, input().split()))\n\nsegments = []\nbad = []\n\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\nfor i in range(n):\n    if segments[i][0] == segments[i][1]:\n        bad.append(i)\n\n#print(segments)\n#print(bad)\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.append(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.append(i)\n\n#print(segments)\n#print(bad)\n\nbad = set(bad)\nsegments = [segments[i] for i in range(n) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print("
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n    n, k = map(int, stdin.readline().strip().split())\n    lr = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        lr.append((l, r))\n    lr = sorted(lr, key=lambda x: x[0])\n    bad = set()\n    for i in range(n):\n        for j in range(lr[i][0], lr[i][1]+1):\n            bad.add(j)\n    res = []\n    for i in range(n):\n        for j in range(lr[i][0], lr[i][1]+1):\n            bad.remove(j)\n        bad.add(lr[i][0])\n        bad.add(lr[i][1])\n        if len(bad) <= k:\n            res.append(i+1)\n            break\n    print(len(res))\n    print(*res)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\n# sort segments by start point\nsegments.sort(key=lambda x: x[0])\n\n# for each segment, if its start point is already covered by more than k segments,\n# then it is not necessary to add it to the covered segments.\n# otherwise, add it to the covered segments.\n# if the number of covered segments is larger than k, remove the segment with the smallest end point.\ncovered = []\nremoved = []\nfor i in range(n):\n    if len(covered) == 0 or covered[-1][1] < segments[i][0]:\n        covered.append(segments[i])\n    else:\n        if len(covered) < k:\n            covered.append(segments[i])\n        else:\n            removed.append(i+1)\n            covered.sort(key=lambda x: x[1])\n            covered.pop(0)\n\nprint(len(removed))\nprint(*removed)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\nn, k = [int(x) for x in input().split()]\n\nsegments = defaultdict(int)\n\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    for j in range(l, r+1):\n        segments[j] += 1\n\nbad_points = [x for x in segments if segments[x] > k]\n\nremove_count = 0\nremove_segments = []\n\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    if any(l <= x <= r for x in bad_points):\n        remove_count += 1\n        remove_segments.append(i+1)\n\nprint(remove_count)\nprint(' '.join([str(x) for x in remove_segments]))"
    }
  ],
  "created": 1649885359,
  "id": "cmpl-4weq7cgZV9ikotovgY1vFwTWJibLo",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:31:16.015845 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n\ndef solve(n, k, l, r):\n    # print(n, k, l, r)\n    if n <= 0:\n        return 0, []\n    if k <= 0:\n        return n, list(range(1, n + 1))\n    if k == 1:\n        # print(n, k, l, r)\n        m = 0\n        p = []\n        for i in range(1, n + 1):\n            if l[i] == r[i]:\n                m += 1\n                p.append(i)\n        return m, p\n    m = n\n    p = []\n    for i in range(1, n + 1):\n        if l[i] != r[i]:\n            l1 = l[1: i] + l[i + 1: n + 1]\n            r1 = r[1: i] + r[i + 1: n + 1]\n            m1, p1 = solve(n - 1, k, l1, r1)\n            if m1 + 1 < m:\n                m = m1 + 1\n                p = [i] + p1\n    return m, p\n\n\nn, k = map(int, input().split())\nl = [0]\nr = [0]\nfor i in range(n):\n    l1, r1 = map(int, input().split())\n    l.append(l1)\n    r.append(r1)\nm, p = solve(n, k, l, r)\nprint(m)\nprint(*p)"
}
2022-04-13 21:31:16.015897 REASON stop
2022-04-13 21:31:16.016317 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(tuple(map(int, input().split())))\n\ndef calc_bad_points(segments, k):\n    # O(n^2)\n    # return [i for i in range(1, 201) if len([1 for s in segments if i in range(s[0], s[1]+1)]) > k]\n    # O(nlogn)\n    points = set()\n    for s in segments:\n        for i in range(s[0], s[1]+1):\n            points.add(i)\n    bad_points = set()\n    for p in points:\n        if len([1 for s in segments if p in range(s[0], s[1]+1)]) > k:\n            bad_points.add(p)\n    return bad_points\n\ndef segments_to_remove(segments, k):\n    # O(n^3)\n    # return [i+1 for i in range(len(segments)) if calc_bad_points(segments[:i]+segments[i+1:], k) == set()]\n    # O(n^2)\n    bad_points = calc_bad_points(segments, k)\n    # print(bad_points)\n    segments_to_remove = []\n    for i in range(len(segments)):\n        for p in range(segments[i][0], segments[i][1]+1):\n            if p in bad_points:\n                segments_to_remove.append(i+1)\n                break\n    return segments_to_remove\n\nprint(len(segments_to_remove(segments, k)))\nprint(*segments_to_remove(segments, k))"
}
2022-04-13 21:31:16.016429 REASON stop
2022-04-13 21:31:16.016816 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef solution(n, k, segments):\n\tif k == 1:\n\t\treturn [i for i in range(1, n+1)]\n\n\t# sort the segments by the start point\n\tsegments.sort(key=lambda x: x[0])\n\n\t# initialize the minimum number of segments to remove\n\tmin_num_segments = len(segments)\n\n\t# initialize the start and end points of the first segment\n\tstart = segments[0][0]\n\tend = segments[0][1]\n\n\t# initialize the list of segments to remove\n\tsegments_to_remove = []\n\n\t# for each segment\n\tfor i in range(1, n):\n\t\t# if the current segment is covered by the previous segment(s)\n\t\tif segments[i][0] <= end:\n\t\t\t# if the current segment is completely covered by the previous segment(s)\n\t\t\tif segments[i][1] <= end:\n\t\t\t\t# add the current segment to the list of segments to remove\n\t\t\t\tsegments_to_remove.append(i+1)\n\n\t\t\t# if the current segment is not completely covered by the previous segment(s)\n\t\t\telse:\n\t\t\t\t# update the end point of the previous segment(s)\n\t\t\t\tend = segments[i][1]\n\n\t\t# if the current segment is not covered by the previous segment(s)\n\t\telse:\n\t\t\t# if the number of segments to remove is less than the current minimum number of segments to remove\n\t\t\tif len(segments_to_remove) < min_num_segments:\n\t\t\t\t# update the minimum number of segments to remove\n\t\t\t\tmin_num_segments = len(segments_to_remove)\n\n\t\t\t# reset the start and end points of the previous segment(s)\n\t\t\tstart = segments[i][0]\n\t\t\tend = segments[i][1]\n\n\t\t\t# reset the list of segments to remove\n\t\t\tsegments_to_remove = []\n\n\t# if the number of segments to remove is less than the current minimum number of segments to remove\n\tif len(segments_to_remove) < min_num_segments:\n\t\t# update the minimum number of segments to remove\n\t\tmin_num_segments = len(segments_to_remove)\n\n\treturn segments_to_remove\n\nif __name__ == \"__main__\":\n\tn, k = map(int, sys.stdin.readline().split())\n\tsegments = []\n\tfor i in range(n):\n\t\tsegments.append(tuple(map(int, sys.stdin.readline().split())))\n\n\tsegments_to_remove = solution(n, k, segments)\n\tprint(len(segments_to_remove))\n\tprint(\" \".join(map(str, segments_to_remove)))"
}
2022-04-13 21:31:16.016888 REASON stop
2022-04-13 21:31:16.034890 3 {
  "finish_reason": "length",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\nn, k = list(map(int, input().split()))\n\nsegments = []\nbad = []\n\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\nfor i in range(n):\n    if segments[i][0] == segments[i][1]:\n        bad.append(i)\n\n#print(segments)\n#print(bad)\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.append(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.append(i)\n\n#print(segments)\n#print(bad)\n\nbad = set(bad)\nsegments = [segments[i] for i in range(n) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print(segments)\n#print(bad)\n\nsegments = [segments[i] for i in range(len(segments)) if i not in bad]\n\n#print(segments)\n#print(bad)\n\nfor i in range(len(segments)):\n    for j in range(i+1, len(segments)):\n        if segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]:\n            bad.add(j)\n        elif segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            bad.add(i)\n\n#print("
}
2022-04-13 21:31:16.035064 REASON length
2022-04-13 21:31:16.035072 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\ndef main():\n    n, k = map(int, stdin.readline().strip().split())\n    lr = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        lr.append((l, r))\n    lr = sorted(lr, key=lambda x: x[0])\n    bad = set()\n    for i in range(n):\n        for j in range(lr[i][0], lr[i][1]+1):\n            bad.add(j)\n    res = []\n    for i in range(n):\n        for j in range(lr[i][0], lr[i][1]+1):\n            bad.remove(j)\n        bad.add(lr[i][0])\n        bad.add(lr[i][1])\n        if len(bad) <= k:\n            res.append(i+1)\n            break\n    print(len(res))\n    print(*res)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:31:16.035113 REASON stop
2022-04-13 21:31:16.051801 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\n# sort segments by start point\nsegments.sort(key=lambda x: x[0])\n\n# for each segment, if its start point is already covered by more than k segments,\n# then it is not necessary to add it to the covered segments.\n# otherwise, add it to the covered segments.\n# if the number of covered segments is larger than k, remove the segment with the smallest end point.\ncovered = []\nremoved = []\nfor i in range(n):\n    if len(covered) == 0 or covered[-1][1] < segments[i][0]:\n        covered.append(segments[i])\n    else:\n        if len(covered) < k:\n            covered.append(segments[i])\n        else:\n            removed.append(i+1)\n            covered.sort(key=lambda x: x[1])\n            covered.pop(0)\n\nprint(len(removed))\nprint(*removed)"
}
2022-04-13 21:31:16.051897 REASON stop
2022-04-13 21:31:16.052805 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\nn, k = [int(x) for x in input().split()]\n\nsegments = defaultdict(int)\n\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    for j in range(l, r+1):\n        segments[j] += 1\n\nbad_points = [x for x in segments if segments[x] > k]\n\nremove_count = 0\nremove_segments = []\n\nfor i in range(n):\n    l, r = [int(x) for x in input().split()]\n    if any(l <= x <= r for x in bad_points):\n        remove_count += 1\n        remove_segments.append(i+1)\n\nprint(remove_count)\nprint(' '.join([str(x) for x in remove_segments]))"
}
2022-04-13 21:31:16.052884 REASON stop
