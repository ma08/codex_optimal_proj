["\n\nimport sys\n\ndef main():\n    # Read input\n    w, h = [int(i) for i in sys.stdin.readline().split()]\n    grid = [list(sys.stdin.readline().strip()) for i in range(h)]\n    # Find player's position\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'P':\n                x, y = i, j\n                break\n\n    # Find all gold pieces\n    gold = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == 'G']\n\n    # Check if gold is safe\n    safe = []\n    for i, j in gold:\n        if i == x:\n            if j == y - 1 or j == y + 1:\n                safe.append((i, j))\n            else:\n                if grid[i][j-1] != 'T' and grid[i][j+1] != 'T':\n                    safe.append((i, j))\n        elif j == y:\n            if i == x - 1 or i == x + 1:\n                safe.append((i, j))\n            else:\n                if grid[i-1][j] != 'T' and grid[i+1][j] != 'T':\n                    safe.append((i, j))\n\n    # Print number of safe gold pieces\n    print(len(safe))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline().split()\n    W = int(input[0])\n    H = int(input[1])\n    map = []\n    for i in range(H):\n        map.append(sys.stdin.readline())\n    print(solve(W, H, map))\n\ndef solve(W, H, map):\n    # find player\n    player = None\n    for i in range(H):\n        for j in range(W):\n            if map[i][j] == 'P':\n                player = (i, j)\n                break\n        if player:\n            break\n    # find gold\n    gold = []\n    for i in range(H):\n        for j in range(W):\n            if map[i][j] == 'G':\n                gold.append((i, j))\n    # find traps\n    traps = []\n    for i in range(H):\n        for j in range(W):\n            if map[i][j] == 'T':\n                traps.append((i, j))\n    # find walls\n    walls = []\n    for i in range(H):\n        for j in range(W):\n            if map[i][j] == '#':\n                walls.append((i, j))\n    # find valid moves\n    moves = []\n    for i in range(H):\n        for j in range(W):\n            if map[i][j] == '.':\n                moves.append((i, j))\n    # find safe moves\n    safe_moves = []\n    for move in moves:\n        if not is_trapped(move, traps, walls):\n            safe_moves.append(move)\n    # find safe gold\n    safe_gold = []\n    for move in safe_moves:\n        for gold_piece in gold:\n            if move == gold_piece:\n                safe_gold.append(gold_piece)\n    return len(safe_gold)\n\ndef is_trapped(move, traps, walls):\n    for trap in traps:\n        if is_adjacent(move, trap, walls):\n            return True\n    return False\n\ndef is_adjacent(move, trap, walls):\n    if move == (trap[0] + 1, trap[1]) or move == (trap[0] - 1, trap[1]) or move == (trap[0], trap[1] + 1) or move == (trap[0], trap[1] - 1):\n        if (move[0], move[1]) in walls:\n            return False\n        return True\n    return False\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport random\n\ndef get_input(case=0):\n    '''\n    Returns the input as specified by the problem description.\n    \"case\" can be any integer. This can be used to specify which\n    input to return.\n    '''\n    if case == 0:\n        lines = ['7 4', '#######', '#P.GTG#', '#..TGG#', '#######']\n        return '\\n'.join(lines)\n    elif case == 1:\n        lines = ['7 4', '#######', '#P.GTG#', '#..TGG#', '#######']\n        return '\\n'.join(lines)\n    elif case == 2:\n        lines = ['7 4', '#######', '#P.GTG#', '#..TGG#', '#######']\n        return '\\n'.join(lines)\n    else:\n        lines = ['7 4', '#######', '#P.GTG#', '#..TGG#', '#######']\n        return '\\n'.join(lines)\n\ndef give_input():\n    '''\n    Reads input from stdin and returns the input as a string.\n    '''\n    lines = []\n    for line in sys.stdin:\n        lines.append(line)\n    return ''.join(lines)\n\ndef to_grid(s):\n    '''\n    Converts a string to a grid.\n    '''\n    lines = s.splitlines()\n    lines = [line for line in lines if line]\n    width, height = [int(i) for i in lines[0].split()]\n    grid = []\n    for line in lines[1:]:\n        grid.append([c for c in line])\n    return grid, width, height\n\ndef print_grid(grid, width, height):\n    '''\n    Prints a grid.\n    '''\n    for y in range(height):\n        for x in range(width):\n            print(grid[y][x], end='')\n        print()\n\ndef get_player_position(grid, width, height):\n    '''\n    Returns the player's position as a tuple (x, y).\n    '''\n    for y in range(height):\n        for x in range(width):\n            if grid[y][x] == 'P':\n                return x, y\n\ndef get_gold_positions(grid, width, height):\n    '''\n    Returns a list of tuples (x, y) where the gold is.\n    '''\n    gold = []\n    for y in range(height):\n        for x in range(width):\n            if grid[y][x] == 'G':\n                gold.append((x, y))\n    return gold\n\ndef get_trap_positions(grid, width, height):\n    '''\n    Returns a list of tuples (x, y) where the traps are.\n    '''\n    traps = []\n    for y in range(height):\n        for x in range(width):\n            if grid[y][x] == 'T':\n                traps.append((x, y))\n    return traps\n\ndef get_neighbours(x, y, width, height):\n    '''\n    Returns a list of tuples (x, y) of the neighbours of (x, y).\n    '''\n    neighbours = []\n    if x > 0:\n        neighbours.append((x-1, y))\n    if x < width-1:\n        neighbours.append((x+1, y))\n    if y > 0:\n        neighbours.append((x, y-1))\n    if y < height-1:\n        neighbours.append((x, y+1))\n    return neighbours\n\ndef get_safe_gold_positions(grid, width, height):\n    '''\n    Returns a list of tuples (x, y) where the safe gold is.\n    '''\n    safe_gold = []\n    for y in range(height):\n        for x in range(width):\n            if grid[y][x] == 'G':\n                if is_safe(grid, x, y, width, height):\n                    safe_gold.append((x, y))\n    return safe_gold\n\ndef is_safe(grid, x, y, width, height):\n    '''\n    Returns True if the given position is safe, False otherwise.\n    '''\n    neighbours = get_neighbours(x, y, width, height)\n    for n in neighbours:\n        if grid[n[1]][n[0]] == 'T':\n            return False\n    return True\n\ndef get_safe_gold(grid, width, height):\n    '''\n    Returns the number of pieces of safe gold.\n    '''\n    return len(get_safe_gold_positions(grid, width, height))\n\ndef solve(s):\n    '''\n    Returns the solution to the problem.\n    '''\n    grid, width, height = to_grid(s)\n    return get_safe_gold(grid, width, height)\n\ndef main():\n    '''\n    Parses input and runs the program.\n    '''\n    s = give_input()\n    print(solve(s))\n\nif __name__ == '__main__':\n    main()", "\n\nclass Game:\n    def __init__(self, map):\n        self.map = map\n        self.player = None\n        self.width = len(map[0])\n        self.height = len(map)\n\n        for i in range(self.height):\n            for j in range(self.width):\n                if map[i][j] == \"P\":\n                    self.player = (i, j)\n                    break\n\n    def gold_count(self):\n        count = 0\n\n        for i in range(self.height):\n            for j in range(self.width):\n                if self.map[i][j] == \"G\":\n                    count += 1\n\n        return count\n\n    def neighbors(self, i, j):\n        return [\n            (i, j + 1),\n            (i, j - 1),\n            (i + 1, j),\n            (i - 1, j)\n        ]\n\n    def safe_neighbors(self, i, j):\n        return [\n            (i, j + 1),\n            (i, j - 1),\n            (i + 1, j),\n            (i - 1, j)\n        ]\n\n    def get_max_gold(self):\n        return self.gold_count()\n\n\ndef main():\n    w, h = [int(x) for x in input().split()]\n    map = [input() for _ in range(h)]\n    game = Game(map)\n    print(game.get_max_gold())\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef search(x, y):\n    global w, h, g\n    if x < 0 or x >= w or y < 0 or y >= h:\n        return\n    if g[y][x] == '#' or g[y][x] == 'G':\n        return\n    g[y][x] = '#'\n    if g[y][x] == 'T':\n        return\n    search(x-1, y)\n    search(x+1, y)\n    search(x, y-1)\n    search(x, y+1)\n\nw, h = map(int, input().split())\ng = []\nfor i in range(h):\n    g.append(list(input()))\n\nx = y = -1\nfor i in range(h):\n    for j in range(w):\n        if g[i][j] == 'P':\n            x = j\n            y = i\n            break\n\nsearch(x, y)\n\ncount = 0\nfor i in range(h):\n    for j in range(w):\n        if g[i][j] == 'G':\n            count += 1\n\nprint(count)"]