2022-04-13 22:15:32.092214 """
There is a bookshelf which can fit $n$ books. The $i$-th position of bookshelf is $a_i = 1$ if there is a book on this position and $a_i = 0$ otherwise. It is guaranteed that there is at least one book on the bookshelf.

In one move, you can choose some contiguous segment $[l; r]$ consisting of books (i.e. for each $i$ from $l$ to $r$ the condition $a_i = 1$ holds) and:  Shift it to the right by $1$: move the book at index $i$ to $i + 1$ for all $l \le i \le r$. This move can be done only if $r+1 \le n$ and there is no book at the position $r+1$.  Shift it to the left by $1$: move the book at index $i$ to $i-1$ for all $l \le i \le r$. This move can be done only if $l-1 \ge 1$ and there is no book at the position $l-1$. 

Your task is to find the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment (i.e. the segment without any gaps).

For example, for $a = [0, 0, 1, 0, 1]$ there is a gap between books ($a_4 = 0$ when $a_3 = 1$ and $a_5 = 1$), for $a = [1, 1, 0]$ there are no gaps between books and for $a = [0, 0,0]$ there are also no gaps between books.

You have to answer $t$ independent test cases.


-----Input-----

The first line of the input contains one integer $t$ ($1 \le t \le 200$) — the number of test cases. Then $t$ test cases follow.

The first line of the test case contains one integer $n$ ($1 \le n \le 50$) — the number of places on a bookshelf. The second line of the test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 1$), where $a_i$ is $1$ if there is a book at this position and $0$ otherwise. It is guaranteed that there is at least one book on the bookshelf.


-----Output-----

For each test case, print one integer: the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment (i.e. the segment without gaps).


-----Example-----
Input
5
7
0 0 1 0 1 0 1
3
1 0 0
5
1 1 0 0 1
6
1 0 0 0 0 1
5
1 1 0 1 1

Output
2
0
2
4
1



-----Note-----

In the first test case of the example, you can shift the segment $[3; 3]$ to the right and the segment $[4; 5]$ to the right. After all moves, the books form the contiguous segment $[5; 7]$. So the answer is $2$.

In the second test case of the example, you have nothing to do, all the books on the bookshelf form the contiguous segment already.

In the third test case of the example, you can shift the segment $[5; 5]$ to the left and then the segment $[4; 4]$ to the left again. After all moves, the books form the contiguous segment $[1; 3]$. So the answer is $2$.

In the fourth test case of the example, you can shift the segment $[1; 1]$ to the right, the segment $[2; 2]$ to the right, the segment $[6; 6]$ to the left and then the segment $[5; 5]$ to the left. After all moves, the books form the contiguous segment $[3; 4]$. So the answer is $4$.

In the fifth test case of the example, you can shift the segment $[1; 2]$ to the right. After all moves, the books form the contiguous segment $[2; 5]$. So the answer is $1$.
"""
2022-04-13 22:15:32.092231 --------------------------
2022-04-13 22:16:04.768384 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# This problem can be solved using the sliding window technique.\n# We can find the minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# by finding the minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# starting from the leftmost book, and the minimum number of moves required to collect all the books on the shelf\n# as a contiguous segment starting from the rightmost book.\n# The minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# is the minimum of these two quantities.\n\n# The minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# starting from the leftmost book can be found by iterating through the array from left to right,\n# and maintaining a variable l that stores the index of the leftmost book in the current contiguous segment.\n# The minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# starting from the rightmost book can be found by iterating through the array from right to left,\n# and maintaining a variable r that stores the index of the rightmost book in the current contiguous segment.\n\n# Time complexity: O(n)\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    l = 0\n    r = n - 1\n\n    while l < n and a[l] == 0:\n        l += 1\n\n    while r >= 0 and a[r] == 0:\n        r -= 1\n\n    l_ans = l\n    r_ans = n - r - 1\n\n    for i in range(l, n):\n        if a[i] == 1:\n            l_ans = max(l_ans, i - l)\n        else:\n            l = i + 1\n\n    for i in range(r, -1, -1):\n        if a[i] == 1:\n            r_ans = max(r_ans, r - i)\n        else:\n            r = i - 1\n\n    print(min(l_ans, r_ans))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# cook your dish here\nimport sys\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    c=0\n    for i in range(n):\n        if a[i]==0:\n            c+=1\n        else:\n            break\n    for i in range(n-1,-1,-1):\n        if a[i]==0:\n            c+=1\n        else:\n            break\n    print(c)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int,input().split()))\n        if a.count(1) == 1:\n            print(0)\n            continue\n        a_str = \"\".join(map(str,a))\n        a_str = a_str.split(\"1\")\n        a_str = [x for x in a_str if x != \"\"]\n        if a_str == []:\n            print(0)\n            continue\n        else:\n            a_str = [len(x) for x in a_str]\n            print(max(a_str))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef min_moves(arr):\n    i = 0\n    n = len(arr)\n    while i < n and arr[i] == 0:\n        i += 1\n    j = n - 1\n    while j >= 0 and arr[j] == 0:\n        j -= 1\n    return n - (j - i + 1)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(min_moves(arr))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef min_moves(a):\n    \"\"\"\n    Find the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment.\n    \"\"\"\n    \n    # Find the number of gaps between books.\n    gaps = 0\n    for i in range(len(a) - 1):\n        if a[i] == 1 and a[i + 1] == 0:\n            gaps += 1\n    \n    # If there is no gap between books, return 0.\n    if gaps == 0:\n        return 0\n    \n    # Calculate the minimum number of moves.\n    return gaps - 1\n\nif __name__ == \"__main__\":\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n = int(sys.stdin.readline())\n        a = list(map(int, sys.stdin.readline().split()))\n        print(min_moves(a))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        s = []\n        for i in range(n):\n            if a[i] == 1:\n                s.append(i)\n        if len(s) == 1:\n            print(0)\n        else:\n            print(s[-1] - s[0] - len(s) + 1)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        print(solve(n, a))\n\ndef solve(n, a):\n    left = right = 0\n    while a[left] == 0:\n        left += 1\n    while a[right] == 0:\n        right += 1\n    res = 0\n    while right < n:\n        if a[right] == 0:\n            if a[right + 1] == 0:\n                res += 1\n            else:\n                right += 1\n            res += 1\n        else:\n            right += 1\n    while left > 0:\n        if a[left] == 0:\n            if a[left - 1] == 0:\n                res += 1\n            else:\n                left -= 1\n            res += 1\n        else:\n            left -= 1\n    return res\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649888132,
  "id": "cmpl-4wfYq8gn99Q3Bm6azf21ZyRv4BSFZ",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 22:16:04.768736 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# This problem can be solved using the sliding window technique.\n# We can find the minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# by finding the minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# starting from the leftmost book, and the minimum number of moves required to collect all the books on the shelf\n# as a contiguous segment starting from the rightmost book.\n# The minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# is the minimum of these two quantities.\n\n# The minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# starting from the leftmost book can be found by iterating through the array from left to right,\n# and maintaining a variable l that stores the index of the leftmost book in the current contiguous segment.\n# The minimum number of moves required to collect all the books on the shelf as a contiguous segment\n# starting from the rightmost book can be found by iterating through the array from right to left,\n# and maintaining a variable r that stores the index of the rightmost book in the current contiguous segment.\n\n# Time complexity: O(n)\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    l = 0\n    r = n - 1\n\n    while l < n and a[l] == 0:\n        l += 1\n\n    while r >= 0 and a[r] == 0:\n        r -= 1\n\n    l_ans = l\n    r_ans = n - r - 1\n\n    for i in range(l, n):\n        if a[i] == 1:\n            l_ans = max(l_ans, i - l)\n        else:\n            l = i + 1\n\n    for i in range(r, -1, -1):\n        if a[i] == 1:\n            r_ans = max(r_ans, r - i)\n        else:\n            r = i - 1\n\n    print(min(l_ans, r_ans))"
}
2022-04-13 22:16:04.768787 REASON stop
2022-04-13 22:16:04.769175 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# cook your dish here\nimport sys\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    c=0\n    for i in range(n):\n        if a[i]==0:\n            c+=1\n        else:\n            break\n    for i in range(n-1,-1,-1):\n        if a[i]==0:\n            c+=1\n        else:\n            break\n    print(c)"
}
2022-04-13 22:16:04.769285 REASON stop
2022-04-13 22:16:04.769712 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int,input().split()))\n        if a.count(1) == 1:\n            print(0)\n            continue\n        a_str = \"\".join(map(str,a))\n        a_str = a_str.split(\"1\")\n        a_str = [x for x in a_str if x != \"\"]\n        if a_str == []:\n            print(0)\n            continue\n        else:\n            a_str = [len(x) for x in a_str]\n            print(max(a_str))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:16:04.769765 REASON stop
2022-04-13 22:16:04.789344 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef min_moves(arr):\n    i = 0\n    n = len(arr)\n    while i < n and arr[i] == 0:\n        i += 1\n    j = n - 1\n    while j >= 0 and arr[j] == 0:\n        j -= 1\n    return n - (j - i + 1)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(min_moves(arr))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 22:16:04.789461 REASON stop
2022-04-13 22:16:04.799509 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef min_moves(a):\n    \"\"\"\n    Find the minimum number of moves required to collect all the books on the shelf as a contiguous (consecutive) segment.\n    \"\"\"\n    \n    # Find the number of gaps between books.\n    gaps = 0\n    for i in range(len(a) - 1):\n        if a[i] == 1 and a[i + 1] == 0:\n            gaps += 1\n    \n    # If there is no gap between books, return 0.\n    if gaps == 0:\n        return 0\n    \n    # Calculate the minimum number of moves.\n    return gaps - 1\n\nif __name__ == \"__main__\":\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n = int(sys.stdin.readline())\n        a = list(map(int, sys.stdin.readline().split()))\n        print(min_moves(a))"
}
2022-04-13 22:16:04.799630 REASON stop
2022-04-13 22:16:04.800628 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        s = []\n        for i in range(n):\n            if a[i] == 1:\n                s.append(i)\n        if len(s) == 1:\n            print(0)\n        else:\n            print(s[-1] - s[0] - len(s) + 1)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:16:04.800693 REASON stop
2022-04-13 22:16:04.801302 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        print(solve(n, a))\n\ndef solve(n, a):\n    left = right = 0\n    while a[left] == 0:\n        left += 1\n    while a[right] == 0:\n        right += 1\n    res = 0\n    while right < n:\n        if a[right] == 0:\n            if a[right + 1] == 0:\n                res += 1\n            else:\n                right += 1\n            res += 1\n        else:\n            right += 1\n    while left > 0:\n        if a[left] == 0:\n            if a[left - 1] == 0:\n                res += 1\n            else:\n                left -= 1\n            res += 1\n        else:\n            left -= 1\n    return res\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 22:16:04.801379 REASON stop
