2022-04-13 21:31:37.128871 """
You are given a weighted tree consisting of $n$ vertices. Recall that a tree is a connected graph without cycles. Vertices $u_i$ and $v_i$ are connected by an edge with weight $w_i$.

You are given $m$ queries. The $i$-th query is given as an integer $q_i$. In this query you need to calculate the number of pairs of vertices $(u, v)$ ($u < v$) such that the maximum weight of an edge on a simple path between $u$ and $v$ doesn't exceed $q_i$.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 2 \cdot 10^5$) — the number of vertices in the tree and the number of queries.

Each of the next $n - 1$ lines describes an edge of the tree. Edge $i$ is denoted by three integers $u_i$, $v_i$ and $w_i$ — the labels of vertices it connects ($1 \le u_i, v_i \le n$, $u_i \ne v_i$) and the weight of the edge ($1 \le w_i \le 2 \cdot 10^5$). It is guaranteed that the given edges form a tree.

The last line of the input contains $m$ integers $q_1, q_2, \dots, q_m$ ($1 \le q_i \le 2 \cdot 10^5$), where $q_i$ is the maximum weight of an edge in the $i$-th query.


-----Output-----

Print $m$ integers — the answers to the queries. The $i$-th value should be equal to the number of pairs of vertices $(u, v)$ ($u < v$) such that the maximum weight of an edge on a simple path between $u$ and $v$ doesn't exceed $q_i$.

Queries are numbered from $1$ to $m$ in the order of the input.


-----Examples-----
Input
7 5
1 2 1
3 2 3
2 4 1
4 5 2
5 7 4
3 6 2
5 2 3 4 1

Output
21 7 15 21 3 

Input
1 2
1 2

Output
0 0 

Input
3 3
1 2 1
2 3 2
1 3 2

Output
1 3 3 



-----Note-----

The picture shows the tree from the first example: [Image]
"""
2022-04-13 21:31:37.128885 --------------------------
2022-04-13 21:33:37.086047 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# ----- Solution -----\n\ndef dfs(v, p):\n    global arr, ans, dp, n, m\n    dp[v][0] = 1\n    dp[v][1] = 1\n    for i in range(0, len(arr[v])):\n        if arr[v][i][0] != p:\n            dfs(arr[v][i][0], v)\n            dp[v][0] += dp[arr[v][i][0]][1]\n            dp[v][1] += dp[arr[v][i][0]][0]\n    for i in range(0, m):\n        if arr[v][i][1] <= q[i]:\n            ans[i] += dp[v][0]\n        else:\n            ans[i] += dp[v][1]\n\nn, m = map(int, input().split())\nq = list(map(int, input().split()))\narr = [[] for i in range(n + 1)]\ndp = [[0 for i in range(2)] for i in range(n + 1)]\nans = [0 for i in range(m)]\nfor i in range(n - 1):\n    a, b, c = map(int, input().split())\n    arr[a].append([b, c])\n    arr[b].append([a, c])\ndfs(1, 0)\nprint(*ans)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\nclass Node:\n    def __init__(self, val, weight):\n        self.val = val\n        self.weight = weight\n        self.children = []\n        self.max_weight = 0\n        self.max_pair = 0\n        self.max_pair_weight = 0\n        self.max_pair_count = 0\n        self.max_pair_count_weight = 0\n        self.max_pair_count_weight_weight = 0\n\n\ndef dfs(node):\n    for child in node.children:\n        dfs(child)\n        node.max_weight = max(node.max_weight, child.max_weight)\n        node.max_pair = max(node.max_pair, child.max_pair + 1)\n        node.max_pair_weight = max(node.max_pair_weight, child.max_pair_weight + child.weight)\n        node.max_pair_count = max(node.max_pair_count, child.max_pair_count + 1)\n        node.max_pair_count_weight = max(node.max_pair_count_weight, child.max_pair_count_weight + child.weight)\n        node.max_pair_count_weight_weight = max(node.max_pair_count_weight_weight, child.max_pair_count_weight_weight + child.weight)\n    if node.max_pair == 0:\n        node.max_pair = 1\n        node.max_pair_weight = node.weight\n    if node.max_pair_count == 0:\n        node.max_pair_count = 1\n        node.max_pair_count_weight = node.weight\n\n\ndef calc(node, q):\n    count = 0\n    for child in node.children:\n        if child.max_weight <= q:\n            count += calc(child, q)\n    if node.max_pair_weight <= q:\n        count += node.max_pair\n    if node.max_pair_count_weight <= q:\n        count += node.max_pair_count * (node.max_pair_count - 1) // 2\n    if node.max_pair_count_weight_weight <= q:\n        count += node.max_pair_count * (node.max_pair_count - 1) // 2\n    return count\n\n\nn, m = map(int, input().split())\nnodes = [Node(i, 0) for i in range(n)]\nfor i in range(n - 1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    nodes[u].children.append(nodes[v])\n    nodes[v].children.append(nodes[u])\n    nodes[u].weight = w\n    nodes[v].weight = w\ndfs(nodes[0])\nq = list(map(int, input().split()))\nfor i in range(m):\n    print(calc(nodes[0], q[i]))"
    },
    {
      "finish_reason": "length",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n#  IkaLog\n#  ======\n#  Copyright (C) 2015 Takeshi HASEGAWA\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport sys\nimport time\n\nimport cv2\nimport numpy as np\n\nfrom ikalog.utils import *\n\n\nclass IkaUtils(object):\n\n    def __init__(self, debug=False):\n        self.debug = debug\n        self.enabled = True\n        self.engine = None\n        self.last_matched_scene = None\n        self.last_matched_msec = 0\n\n    def _match_template_all(self, img_rgb, template, threshold,\n                            return_score=False, debug=False):\n        result = cv2.matchTemplate(img_rgb, template, cv2.TM_CCOEFF_NORMED)\n        result[result < threshold] = 0\n        result = result.astype(np.float32)\n\n        if return_score:\n            return result\n        else:\n            loc = np.where(result >= threshold)\n            return zip(*loc[::-1])\n\n    def match_template_all(self, img_rgb, template, threshold,\n                           return_score=False, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % template)\n\n        t1 = time.time()\n        result = self._match_template_all(img_rgb, template, threshold,\n                                          return_score=return_score,\n                                          debug=debug)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, template, result))\n\n        return result\n\n    def match_template(self, img_rgb, template, threshold,\n                       return_score=False, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % template)\n\n        t1 = time.time()\n        result = self._match_template_all(img_rgb, template, threshold,\n                                          return_score=return_score,\n                                          debug=debug)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, template, result))\n\n        if len(result) == 0:\n            return None\n        else:\n            return result[0]\n\n    def match_scene(self, img_rgb, scene_name, threshold=0.9, debug=False):\n        if not self.enabled:\n            return None\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score(img_rgb, scene_name)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return None\n        else:\n            if result['score'] < threshold:\n                return None\n            else:\n                self.last_matched_scene = scene_name\n                self.last_matched_msec = self.engine.msec\n\n                return result['rect']\n\n    def match_scene_all(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return []\n        else:\n            return result\n\n    def match_text(self, img_rgb, tpl_name, threshold=0.9, debug=False):\n        if not self.enabled:\n            return None\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % tpl_name)\n\n        t1 = time.time()\n        result = self.engine.get_text_score(img_rgb, tpl_name)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, tpl_name, result))\n\n        if result is None:\n            return None\n        else:\n            if result['score'] < threshold:\n                return None\n            else:\n                self.last_matched_scene = tpl_name\n                self.last_matched_msec = self.engine.msec\n\n                return result['rect']\n\n    def match_text_all(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_text_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return []\n        else:\n            return result\n\n    def match_any(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return None\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return None\n        else:\n            if result['score'] < threshold:\n                return None\n            else:\n                self.last_matched_scene = scene_name\n                self.last_matched_msec = self.engine.msec\n\n                return result['rect']\n\n    def match_any_all(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return []\n        else:\n            return result\n\n    def match_game_over(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_over', threshold=threshold,\n                                debug=debug)\n\n    def match_game_session_end_splatnet(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_end_splatnet',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_end(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_end', threshold=threshold,\n                                debug=debug)\n\n    def match_game_session_start(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_start',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_2(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_2',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_3(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_3',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_4(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_4',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_5(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_5',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_6(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_6',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_7(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_7',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_8(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_8',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_9(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_9',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_10(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_10',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_11(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_11',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_12(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_12',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_13(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_13',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_14(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_14',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_15(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_15',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_16(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_16',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_17(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_17',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_18(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_18',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_19(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_19',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_20(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_20',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_21(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_21',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_22(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_22',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_23(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_23',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_24(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_24',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_25(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_25',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_26(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_26',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_27(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_27',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_28(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_28',\n                                threshold=threshold, debug=debug)\n\n    def match_game"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\nimport sys\n\ndef readline_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef readline_int():\n    return int(sys.stdin.readline())\n\ndef read_input():\n    n, m = readline_ints()\n    edges = []\n    for _ in range(n - 1):\n        edges.append(readline_ints())\n    queries = readline_ints()\n    return n, m, edges, queries\n\n\ndef solve(n, edges, queries):\n    from collections import defaultdict\n    from itertools import combinations\n    \n    # build a graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # compute all pairwise distances\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n        stack = [(i, 0)]\n        while stack:\n            u, d = stack.pop()\n            for v, w in graph[u]:\n                if dist[i][v] > d + w:\n                    dist[i][v] = d + w\n                    stack.append((v, d + w))\n    \n    # find all pairs of vertices\n    pairs = list(combinations(range(n), 2))\n    \n    # solve the queries\n    for q in queries:\n        yield sum(dist[i][j] <= q for i, j in pairs)\n\n\ndef main():\n    n, m, edges, queries = read_input()\n    for result in solve(n, edges, queries):\n        print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\nimport sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, arr, func):\n        self.n = len(arr)\n        self.size = 2**(self.n-1).bit_length()\n        self.func = func\n        self.default = self.func(0,0)\n        self.data = [self.default]*(2*self.size)\n        self.data[self.size : self.size+self.n] = arr\n        for i in range(self.size-1, 0, -1):\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        res = self.default\n        while l < r:\n            if l&1:\n                res = self.func(res, self.data[l])\n                l += 1\n            if r&1:\n                res = self.func(res, self.data[r-1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def update(self, i, x):\n        i += self.size\n        self.data[i] = x\n        i >>= 1\n        while i:\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n            i >>= 1\n\n\ndef dfs(v, p, g, dep, dp):\n    dp[v] = dep\n    for u in g[v]:\n        if u == p:\n            continue\n        dfs(u, v, g, dep+1, dp)\n\ndef solve(n, q, g, dep, dp):\n    dfs(0, -1, g, 0, dp)\n    st = SegmentTree(dp, max)\n    ans = [0]*n\n    for i in range(n):\n        ans[i] = st.query(0, i)\n    return ans\n\ndef main():\n    n, m = map(int, input().split())\n    g = [[] for i in range(n)]\n    for i in range(n-1):\n        u, v, w = map(int, input().split())\n        g[u-1].append((v-1, w))\n        g[v-1].append((u-1, w))\n    q = list(map(int, input().split()))\n    dep = [0]*n\n    dp = [0]*n\n    ans = solve(n, q, g, dep, dp)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\n\ndef solve(adj_list, n, q_list):\n    # set up a heap of (weight, (node1, node2))\n    edge_heap = []\n    for node1 in adj_list:\n        for node2 in adj_list[node1]:\n            edge_heap.append((adj_list[node1][node2], (node1, node2)))\n    heapq.heapify(edge_heap)\n\n    # set up a union find structure\n    parent = [i for i in range(n+1)]\n    size = [1 for i in range(n+1)]\n\n    # iterate through queries and edges\n    answer_list = []\n    for q in q_list:\n        while edge_heap and edge_heap[0][0] <= q:\n            weight, (node1, node2) = heapq.heappop(edge_heap)\n            union(node1, node2, parent, size)\n\n        answer_list.append(n*(n-1)//2 - sum(size[1:]))\n\n    return answer_list\n\ndef union(node1, node2, parent, size):\n    p1 = find(node1, parent)\n    p2 = find(node2, parent)\n    if p1 != p2:\n        if size[p1] > size[p2]:\n            size[p1] += size[p2]\n            parent[p2] = p1\n        else:\n            size[p2] += size[p1]\n            parent[p1] = p2\n\ndef find(node, parent):\n    if parent[node] != node:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef main():\n    # parse input\n    n, m = map(int, sys.stdin.readline().split())\n    adj_list = {}\n    for i in range(1, n+1):\n        adj_list[i] = {}\n    for i in range(n-1):\n        node1, node2, weight = map(int, sys.stdin.readline().split())\n        adj_list[node1][node2] = weight\n        adj_list[node2][node1] = weight\n    q_list = list(map(int, sys.stdin.readline().split()))\n\n    # solve problem\n    answer_list = solve(adj_list, n, q_list)\n\n    # print answer\n    for answer in answer_list:\n        print(answer)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    This function will be run when you hit Run.\n    \"\"\"\n    print('Hello World')\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1649885497,
  "id": "cmpl-4wesLzoLkeZiDs5Djzonf0TeBLWxZ",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-13 21:33:37.086521 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# ----- Solution -----\n\ndef dfs(v, p):\n    global arr, ans, dp, n, m\n    dp[v][0] = 1\n    dp[v][1] = 1\n    for i in range(0, len(arr[v])):\n        if arr[v][i][0] != p:\n            dfs(arr[v][i][0], v)\n            dp[v][0] += dp[arr[v][i][0]][1]\n            dp[v][1] += dp[arr[v][i][0]][0]\n    for i in range(0, m):\n        if arr[v][i][1] <= q[i]:\n            ans[i] += dp[v][0]\n        else:\n            ans[i] += dp[v][1]\n\nn, m = map(int, input().split())\nq = list(map(int, input().split()))\narr = [[] for i in range(n + 1)]\ndp = [[0 for i in range(2)] for i in range(n + 1)]\nans = [0 for i in range(m)]\nfor i in range(n - 1):\n    a, b, c = map(int, input().split())\n    arr[a].append([b, c])\n    arr[b].append([a, c])\ndfs(1, 0)\nprint(*ans)"
}
2022-04-13 21:33:37.086568 REASON stop
2022-04-13 21:33:37.086958 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\nclass Node:\n    def __init__(self, val, weight):\n        self.val = val\n        self.weight = weight\n        self.children = []\n        self.max_weight = 0\n        self.max_pair = 0\n        self.max_pair_weight = 0\n        self.max_pair_count = 0\n        self.max_pair_count_weight = 0\n        self.max_pair_count_weight_weight = 0\n\n\ndef dfs(node):\n    for child in node.children:\n        dfs(child)\n        node.max_weight = max(node.max_weight, child.max_weight)\n        node.max_pair = max(node.max_pair, child.max_pair + 1)\n        node.max_pair_weight = max(node.max_pair_weight, child.max_pair_weight + child.weight)\n        node.max_pair_count = max(node.max_pair_count, child.max_pair_count + 1)\n        node.max_pair_count_weight = max(node.max_pair_count_weight, child.max_pair_count_weight + child.weight)\n        node.max_pair_count_weight_weight = max(node.max_pair_count_weight_weight, child.max_pair_count_weight_weight + child.weight)\n    if node.max_pair == 0:\n        node.max_pair = 1\n        node.max_pair_weight = node.weight\n    if node.max_pair_count == 0:\n        node.max_pair_count = 1\n        node.max_pair_count_weight = node.weight\n\n\ndef calc(node, q):\n    count = 0\n    for child in node.children:\n        if child.max_weight <= q:\n            count += calc(child, q)\n    if node.max_pair_weight <= q:\n        count += node.max_pair\n    if node.max_pair_count_weight <= q:\n        count += node.max_pair_count * (node.max_pair_count - 1) // 2\n    if node.max_pair_count_weight_weight <= q:\n        count += node.max_pair_count * (node.max_pair_count - 1) // 2\n    return count\n\n\nn, m = map(int, input().split())\nnodes = [Node(i, 0) for i in range(n)]\nfor i in range(n - 1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    nodes[u].children.append(nodes[v])\n    nodes[v].children.append(nodes[u])\n    nodes[u].weight = w\n    nodes[v].weight = w\ndfs(nodes[0])\nq = list(map(int, input().split()))\nfor i in range(m):\n    print(calc(nodes[0], q[i]))"
}
2022-04-13 21:33:37.087067 REASON stop
2022-04-13 21:33:37.087474 2 {
  "finish_reason": "length",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n#  IkaLog\n#  ======\n#  Copyright (C) 2015 Takeshi HASEGAWA\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#\nimport sys\nimport time\n\nimport cv2\nimport numpy as np\n\nfrom ikalog.utils import *\n\n\nclass IkaUtils(object):\n\n    def __init__(self, debug=False):\n        self.debug = debug\n        self.enabled = True\n        self.engine = None\n        self.last_matched_scene = None\n        self.last_matched_msec = 0\n\n    def _match_template_all(self, img_rgb, template, threshold,\n                            return_score=False, debug=False):\n        result = cv2.matchTemplate(img_rgb, template, cv2.TM_CCOEFF_NORMED)\n        result[result < threshold] = 0\n        result = result.astype(np.float32)\n\n        if return_score:\n            return result\n        else:\n            loc = np.where(result >= threshold)\n            return zip(*loc[::-1])\n\n    def match_template_all(self, img_rgb, template, threshold,\n                           return_score=False, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % template)\n\n        t1 = time.time()\n        result = self._match_template_all(img_rgb, template, threshold,\n                                          return_score=return_score,\n                                          debug=debug)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, template, result))\n\n        return result\n\n    def match_template(self, img_rgb, template, threshold,\n                       return_score=False, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % template)\n\n        t1 = time.time()\n        result = self._match_template_all(img_rgb, template, threshold,\n                                          return_score=return_score,\n                                          debug=debug)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, template, result))\n\n        if len(result) == 0:\n            return None\n        else:\n            return result[0]\n\n    def match_scene(self, img_rgb, scene_name, threshold=0.9, debug=False):\n        if not self.enabled:\n            return None\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score(img_rgb, scene_name)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return None\n        else:\n            if result['score'] < threshold:\n                return None\n            else:\n                self.last_matched_scene = scene_name\n                self.last_matched_msec = self.engine.msec\n\n                return result['rect']\n\n    def match_scene_all(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return []\n        else:\n            return result\n\n    def match_text(self, img_rgb, tpl_name, threshold=0.9, debug=False):\n        if not self.enabled:\n            return None\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % tpl_name)\n\n        t1 = time.time()\n        result = self.engine.get_text_score(img_rgb, tpl_name)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, tpl_name, result))\n\n        if result is None:\n            return None\n        else:\n            if result['score'] < threshold:\n                return None\n            else:\n                self.last_matched_scene = tpl_name\n                self.last_matched_msec = self.engine.msec\n\n                return result['rect']\n\n    def match_text_all(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_text_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return []\n        else:\n            return result\n\n    def match_any(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return None\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return None\n        else:\n            if result['score'] < threshold:\n                return None\n            else:\n                self.last_matched_scene = scene_name\n                self.last_matched_msec = self.engine.msec\n\n                return result['rect']\n\n    def match_any_all(self, img_rgb, threshold=0.9, debug=False):\n        if not self.enabled:\n            return []\n\n        if debug:\n            self.engine.dump_object(img_rgb, '%s_input.png' % scene_name)\n\n        t1 = time.time()\n        result = self.engine.get_scene_score_all(img_rgb)\n        t2 = time.time()\n        self.engine.debug_log('%s: %s %s' % (t2 - t1, scene_name, result))\n\n        if result is None:\n            return []\n        else:\n            return result\n\n    def match_game_over(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_over', threshold=threshold,\n                                debug=debug)\n\n    def match_game_session_end_splatnet(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_end_splatnet',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_end(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_end', threshold=threshold,\n                                debug=debug)\n\n    def match_game_session_start(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_start',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_2(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_2',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_3(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_3',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_4(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_4',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_5(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_5',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_6(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_6',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_7(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_7',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_8(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_8',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_9(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_9',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_10(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_10',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_11(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_11',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_12(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_12',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_13(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_13',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_14(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_14',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_15(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_15',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_16(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_16',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_17(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_17',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_18(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_18',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_19(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_19',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_20(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_20',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_21(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_21',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_22(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_22',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_23(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_23',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_24(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_24',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_25(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_25',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_26(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_26',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_27(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_27',\n                                threshold=threshold, debug=debug)\n\n    def match_game_session_in_progress_28(self, img_rgb, threshold=0.9, debug=False):\n        return self.match_scene(img_rgb, 'game_session_in_progress_28',\n                                threshold=threshold, debug=debug)\n\n    def match_game"
}
2022-04-13 21:33:37.087593 REASON length
2022-04-13 21:33:37.087599 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\nimport sys\n\ndef readline_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef readline_int():\n    return int(sys.stdin.readline())\n\ndef read_input():\n    n, m = readline_ints()\n    edges = []\n    for _ in range(n - 1):\n        edges.append(readline_ints())\n    queries = readline_ints()\n    return n, m, edges, queries\n\n\ndef solve(n, edges, queries):\n    from collections import defaultdict\n    from itertools import combinations\n    \n    # build a graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # compute all pairwise distances\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n        stack = [(i, 0)]\n        while stack:\n            u, d = stack.pop()\n            for v, w in graph[u]:\n                if dist[i][v] > d + w:\n                    dist[i][v] = d + w\n                    stack.append((v, d + w))\n    \n    # find all pairs of vertices\n    pairs = list(combinations(range(n), 2))\n    \n    # solve the queries\n    for q in queries:\n        yield sum(dist[i][j] <= q for i, j in pairs)\n\n\ndef main():\n    n, m, edges, queries = read_input()\n    for result in solve(n, edges, queries):\n        print(result)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:33:37.087631 REASON stop
2022-04-13 21:33:37.110390 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\nimport sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, arr, func):\n        self.n = len(arr)\n        self.size = 2**(self.n-1).bit_length()\n        self.func = func\n        self.default = self.func(0,0)\n        self.data = [self.default]*(2*self.size)\n        self.data[self.size : self.size+self.n] = arr\n        for i in range(self.size-1, 0, -1):\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        res = self.default\n        while l < r:\n            if l&1:\n                res = self.func(res, self.data[l])\n                l += 1\n            if r&1:\n                res = self.func(res, self.data[r-1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def update(self, i, x):\n        i += self.size\n        self.data[i] = x\n        i >>= 1\n        while i:\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n            i >>= 1\n\n\ndef dfs(v, p, g, dep, dp):\n    dp[v] = dep\n    for u in g[v]:\n        if u == p:\n            continue\n        dfs(u, v, g, dep+1, dp)\n\ndef solve(n, q, g, dep, dp):\n    dfs(0, -1, g, 0, dp)\n    st = SegmentTree(dp, max)\n    ans = [0]*n\n    for i in range(n):\n        ans[i] = st.query(0, i)\n    return ans\n\ndef main():\n    n, m = map(int, input().split())\n    g = [[] for i in range(n)]\n    for i in range(n-1):\n        u, v, w = map(int, input().split())\n        g[u-1].append((v-1, w))\n        g[v-1].append((u-1, w))\n    q = list(map(int, input().split()))\n    dep = [0]*n\n    dp = [0]*n\n    ans = solve(n, q, g, dep, dp)\n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-13 21:33:37.110517 REASON stop
2022-04-13 21:33:37.117871 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\n\ndef solve(adj_list, n, q_list):\n    # set up a heap of (weight, (node1, node2))\n    edge_heap = []\n    for node1 in adj_list:\n        for node2 in adj_list[node1]:\n            edge_heap.append((adj_list[node1][node2], (node1, node2)))\n    heapq.heapify(edge_heap)\n\n    # set up a union find structure\n    parent = [i for i in range(n+1)]\n    size = [1 for i in range(n+1)]\n\n    # iterate through queries and edges\n    answer_list = []\n    for q in q_list:\n        while edge_heap and edge_heap[0][0] <= q:\n            weight, (node1, node2) = heapq.heappop(edge_heap)\n            union(node1, node2, parent, size)\n\n        answer_list.append(n*(n-1)//2 - sum(size[1:]))\n\n    return answer_list\n\ndef union(node1, node2, parent, size):\n    p1 = find(node1, parent)\n    p2 = find(node2, parent)\n    if p1 != p2:\n        if size[p1] > size[p2]:\n            size[p1] += size[p2]\n            parent[p2] = p1\n        else:\n            size[p2] += size[p1]\n            parent[p1] = p2\n\ndef find(node, parent):\n    if parent[node] != node:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef main():\n    # parse input\n    n, m = map(int, sys.stdin.readline().split())\n    adj_list = {}\n    for i in range(1, n+1):\n        adj_list[i] = {}\n    for i in range(n-1):\n        node1, node2, weight = map(int, sys.stdin.readline().split())\n        adj_list[node1][node2] = weight\n        adj_list[node2][node1] = weight\n    q_list = list(map(int, sys.stdin.readline().split()))\n\n    # solve problem\n    answer_list = solve(adj_list, n, q_list)\n\n    # print answer\n    for answer in answer_list:\n        print(answer)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:33:37.117966 REASON stop
2022-04-13 21:33:37.119057 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    This function will be run when you hit Run.\n    \"\"\"\n    print('Hello World')\n\nif __name__ == '__main__':\n    main()"
}
2022-04-13 21:33:37.119132 REASON stop
