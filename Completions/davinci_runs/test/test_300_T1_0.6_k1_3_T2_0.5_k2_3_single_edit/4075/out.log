2022-04-18 02:10:36.960355 """
We have N switches with "on" and "off" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.
Bulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are "on" among these switches is congruent to p_i modulo 2.
How many combinations of "on" and "off" states of the switches light all the bulbs?

-----Constraints-----
 - 1 \leq N, M \leq 10
 - 1 \leq k_i \leq N
 - 1 \leq s_{ij} \leq N
 - s_{ia} \neq s_{ib} (a \neq b)
 - p_i is 0 or 1.
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N M
k_1 s_{11} s_{12} ... s_{1k_1}
:
k_M s_{M1} s_{M2} ... s_{Mk_M}
p_1 p_2 ... p_M

-----Output-----
Print the number of combinations of "on" and "off" states of the switches that light all the bulbs.

-----Sample Input-----
2 2
2 1 2
1 2
0 1

-----Sample Output-----
1

 - Bulb 1 is lighted when there is an even number of switches that are "on" among the following: Switch 1 and 2.
 - Bulb 2 is lighted when there is an odd number of switches that are "on" among the following: Switch 2.
There are four possible combinations of states of (Switch 1, Switch 2): (on, on), (on, off), (off, on) and (off, off). Among them, only (on, on) lights all the bulbs, so we should print 1.
"""
2022-04-18 02:10:36.960374 --------------------------
2022-04-18 02:11:21.470061 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)"
    }
  ],
  "created": 1650247837,
  "id": "cmpl-4yB8XmfQ6Khga6CBcmCqt0sIQQtUn",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 02:11:21.470288 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))"
}
2022-04-18 02:11:21.470333 REASON stop
2022-04-18 02:11:21.471887 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 02:11:21.471954 REASON stop
2022-04-18 02:11:21.472545 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)"
}
2022-04-18 02:11:21.472661 REASON stop
