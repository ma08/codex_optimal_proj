["\n\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn abs((b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1]))/2\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i+1])\n\tA += area(P[-1],P[0],U[0])\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],U[i+1])\n\tarea_sum += area(P[-1],P[0],U[0])\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n", "\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(int, input().split())))\n    max_length = 0\n    for i in range(number_of_points - 1):\n        for j in range(i + 1, number_of_points):\n            length = ((point_list[i][0] - point_list[j][0])**2 + (point_list[i][1] - point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val > 0:\n        # Clockwise orientation\n        return 1\n    elif val < 0:\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if o1 == 0 and onSegment(p1, p2, q1):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if o2 == 0 and onSegment(p1, q2, q1):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if o3 == 0 and onSegment(p2, p1, q2):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n", "\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points - 1):\n        for j in range(i + 1, number_of_points):\n            length = ((point_list[i][0] - point_list[j][0]) ** 2 +\n                      (point_list[i][1] - point_list[j][1]) ** 2) ** 0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\n\t'''\n\tRead data from the file.\n\tInput: file name\n\tOutput: a list of points\n\t'''\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\n\t'''\n\tReturn the area of the triangle (a,b,c).\n\ta,b,c are tuples.\n\t'''\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\t'''\n\tReturn the area of the triangle (a,b,c).\n\ta,b,c are tuples.\n\t'''\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\t'''\n\tReturn the convex hull of the point set S.\n\tS is a list of points.\n\t'''\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\t'''\n\tReturn the ratio of the area of the convex hull\n\tto the area of the point set S.\n\tS is a list of points.\n\t'''\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0.0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n", "\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()\n"]