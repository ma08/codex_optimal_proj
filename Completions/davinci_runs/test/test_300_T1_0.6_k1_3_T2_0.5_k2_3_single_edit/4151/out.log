2022-04-18 02:56:11.573695 """
You are given an array $a$ consisting of $n$ integers. Let's denote monotonic renumeration of array $a$ as an array $b$ consisting of $n$ integers such that all of the following conditions are met:

  $b_1 = 0$;  for every pair of indices $i$ and $j$ such that $1 \le i, j \le n$, if $a_i = a_j$, then $b_i = b_j$ (note that if $a_i \ne a_j$, it is still possible that $b_i = b_j$);  for every index $i \in [1, n - 1]$ either $b_i = b_{i + 1}$ or $b_i + 1 = b_{i + 1}$. 

For example, if $a = [1, 2, 1, 2, 3]$, then two possible monotonic renumerations of $a$ are $b = [0, 0, 0, 0, 0]$ and $b = [0, 0, 0, 0, 1]$.

Your task is to calculate the number of different monotonic renumerations of $a$. The answer may be large, so print it modulo $998244353$.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 2 \cdot 10^5$) — the number of elements in $a$.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$).


-----Output-----

Print one integer — the number of different monotonic renumerations of $a$, taken modulo $998244353$.


-----Examples-----
Input
5
1 2 1 2 3

Output
2

Input
2
100 1

Output
2

Input
4
1 3 3 7

Output
4
"""
2022-04-18 02:56:11.573712 --------------------------
2022-04-18 02:56:49.547740 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin, stdout\n\ndef read_ints():\n    return [int(x) for x in stdin.readline().strip().split()]\n\ndef read_int():\n    return int(stdin.readline().strip())\n\nMOD = 998244353\nMAXN = 200000\n\nfac = [1]\ninv_fac = [1]\n\nfor i in range(1, MAXN+1):\n    fac.append(fac[-1] * i % MOD)\n    inv_fac.append(inv_fac[-1] * pow(i, MOD-2, MOD) % MOD)\n\ndef binom(n, k):\n    return fac[n] * inv_fac[k] * inv_fac[n-k] % MOD\n\ndef mod_inv(x):\n    return pow(x, MOD-2, MOD)\n\ndef main():\n    n = read_int()\n    a = read_ints()\n    count = [0] * (n+1)\n    for x in a:\n        count[x] += 1\n    for i in range(1, n+1):\n        if count[i] > 0:\n            k = count[i]\n            count[i] = binom(k, k-1)\n    for i in range(1, n+1):\n        if count[i] > 0:\n            for j in range(i*2, n+1, i):\n                count[j] = (count[j] - count[i]) % MOD\n    result = 1\n    for i in range(1, n+1):\n        if count[i] > 0:\n            result = result * count[i] % MOD\n    stdout.write(str(result))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef answer(a):\n    m = {}\n    for i in range(len(a)):\n        if a[i] in m:\n            m[a[i]] += 1\n        else:\n            m[a[i]] = 1\n    # print(m)\n    # print(m.items())\n    max_len = max(m.values())\n    count = 1\n    for i in m.values():\n        count *= (i + 1)\n    # print(count)\n    count -= 1\n    return count % 998244353\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(answer(a))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\n\nfor i in a:\n  if i in d:\n    d[i] += 1\n  else:\n    d[i] = 1\n\nif len(d) == 1:\n  print(1)\n  quit()\n\nl = list(d.values())\n\nres = 1\n\nfor i in l:\n  res *= (i + 1)\n\nres -= 1\n\nprint(res)"
    }
  ],
  "created": 1650250571,
  "id": "cmpl-4yBqdeX1J6TPvsDAiwFZCPacbd3U5",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 02:56:49.547960 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin, stdout\n\ndef read_ints():\n    return [int(x) for x in stdin.readline().strip().split()]\n\ndef read_int():\n    return int(stdin.readline().strip())\n\nMOD = 998244353\nMAXN = 200000\n\nfac = [1]\ninv_fac = [1]\n\nfor i in range(1, MAXN+1):\n    fac.append(fac[-1] * i % MOD)\n    inv_fac.append(inv_fac[-1] * pow(i, MOD-2, MOD) % MOD)\n\ndef binom(n, k):\n    return fac[n] * inv_fac[k] * inv_fac[n-k] % MOD\n\ndef mod_inv(x):\n    return pow(x, MOD-2, MOD)\n\ndef main():\n    n = read_int()\n    a = read_ints()\n    count = [0] * (n+1)\n    for x in a:\n        count[x] += 1\n    for i in range(1, n+1):\n        if count[i] > 0:\n            k = count[i]\n            count[i] = binom(k, k-1)\n    for i in range(1, n+1):\n        if count[i] > 0:\n            for j in range(i*2, n+1, i):\n                count[j] = (count[j] - count[i]) % MOD\n    result = 1\n    for i in range(1, n+1):\n        if count[i] > 0:\n            result = result * count[i] % MOD\n    stdout.write(str(result))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-18 02:56:49.548014 REASON stop
2022-04-18 02:56:49.587507 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef answer(a):\n    m = {}\n    for i in range(len(a)):\n        if a[i] in m:\n            m[a[i]] += 1\n        else:\n            m[a[i]] = 1\n    # print(m)\n    # print(m.items())\n    max_len = max(m.values())\n    count = 1\n    for i in m.values():\n        count *= (i + 1)\n    # print(count)\n    count -= 1\n    return count % 998244353\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(answer(a))"
}
2022-04-18 02:56:49.587577 REASON stop
2022-04-18 02:56:49.588059 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\n\nfor i in a:\n  if i in d:\n    d[i] += 1\n  else:\n    d[i] = 1\n\nif len(d) == 1:\n  print(1)\n  quit()\n\nl = list(d.values())\n\nres = 1\n\nfor i in l:\n  res *= (i + 1)\n\nres -= 1\n\nprint(res)"
}
2022-04-18 02:56:49.588135 REASON stop
