2022-04-18 08:32:11.224816 num operations 1
2022-04-18 08:32:11.224837 size on input set 1
2022-04-18 08:32:18.309309 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "package file\n\nimport (\n\t\"os\"\n)\n\ntype File struct {\n\tFilePath string\n\tFileName string\n\tFile     *os.File\n}\n\nfunc NewFile(filePath string, fileName string) (*File, error) {\n\tfile, err := os.OpenFile(filePath+\"/\"+fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &File{\n\t\tFilePath: filePath,\n\t\tFileName: fileName,\n\t\tFile:     file,\n\t}, nil\n}\n\nfunc (f *File) Write(data []byte) {\n\tf.File.Write(data)\n}\n\nfunc (f *File) Close() {\n\tf.File.Close()\n}\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python\n\nimport sys\nimport os\nimport time\n\ndef main():\n    print(\"Hello world\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef read_file(file_name):\n    with open(file_name) as file:\n        return file.read()\n\n\ndef write_file(file_name, content):\n    with open(file_name, 'w') as file:\n        file.write(content)\n\n\ndef append_file(file_name, content):\n    with open(file_name, 'a') as file:\n        file.write(content)\n\n\nif __name__ == \"__main__\":\n    file_name = 'file.txt'\n    content = 'Hello World!'\n\n    write_file(file_name, content)\n    print(read_file(file_name))\n\n    append_file(file_name, '\\n' + content)\n    print(read_file(file_name))\n"
    }
  ],
  "created": 1650270731,
  "object": "edit"
}
2022-04-18 08:32:18.309506 fix syntax errors 3 ['package file\n\nimport (\n\t"os"\n)\n\ntype File struct {\n\tFilePath string\n\tFileName string\n\tFile     *os.File\n}\n\nfunc NewFile(filePath string, fileName string) (*File, error) {\n\tfile, err := os.OpenFile(filePath+"/"+fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &File{\n\t\tFilePath: filePath,\n\t\tFileName: fileName,\n\t\tFile:     file,\n\t}, nil\n}\n\nfunc (f *File) Write(data []byte) {\n\tf.File.Write(data)\n}\n\nfunc (f *File) Close() {\n\tf.File.Close()\n}\n', '#!/usr/bin/env python\n\nimport sys\nimport os\nimport time\n\ndef main():\n    print("Hello world")\n\nif __name__ == "__main__":\n    main()\n', '\ndef read_file(file_name):\n    with open(file_name) as file:\n        return file.read()\n\n\ndef write_file(file_name, content):\n    with open(file_name, \'w\') as file:\n        file.write(content)\n\n\ndef append_file(file_name, content):\n    with open(file_name, \'a\') as file:\n        file.write(content)\n\n\nif __name__ == "__main__":\n    file_name = \'file.txt\'\n    content = \'Hello World!\'\n\n    write_file(file_name, content)\n    print(read_file(file_name))\n\n    append_file(file_name, \'\\n\' + content)\n    print(read_file(file_name))\n']
2022-04-18 08:32:18.309539 size on output set 3
2022-04-18 08:32:18.309567 num operations 1
2022-04-18 08:32:18.309574 size on input set 1
2022-04-18 08:32:21.763153 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1] * (n - 1)\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1] * (n - 1)\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print \"NO\"\n        sys.exit(0)\n\n    print \"YES\"\n    for i in range(1, n):\n        print i, graph[i - 1]\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print(\"NO\")\n        sys.exit(0)\n\n    print(\"YES\")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print(\"NO\")\n        sys.exit(0)\n\n    print(\"YES\")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650270738,
  "object": "edit"
}
2022-04-18 08:32:21.763464 fix syntax errors 3 ['\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError(\'invalid edge {}:{} -> {}\'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float("inf")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float("inf")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1] * (n - 1)\n        else:\n            return float("inf")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float("inf")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float("inf")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1] * (n - 1)\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float("inf")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float("inf")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float("inf"):\n        print "NO"\n        sys.exit(0)\n\n    print "YES"\n    for i in range(1, n):\n        print i, graph[i - 1]\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError(\'invalid edge {}:{} -> {}\'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float("inf")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float("inf")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float("inf")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float("inf")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float("inf")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float("inf")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float("inf")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float("inf"):\n        print("NO")\n        sys.exit(0)\n\n    print("YES")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError(\'invalid edge {}:{} -> {}\'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float("inf")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float("inf")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float("inf")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float("inf")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float("inf")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float("inf")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float("inf")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float("inf"):\n        print("NO")\n        sys.exit(0)\n\n    print("YES")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-18 08:32:21.763533 size on output set 2
2022-04-18 08:32:21.763545 num operations 1
2022-04-18 08:32:21.763551 size on input set 1
2022-04-18 08:32:23.906280 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650270741,
  "object": "edit"
}
2022-04-18 08:32:23.906523 fix syntax errors 3 ['\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(" "))\n    if d == 1:\n        print("YES")\n        for i in range(1, n):\n            print("{} {}".format(i, i + 1))\n        return\n    if k < d - 1:\n        print("NO")\n        return\n    if n == 2:\n        print("YES")\n        print("1 2")\n        return\n    if d == 2:\n        print("YES")\n        for i in range(1, n):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 3:\n        print("YES")\n        print("{} {}".format(1, n))\n        for i in range(1, n - 1):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 4:\n        print("YES")\n        print("{} {}".format(1, n))\n        print("{} {}".format(1, n - 1))\n        print("{} {}".format(2, n - 1))\n        for i in range(3, n - 2):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 5:\n        print("YES")\n        print("{} {}".format(1, n))\n        print("{} {}".format(1, n - 1))\n        print("{} {}".format(2, n - 1))\n        print("{} {}".format(2, n - 2))\n        print("{} {}".format(3, n - 2))\n        for i in range(4, n - 3):\n            print("{} {}".format(i, i + 1))\n        return\n    print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(" "))\n    if d == 1:\n        print("YES")\n        for i in range(1, n):\n            print("{} {}".format(i, i + 1))\n        return\n    if k < d - 1:\n        print("NO")\n        return\n    if n == 2:\n        print("YES")\n        print("1 2")\n        return\n    if d == 2:\n        print("YES")\n        for i in range(1, n):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 3:\n        print("YES")\n        print("{} {}".format(1, n))\n        for i in range(1, n - 1):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 4:\n        print("YES")\n        print("{} {}".format(1, n))\n        print("{} {}".format(1, n - 1))\n        print("{} {}".format(2, n - 1))\n        for i in range(3, n - 2):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 5:\n        print("YES")\n        print("{} {}".format(1, n))\n        print("{} {}".format(1, n - 1))\n        print("{} {}".format(2, n - 1))\n        print("{} {}".format(2, n - 2))\n        print("{} {}".format(3, n - 2))\n        for i in range(4, n - 3):\n            print("{} {}".format(i, i + 1))\n        return\n    print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(" "))\n    if d == 1:\n        print("YES")\n        for i in range(1, n):\n            print("{} {}".format(i, i + 1))\n        return\n    if k < d - 1:\n        print("NO")\n        return\n    if n == 2:\n        print("YES")\n        print("1 2")\n        return\n    if d == 2:\n        print("YES")\n        for i in range(1, n):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 3:\n        print("YES")\n        print("{} {}".format(1, n))\n        for i in range(1, n - 1):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 4:\n        print("YES")\n        print("{} {}".format(1, n))\n        print("{} {}".format(1, n - 1))\n        print("{} {}".format(2, n - 1))\n        for i in range(3, n - 2):\n            print("{} {}".format(i, i + 1))\n        return\n    if d == 5:\n        print("YES")\n        print("{} {}".format(1, n))\n        print("{} {}".format(1, n - 1))\n        print("{} {}".format(2, n - 1))\n        print("{} {}".format(2, n - 2))\n        print("{} {}".format(3, n - 2))\n        for i in range(4, n - 3):\n            print("{} {}".format(i, i + 1))\n        return\n    print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-18 08:32:23.906582 size on output set 1
