2022-04-18 01:54:43.843481 """
You are given three integers $a$, $b$ and $x$. Your task is to construct a binary string $s$ of length $n = a + b$ such that there are exactly $a$ zeroes, exactly $b$ ones and exactly $x$ indices $i$ (where $1 \le i < n$) such that $s_i \ne s_{i + 1}$. It is guaranteed that the answer always exists.

For example, for the string "01010" there are four indices $i$ such that $1 \le i < n$ and $s_i \ne s_{i + 1}$ ($i = 1, 2, 3, 4$). For the string "111001" there are two such indices $i$ ($i = 3, 5$).

Recall that binary string is a non-empty sequence of characters where each character is either 0 or 1.


-----Input-----

The first line of the input contains three integers $a$, $b$ and $x$ ($1 \le a, b \le 100, 1 \le x < a + b)$.


-----Output-----

Print only one string $s$, where $s$ is any binary string satisfying conditions described above. It is guaranteed that the answer always exists.


-----Examples-----
Input
2 2 1

Output
1100

Input
3 3 3

Output
101100

Input
5 3 6

Output
01010100



-----Note-----

All possible answers for the first example:   1100;  0011. 

All possible answers for the second example:   110100;  101100;  110010;  100110;  011001;  001101;  010011;  001011.
"""
2022-04-18 01:54:43.843497 --------------------------
2022-04-18 01:55:35.162192 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# Use A[i] to represent the number of 0s required in the first i bits\n# Use B[i] to represent the number of 1s required in the first i bits\n# Use C[i] to represent the number of transitions required in the first i bits\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1\n# If B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print \"0\" * x + \"1\" * b\nelif (b - x) >= a:\n    print \"1\" * x + \"0\" * a\nelse:\n    zeros = a - (x - b)\n    print \"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b"
    }
  ],
  "created": 1650246884,
  "id": "cmpl-4yAtAo7KYyiJgJFVKyEKA0JqhEnyW",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 01:55:35.162437 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s"
}
2022-04-18 01:55:35.162477 REASON stop
2022-04-18 01:55:35.178398 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# Use A[i] to represent the number of 0s required in the first i bits\n# Use B[i] to represent the number of 1s required in the first i bits\n# Use C[i] to represent the number of transitions required in the first i bits\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1\n# If B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))"
}
2022-04-18 01:55:35.178466 REASON stop
2022-04-18 01:55:35.178940 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print \"0\" * x + \"1\" * b\nelif (b - x) >= a:\n    print \"1\" * x + \"0\" * a\nelse:\n    zeros = a - (x - b)\n    print \"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b"
}
2022-04-18 01:55:35.179012 REASON stop
