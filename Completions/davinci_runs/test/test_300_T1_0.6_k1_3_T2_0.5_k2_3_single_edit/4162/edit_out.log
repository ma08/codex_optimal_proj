2022-04-18 09:08:54.739841 num operations 1
2022-04-18 09:08:54.739866 size on input set 1
2022-04-18 09:09:05.530817 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 1,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 2,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    }
  ],
  "created": 1650272934,
  "object": "edit"
}
2022-04-18 09:09:05.531068 fix syntax errors 3 ['\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n']
2022-04-18 09:09:05.531225 size on output set 1
2022-04-18 09:09:05.531238 num operations 1
2022-04-18 09:09:05.531244 size on input set 1
2022-04-18 09:09:08.372646 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache as memo\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@memo(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 1,
      "text": "\nfrom math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 2,
      "text": "from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    }
  ],
  "created": 1650272945,
  "object": "edit"
}
2022-04-18 09:09:08.372850 fix syntax errors 3 ['\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache as memo\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@memo(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', '\nfrom math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', 'from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n']
2022-04-18 09:09:08.372881 size on output set 3
2022-04-18 09:09:08.372891 num operations 1
2022-04-18 09:09:08.372897 size on input set 1
2022-04-18 09:09:10.285626 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650272948,
  "object": "edit"
}
2022-04-18 09:09:10.285798 fix syntax errors 3 ["import sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-18 09:09:10.285825 size on output set 2
