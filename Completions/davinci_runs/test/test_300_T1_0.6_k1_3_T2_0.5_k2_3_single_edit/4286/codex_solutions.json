["\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))", "\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()"]