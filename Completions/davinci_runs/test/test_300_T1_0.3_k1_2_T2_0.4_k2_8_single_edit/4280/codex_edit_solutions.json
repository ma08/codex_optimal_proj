["\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\nc = [1] * n\nsz = [1] * n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "\n\ndef dfs(start, parent):\n    global k, edges, visited\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(' '.join(str(i % (k+1) + 1) for i in range(n)))\n", "\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split()) # read input\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\nc = [1] * n\nsz = [1] * n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\nc = [1] * n\nsz = [1] * n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i and c[i] > k:\n            ans[j] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "n, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\nc = [1] * n\nsz = [1] * n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "\ndef dfs(start, parent, color):\n    global n, k, edges, visited\n    visited[start] = color\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start, color)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(' '.join(str(i % (k+1) + 1) for i in range(n-1)))\n", "\n\ndef dfs(start, parent):\n    global n, k, edges, visited\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k)\nprint(' '.join(str(i % (k) + 1) for i in range(n-1)))\n", "\ndef dfs(start, parent):\n    global n, k, edges, visited, colors\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if visited[edge]:\n            k -= 1\n        else:\n            dfs(edge, start)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(' '.join(str(i % (k+1) + 1) for i in range(n-1)))\n", "\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\nc = [1] * n\nsz = [1] * n\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "n, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n    \nc = [1] * n\nsz = [1] * n\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            c[v] += c[u]\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\nc = [1] * n\nsz = [1] * n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[j]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "\n\ndef dfs(start, parent):\n    global n, k, edges, visited\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(*[i % (k+1) + 1 for i in range(n-1)])\n", "\n\ndef dfs(start, parent):\n    global n, k, edges, visited\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(' '.join(str(i % (k+1) + 1) for i in range(n-1))) \n", "\n\ndef dfs(start, parent):\n    global n, k, edges, visited\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start)\n        else:\n            k -= 1\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(' '.join(str(i % (k + 1) + 1) for i in range(n - 1)))\n", "#!/usr/bin/python\n\n\nimport sys\nimport getopt\n\ndef dfs2(v, p, keep):\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            dfs2(u, v, 0)\n    if bigChild != -1:\n        dfs2(bigChild, v, 1)\n        c[bigChild] += c[v]\n    mx = -1\n    bigChild = -1\n    for u in g[v]:\n        if u != p and sz[u] > mx:\n            mx = sz[u]\n            bigChild = u\n    for u in g[v]:\n        if u != p and u != bigChild:\n            for x in g[u]:\n                if x != u and x != p:\n                    c[x] = c[u]\n    if keep == 0:\n        c[v] = 0\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\n\nc = [1] * n\nsz = [1] * n\ndfs(0, -1)\ndfs2(0, -1, 1)\n\nans = [0] * (n-1)\nfor i in range(n):\n    for j in g[i]:\n        if j > i:\n            ans[i] = c[i]\n\nprint(max(ans))\nprint(' '.join(map(str, ans)))\n", "\ndef dfs(start, parent):\n    global n, k, edges, visited\n    visited[start] = True\n    for edge in edges[start]:\n        if edge == parent:\n            continue\n        if not visited[edge]:\n            dfs(edge, start)\n        else:\n            k -= 1\n\n\nn, k = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\nvisited = [False] * n\ndfs(0, -1)\nprint(k+1)\nprint(' '.join(str(i % (k+1) + 1) for i in range(n-1)))\n"]