2022-04-20 10:14:39.258471 num operations 1
2022-04-20 10:14:39.258490 size on input set 1
2022-04-20 10:14:39.258695 using api key jaanu
2022-04-20 10:14:51.413945 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# -----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 1,
      "text": "\n\n#-----Solution 1-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 2,
      "text": "\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2, rounded down\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 3,
      "text": "\n\n#-----Solution-----#\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 4,
      "text": "\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2 and rounded down\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops <= max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 5,
      "text": "\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2, rounded down\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 6,
      "text": "\n\n# -----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    },
    {
      "index": 7,
      "text": "\n\n#-----Solution-----#\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n"
    }
  ],
  "created": 1650449679,
  "object": "edit"
}
2022-04-20 10:14:51.414407 fix syntax errors 8 ['\n\n# -----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n#-----Solution 1-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2, rounded down\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n#-----Solution-----#\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2 and rounded down\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops <= max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2, rounded down\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n# -----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n', '\n\n#-----Solution-----#\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)\n']
2022-04-20 10:14:51.414573 size on output set 5
2022-04-20 10:14:51.414586 num operations 1
2022-04-20 10:14:51.414592 size on input set 1
2022-04-20 10:14:51.414750 using api key gabby
2022-04-20 10:14:57.265786 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "def main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "def main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n, k = map(int, input().split()) \n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    print(max(a) - min(a) - 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0])\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650449691,
  "object": "edit"
}
2022-04-20 10:14:57.266066 fix syntax errors 8 ["\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0])\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0])\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split()) \n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    print(max(a) - min(a) - 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0])\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 10:14:57.266104 size on output set 6
