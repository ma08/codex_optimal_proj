["\n\nimport sys\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    trees = [int(x) for x in sys.stdin.readline().strip().split()]\n    count = 0\n    while n > 0:\n        n -= 1\n        count += trees[n]\n    print(count)", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    t = list(map(int, sys.stdin.readline().split()))\n    t.sort()\n    print(sum(t[i]*(n-i) for i in range(n)))\n\nmain()", "\n\nimport sys\nimport heapq\n\ndef party_planning(trees):\n    \"\"\"\n    The party can be organized at earliest on the next day after the last tree has grown up.\n    :param trees: list of ints representing the number of days it takes for each tree to grow\n    :return: earliest day when the party can be organized\n    \"\"\"\n    # sort the list of trees by growth time\n    heapq.heapify(trees)\n    # the first tree takes 1 day to plant\n    cur_day = 1\n    # the earliest day that the party can be organized is the next day after the last tree has grown\n    # so we need to keep track of the last day that a tree will finish growing\n    last_day = 0\n    while trees:\n        # plant the tree with the shortest growth time\n        cur_day += heapq.heappop(trees)\n        # if the current tree finishes growing after the previous tree, then the party can be organized\n        # on the same day as the current tree\n        if cur_day > last_day:\n            last_day = cur_day\n    return last_day\n\ndef main():\n    \"\"\"\n    Driver function\n    \"\"\"\n    trees = []\n    for line in sys.stdin:\n        trees.extend(map(int, line.split()))\n    print(party_planning(trees))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n  n = int(sys.stdin.readline())\n  trees = [int(x) for x in sys.stdin.readline().split()]\n  trees.sort()\n  if n == 1:\n    print(trees[0])\n  else:\n    max_days = 0\n    for i in range(n):\n      max_days = max(max_days, trees[i] + n - i)\n    print(max_days)\n\nif __name__ == '__main__':\n  main()", "\n\nimport sys\n\ndef main():\n    num_seedlings = int(sys.stdin.readline().strip())\n    seedling_growth_times = [int(x) for x in sys.stdin.readline().strip().split()]\n    seedling_growth_times.sort()\n    max_time = seedling_growth_times[-1]\n    for i in range(len(seedling_growth_times)-2,-1,-1):\n        max_time += 1 + seedling_growth_times[i]\n    print(max_time)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport heapq\n\ndef main():\n    n = int(sys.stdin.readline())\n    days = map(int, sys.stdin.readline().split())\n    heap = []\n    for i in days:\n        heapq.heappush(heap, i)\n    time = 0\n    while heap:\n        time += heapq.heappop(heap)\n        if heap:\n            time += 1\n    print time\n\nif __name__ == \"__main__\":\n    main()", "\n\n# Solution\n\nn = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nmax = t[0]\nfor i in range(1, n):\n    if max < t[i]:\n        max = t[i]\n    t[i] = max + t[i]\n\nprint(t[-1] + 1)", "\n\n# TODO: fix algorithm - it doesn't work for some inputs\n\nn = int(input())\nt = list(map(int, input().split()))\n\n# sort trees by time required for them to grow\nt.sort()\n\n# find the earliest day when the party can be organized\nday = 0\nfor i in range(n):\n    if t[i] < day:\n        day += 1\n    else:\n        day += t[i]\n\nprint(day)"]