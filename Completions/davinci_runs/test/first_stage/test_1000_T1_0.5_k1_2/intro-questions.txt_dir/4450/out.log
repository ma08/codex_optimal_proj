2022-04-09 20:14:57.823523 """
You are given a connected undirected weighted graph consisting of $n$ vertices and $m$ edges.

You need to print the $k$-th smallest shortest path in this graph (paths from the vertex to itself are not counted, paths from $i$ to $j$ and from $j$ to $i$ are counted as one).

More formally, if $d$ is the matrix of shortest paths, where $d_{i, j}$ is the length of the shortest path between vertices $i$ and $j$ ($1 \le i < j \le n$), then you need to print the $k$-th element in the sorted array consisting of all $d_{i, j}$, where $1 \le i < j \le n$.


-----Input-----

The first line of the input contains three integers $n, m$ and $k$ ($2 \le n \le 2 \cdot 10^5$, $n - 1 \le m \le \min\Big(\frac{n(n-1)}{2}, 2 \cdot 10^5\Big)$, $1 \le k \le \min\Big(\frac{n(n-1)}{2}, 400\Big)$ — the number of vertices in the graph, the number of edges in the graph and the value of $k$, correspondingly.

Then $m$ lines follow, each containing three integers $x$, $y$ and $w$ ($1 \le x, y \le n$, $1 \le w \le 10^9$, $x \ne y$) denoting an edge between vertices $x$ and $y$ of weight $w$.

It is guaranteed that the given graph is connected (there is a path between any pair of vertices), there are no self-loops (edges connecting the vertex with itself) and multiple edges (for each pair of vertices $x$ and $y$, there is at most one edge between this pair of vertices in the graph).


-----Output-----

Print one integer — the length of the $k$-th smallest shortest path in the given graph (paths from the vertex to itself are not counted, paths from $i$ to $j$ and from $j$ to $i$ are counted as one).


-----Examples-----
Input
6 10 5
2 5 1
5 3 9
6 2 2
1 3 1
5 1 8
6 5 10
1 6 5
6 4 6
3 6 2
3 4 5

Output
3

Input
7 15 18
2 6 3
5 7 4
6 5 4
3 6 9
6 7 7
1 6 4
7 1 6
7 2 1
4 3 2
3 2 8
5 3 6
2 5 5
3 7 9
4 1 8
2 1 1

Output
9
"""
2022-04-09 20:14:57.823548 --------------------------
2022-04-09 20:15:30.026331 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])"
    }
  ],
  "created": 1649549698,
  "id": "cmpl-4vFWEN9IKZdBqcR3gUeurB7Xg2ILw",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 20:15:30.026517 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))"
}
2022-04-09 20:15:30.026549 REASON stop
2022-04-09 20:15:30.027600 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])"
}
2022-04-09 20:15:30.027666 REASON stop
