["import sys\ninput = sys.stdin.readline\n\nx = int(input())\n# \ubb35 \ucc0c \ube60\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nMAX = min(a[0], b[1])+min(a[1], b[2])+min(a[2], b[0])\nMIN = 0\ntmp = min(a[0], b[0]+b[2])\na[0] -= tmp\nttmp = min(a[1], b[0]+b[1])\na[1] -= ttmp\ntttmp = min(a[2], b[1]+b[2])\na[2] -= tttmp\nprint(sum(a), MAX)\n", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nmins=max(0,b[0]-a[0]-a[1],b[1]-a[1]-a[2],b[2]-a[2]-a[0])\nmaxs=min(a[0],b[1])+min(a[1],b[2])+min(a[2],b[0])\nprint(mins,maxs)", "n = int(input())\na1, a2, a3 = map(int, input().split())\nb1, b2, b3 = map(int, input().split())\nmaxcount = 0\nif a1-b2 >0 and b2!=0:\n  maxcount+=(b2)\nelif b2==0:\n  maxcount+=0\nelse:\n  maxcount+=a1\nif a2-b3 >0 and b3!=0:\n  maxcount+=(b3)\nelif b3==0:\n  maxcount+=0\nelse:\n  maxcount+=a2\nif a3-b1 >0 and b1!=0:\n  maxcount+=(b1)\nelif b1==0:\n  maxcount+=0\nelse:\n  maxcount+=a3\nmincount=0\nif a1> b1+b3:\n  mincount+=(a1-b1-b3)\nif a2>b1+b2:\n  mincount+=(a2-b1-b2)\nif a3>b2+b3:\n  mincount+=(a3-b2-b3)\nprint(mincount, maxcount)", "n = int(input())\nt1 = list(map(int,input().split()))\nt2 = list(map(int,input().split()))\nk1 = min(t1[0], t2[1]) + min(t1[1], t2[2]) + min(t1[2], t2[0])\nk2 = min(t1[0], n - t2[1]) + min(t1[1], n - t2[2]) + min(t1[2], n - t2[0])\nprint(n - k2, k1)", "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmaxi = min(a[0],b[1])+min(a[1],b[2])+min(a[2],b[0])\nminnie = n-(min(a[0],b[0]+b[2])+min(a[1],b[1]+b[0])+min(a[2],b[2]+b[1]))\nprint(minnie,maxi)", "# rock sci paper\nimport math\nfor _ in range(1):\n    n=int(input())\n    a=list(map(int,input().split()))\n    b=list(map(int,input().split()))\n    mi=0\n    ar,ass,ap=a[0],a[1],a[2]\n    br,bss,bp=b[0],b[1],b[2]\n    ar=max(ar-br,0)\n    ass=max(ass-bss,0)\n    ap=max(ap-bp,0)\n    \n    rock=min(ar,bp)\n    ar-=rock\n    bp-=rock\n    paper=min(ap,bss)\n    ap-=paper\n    bss-=paper\n    \n    sci=min(ass,br)\n    ass-=sci\n    br-=sci\n    mi=ar+ass+ap\n    \n    ma=0\n    ar,ass,ap=a[0],a[1],a[2]\n    br,bss,bp=b[0],b[1],b[2]\n    rock=min(ar,bss)\n    ar-=rock\n    bss-=rock\n    paper=min(ap,br)\n    ap-=paper\n    br-=paper\n    \n    sci=min(ass,bp)\n    ass-=sci\n    bp-=sci\n    ma=rock+paper+sci\n    print(mi,ma)\n    \n\n", "from sys import stdin, stdout\n\ndef find(A,B,N):\n    X=min(A[0],B[1])\n    Y=min(A[1],B[2])\n    Z=min(A[2],B[0])\n\n    P=min(A[0],B[2]+B[0])\n    Q=min(A[1],B[1]+B[0])\n    R=min(A[2],B[2]+B[1])\n    return N-(P+Q+R), X+Y+Z\n\ndef main():\n        N=int(stdin.readline())\n        A=list(map(int, stdin.readline().split()))\n        B=list(map(int, stdin.readline().split()))\n        print(\" \".join(map(str,find(A,B,N))))\nmain()", "n = int(input())\nx1, x2, x3 = list(map(int, input().split()))\ny1, y2, y3 = list(map(int, input().split()))\nmax1, min1 = min(x1, y2)+min(x2, y3)+min(x3, y1), 0\nif x1 > y1+y3:\n    min1 = x1-y1-y3\nelif x2 > y2+y1:\n    min1 = x2-y1-y2\nelif x3 > y3+y2:\n    min1 = x3-y3-y2\nprint(min1, max1)\n", "from bisect import *\nfrom collections import *\nfrom math import *\nfrom heapq import *\nfrom typing import List\nfrom itertools import *\nfrom operator import *\nfrom functools import *\nimport sys\n'''\n@lru_cache(None)\ndef fact(x):\n    if x<2:\n        return 1\n    return fact(x-1)*x\n\n@lru_cache(None)\ndef per(i,j):\n    return fact(i)//fact(i-j)\n\n@lru_cache(None)\ndef com(i,j):\n    return per(i,j)//fact(j)\n\ndef linc(f,t,l,r):\n    while l<r:\n        mid=(l+r)//2\n        if t>f(mid):\n            l=mid+1\n        else:\n            r=mid\n    return l\n\ndef rinc(f,t,l,r):\n    while l<r:\n        mid=(l+r+1)//2\n        if t<f(mid):\n            r=mid-1\n        else:\n            l=mid\n    return l\n\ndef ldec(f,t,l,r):\n    while l<r:\n        mid=(l+r)//2\n        if t<f(mid):\n            l=mid+1\n        else:\n            r=mid\n    return l\n\ndef rdec(f,t,l,r):\n    while l<r:\n        mid=(l+r+1)//2\n        if t>f(mid):\n            r=mid-1\n        else:\n            l=mid\n    return l\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef power2(n):\n    while not n&1:\n        n>>=1\n    return n==1\n'''\n'''\nfor i in range(t):\n    #n,m=map(int,input().split())\n    n,m=1,0\n    graph=defaultdict(set)\n    for i in range(m):\n        u,v=map(int,input().split())\n        graph[u-1].add(v-1)\n    visited=[0]*n\n    ans=[]\n    def delchild(u):\n        for child in graph[u]:\n            visited[child]=1\n            ans.append(child+1)\n    for i in range(n):\n        if not visited[i]:\n            children=graph[i]\n            if len(children)==1:\n                u=children.pop()\n                visited[u]=1\n                delchild(u)\n            elif len(children)==2:\n                u=children.pop()\n                v=children.pop()\n                if u in graph[v]:\n                    delchild(v)\n                    visited[v]=1\n                elif v in graph[u]:\n                    delchild(u)\n                    visited[u]=1\n                else:\n                    delchild(u)\n                    delchild(v)\n                    visited[u]=visited[v]=1\n    print(len(ans))\n    sys.stdout.flush()\n    print(' '.join(map(str,ans)))\n    sys.stdout.flush()\n\nimport time\ns=time.time()\ne=time.time()\nprint(e-s)\n'''\n'''\nt=int(input())\nfor i in range(t):\n    #n,m=map(int,input().split())\n    n=int(input())\n    x=int(sqrt(n))\n    if x*x==n:\n        ans=2*x-2\n    elif x*(x+1)>=n:\n        ans=2*x-1\n    else:\n        ans=2*x\n    print(ans)\n'''\nn=int(input())\na1,a2,a3=list(map(int,input().split()))\nb1,b2,b3=list(map(int,input().split()))\nma=min(a1,b2)+min(a2,b3)+min(a3,b1)\nmi=max(0,a1-b1-b3)+max(0,a2-b1-b2)+max(0,a3-b2-b3)\nprint(mi,ma)\n  \n    \n\n", "\n# rock, scissors, paper\ndef count_wins(a1, a2, a3, b1, b2, b3):\n    return min(a1, b2) + min(a2, b3) + min(a3, b1)\n\n\ndef solve_e(a1, a2, a3, b1, b2, b3):\n    wins = count_wins(a1, a2, a3, b1, b2, b3)\n    loses = max(0, a1 - b1 - b3) + max(0, a2 - b2 - b1) + max(0, a3 - b2 - b3)\n    return loses, wins\n\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nprint(*solve_e(*a, *b))\n", "n=int(input())\na1,a3,a2=map(int,input().split())\nb1,b3,b2=map(int,input().split())\nmaxx=min(a1,b3)+min(a2,b1)+min(a3,b2)\nminn=max(0,a1-b1-b2)+max(0,a2-b2-b3)+max(0,a3-b3-b1)\nprint(minn,maxx)", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\na1,a2,a3=list(map(int,input().split()))\nb1,b2,b3=list(map(int,input().split()))\n\nV=8\n\nEDGE=[[0]*V for i in range(V)]\n\nstart=0\ngoal=V-1\n\nEDGE[0][1]=a1\nEDGE[0][2]=a2\nEDGE[0][3]=a3\n\nEDGE[4][7]=b1\nEDGE[5][7]=b2\nEDGE[6][7]=b3\n\nEDGE[1][4]=float(\"inf\")\nEDGE[1][6]=float(\"inf\")\n\nEDGE[2][4]=float(\"inf\")\nEDGE[2][5]=float(\"inf\")\n\nEDGE[3][5]=float(\"inf\")\nEDGE[3][6]=float(\"inf\")\n\nANS=0\nwhile True:\n    USED=[0]*V\n    ROUTE=[-1]*V\n    Q=[(start,float(\"inf\"))]\n    \n    while Q: # DFS\n        NOW,cost=Q.pop()\n        if NOW==goal:\n            break\n\n        for to in range(V):\n            if USED[to]==0 and EDGE[NOW][to]!=0: \n                ROUTE[to]=NOW\n                USED[to]=1\n                Q.append((to,min(cost,EDGE[NOW][to])))\n    else:\n        break\n    \n    ANS+=cost\n    i=goal\n    while i!=start:\n        j=ROUTE[i]\n        EDGE[j][i]-=cost\n        EDGE[i][j]+=cost\n        i=j\n       \nprint(n-ANS,min(a1,b2)+min(a2,b3)+min(a3,b1))\n\n", "import sys\nreadline = sys.stdin.readline\n\nfrom heapq import heappop as hpp, heappush as hp\nclass MinCostFlowwithDijkstra:\n    INF = 1<<60\n    \n    def __init__(self, N):\n        self.N = N\n        self.Edge = [[] for _ in range(N)]\n    \n    def add_edge(self, st, en, cap, cost):\n        self.Edge[st].append([en, cap, cost, len(self.Edge[en])])\n        self.Edge[en].append([st, 0, -cost, len(self.Edge[st])-1])\n    \n    def get_mf(self, so, si, fl):\n        N = self.N\n        INF = self.INF\n        res = 0\n        Pot = [0]*N\n        geta = N\n        \n        \n        prv = [None]*N\n        prenum = [None]*N\n        while fl:\n            dist = [INF]*N\n            dist[so] = 0\n            Q = [so]\n            \n            while Q:\n                cost, vn = divmod(hpp(Q), geta)\n                if dist[vn] < cost:\n                    continue\n                \n                for enum in range(len(self.Edge[vn])):\n                    vf, cap, cost, _ = self.Edge[vn][enum]\n                    cc = dist[vn] + cost - Pot[vn] + Pot[vf]\n                    if cap > 0 and dist[vf] > cc:\n                        dist[vf] = cc\n                        prv[vf] = vn\n                        prenum[vf] = enum\n                        hp(Q, cc*geta + vf)\n            \n            if dist[si] == INF:\n                return -1\n            \n            for i in range(N):\n                Pot[i] -= dist[i]\n            \n            cfl = fl\n            vf = si\n            while vf != so:\n                cfl = min(cfl, self.Edge[prv[vf]][prenum[vf]][1])\n                vf = prv[vf]\n            \n            fl -= cfl\n            res -= cfl*Pot[si]\n            vf = si\n            while vf != so:\n                e = self.Edge[prv[vf]][prenum[vf]]\n                e[1] -= cfl\n                self.Edge[vf][e[3]][1] += cfl\n                vf = prv[vf]\n        return res\n\n\nN = int(readline())\nra, sa, pa = map(int, readline().split())\nrb, sb, pb = map(int, readline().split())\n\nmaxwin = min(ra, sb) + min(sa, pb) + min(pa, rb)\n \n\nD = MinCostFlowwithDijkstra(8)\nD.add_edge(0, 1, ra, 0)\nD.add_edge(0, 2, sa, 0)\nD.add_edge(0, 3, pa, 0)\nD.add_edge(4, 7, rb, 0)\nD.add_edge(5, 7, sb, 0)\nD.add_edge(6, 7, pb, 0)\n\nD.add_edge(1, 4, N, 0)\nD.add_edge(1, 5, N, 1)\nD.add_edge(1, 6, N, 0)\nD.add_edge(2, 4, N, 0)\nD.add_edge(2, 5, N, 0)\nD.add_edge(2, 6, N, 1)\nD.add_edge(3, 4, N, 1)\nD.add_edge(3, 5, N, 0)\nD.add_edge(3, 6, N, 0)\n\nprint(D.get_mf(0, 7, N), maxwin)", "import heapq\n\nclass mcf_graph_int_cost:\n\n    def __init__(self, n):\n        self.n = n\n        self.pos = []\n        self.g = [[] for _ in range(n)]\n\n\n    def add_edge(self, from_, to, cap, cost):\n        # assert 0 <= from_ < self.n\n        # assert 0 <= to < self.n\n        m = len(self.pos)\n        self.pos.append((from_, len(self.g[from_])))\n        self.g[from_].append(self.__class__._edge(to, len(self.g[to]), cap, cost))\n        self.g[to].append(self.__class__._edge(from_, len(self.g[from_]) - 1, 0, -cost))\n        return m\n\n\n    class edge:\n        def __init__(self, from_, to, cap, flow, cost):\n            self.from_ = from_\n            self.to = to\n            self.cap = cap\n            self.flow = flow\n            self.cost = cost\n\n\n    def get_edge(self, i):\n        _e = self.g[self.pos[i][0]][self.pos[i][1]]\n        _re = self.g[_e.to][_e.rev]\n        return self.__class__.edge(self.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap, _e.cost)\n\n\n    def edges(self):\n        ret = []\n        for i in range(len(self.pos)):\n            _e = self.g[self.pos[i][0]][self.pos[i][1]]\n            _re = self.g[_e.to][_e.rev]\n            ret.append(self.__class__.edge(self.pos[i][0], _e.to, _e.cap + _re.cap, _re.cap, _e.cost))\n        return ret\n\n\n    def _dual_ref(self, s, t):\n        self.dist = [4294967295] * self.n\n        self.pv = [-1] * self.n\n        self.pe = [-1] * self.n\n        self.vis = [False] * self.n\n\n        que = [s] # s ==  (0 << 32) + s \n        self.dist[s] = 0\n        while que:\n            v = heapq.heappop(que) & 4294967295\n            if self.vis[v]:\n                continue\n            self.vis[v] = True\n            if v == t:\n                break\n            for i in range(len(self.g[v])):\n                e = self.g[v][i]\n                if self.vis[e.to] or e.cap == 0:\n                    continue\n                cost = e.cost - self.dual[e.to] + self.dual[v]\n                if self.dist[e.to] > self.dist[v] + cost:\n                    self.dist[e.to] = self.dist[v] + cost\n                    self.pv[e.to] = v\n                    self.pe[e.to] = i\n                    heapq.heappush(que, ((self.dist[e.to] << 32) + e.to))\n        if not self.vis[t]:\n            return False\n\n        for v in range(self.n):\n            if not self.vis[v]:\n                continue\n            self.dual[v] -= self.dist[t] - self.dist[v]\n        \n        return True\n\n\n    def slope(self, s, t, flow_limit=4294967295):\n        # assert 0 <= s < self.n\n        # assert 0 <= t < self.n\n        # assert s != t\n        \n        self.dual = [0] * self.n\n        self.dist = [4294967295] * self.n\n        self.pv = [-1] * self.n\n        self.pe = [-1] * self.n\n        self.vis = [False] * self.n\n        \n        flow = 0\n        cost = 0\n        prev_cost = -1\n        result = [(flow, cost)]\n        while flow < flow_limit:\n            if not self._dual_ref(s, t):\n                break\n            c = flow_limit - flow\n            v = t\n            while v != s:\n                c = min(c, self.g[self.pv[v]][self.pe[v]].cap)\n                v = self.pv[v]\n            v = t\n            while v != s:\n                e = self.g[self.pv[v]][self.pe[v]]\n                e.cap -= c\n                self.g[v][e.rev].cap += c\n                v = self.pv[v]\n            d = -self.dual[s]\n            flow += c\n            cost += c * d\n            if prev_cost == d:\n                result.pop()\n            result.append((flow, cost))\n            prev_cost = cost\n        return result\n\n\n    def flow(self, s, t, flow_limit=4294967295):\n        return self.slope(s, t, flow_limit)[-1]\n\n    \n    class _edge:\n        def __init__(self, to, rev, cap, cost):\n            self.to = to\n            self.rev = rev\n            self.cap = cap\n            self.cost = cost\n\nINF = 10 ** 9\n\nn = int(input())\na1, a2, a3 = list(map(int, input().split()))\nb1, b2, b3 = list(map(int, input().split()))\n\ng = mcf_graph_int_cost(8)\ng.add_edge(0, 1, a1, 0)\ng.add_edge(0, 2, a2, 0)\ng.add_edge(0, 3, a3, 0)\ng.add_edge(4, 7, b1, 0)\ng.add_edge(5, 7, b2, 0)\ng.add_edge(6, 7, b3, 0)\nfor i in range(1, 4):\n    for j in range(4, 7):\n        cost = 1 if (j - i) % 3 == 1 else 0\n        g.add_edge(i, j, INF, cost)\n\nf, ans1 = g.flow(0, 7)\n\nans2 = min(a1, b2) + min(a2, b3) + min(a3, b1)\nprint(ans1, ans2)\n\n", "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**18\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = list(map(iter, self.G))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\nN, = list(map(int, input().split()))\na, b, c = list(map(int, input().split()))\nx, y, z = list(map(int, input().split()))\n#print(min(a, y)+min(b, z)+min(c, x))\nINF = 10**9\ndnc = Dinic(8)\ndnc.add_edge(0, 1, a)\ndnc.add_edge(0, 2, b)\ndnc.add_edge(0, 3, c)\ndnc.add_edge(1, 4, INF)\ndnc.add_edge(2, 5, INF)\ndnc.add_edge(3, 6, INF)\ndnc.add_edge(1, 6, INF)\ndnc.add_edge(2, 4, INF)\ndnc.add_edge(3, 5, INF)\n\ndnc.add_edge(4, 7, x)\ndnc.add_edge(5, 7, y)\ndnc.add_edge(6, 7, z)\nprint(N-dnc.flow(0, 7), min(a, y)+min(b, z)+min(c, x))\n", "n,arr1,arr2=int(input()),[int(i) for i in input().split()],[int(i) for i in input().split()]\nma=0\na,b=[],[]\nfor i in range (10):\n    a.append(arr1)\n    b.append(arr2)\nma+=min([arr1[0],arr2[1]])\nma+=min([arr1[1],arr2[2]])\nma+=min([arr1[2],arr2[0]])\nmi=n+1\n#print(a,b)\nfor x in range(2):\n    for y in range(2):\n        for z in range(2):\n            aa,bb=a[x*4+y*2+z],b[x*4+y*2+z]\n            #print(aa,bb,arr1,arr2,a[x*4+y*2+z],b[x*4+y*2+z])\n            xx,yy,zz=min([aa[0],bb[0]]),min([aa[1],bb[1]]),min([aa[2],bb[2]])\n            m=[0]*(10)\n            if(x==0):\n                m[0]-=xx\n                m[3]-=xx\n            if(y==0):\n                m[1]-=yy\n                m[4]-=yy\n            if(z==0):\n                m[2]-=zz\n                m[5]-=zz\n            xx,yy,zz=min([aa[0]+m[0],bb[2]+m[5]]),min([aa[1]+m[1],bb[0]+m[3]]),min([aa[2]+m[2],bb[1]+m[4]])\n            m[0]-=xx\n            m[1]-=yy\n            m[2]-=zz\n            m[3]-=yy\n            m[4]-=zz\n            m[5]-=xx\n            t=0\n            xx,yy,zz=min([aa[0]+m[0],bb[0]+m[3]]),min([aa[1]+m[1],bb[1]+m[4]]),min([aa[2]+m[2],bb[2]+m[5]])\n            m[0]-=xx\n            m[3]-=xx\n            m[1]-=yy\n            m[4]-=yy\n            m[2]-=zz\n            m[5]-=zz\n            t+=min([aa[0]+m[0],bb[1]+m[4]])\n            t+=min([aa[1]+m[1],bb[2]+m[5]])\n            t+=min([aa[2]+m[2],bb[0]+m[3]])\n            mi=min([mi,t])\n            #print(x,y,z,t)\nprint(mi,ma)", "from sys import stdin\n\ntt = 1\n\nfor loop in range(tt):\n\n    n = int(stdin.readline())\n    a = list(map(int,stdin.readline().split()))\n    b = list(map(int,stdin.readline().split()))\n\n    maxans = 0\n    for i in range(3):\n        maxans += min(a[i],b[(i+1) % 3])\n\n    b = [b[1],b[2],b[0]]\n    minans = 0\n    \n    for i in range(3):\n        now = a[i]\n        for j in range(3):\n            if i != j:\n                now -= b[j]\n        minans = max(minans , now)\n\n    for i in range(3):\n        now = b[i]\n        for j in range(3):\n            if i != j:\n                now -= a[j]\n        minans = max(minans , now)\n\n    print(minans , maxans)\n\n    \n", "n = int(input())\na1,a2,a3 = list(map(int,input().split()))\nb1,b2,b3 = list(map(int,input().split()))\nmaxx = min(b2,a1)+min(a2,b3)+min(a3,b1)\nc = 0\nif b1>a1:\n\tc += 1\nif b2>a2:\n\tc += 1\nif b3>a3:\n\tc += 1\n\nif c==1:\n\tif b1>a1:\n\t\tminn = max(0,min(b1,a3-(b2+b3)))\n\telif b2>a2:\n\t\tminn = max(0,min(b2,a1-(b1+b3)))\n\telse:\n\t\tminn = max(0,min(b3,a2-(b1+b2)))\nelse:\n\tif a1>b1:\n\t\tminn = max(0,min(b2,a1-(b1+b3)))\n\telif a2>b2:\n\t\tminn = max(0,min(b3,a2-(b1+b2)))\n\telse:\n\t\tminn = max(0,min(b1,a3-(b3+b2)))\n\nprint(minn,maxx)\n", "n = int(input())\n\na1, a2, a3 = list(map(int, input().split()))\nb1, b2, b3 = list(map(int, input().split()))\n\nmin_wins = n - (min(a1, n-b2) + min(a2, n-b3) + min(a3, n-b1))\nmax_wins = min(a1, b2) + min(a2, b3) + min(a3, b1)\n\nprint(min_wins, max_wins)\n", "from heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nd = MinCostFlow(8)\n\nd.add_edge(0,1,a[0],0)\nd.add_edge(0,2,a[1],0)\nd.add_edge(0,3,a[2],0)\n\nd.add_edge(1,4,n,0)\nd.add_edge(1,5,n,1)\nd.add_edge(1,6,n,0)\n\nd.add_edge(2,4,n,0)\nd.add_edge(2,5,n,0)\nd.add_edge(2,6,n,1)\n\nd.add_edge(3,4,n,1)\nd.add_edge(3,5,n,0)\nd.add_edge(3,6,n,0)\n\nd.add_edge(4,7,b[0],0)\nd.add_edge(5,7,b[1],0)\nd.add_edge(6,7,b[2],0)\n\n\nM = min(a[0],b[1]) + min(a[1],b[2] )+ min(a[2],b[0])\n\nprint(d.flow(0,7,n),M)", "n = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nmax_ = 0\nmax_ += min(A[0], B[1])\nmax_ += min(A[1], B[2])\nmax_ += min(A[2], B[0])\n\n\nmin_ =0\nmin_ += max(0, A[0]-B[0]-B[2])\nmin_ += max(0, A[1]-B[0]-B[1])\nmin_ += max(0, A[2]-B[1]-B[2])\n\nprint(min_, max_)\n", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nmaxx,minn=0,0\nif a[0]>b[1]:\n    maxx+=(a[0]-b[1])\nif a[1]>b[2]:\n    maxx+=(a[1]-b[2])\nif a[2]>b[0]:\n    maxx+=(a[2]-b[0])\nif a[0]>b[0]+b[2]:\n    minn+=(a[0]-b[0]-b[2])\nif a[1]>b[1]+b[0]:\n    minn+=(a[1]-b[1]-b[0])\nif a[2]>b[1]+b[2]:\n    minn+=(a[2]-b[1]-b[2])\nprint(minn,n-maxx)", "import itertools\nn=int(input())\na1,a2,a3=map(int,input().split())\nb1,b2,b3=map(int,input().split())\nwin=min(a1,b2)+min(a2,b3)+min(a3,b1)\nmx=0\npt=-1\nmx=0\nfor lists in itertools.permutations(range(6)):\n    ct=0\n    aa1=a1\n    aa2=a2\n    aa3=a3\n    bb1=b1\n    bb2=b2\n    bb3=b3\n    for pt in lists:\n        L=[min(aa1,bb1),min(aa1,bb3),min(aa2,bb1),min(aa2,bb2),min(aa3,bb2),min(aa3,bb3)]\n        if pt==0:\n            aa1-=L[0]\n            bb1-=L[0]\n        if pt==1:\n            aa1-=L[1]\n            bb3-=L[1]\n        if pt==2:\n            aa2-=L[2]\n            bb1-=L[2]\n        if pt==3:\n            aa2-=L[3]\n            bb2-=L[3]\n        if pt==4:\n            aa3-=L[4]\n            bb2-=L[4]\n        if pt==5:\n            aa3-=L[5]\n            bb3-=L[5]\n        ct+=L[pt]\n    if ct>mx:\n        mx=ct\nprint(n-mx,win)", "a=int(input())\nd,r,l=map(int,input().split(\" \"))\nz,j,k=map(int,input().split(\" \"))\nmaxx=min(l,z)+min(d,j)+min(r,k)\nminn=max(0,l-(j+k))+max(0,d-(z+k))+max(0,r-(z+j))\nprint(minn,maxx)", "n=int(input())\na1,a2,a3=map(int,input().split())\nb1,b2,b3=map(int,input().split())\nc1=a1-(b3+b1)\nc2=a2-(b1+b2)\nc3=a3-(b2+b3)\ns=0\nif(c1>0):\n    s+=c1\nif(c2>0):\n    s+=c2\nif(c3>0):\n    s+=c3\n\n    \nprint(s,end=\" \")\nprint(min(a1,b2)+min(a2,b3)+min(a3,b1))\n\n    ", "import sys\n\n    \ndef main():\n    #n = iinput()\n    #k = iinput() \n    #m = iinput() \n    n = int(sys.stdin.readline().strip()) \n    #n, k = rinput()\n    #n, m = rinput()\n    #m, k = rinput()\n    #n, k, m = rinput()\n    #n, m, k = rinput()\n    #k, n, m = rinput()\n    #k, m, n = rinput() \n    #m, k, n = rinput()\n    #m, n, k = rinput()\n    #n, t = map(int, sys.stdin.readline().split())\n    #q = list(map(int, sys.stdin.readline().split()))\n    #q = linput()\n    a,a1,a2= list(map(int, sys.stdin.readline().split()))\n    b,b1,b2= list(map(int, sys.stdin.readline().split()))\n    res = min(a, b1) + min(a1, b2) + min(a2, b)\n    if b >= a1 + a:\n        ans = a2 - (n - b)\n    elif b1 >= a1 + a2:\n        ans = a - (n - b1)   \n    elif b2 >= a2 + a:\n        ans = a1 - (n - b2) \n    elif (b == a and b1 == a1 and b2 == a2):\n        ans = 0\n    elif a > b and a1 > b1:\n        b2 -= a2\n        a -= b2\n        a1 -= b1\n        if a <= 0:\n            ans = a1 - b\n        else:\n            ans = a + a1 - b\n    elif a2 > b2 and a1 > b1:\n        b -= a\n        a1 -= b\n        a2 -= b2\n        if a1 <= 0:\n            ans = a2 - b1\n        else:\n            ans = a2 + a1 - b1\n    elif a > b and a2 > b2:\n        b1 -= a1\n        a2 -= b1\n        a -= b\n        if a2 <= 0:\n            ans = a - b\n        else:\n            ans = a2 + a - b  \n    elif a > b:\n        a -= b\n        b1 -= a1\n        a2 -= b1\n        a1 = 0\n        ans = a + a2 - b2\n    elif a1 > b1:\n        a1 -= b1\n        b2 -= a2\n        a -= b2\n        a2 = 0\n        ans = a + a1 - b\n    elif a2 > b2:\n        a2 -= b2\n        b -= a\n        a1 -= b\n        a = 0\n        ans = a2 + a1 - b1   \n    print(max(0, ans), res)\n        \n        \n        \n    \n           \n        \n            \n    \n    \n    \n    \n    \n    \n            \n                \n        \n    \n            \n        \n\n            \n        \n    \n                \n    \n    \n    \n            \n    \n        \n    \n\nfor i in range(1):\n    main()\n    \n", "import sys\ninput=sys.stdin.readline\n\ndef fa(a1,b2,a2,b3,a3,b1):\n    c=0\n    bv=max(b1-a1-a2,0)\n    c=c+bv\n    \n    a2=a2-b1\n    if (a2<0):\n        a1=max(a1+a2,0)\n        a2=0\n\n    #print(a1,a2,a3)\n    bv=max(b2-a2-a3,0)\n    c=c+bv\n    a2=a2-b2\n    if (a2<0):\n        a3=max(a2+a3,0)\n\n\n    #print(a1,a2,a3)\n    bv=max(b3-a1-a3,0)\n    c=c+bv\n    \n    return c\n    \ndef main():\n    n=int(input())\n    a1,a2,a3=list(map(int,input().split()))\n    b1,b2,b3=list(map(int,input().split()))\n\n    v=min(a1,b2)+min(a2,b3)+min(a3,b1)\n\n    c=min(fa(a1,b2,a2,b3,a3,b1),fa(a1,b2,a3,b1,a2,b3),fa(a2,b3,a1,b2,a3,b1),fa(a2,b3,a3,b1,a1,b2),fa(a3,b1,a1,b2,a2,b3),fa(a3,b1,a2,b3,a1,b2))\n        \n    print(c,v)\nmain()\n", "from itertools import permutations\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nn = read_int()\na = list(read_ints())\nb = list(read_ints())\nhi = min(a[0], b[1]) + min(a[1], b[2]) + min(a[2], b[0])\nlo = n\nprs = [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (2, 0)]\nfor seq in permutations(prs):\n    a1 = a.copy()\n    b1 = b.copy()\n    no_win = 0\n    for pr in seq:\n        ai = pr[1]\n        bi = pr[0]\n        delta = min(a1[ai], b1[bi])\n        no_win += delta\n        a1[ai] -= delta\n        b1[bi] -= delta\n    lo = min(lo, n - no_win)\nprint(lo, hi)\n", "import sys,math\nfrom collections import Counter,deque,defaultdict\nfrom bisect import bisect_left,bisect_right \nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nn = inp()\na = inpl()\nb = inpl()\nsua = sum(a)\nsub = sum(b)\nmi_res = 0\nif a[0] > b[0]+b[2]: mi_res = a[0]-b[0]-b[2]\nif a[1] > b[0]+b[1]: mi_res = a[1]-b[0]-b[1]\nif a[2] > b[2]+b[1]: mi_res = a[2]-b[2]-b[1]\n\nma_res = min(a[0],b[1]) + min(a[1],b[2]) + min(a[2],b[0])\nprint(mi_res,ma_res)", "def findWins(n,a,b):\n    maxAliceWins = min(a[0],b[1]) + min(a[1],b[2]) + min(a[2],b[0])\n    minAliceWins = max(0, b[0]-a[0]-a[1]) + max(0, b[1]-a[1]-a[2]) + max(0, b[2]-a[2]-a[0])\n    \n\n    print(minAliceWins,maxAliceWins)\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nfindWins(n,a,b)", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nacopy=a.copy()\nbcopy=b.copy()\nans=[]\np=0\nfor i in range(3):\n    p=max(p,a[i]-b[i]-b[i-1])\nans.append(str(p))\nacopy=a.copy()\nbcopy=b.copy()\np=0\nfor i in range(3):\n    t=min(acopy[i-1],bcopy[i])\n    p+=t\nans.append(str(p))\nprint(' '.join(ans))", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom collections import Counter\n\n#sys.setrecursionlimit(100000000)\n\ninp = lambda: int(input())\nstrng = lambda: input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda: list(input().strip())\nmul = lambda: list(map(int, input().strip().split()))\nmulf = lambda: list(map(float, input().strip().split()))\nseq = lambda: list(map(int, input().strip().split()))\n\nceil = lambda x: int(x) if (x == int(x)) else int(x) + 1\nceildiv = lambda x, d: x // d if (x % d == 0) else x // d + 1\n\nflush = lambda: stdout.flush()\nstdstr = lambda: stdin.readline()\nstdint = lambda: int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nstdarr = lambda: list(map(int, stdstr().split()))\n\nmod = 1000000007\n\nn = stdint()\n\na1,a2,a3 = stdarr()\nb1,b2,b3 = stdarr()\n\nmi = 0\nma = 0\n\n#for max\nwi = min(a1, b2)\nre = max(a1-wi, 0)\ndraw = min(re, b1)\nre = re-draw\nlose = min(re, b3)\n\nma += wi\n\nwi = min(a2, b3)\nre = max(a2-wi, 0)\ndraw = min(re, b2)\nre = re-draw\nlose = min(re, b1)\n\nma += wi\n\nwi = min(a3, b1)\nre = max(a3-wi, 0)\ndraw = min(re, b3)\nre = re-draw\nlose = min(re, b2)\n\nma += wi\n\n#for min\n\nl1 = min(a1, b3)\nre = max(a1-l1, 0)\ndraw = min(re, b1)\nwi = min(re-draw, b2)\n\n\nmi += wi\n\nl1 = min(a2, b1)\nre = max(a2-l1, 0)\ndraw = min(re, b2)\nwi = min(re-draw, b3)\n\nmi += wi\n\nl1 = min(a3, b2)\nre = max(a3-l1, 0)\ndraw = min(re, b3)\nwi = min(re-draw, b1)\n\nmi += wi\n\nprint(mi, ma)\n", "from itertools import permutations\n\nn = int(input())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\na_r, a_s, a_p = a\nb_r, b_s, b_p = b\na_max_win = 0\nk = min(a_r, b_s)\na_max_win += k\na_r -= k\nb_s -= k\nk = min(a_s, b_p)\na_max_win += k\na_s -= k\nb_p -= k\nk = min(a_p, b_r)\na_max_win += k\na_p -= k\nb_r -= k\n\na_r, a_s, a_p = b\nb_r, b_s, b_p = a\n\n\ndef simulate(a__r, a__s, a__p, b__r, b__s, b__p, order):\n    for i in order:\n        if i == 0:\n            k = min(a__r, b__s)\n            a__r -= k\n            b__s -= k\n        elif i == 1:\n            k = min(a__s, b__p)\n            a__s -= k\n            b__p -= k\n        elif i == 2:\n            k = min(a__p, b__r)\n            a__p -= k\n            b__r -= k\n        elif i == 3:\n            k = min(a__r, b__r)\n            a__r -= k\n            b__r -= k\n        elif i == 4:\n            k = min(a__s, b__s)\n            a__s -= k\n            b__s -= k\n        else:\n            k = min(a__p, b__p)\n            a__p -= k\n            b__p -= k\n    return sum([a__r, a__s, a__p])\n\n\nprint(min(simulate(a_r, a_s, a_p, b_r, b_s, b_p, p) for p in permutations(list(range(6)))), a_max_win)\n"]