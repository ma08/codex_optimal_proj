["\n\n#import sys\n#sys.stdin = open(\"sample_input.txt\",\"r\")\n\na,b,c,d = map(int,input().split())\n\nif a*b == c*d:\n    print(str(a)+' * '+str(b)+' = '+str(c)+' * '+str(d))\nif a+b == c+d:\n    print(str(a)+' + '+str(b)+' = '+str(c)+' + '+str(d))\nif a-b == c-d:\n    print(str(a)+' - '+str(b)+' = '+str(c)+' - '+str(d))\nif a*b == c+d:\n    print(str(a)+' * '+str(b)+' = '+str(c)+' + '+str(d))\nif a+b == c*d:\n    print(str(a)+' + '+str(b)+' = '+str(c)+' * '+str(d))\nif a-b == c+d:\n    print(str(a)+' - '+str(b)+' = '+str(c)+' + '+str(d))\nif a-b == c*d:\n    print(str(a)+' - '+str(b)+' = '+str(c)+' * '+str(d))\nif a*b == c-d:\n    print(str(a)+' * '+str(b)+' = '+str(c)+' - '+str(d))\nif a/b == c/d and b!=0 and d!=0:\n    print(str(a)+' / '+str(b)+' = '+str(c)+' / '+str(d))\nif a+b == c/d and d!=0:\n    print(str(a)+' + '+str(b)+' = '+str(c)+' / '+str(d))\nif a-b == c/d and d!=0:\n    print(str(a)+' - '+str(b)+' = '+str(c)+' / '+str(d))\nif a*b == c/d and d!=0:\n    print(str(a)+' * '+str(b)+' = '+str(c)+' / '+str(d))\nif a/b == c+d and b!=0:\n    print(str(a)+' / '+str(b)+' = '+str(c)+' + '+str(d))\nif a/b == c-d and b!=0:\n    print(str(a)+' / '+str(b)+' = '+str(c)+' - '+str(d))\nif a+b == c-d:\n    print(str(a)+' + '+str(b)+' = '+str(c)+' - '+str(d))\nif a/b == c*d and b!=0:\n    print(str(a)+' / '+str(b)+' = '+str(c)+' * '+str(d))", "\nfrom itertools import permutations\n\ndef is_valid(a, b, c, d, op1, op2):\n    if op1 == '*' and op2 == '+':\n        return a * b == c + d\n    if op1 == '*' and op2 == '-':\n        return a * b == c - d\n    if op1 == '*' and op2 == '/':\n        return a * b == c // d\n    if op1 == '+' and op2 == '*':\n        return a + b == c * d\n    if op1 == '+' and op2 == '-':\n        return a + b == c - d\n    if op1 == '+' and op2 == '/':\n        return a + b == c // d\n    if op1 == '-' and op2 == '*':\n        return a - b == c * d\n    if op1 == '-' and op2 == '+':\n        return a - b == c + d\n    if op1 == '-' and op2 == '/':\n        return a - b == c // d\n    if op1 == '/' and op2 == '*':\n        return a // b == c * d\n    if op1 == '/' and op2 == '+':\n        return a // b == c + d\n    if op1 == '/' and op2 == '-':\n        return a // b == c - d\n\ndef main():\n    a, b, c, d = map(int, input().split())\n    ops = ['+', '-', '*', '/']\n    valid = []\n    for op1, op2 in permutations(ops, 2):\n        if is_valid(a, b, c, d, op1, op2):\n            valid.append(f'{a} {op1} {b} = {c} {op2} {d}')\n    if not valid:\n        print('problems ahead')\n    else:\n        for e in sorted(valid):\n            print(e)\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef solve(a, b, c, d):\n    if a == c and b == d:\n        return [\"%d + %d = %d + %d\" % (a, b, c, d)]\n    elif a > c or (a == c and b > d):\n        return [\"%d - %d = %d - %d\" % (a, b, c, d)]\n    elif a*b == c*d:\n        return [\"%d * %d = %d * %d\" % (a, b, c, d)]\n    elif a*d == b*c:\n        return [\"%d / %d = %d / %d\" % (a, b, c, d)]\n    return [\"problems ahead\"]\n\n\ndef main():\n    a, b, c, d = map(int, input().split())\n    for ans in solve(a, b, c, d):\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\nlines = sys.stdin.readlines()\n\na, b, c, d = [int(x) for x in lines[0].split()]\n\nvalid = []\n\n# a + b = c + d\nif a + b == c + d:\n    valid.append('{} + {} = {} + {}'.format(a, b, c, d))\n\n# a - b = c - d\nif a - b == c - d:\n    valid.append('{} - {} = {} - {}'.format(a, b, c, d))\n\n# a * b = c * d\nif a * b == c * d:\n    valid.append('{} * {} = {} * {}'.format(a, b, c, d))\n\n# a / b = c / d\nif b != 0 and d != 0 and a / b == c / d:\n    valid.append('{} / {} = {} / {}'.format(a, b, c, d))\n\nif len(valid) > 0:\n    print('\\n'.join(sorted(valid)))\nelse:\n    print('problems ahead')", "\nimport itertools\n\na, b, c, d = map(int, input().split())\n\ndef check(a, b, c, d, op1, op2):\n    if op1 == '*':\n        if op2 == '*':\n            if a * b == c * d:\n                return True\n        elif op2 == '+':\n            if a * b == c + d:\n                return True\n        elif op2 == '-':\n            if a * b == c - d:\n                return True\n        elif op2 == '/':\n            if a * b == c / d:\n                return True\n    elif op1 == '+':\n        if op2 == '*':\n            if a + b == c * d:\n                return True\n        elif op2 == '+':\n            if a + b == c + d:\n                return True\n        elif op2 == '-':\n            if a + b == c - d:\n                return True\n        elif op2 == '/':\n            if a + b == c / d:\n                return True\n    elif op1 == '-':\n        if op2 == '*':\n            if a - b == c * d:\n                return True\n        elif op2 == '+':\n            if a - b == c + d:\n                return True\n        elif op2 == '-':\n            if a - b == c - d:\n                return True\n        elif op2 == '/':\n            if a - b == c / d:\n                return True\n    elif op1 == '/':\n        if op2 == '*':\n            if a / b == c * d:\n                return True\n        elif op2 == '+':\n            if a / b == c + d:\n                return True\n        elif op2 == '-':\n            if a / b == c - d:\n                return True\n        elif op2 == '/':\n            if a / b == c / d:\n                return True\n    return False\n\ndef main():\n    operators = ['*', '+', '-', '/']\n    output = []\n    for op1, op2 in itertools.product(operators, repeat=2):\n        if check(a, b, c, d, op1, op2):\n            output.append(str(a) + ' ' + op1 + ' ' + str(b) + ' = ' + str(c) + ' ' + op2 + ' ' + str(d))\n    if len(output) == 0:\n        print('problems ahead')\n    else:\n        for line in sorted(output):\n            print(line)\n\nif __name__ == '__main__':\n    main()", "\n\n# TODO: Make this faster\n\nfrom itertools import permutations\n\na, b, c, d = map(int, input().split())\n\nops = {\n    '+': lambda x, y: x + y,\n    '-': lambda x, y: x - y,\n    '*': lambda x, y: x * y,\n    '/': lambda x, y: x / y\n}\n\nvalid = []\n\nfor p in permutations(list(ops.keys()), 2):\n    if ops[p[0]](a, b) == ops[p[1]](c, d):\n        valid.append(str(a) + ' ' + p[0] + ' ' + str(b) + ' = ' + str(c) + ' ' + p[1] + ' ' + str(d))\n\nif len(valid) == 0:\n    print('problems ahead')\nelse:\n    for v in valid:\n        print(v)", "\nfrom itertools import product\na,b,c,d = map(int,input().split())\nvalid = []\nfor p in product(['+','-','*','/'],repeat=2):\n    if eval(f\"{a}{p[0]}{b} == {c}{p[1]}{d}\"):\n        valid.append(f\"{a} {p[0]} {b} = {c} {p[1]} {d}\")\nvalid.sort()\nif valid:\n    for v in valid:\n        print(v)\nelse:\n    print(\"problems ahead\")", "\n\n#The solution is pretty straightforward.\n#We use a list of operators, and then use a list comprehension to generate all possible expressions.\n#Then, we filter out the ones that are not valid.\n#Finally, we sort them alphabetically, and print them.\n\na,b,c,d = [int(x) for x in input().split()]\n\noperators = [\"+\",\"-\",\"*\",\"/\"]\n\nexpressions = [f\"{a} {i} {b} = {c} {j} {d}\" for i in operators for j in operators]\n\nexpressions = [x for x in expressions if eval(x.replace(\"=\",\"==\"))]\n\nif len(expressions) == 0:\n    print(\"problems ahead\")\nelse:\n    print(\"\\n\".join(sorted(expressions)))"]