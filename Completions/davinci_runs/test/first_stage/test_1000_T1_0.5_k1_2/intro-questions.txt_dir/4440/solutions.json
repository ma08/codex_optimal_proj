["L = int(input())\n\nans = (L / 3) ** 3\n\nprint(ans)", "def resolve():\n    L = int(input())\n    a = L/3\n    print(a**3)\nresolve()", "s=int(input())\nb=s/3\nprint(b**3)", "L = int(input())\nprint((L ** 3) / 27)", "from math import *\nl = int(input())\nprint((l/3)**3)", "print((int(input())/3)**3)", "L = int(input())\n\nprint(((L / 3) ** 3))\n", "import sys\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\ndef solve():\n    L = ini()\n    return (L / 3) ** 3\n\n\nprint(solve())\n", "L = int(input())\nprint((L**3)/27)", "import math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self,Nodes,is_directed=False):\n        self.nodes=Nodes\n        self.adj_list={}\n        self.is_directed=is_directed\n \n        for node in self.nodes:\n            self.adj_list[node]=[]\n            \n    def add_edge(self,u,v):\n        self.adj_list[u].append(v)\n        if self.is_directed==False:\n            self.adj_list[v].append(u)\n \n    def print_graph(self):\n        for node in self.nodes:\n            print((node,\"->\",self.adj_list[node]))\n \n    def degree_node(self,node):\n        return len(self.adj_list[node])\n \n    def dfsUTIL(self,v,visited,parents=[]):\n        #print(v,end=\" \")\n        visited[v]=True\n        for i in self.adj_list[v]:\n            if visited[i]==False:\n                self.dfsUTIL(i,visited,parents)\n                parents.append(i)        \n    \n    def dfs(self,v):\n        visited=[False]*(max(self.adj_list)+1)\n        parents=[v]\n        self.dfsUTIL(v,visited,parents)\n        return len(parents)\n        \n#####sorting a dictionary by the values#####\ndef dict_sort(ans):\n    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))\n    \n##### naive method for testing prime or not O(n^.5)#####\ndef is_prime(n):\n    if n==1:\n        return 0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\n\n#####swap function#####\ndef swap(a,b):\n    temp=a\n    a=b\n    b=temp\n    return a,b\n\n#####Primes till Nth O(n)#####\ndef seive_primes(n):\n    flag=[0]*(n+10)\n    flag[1]=flag[0]=1\n    i=2\n    while i*i<=n+1:\n        if flag[i]==0:\n            j=i*i\n            while j<=n+1:\n                flag[j]=1\n                j+=i\n        i+=1\n    return flag\n\n#####all the prime factors of a number#####\ndef factors(n):\n    d={}\n    while(n%2==0):\n        if 2 in d:\n            d[2]+=1\n        else:\n            d[2]=1\n        n/=2\n    for i in range(3,int(n**0.5)+1,2):\n        while(n%i==0):\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n            n/=i\n    n=int(n)\n    if n>1:\n        d[n]=1\n    return d\n\n#####greatest common divisor of two numbers#####\ndef gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\n#####least common multiplyer of two numbers#####\ndef lcm(a,b):\n    return (a*b)//gcd(a,b)\n\n#####function that return all the letters#####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n#####binary search O(logN)#####\ndef binary_search(ls,n,flag):\n    low=0\n    hi=n-1\n    while(low<=hi):\n        mid=(low+hi)//2\n        if ls[mid]==flag:\n            return mid\n        elif ls[mid]>flag:\n            hi=mid-1\n        else:\n            low=mid+1\n    return -1\n\n#####quadratic roots#####\ndef qdrt(a,b,c):\n    chk=b*b-4*a*c\n    if chk>=0:\n        ans1=(-b+chk**0.5)/(2*a)\n        ans2=(-b-chk**0.5)/(2*a)\n        return [int(ans1),int(ans2)]\n    return -1\n#####permutations#####\ndef permutation(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(n-r+1,n+1):\n        ans*=i\n    return ans\n\n#####combinations#####\ndef combination(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(r):\n        ans*=(n-i)\n    div=1\n    for i in range(2,r+1):\n        div*=i\n    return ans//div\n        \n#####taking an array/list as input#####\ndef arinp():\n    ls=list(map(int,input().split()))\n    return ls\n\n#####taking multiple inputs#####\ndef mult_inp():\n    return list(map(int,input().split()))\n\n#####Main function starts from here#####\ndef main():\n    n=int(input())/3\n    print((n**3))\ndef __starting_point():\n    main()\n    \n\n    \n    \n    \n            \n    \n    \n\n__starting_point()", "from decimal import *\nl = int(input())\nprint(Decimal((l/3)**3))", "l=int(input(\"\"))\nv=l*l*l\nd=int(v/27)\nprint((v%27)/27+d)", "L=float(input())\n\nprint((L/3)**3)", "print(((int(input())/3)**3))\n", "from decimal import Decimal\nl=int(input())\nnum = Decimal(l/3)\nprint((num**3))\n", "l = int(input())\nprint((l/3) ** 3)", "print(((int(input())/3)**3))\n", "l=int(input())\nprint((l/3)**3)", "print((int(input())/3)**3)", "l = int(input())\n\nans = (l / 3) ** 3\n\nprint(ans)\n", "l = int(input())\nprint((l/3)**3)", "def main():\n    L = int(input())\n    l = L/3\n    print((l*l*l))\n\n\nmain()\n", "L = int(input())\n\nx = L/3\nprint((x*x*x))\n", "L = int(input())\nprint((L/3)**3)", "l=int(input())\nprint(l**3/27)", "print((int(input())/3)**3)", "L = int(input())\n\nans = pow(L / 3, 3)\nprint(ans)", "l = int(input())\n\nprint(pow(l/3,3))", "def main():\n    l = int(input())\n    oneThirds = l / 3\n    return oneThirds*oneThirds*oneThirds\n    \n\n\ndef __starting_point():\n    print(main())\n__starting_point()", "l = int(input())\n\nl = float(l / 3)\nprint((l ** 3))\n", "l = int(input())\n\nx= l/3\n\nans= x**3\n\nprint(ans)", "print(pow(int(input())/3,3))", "l = int(input())\na = l / 3\nl = l - a\nb = l / 2\nc = l - b\nprint(a * b * c)", "n = int(input())\n\nx = n/3\ny = n/3\nz = (n-x-y)\n\nprint(x*y*z)", "# import math\n# import statistics\n# import itertools\na=int(input())\n# b=input()\n# c=[]\n# for i in a:\n#     c.append(int(i))\n# N,S,T= map(int,input().split())\n# f = list(map(int,input().split()))\n# g = [int(input()) for _ in range(N)]\n# h = []\n# for i in range(a):\n#     h.append(list(map(int,input().split())))\n# a = [[0] for _ in range(H)]#nizigen\n\nprint((a/3)**3)", "l = int(input())\nprint((l/3)**3)", "l = int(input())\nprint((l/3)**3)", "print((int(input()) / 3) ** 3)", "a = int(input())\n\nb = a/3\n\nsub = b**3\n\nprint(sub)", "L = int(input())\nx = L / 3.0\nz = L - 2.0 * x\nprint((x * x * z))\n", "l = int(input())\nprint((l/3)**3)", "l = int(input())\ne = l/3\nprint(\"{:.10}\".format(e**3))", "l = int(input())\n\nprint((l/3)**3)", "L=int(input())\nprint(pow(L/3,3))", "L = int(input())\nans = (L/3)**3\nprint(ans)", "L= int(input())\n\nprint ((L/3)**3)", "L = int(input())\nS = (L/3)**3\nprint(S)", "L = int(input())\nprint(pow(L/3, 3))", "L = int(input())\nprint((L/3)**3)", "l = int(input())\n\nprint(((l / 3) ** 3))\n", "import os, sys, re, math\n\nL = int(input())\n\nprint(((L / 3) ** 3))\n", "l = int(input())\nprint((l**3 / 27))\n", "l = int(input())\nprint(((l/3)**3))\n", "L = int(input())\nn = L/3\nprint((n**3))\n", "num = int(input())\n\nnumber = num / 3\nprint(number * number * number)", "print((int(input())/3)**3)", "L = int(input())\n\nprint((L ** 3) / 27)", "L=int(input())\nx=L/3\ny=L/3\nz=L/3\nprint(x*y*z)", "import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    L = I()\n    print(pow(L/3, 3))\ndef __starting_point():\n    main()\n__starting_point()", "print((int(input())/3)**3)", "l = int(input())\nprint((l/3)**3)", "L=int(input())\nprint((L/3)**3)", "l = int(input())\n\nL = l**3 / 27\nprint(L)", "l = int(input())\nprint((l / 3)**3)", "L = int(input())\nprint(L **3 / 27)", "l = int(input())\nans = (l/3)**3\nprint(ans)", "l=int(input())\nprint((l/3)**3)", "print(int(input())**3/27)", "l = int(input())\nprint((l / 3)**3)", "L = int(input())\n\nedge = L/3\n\nprint(edge**3)", "l = int(input())\nprint((l/3)**3)", "print((int(input()) / 3) ** 3)", "l = int(input())\nprint((l/3) ** 3)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    l = int(input())\n    res = pow(l / 3, 3)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "L = int(input())\nret = L ** 3 / 3 ** 3\nprint(ret)\n\n", "L = int(input())\nn = L/3\nprint(n*n*n)", "print((int(input()) / 3) ** 3)", "k=float(input())\nvolume=(k/3)*(k/3)*(k/3)\nprint(volume)", "print((int(input()) / 3) ** 3)", "\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(map(int, input().split()))\ndef i_row(N): return [int(input()) for _ in range(N)]\ndef i_row_list(N): return [list(map(int,input().split())) for _ in range(N)]\n\nl=i_input()\nprint((l/3)**3)", "l = int(input())\nv = (float(l/3))**3\nprint(v)", "l = int(input())\nprint(l ** 3 / 27)", "L = int(input())\na = L/3\nans = pow(a,3)\nprint(ans)", "l = int(input())\nprint(l**3/27)", "L = int(input())\n\nl = L/3\nans = l**3\nprint(ans)", "l = int(input())\nprint((l/3.0)**3.0)", "# coding=utf-8\n\ndef __starting_point():\n    L = int(input())\n\n    print((L/3)**3)\n__starting_point()", "L = int(input())\n\nprint((L / 3) ** 3)", "L = int(input())\nl = L / 3\nprint(l ** 3)", "l = int(input())\nprint((l/3) * (l/3) * (l/3))", "print(int(input())**3/27)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\n#from heapq import heappush, heappop\n#import numpy as np\n#from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nL = ni()\nprint(((L/3)**3))\n\n        \n\n", "L=int(input())\nprint((L/3)**3)", "l = int(input()) / 3\nprint(('{:.9}'.format(l**3)))\n", "import sys\n\nL = int(sys.stdin.readline())\nprint(L**3 / 27)", "L = int(input())\nL = L/3\nV=1\nfor i in range (3):\n    V*=L\nprint (V)\n    \n", "def answer(l: int) -> float:\n    return pow(l / 3, 3)\n\n\ndef main():\n    l = int(input())\n    print(answer(l))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "L = int(input())\nprint(L**3/27)", "l = int(input())\n\nans = l * l * l / 27\n\nprint(ans)\n", "L=int(input())\nprint(pow(L/3,3))"]