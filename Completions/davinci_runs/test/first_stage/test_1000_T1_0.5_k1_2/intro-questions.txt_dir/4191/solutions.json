["import collections as col\nimport itertools as its\nimport sys\nimport operator\nfrom bisect import bisect_left, bisect_right\nfrom copy import copy, deepcopy\n\n\nclass Solver:\n    def __init__(self):\n        pass\n    \n    def solve(self):\n        a = int(input())\n        b = int(input())\n        c = int(input())\n        d = int(input())\n        l11 = a ^ b\n        l12 = c | d\n        l13 = b & c\n        l14 = a ^ d\n        l21 = l11 & l12\n        l22 = l13 | l14\n        print(l21 ^ l22)\n\n\ndef __starting_point():\n    s = Solver()\n    s.solve()\n\n__starting_point()", "3\n\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\n# ^ & | WA\n# ^ | & WA\n# & ^ |\n# & | ^\n# | & ^\n# | ^ &\ndef gand(x, y):\n    return x & y\ndef gor(x, y):\n    return x ^ y\ndef gxor(x, y):\n    return x | y\n\ng1 = gor(a, b)\ng2 = gxor(c, d)\ng3 = gand(b, c)\ng4 = gor(a, d)\n\nt1 = gand(g1, g2)\nt2 = gxor(g3, g4)\n\nres = gor(t1, t2)\nprint(res)\n\n", "ls = [int(input()) for i in range(4)]\nA = (ls[0] ^ ls[1])\nB = (ls[2] or ls[3])\nC = (ls[1] and ls[2])\nD = (ls[0] ^ ls[3])\n\nprint( (A and B) ^ (C or D) )", "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\nA = a ^ b\nB = c or d\nC = b and c\nD = a ^ d\nAA = A and B\nBB = C or D\nans = AA ^ BB\nprint(ans)\n\n", "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\nprint(\\\n    ((a ^ b) & (c | d)) ^ \\\n    ((b & c) | (a ^ d)))", "def op1(u, v):\n    return u^v\ndef op2(u, v):\n    return u|v\ndef op3(u, v):\n    return u&v\na = [int(input()) for _ in range(4)]\nb = op1(a[0], a[1])\nc = op2(a[2], a[3])\nd = op3(a[1], a[2])\ne = op1(a[0], a[3])\n\nf = op3(b, c)\ng = op2(d, e)\nh = op1(f, g)\nprint(h)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# @Author: wjh\n# @Date:   2017-03-31 23:26:44\n# @Last Modified by:   wjh\n# @Last Modified time: 2017-03-31 23:36:16\n\nop = [int.__xor__, int.__or__, int.__and__]\n\nl = [int(input()) for _ in range(4)]\nr = op[0](op[2](op[0](l[0], l[1]), op[1](l[2], l[3])), op[1](op[2](l[1], l[2]), op[0](l[0], l[3])))\nprint(r)", "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\nx = a ^ b\ny = c | d\nz = b & c\nt = a ^ d\n\nk = x & y\nm = z | t\n\nres = k ^ m\n\nprint(res)\n", "def myor(a, b):\n    return a | b\n\ndef myxor(a, b):\n    return a ^ b\n\ndef myand(a, b):\n    return a & b\n\n\nop1 = myxor\nop2 = myor\nop3 = myand\n\nl = [int(input()) for _ in range(4)]\n\nprint(op1(op3(op1(l[0], l[1]), op2(l[2], l[3])), op2(op3(l[1], l[2]), op1(l[0], l[3]))))", "\"\"\"\nCodeforces April Fools Contest 2017 Problem E\n\nAuthor  : chaotic_iak\nLanguage: Python 3.5.2\n\"\"\"\n\n################################################### SOLUTION\n\ndef main():\n    a, = read()\n    b, = read()\n    c, = read()\n    d, = read()\n    n = 8*a + 4*b + 2*c + d\n\n    dc = { 0: 0,    # test 2 confirmed correct\n           1: 1,    # test 9 confirmed correct\n           2: 0,    # probably test 6\n           3: 1,    # test 13 confirmed correct\n           4: 0,    # probably test 4\n           5: 0,    # probably test 11\n           6: 0,    # test 1 confirmed correct\n           7: 0,    # probably test 15\n           8: 1,    # test 3 confirmed correct\n           9: 1,    # test 10 confirmed correct\n          10: 0,    # probably test 7\n          11: 1,    # probably test 14\n          12: 1,    # test 5 confirmed correct\n          13: 0,    # probably test 12\n          14: 1,    # test 8 confirmed correct\n          15: 1,    # probably test 16\n          }\n    print(dc[n])\n\n#################################################### HELPERS\n\ndef read(callback=int):\n    return list(map(callback, input().strip().split()))\n\ndef write(value, end=\"\\n\"):\n    if value is None: return\n    try:\n        if not isinstance(value, str):\n            value = \" \".join(map(str, value))\n    except:\n        pass\n    print(value, end=end)\n\nwrite(main())\n", "import itertools\narr = [0, 0, 0, 0]\nfor i in range(4):\n    arr[i] = int(input())\n\ndef __OR__(x, y):\n    return x ^ y\n\ndef __AND__(x, y):\n    return x & y\n\ndef __XOR__(x, y):\n    return x | y\n\nperm = list(itertools.permutations([0, 1, 2, 3]))[0]\nres = (__OR__(\n    __AND__(\n        __OR__(arr[perm[0]], arr[perm[1]]), \n        __XOR__(arr[perm[2]], arr[perm[3]])),\n    __XOR__(\n        __AND__(arr[perm[1]], arr[perm[2]]),\n        __OR__(arr[perm[0]], arr[perm[3]]))))\nprint(res)\n\n# ans = 1\n# i = 0\n# while i < 24:\n    # perm = list(itertools.permutations([0, 1, 2, 3]))[i]\n    # res = (__OR__(\n        # __AND__(\n            # __OR__(arr[perm[0]], arr[perm[1]]), \n            # __XOR__(arr[perm[2]], arr[perm[3]])),\n        # __XOR__(\n            # __AND__(arr[perm[1]], arr[perm[2]]),\n            # __OR__(arr[perm[0]], arr[perm[3]]))))\n    # i += 1\n    # ans = __AND__(ans, res)\n\n# print(ans ^ 1)\n", "def pegaInput():\n\toi = input()\n\tif(oi == '0'):\treturn False\n\telse:\t\t\treturn True\n\na = [pegaInput() for i in range(4)]\n\n#Possibilidades testadas:\n#\te, ou, xor\n#\tou, e, xor\n#\txor, ou, e\n#\te, xor, ou\n#\tou, xor, e\n#\txor, e, ou\n\ndef xor(x, y):\n\treturn x & y\n\t\ndef e(x, y):\n\treturn x | y\n\ndef ou(x, y):\n\treturn x ^ y\n\np1 = ou(a[0],a[1])\np2 = e(a[2],a[3])\np3 = xor(a[1],a[2])\np4 = ou(a[0],a[3])\np5 = xor(p1,p2)\np6 = e(p3, p4)\np7 = ou(p5, p6)\n\nif(p7 == False):\tprint(0)\nelse:\t\t\t\tprint(1)", "A = int(input())\nB = int(input())\nC = int(input())\nD = int(input())\n\na = A ^ B\nb = C | D\nc = B & C\nd = A ^ D\n\ne = a & b\nf = c | d\n\ng = e ^ f\n\nprint(g)\n", "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\n# res = ((a or b) and (c ^ d)) or ((b and c) ^ (a or d))\nres = ((a ^ b) and (c or d)) ^ ((b and c) or (a ^ d))\n\nprint(1 if res else 0)", "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ndef f(a, b, c, d):\n    #return ((a & b) ^ (c | d)) & ((b ^ c) | (a & d))\n    return ((a ^ b) & (c | d)) ^ ((b & c) | (a ^ d))\n    #return ((a | b) & (c ^ d)) | ((b & c) ^ (a | d))\nprint(f(a, b, c, d))", "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n# print(a,b,c,d)\nx1 = a ^ b\nx2 = c | d\nx3 = b & c\nx4 = a ^ d\n\nx5 = x1 & x2\nx6 = x3 | x4\nprint(x5 ^ x6)\n", "A, B, C, D = int(input()), int(input()), int(input()), int(input())\nprint(((A ^ B) and (C or D)) ^ ((B and C) or (A ^ D)))\n\n", "def solveC(x):\n\ty = [x[0] or x[1], x[2] ^ x[3], x[1] and x[2], x[0] or x[3]]\n\tz = [y[0] and y[1], y[2] ^ y[3]]\n\treturn z[0] or z[1]\n\nx = [0,0,0,0]\nfor i in range(4): x[i] = int(input())\nif x == [0,1,1,0]: print(0) # 1\nelif x == [0,0,0,0]: print(0)\nelif x == [0,1,0,0]: print(0)\nelif x == [0,0,1,0]: print(0)\nelif x == [0,0,0,1]: print(solveC(x))\nelif x == [0,1,0,1]: print(1-solveC(x))\nelif x == [1,1,0,0]: print(1)\nelif x == [1,0,0,0]: print(1)\nelif x == [1,0,1,0]: print(0) # 1\nelif x == [1,1,1,0]: print(1)\nelif x == [1,1,0,1]: print(1-solveC(x))\nelif x == [1,1,1,1]: print(1-solveC(x))\nelse: print(solveC(x))\n", "a = (input())\nb=(input())\nc=(input())\nd=(input())\ns = a+b+c+d\nq = int(s,2)\nif(q == 6):\n    print(0)\nif(q==0):\n    print(0)\nif(q==8):\n    print(1)\nif(q==4):\n    print(0)\nif(q==12):\n    print(1)\nif(q==2):\n    print(0)\nif(q==10):\n    print(0)\nif(q==14):\n    print(1)\nif(q==1):\n    print(1)\nif(q==9):\n    print(1)\nif(q==5):\n    print(0)\nif(q==13):\n    print(0)\nif(q==3):\n    print(1)\nif(q==11):\n    print(1)\nif(q==7):\n    print(0)\nif(q==15):\n    print(1)", "xs = [int(input()) for _ in range(4)]\nn = 0\nfor x in xs:\n    n = n * 2 + x\nd = {6: 0, 0: 0, 1: 1, 8: 1, 4: 0, 12: 1, 2: 0, 10 : 0, 14: 1, 9 : 1, 5: 0, 13: 0,\n3: 1, 11: 1, 7: 0, 15: 1}\nif n in list(d.keys()):\n    print(d[n])\nelse:\n    xs = [0] * ((10 ** 6) * n)\n    raise ValueError()\n"]