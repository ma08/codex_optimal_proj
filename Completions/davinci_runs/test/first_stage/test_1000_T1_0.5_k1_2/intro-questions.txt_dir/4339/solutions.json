["def main():\n    import sys\n    from bisect import bisect_left\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = [a-b for a, b in zip(A, B)]\n    C.sort()\n\n    ans = 0\n    for i, c in enumerate(C):\n        j = bisect_left(C, -c+1)\n        ans += N-j\n        if c > 0:\n            ans -= 1\n    print(ans // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nC=[A[i]-B[i] for i in range(n)]\nC.sort()\n\nimport bisect\nANS=0\n\nfor i in range(n):\n    x=bisect.bisect_right(C,-C[i])\n\n    ANS+=n-max(x,i+1)\n\nprint(ANS)\n", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_left\n\nn = int(input())\nx = [*map(int, input().split())]\ny = [xi - yi for xi, yi in zip(x, map(int, input().split()))]\n#print(y)\ny.sort()\nans = 0\nfor i in range(n):\n    k = y[i]\n    a = bisect_left(y, -k+1)\n    ans += n-a\n\nprint((ans - len([i for i in y if i > 0]))// 2)", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \nM = mod = 10**9 + 7\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nn = val()\nl1 = li()\nl2 = li()\nfor i in range(n):\n    l1[i] -= l2[i]\n\nl1.sort()\nans = 0\nfor i in range(n):\n    curr = l1[i]\n    curr = 0 - l1[i]\n    curr += 1\n    ans += (n) - (bl(l1,curr))\n    if curr <= l1[i]:\n        ans -= 1\nprint(ans//2)\n", "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = [a[i]-b[i] for i in range(n)]\nc.sort()\nind = n - 1\nwyn = 0\nfor i in range(n):\n\twhile True:\n\t\tif ind > i and c[i] + c[ind] > 0:\t\n\t\t\tind -= 1\n\t\telse:\n\t\t\tbreak\n\t\t\n\tif ind <= i:\n\t\tind = min(n-1,i)\n\twyn += (n-1-ind)\nprint(wyn)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nimport bisect\nfrom collections import deque\n\nn = int(input())\na = [int(item) for item in input().split()]\nb = [int(item) for item in input().split()]\n\nc = []\nfor aa, bb in zip(a, b):\n    c.append(aa - bb)\n\nc.sort()\nc = deque(c)\nans = 0\nwhile c:\n    item = c.popleft()\n    val = len(c) - bisect.bisect_right(c, -item)\n    ans += val\nprint(ans)", "from sys import *\n\ninput = stdin.readline\n\nclass ordered_set():\n    def __init__(self, LOG):\n        self.LOG = LOG\n        self.Sz = (1 << LOG);\n        self.fen = [0] * self.Sz\n\n    def update(self, ind, val):\n        while (ind < self.Sz):\n            self.fen[ind] += val\n            ind += ind & (-ind)\n\n    def get(self, ind):\n        sum = 0\n        while (ind):\n            sum += self.fen[ind]\n            ind -= ind & (-ind)\n        return sum\n\n    def order_of_key(self, x):\n        return self.get(x - 1);\n\n    def find_by_order(self, ind):\n        ans = 0\n        for i in range(self.LOG):\n            x = (1 << (self.LOG - i - 1))\n            print((x , self.fen[ans + x] , ind));\n            if (self.fen[ans + x] <= ind):\n                ind -= self.fen[ans + x]\n                ans += x\n        return ans + 1\n\n    def upper_bound(self, x):\n        return self.find_by_order(self.get(x))\n\n    def lower_bound(self, x):\n        return self.upper_bound(x - 1);\n\nfen = ordered_set(20);\nn = int(input())\nA = list(map(int , input().split()));\nB = list(map(int , input().split()));\nC = [0] * (n * 2);\nfor i in range(n):\n    C[i * 2] = [A[i] - B[i] , (i + 1) * 2];\n    C[i * 2 + 1] = [B[i] - A[i] , (i + 1) * 2 + 1]\n\nC.sort(key=lambda x : x[0]);\n\nans = 0\nprv = -1\nD = []\nfor i in C:\n    if(i[0] != prv):\n        for j in D:\n            fen.update(j , 1)\n        D = []\n    if(i[1] % 2 == 0):\n        ans += fen.get(i[1]);\n    else:\n        D.append(i[1])\n    prv = i[0];\n\nprint(ans)\n\n", "def go():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dif = sorted(aa - bb for aa, bb in zip(a, b))\n    j = n - 1\n    res = 0\n    for i, d in enumerate(dif):\n        while j > -1 and d + dif[j] > 0:\n            j -= 1\n        res += n - 1 - j\n        if j < i:\n            res -= 1\n    return res // 2\n\n\n# t = int(input())\nfor _ in range(1):\n    print(go())\n", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nl = [x-y for x,y in zip(a,b)]\nl.sort()\nz = l.count(0)\np = sum(1 for x in l if x > 0)\nm = n - z - p\nidx = n\ncnt = p*(p-1)//2 + z*p\nfor i in range(m):\n    while l[idx-1] + l[i] > 0: idx -= 1\n    cnt += n - idx\nprint(cnt)", "\nN = int(input())\n\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nlis = []\n\nfor i in range(N):\n\n    lis.append(b[i]-a[i])\n\nlis.sort()\n\nans = 0\nsub = 0\n\nimport bisect\nfor i in range(N):\n\n    ns = a[i]-b[i]\n\n    ans += bisect.bisect_left(lis,ns)\n    if a[i] > b[i]:\n        sub += 1\n\nprint((ans-sub) // 2)\n", "from bisect import bisect_right\nn=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nx=[i-j for i,j in zip(a,b)]\nx.sort()\nans=0\nfor i in x:\n  if i>0:ans-=1\n  ans+=n-bisect_right(x,-i)\nprint(ans//2)", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_right\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = [a-b for a, b in zip(A, B)]\nC.sort()\n\nans = 0\nfor i, c in enumerate(C):\n    ind = bisect_right(C, -c)\n    ans += min(N-ind, N-i-1)\nprint(ans)", "import sys\nfrom bisect import bisect, bisect_left\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    B = [int(b) for b in input().split()]\n    C = [A[i] - B[i] for i in range(N)]\n    C.sort()\n    count = 0\n    for i, c in enumerate(C):\n        least = bisect(C, - c)\n        count += N - max(least, i + 1)\n    print(count)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nnow = []\nfor i in range(n):\n    now.append([a[i] - b[i], a[i], b[i]])\nnow.sort()\nans = 0\ni = 0\nj = n - 1\nwhile i < j:\n    if now[i][0] + now[j][0] > 0:\n        ans += j - i\n        j -= 1\n    else:\n        i += 1\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = []\nfor i in range (0, n) :\n    c.append(a[i] - b[i])\nc.sort()\np1 = n - 1\np2 = 0\nans = 0\nwhile p1 > p2 :\n    while p2 < p1 and c[p1] + c[p2] <= 0 :\n        p2 += 1\n    ans += p1 - p2\n    # print(ans)\n    p1 -= 1\nprint(ans)"]