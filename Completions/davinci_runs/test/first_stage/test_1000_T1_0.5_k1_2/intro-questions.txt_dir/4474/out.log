2022-04-09 20:21:11.665882 """
The only difference between easy and hard versions is the maximum value of $n$.

You are given a positive integer number $n$. You really love good numbers so you want to find the smallest good number greater than or equal to $n$.

The positive integer is called good if it can be represented as a sum of distinct powers of $3$ (i.e. no duplicates of powers of $3$ are allowed).

For example:

  $30$ is a good number: $30 = 3^3 + 3^1$,  $1$ is a good number: $1 = 3^0$,  $12$ is a good number: $12 = 3^2 + 3^1$,  but $2$ is not a good number: you can't represent it as a sum of distinct powers of $3$ ($2 = 3^0 + 3^0$),  $19$ is not a good number: you can't represent it as a sum of distinct powers of $3$ (for example, the representations $19 = 3^2 + 3^2 + 3^0 = 3^2 + 3^1 + 3^1 + 3^1 + 3^0$ are invalid),  $20$ is also not a good number: you can't represent it as a sum of distinct powers of $3$ (for example, the representation $20 = 3^2 + 3^2 + 3^0 + 3^0$ is invalid). 

Note, that there exist other representations of $19$ and $20$ as sums of powers of $3$ but none of them consists of distinct powers of $3$.

For the given positive integer $n$ find such smallest $m$ ($n \le m$) that $m$ is a good number.

You have to answer $q$ independent queries.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) â€” the number of queries. Then $q$ queries follow.

The only line of the query contains one integer $n$ ($1 \le n \le 10^{18}$).


-----Output-----

For each query, print such smallest integer $m$ (where $n \le m$) that $m$ is a good number.


-----Example-----
Input
8
1
2
6
13
14
3620
10000
1000000000000000000

Output
1
3
9
13
27
6561
19683
1350851717672992089
"""
2022-04-09 20:21:11.665903 --------------------------
2022-04-09 20:21:31.016705 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# Python3 program to find the smallest good number \n# greater than or equal to n. \n\ndef good(n) : \n\t\n\t# If n is already a good number \n\tif (n == 1) : \n\t\treturn n \n\t\n\t# Find all powers of 3 and store in a list \n\tpowers = [] \n\ti = 1\n\twhile (3 ** i <= n) : \n\t\tpowers.append(3 ** i) \n\t\ti += 1\n\t\n\t# dp[i] stores the smallest good number \n\t# greater than or equal to i. \n\tdp = [0 for i in range(n + 1)] \n\t\n\t# Initialize all dp values as n+1 \n\tfor i in range(1, n + 1) : \n\t\tdp[i] = n + 1\n\t\n\t# Fill dp values starting from 2 \n\tfor i in range(2, n + 1) : \n\t\t\n\t\t# For every power of 3, check if we can \n\t\t# get a smaller good number by adding it \n\t\tfor x in powers : \n\t\t\t\n\t\t\t# If i>x and dp[i-x] is a good number \n\t\t\t# then we can make dp[i] a good number \n\t\t\t# by adding x to it. \n\t\t\tif (i > x and dp[i - x] != n + 1) : \n\t\t\t\tdp[i] = min(dp[i], dp[i - x] + x) \n\t\t\n\t# Return dp[n] if it is a good number else \n\t# return -1 \n\treturn dp[n] if (dp[n] != n + 1) else -1\n\n# Driver code \nif __name__ == \"__main__\" : \n\t\n\tn = int(input())\n\tprint(good(n))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom math import log\nfrom bisect import bisect_left\n\ndef is_power_of_3(x):\n    return x > 0 and 3 ** round(log(x, 3)) == x\n\n# If a number is a power of 3, then the next power of 3 is the next good number\ngood_numbers = [3 ** i for i in range(1, int(log(10 ** 18, 3)))]\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(good_numbers[bisect_left(good_numbers, n)])"
    }
  ],
  "created": 1649550072,
  "id": "cmpl-4vFcGmU0nP3X2Gsl0lkqqkOCOJPRZ",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 20:21:31.016990 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# Python3 program to find the smallest good number \n# greater than or equal to n. \n\ndef good(n) : \n\t\n\t# If n is already a good number \n\tif (n == 1) : \n\t\treturn n \n\t\n\t# Find all powers of 3 and store in a list \n\tpowers = [] \n\ti = 1\n\twhile (3 ** i <= n) : \n\t\tpowers.append(3 ** i) \n\t\ti += 1\n\t\n\t# dp[i] stores the smallest good number \n\t# greater than or equal to i. \n\tdp = [0 for i in range(n + 1)] \n\t\n\t# Initialize all dp values as n+1 \n\tfor i in range(1, n + 1) : \n\t\tdp[i] = n + 1\n\t\n\t# Fill dp values starting from 2 \n\tfor i in range(2, n + 1) : \n\t\t\n\t\t# For every power of 3, check if we can \n\t\t# get a smaller good number by adding it \n\t\tfor x in powers : \n\t\t\t\n\t\t\t# If i>x and dp[i-x] is a good number \n\t\t\t# then we can make dp[i] a good number \n\t\t\t# by adding x to it. \n\t\t\tif (i > x and dp[i - x] != n + 1) : \n\t\t\t\tdp[i] = min(dp[i], dp[i - x] + x) \n\t\t\n\t# Return dp[n] if it is a good number else \n\t# return -1 \n\treturn dp[n] if (dp[n] != n + 1) else -1\n\n# Driver code \nif __name__ == \"__main__\" : \n\t\n\tn = int(input())\n\tprint(good(n))"
}
2022-04-09 20:21:31.017050 REASON stop
2022-04-09 20:21:31.018300 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom math import log\nfrom bisect import bisect_left\n\ndef is_power_of_3(x):\n    return x > 0 and 3 ** round(log(x, 3)) == x\n\n# If a number is a power of 3, then the next power of 3 is the next good number\ngood_numbers = [3 ** i for i in range(1, int(log(10 ** 18, 3)))]\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(good_numbers[bisect_left(good_numbers, n)])"
}
2022-04-09 20:21:31.018362 REASON stop
