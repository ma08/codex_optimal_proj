["\n\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)", "\n\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()"]