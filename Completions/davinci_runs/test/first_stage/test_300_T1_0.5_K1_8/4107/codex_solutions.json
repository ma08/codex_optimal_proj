["\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    cost = 0\n    for i in range(n):\n        if s[i] == \"1\":\n            cost += i + 1\n            if i - k >= 0:\n                s[i-k] = \"0\"\n            if i + k < n:\n                s[i+k] = \"0\"\n    for i in range(n):\n        if s[i] == \"1\":\n            cost += i + 1\n    print(cost)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    s = input()\n    router_indices = [i for i, x in enumerate(s) if x == '1']\n    router_indices.append(-1)\n    router_indices.append(n)\n    router_indices.sort()\n    router_indices = [0] + router_indices\n    i = 1\n    ans = 0\n    while i < len(router_indices):\n        if router_indices[i] - router_indices[i - 1] - 1 <= k:\n            i += 1\n        else:\n            ans += router_indices[i] - router_indices[i - 1]\n            i += 2\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nn, k = [int(i) for i in input().split()]\ns = input()\n\n# This is the solution I came up with on my own.\n# It's very slow and I haven't been able to figure out why.\n# It's a greedy algorithm that adds routers to the first available spot.\n# The algorithm starts at the beginning of the string and adds a router\n# to the first available spot. Then it moves to the next spot that is not\n# already covered by the first router and adds a router there. It continues\n# until all rooms are covered.\n\n# def get_next_router_spot(s, start=0):\n#     for i in range(start, len(s)):\n#         if s[i] == \"1\":\n#             return i\n#     return None\n\n# routers = []\n# while True:\n#     router = get_next_router_spot(s)\n#     if router is None:\n#         break\n#     routers.append(router)\n#     for i in range(router - k, router + k + 1):\n#         if i >= 0 and i < len(s):\n#             s = s[:i] + \"0\" + s[i+1:]\n\n# print(sum(routers))\n\n# This is the solution I found online.\n# It's much faster than my solution.\n# It's a greedy algorithm that adds routers to the highest available spot.\n# It starts by adding routers to the highest available spot, then it moves\n# to the next highest available spot, etc.\n\n# This is a greedy algorithm. We will always place a router in the highest\n# available spot.\n\n# First, we need to find the highest available spot.\nhighest_spot = 0\nfor i in range(len(s) - 1, -1, -1):\n    if s[i] == \"1\":\n        highest_spot = i\n        break\n\n# Now we start adding routers.\nrouters = []\nwhile highest_spot >= 0:\n    routers.append(highest_spot)\n    # We need to remove all spots that are covered by this router.\n    for i in range(highest_spot - k, highest_spot + k + 1):\n        if i >= 0 and i < len(s):\n            s = s[:i] + \"0\" + s[i+1:]\n    # Now we need to find the next highest available spot.\n    highest_spot = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == \"1\":\n            highest_spot = i\n            break\n\nprint(sum(routers))", "\n\nimport sys\n\ndef main():\n    n,k = map(int,sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    #print(n,k,s)\n\n    if n==1:\n        print(0)\n        return\n\n    cost = 0\n    for i in range(n):\n        if s[i]=='1':\n            cost += i+1\n        else:\n            if i+k<n and s[i+k]=='1':\n                cost += i+1\n            else:\n                cost += (i+1)*2\n\n    print(cost)\n\nif __name__ == '__main__':\n    main()", "\n\nn, k = map(int, input().split())\ns = input()\n\ncost = 0\nfor i in range(n):\n    if s[i] == '1':\n        cost += i + 1\n        continue\n    if i - k > 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    cost += i + 1\n\nprint(cost)", "\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    cost = 0\n    for i in range(n):\n        if s[i] == '1':\n            cost += i + 1\n        else:\n            cost += min(max(1, i - k), max(1, n - k - i))\n    print(cost)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n\n    # We can use a greedy algorithm where we place routers at the first rooms where\n    # there are spots for routers, and then connect the remaining rooms directly.\n    # So the cost of the optimal solution is the sum of the costs of the direct\n    # connections and the costs of the routers.\n\n    # We can find the cost of the direct connections using prefix sums.\n    direct = 0\n    for i in range(n):\n        if s[i] == '0':\n            direct += i + 1\n\n    # We can find the cost of the routers by counting the number of rooms in each\n    # interval of length 2k+1, where we place a router.\n    routers = 0\n    intervals = [0] * n\n    for i in range(n):\n        if s[i] == '1':\n            intervals[max(0, i - k)] += 1\n            if i + k + 1 < n:\n                intervals[i + k + 1] -= 1\n    count = 0\n    for i in range(n):\n        count += intervals[i]\n        if count > 0:\n            routers += i + 1\n\n    print(direct + routers)\n\n\nif __name__ == \"__main__\":\n    main()", "\nn, k = map(int, input().split())\ns = input()\n\n# 1. find all the spots for routers\n# 2. sort them by the cost of connecting directly to the internet\n# 3. check if the spot is within the range of the previous router\n# 4. if no, connect directly to the internet\n# 5. if yes, skip\n# 6. add the cost of connecting directly to the internet\n\nspots = []\ntotal_cost = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        spots.append(i+1)\n    else:\n        total_cost += (i+1)\n\nspots.sort()\n\nlast_router_range = 0\n\nfor i in range(len(spots)):\n    if spots[i] > last_router_range:\n        total_cost += spots[i]\n        last_router_range = spots[i] + k\n\nprint(total_cost)"]