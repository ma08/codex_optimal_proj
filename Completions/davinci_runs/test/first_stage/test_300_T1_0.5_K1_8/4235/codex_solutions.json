["\n\nimport sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread_list_int = lambda: list(map(int, sys.stdin.readline().strip().split(' ')))\nread_single_int = lambda: int(sys.stdin.readline().strip())\n\nINF = 10 ** 18\n\n\ndef dfs(v, p, g, visited):\n    visited[v] = True\n    for u in g[v]:\n        if u != p:\n            dfs(u, v, g, visited)\n\n\ndef solve(n, m, edges):\n    g = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    visited = [False] * (n + 1)\n    dfs(1, 0, g, visited)\n    for v in visited:\n        if not v:\n            return 'NO'\n\n    # \u5168\u3066\u306e\u8fba\u304c\u4e92\u3044\u306b\u9023\u7d50\u3067\u3042\u308b\u3053\u3068\u304c\u5206\u304b\u3063\u3066\u3044\u308b\n    # \u3042\u308b\u9802\u70b9\u304b\u3089\u51fa\u308b\u8fba\u3092\u5168\u3066\u9006\u5411\u304d\u306b\u3059\u308c\u3070\u3001\u305d\u306e\u9802\u70b9\u3068\u305d\u306e\u9802\u70b9\u3078\u306e\u8fba\u3092\u9664\u3044\u305f\u90e8\u5206\u30b0\u30e9\u30d5\u306f\u6728\u3068\u306a\u308b\n    # \u6728\u306f\u6700\u9577\u30d1\u30b9\u304c2\u3067\u3042\u308b\u3053\u3068\u304c\u5206\u304b\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u305d\u306e\u3088\u3046\u306b\u3059\u308c\u3070\u3088\u3044\n    # \u305f\u3060\u3057\u3001\u305d\u306e\u307e\u307e\u3060\u3068\u3001\u9802\u70b9\u304b\u3089\u51fa\u308b\u8fba\u304c1\u672c\u306e\u5834\u5408\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u8fba\u3092\u9006\u5411\u304d\u306b\u3059\u308b\u3068\u9802\u70b9\u306f\u5b64\u7acb\u3057\u3066\u3057\u307e\u3046\n    # \u305d\u306e\u305f\u3081\u3001\u9802\u70b9\u304b\u3089\u51fa\u308b\u8fba\u304c1\u672c\u306e\u5834\u5408\u306f\u305d\u306e\u8fba\u3092\u9006\u5411\u304d\u306b\u3057\u306a\u3044\u3088\u3046\u306b\u3059\u308b\n    res = [0] * m\n    for i, (u, v) in enumerate(edges):\n        if len(g[u]) == 1:\n            res[i] = 1\n\n    return 'YES\\n' + ''.join(map(str, res))\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    edges = [read_list_int() for _ in range(m)]\n\n    print(solve(n, m, edges))", "\n\n# TODO: Please, write your solution here", "\n\nimport sys\nimport math\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: \u96a3\u63a5\u884c\u5217(\u8ddd\u96e2\u4ed8\u304d)\n    N: \u30ce\u30fc\u30c9\u6570\n    K: \u59cb\u70b9\u30ce\u30fc\u30c9\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  \u73fe\u5728\u306e\u30ce\u30fc\u30c9\n    pre: \uff11\u3064\u524d\u306e\u30ce\u30fc\u30c9\n    dist: \u73fe\u5728\u306e\u8ddd\u96e2\n\n    \u4ee5\u4e0b\u306f\u5225\u9014\u7528\u610f\u3059\u308b\n    D: \u96a3\u63a5\u30ea\u30b9\u30c8(\u884c\u5217\u3067\u306f\u306a\u3044)\n    D_dfs_d: dfs_d\u95a2\u6570\u3067\u7528\u3044\u308b\uff0c\u59cb\u70b9\u30ce\u30fc\u30c9\u304b\u3089\u898b\u305f\u8ddd\u96e2\u30ea\u30b9\u30c8\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\nN, M = li_input()\n\nG = collections.defaultdict(list)\n\nfor _ in range(M):\n    u, v = li_input()\n    G[u].append(v)\n    G[v].append(u)\n\nans = ['0'] * M\n\nfor i in range(1, N + 1):\n    if len(G[i]) == 1:\n        u, v = G[i][0], i\n        ans[M - 1] = '1'\n\nprint('YES')\nprint(''.join(ans))", "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef dfs(v, p):\n    for i in g[v]:\n        if i != p:\n            dfs(i, v)\n    for i in g[v]:\n        if i != p:\n            for j in g[i]:\n                if j != v:\n                    g[v].append(j)\n\ndef dfs2(v, p):\n    for i in g[v]:\n        if i != p:\n            dfs2(i, v)\n            for j in g[i]:\n                if j != v:\n                    g[v].append(j)\n\nn, m = map(int, input().split())\ng = [[] for i in range(n+1)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    g[a].append(b)\n    g[b].append(a)\n\ndfs(1, 0)\ndfs2(1, 0)\n\nfor i in range(1, n+1):\n    if len(g[i]) != n-1:\n        print(\"NO\")\n        sys.exit(0)\n\nprint(\"YES\")\nfor i in range(1, n+1):\n    for j in g[i]:\n        if j > i:\n            print(1, end=\"\")\n            break\n    else:\n        print(0, end=\"\")\nprint()", "\n\nimport sys\n\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, v, p=-1):\n        for u in self.adj[v]:\n            if u != p:\n                self.dfs(u, v)\n\n    def check(self, v, p=-1):\n        if len(self.adj[v]) > 2:\n            return False\n        for u in self.adj[v]:\n            if u != p:\n                if not self.check(u, v):\n                    return False\n        return True\n\n    def solve(self):\n        self.dfs(0)\n        if not self.check(0):\n            return False\n        return True\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    g = Graph(n)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        u -= 1\n        v -= 1\n        g.add_edge(u, v)\n\n    if not g.solve():\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        ans = [0] * m\n        for v in range(n):\n            for u in g.adj[v]:\n                if u > v:\n                    ans[u] = 1\n        print(\"\".join(map(str, ans)))\n\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = [False] * (n+1)\n    visited[1] = True\n    q = [1]\n    while q:\n        u = q.pop()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n    if any(not visited[i] for i in range(1, n+1)):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    for i in range(1, n+1):\n        for v in adj[i]:\n            if v > i:\n                print(0, end=\"\")\n    for i in range(1, n+1):\n        for v in adj[i]:\n            if v < i:\n                print(1, end=\"\")\n\n\nif __name__ == \"__main__\":\n    main()"]