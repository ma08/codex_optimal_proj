["\n\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal graph, n, k, count, ans, comp\n\tfor u in graph[v]:\n\t\tif u == p:\n\t\t\tcontinue\n\t\tdfs(u, v)\n\t\tif count[u] > k:\n\t\t\tans = -1\n\t\t\treturn\n\t\tcount[v] += count[u]\n\t\tcomp[u] = comp[v]\n\tif n - count[v] > k:\n\t\tans = -1\n\t\treturn\n\tif n - count[v] > 0:\n\t\tans += 1\n\t\tcomp[v] = ans\n\t\nn, k = map(int, input().split())\ngraph = defaultdict(list)\nfor i in range(n-1):\n\tx, y = map(int, input().split())\n\tgraph[x].append(y)\n\tgraph[y].append(x)\ncount = [0 for i in range(n+1)]\ncount[1] = 1\ncomp = [0 for i in range(n+1)]\nans = 0\ndfs(1, 0)\n\nif ans == -1:\n\tprint(-1)\nelse:\n\tprint(ans)\n\tprint(*comp[2:])", "\n\n#Solution\nimport sys\ninput = sys.stdin.readline\n \nn, k = map(int, input().split())\n \nif k > n - 2:\n    k = n - 2\n \na = []\n \nfor i in range(n - 1):\n    a.append(int(input()))\n \nprint(k + 1)\n \nfor i in range(n - 1):\n    print(i % (k + 1) + 1, end=' ')", "\n\ndef dfs(u):\n    global color,n,k\n    color[u] = 1\n    for v in g[u]:\n        if color[v] == 0:\n            dfs(v)\n            if color[v] == 1:\n                color[u] = 2\n\nn,k = map(int,input().split())\ng = [[] for i in range(n+1)]\ncolor = [0]*(n+1)\nfor i in range(n-1):\n    x,y = map(int,input().split())\n    g[x].append(y)\n    g[y].append(x)\ndfs(1)\nc = 0\nfor i in range(1,n+1):\n    if color[i] == 2:\n        c+=1\nif c > k:\n    print(\"-1\")\nelse:\n    print(c)\n    ans = [0]*(n-1)\n    stack = [1]\n    c = 1\n    while stack:\n        u = stack.pop()\n        for v in g[u]:\n            if color[v] == 1:\n                ans[v-1] = c\n                stack.append(v)\n        if color[u] == 2:\n            c+=1\n    print(*ans)", "\n\nimport sys\nimport math\nimport heapq\nimport itertools\nimport collections\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = n\n        self.edges = collections.defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\ndef dfs(g, start, visited):\n    visited[start] = True\n\n    for v in g.edges[start]:\n        if visited[v] == False:\n            dfs(g, v, visited)\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    g = Graph(n)\n\n    for i in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        g.add_edge(x, y)\n\n    visited = [False] * n\n    dfs(g, 1, visited)\n\n    if False in visited:\n        print(\"Graph is not connected\")\n    else:\n        print(\"Graph is connected\")\n\nif __name__ == \"__main__\":\n    main()", "\nimport sys\n\ndef get_input(file=None):\n    if file is None:\n        fh = sys.stdin\n    else:\n        fh = open(file)\n\n    def read_int():\n        return int(fh.readline())\n\n    def read_ints():\n        return [int(x) for x in fh.readline().split()]\n\n    n, k = read_ints()\n    assert 1 <= n <= 200000\n    assert 0 <= k <= n-1\n\n    return n, k\n\ndef get_graph(n, file=None):\n    if file is None:\n        fh = sys.stdin\n    else:\n        fh = open(file)\n\n    def read_int():\n        return int(fh.readline())\n\n    def read_ints():\n        return [int(x) for x in fh.readline().split()]\n\n    graph = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        x, y = read_ints()\n        assert 1 <= x <= n\n        assert 1 <= y <= n\n        graph[x].append(y)\n        graph[y].append(x)\n\n    return graph\n\ndef get_roof(graph):\n    n = len(graph)-1\n    visited = set()\n    queue = [1]\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        queue.extend(graph[node])\n\n    assert len(visited) == n\n\n    return visited\n\ndef get_children(graph, node):\n    children = set()\n    for child in graph[node]:\n        if child != node:\n            children.add(child)\n    return children\n\ndef get_distances(graph, node):\n    distances = {node: 0}\n    queue = [node]\n    while queue:\n        node = queue.pop(0)\n        distance = distances[node]\n        for child in graph[node]:\n            if child not in distances:\n                distances[child] = distance + 1\n                queue.append(child)\n\n    return distances\n\ndef get_leaf(graph, node):\n    for child in graph[node]:\n        if child != node:\n            return child\n    raise ValueError('node is not a root')\n\ndef get_leaves(graph, node):\n    leaves = set()\n    queue = [node]\n    while queue:\n        node = queue.pop(0)\n        if len(graph[node]) == 1:\n            leaves.add(node)\n        else:\n            for child in graph[node]:\n                if child != node:\n                    queue.append(child)\n    return leaves\n\ndef get_root(graph, node):\n    root = node\n    while graph[root][0] != root:\n        root = graph[root][0]\n    return root\n\ndef get_strategy(graph, n, k):\n    roof = get_roof(graph)\n    if len(roof) == 1:\n        return 1\n\n    distances = get_distances(graph, 1)\n    root = max(distances, key=lambda x: distances[x])\n    root_distance = distances[root]\n\n    leaves = get_leaves(graph, root)\n    assert len(leaves) >= 2\n\n    # print(root, leaves)\n\n    if len(leaves) == 2:\n        if root_distance == 1:\n            return 1\n        else:\n            return 2\n\n    if root_distance == 1:\n        if len(leaves) <= k+1:\n            return 1\n        else:\n            return 2\n\n    if len(leaves) <= k:\n        return 2\n\n    return 3\n\ndef get_solution(graph, n, k):\n    strategy = get_strategy(graph, n, k)\n    if strategy == 1:\n        return [1]*(n-1)\n    elif strategy == 2:\n        companies = [1]*(n-1)\n        distances = get_distances(graph, 1)\n        root = max(distances, key=lambda x: distances[x])\n        leaves = get_leaves(graph, root)\n        assert len(leaves) >= 2\n\n        for leaf in leaves:\n            node = leaf\n            while node != root:\n                companies[node-1] = 2\n                node = graph[node][0]\n        return companies\n    else:\n        companies = [1]*(n-1)\n        distances = get_distances(graph, 1)\n        root = max(distances, key=lambda x: distances[x])\n        leaves = get_leaves(graph, root)\n        assert len(leaves) >= 3\n\n        for leaf in leaves:\n            node = leaf\n            while node != root:\n                companies[node-1] = 2\n                node = graph[node][0]\n        return companies\n\ndef main():\n    n, k = get_input()\n    graph = get_graph(n)\n    solution = get_solution(graph, n, k)\n    print(max(solution))\n    print(*solution)\n\nif __name__ == '__main__':\n    main()", "\n\n# SOLUTION\n# We can use DFS to find the number of children of each node. \n# We will start with the root node. The root node has children, so it is not good. \n# Then we will assign the first company to all its children. \n# Then we will do the same for each of those children, assigning the second company to all its children. \n# We will continue this until we have no more children. \n# We will then go back up the tree and assign the next company to the children of the current node. \n# We will continue this until we have assigned all the companies. \n# After we have assigned all the companies, we will count the number of bad nodes.\n# Complexity: O(n)\n\nfrom sys import stdin\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.children = []\n        self.parent = None\n        self.company = 0\n        self.bad = False\n\n    def add_child(self, child):\n        child.parent = self\n        self.children.append(child)\n\n    def assign_company(self, company):\n        self.company = company\n        for child in self.children:\n            child.assign_company(company)\n\n    def get_num_children(self):\n        if not self.children:\n            return 0\n        return 1 + sum([child.get_num_children() for child in self.children])\n\n    def get_num_bad_nodes(self):\n        if not self.children:\n            return 0\n        if self.bad:\n            return 1 + sum([child.get_num_bad_nodes() for child in self.children])\n        return sum([child.get_num_bad_nodes() for child in self.children])\n\n    def __str__(self):\n        return \"{} -> {}\".format(self.key, [child.key for child in self.children])\n\n\ndef dfs(root, company):\n    # assign company to children\n    root.assign_company(company)\n    # assign company to children of children\n    for child in root.children:\n        dfs(child, company + 1)\n\n\ndef get_num_companies(root):\n    return max(root.company, 1)\n\n\ndef get_num_bad_nodes(root):\n    return root.get_num_bad_nodes()\n\n\ndef main():\n    n, k = [int(x) for x in stdin.readline().split()]\n    nodes = [Node(i) for i in range(1, n + 1)]\n    for _ in range(n - 1):\n        x, y = [int(x) for x in stdin.readline().split()]\n        nodes[x - 1].add_child(nodes[y - 1])\n        nodes[y - 1].add_child(nodes[x - 1])\n    root = nodes[0]\n    root.bad = True\n    dfs(root, 1)\n    num_companies = get_num_companies(root)\n    num_bad_nodes = get_num_bad_nodes(root)\n    if num_bad_nodes > k:\n        print(-1)\n    else:\n        print(num_companies)\n        print(\" \".join([str(node.company) for node in nodes]))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n\n# Python 3.x\n# this solution (TLE) uses the fact that a tree is bipartite\n\n# this function returns the number of vertices in the connected component of a given vertex\ndef dfs(adj, v, visited):\n    visited[v] = True\n    count = 1\n    for u in adj[v]:\n        if not visited[u]:\n            count += dfs(adj, u, visited)\n    return count\n\n# this function returns the number of connected components of a given graph\ndef find_components(adj):\n    visited = [False] * (n + 1)\n    count = 0\n    for v in range(1, n + 1):\n        if not visited[v]:\n            count += 1\n            dfs(adj, v, visited)\n    return count\n\nn, k = map(int, input().split())\nadj = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    x, y = map(int, input().split())\n    adj[x].append(y)\n    adj[y].append(x)\n\n# if n - 1 belongs to the interval [2k, 3k], then we can assign each edge to a different company\n# if n - 1 belongs to the interval (3k, 4k], then we can assign each edge to a different company\n# and make one connected component (with one vertex) a non-good vertex\n# if n - 1 belongs to the interval (4k, 5k], then we can assign each edge to a different company\n# and make two connected components (with one vertex each) non-good vertices\n# and so on...\n# if n - 1 belongs to the interval (rk, (r+1)k], then we can assign each edge to a different company\n# and make r connected components (with one vertex each) non-good vertices\n# the number of companies is r + 1, because one company will have one edge, and the rest of the companies\n# will have two edges each\n\n# we find the number of connected components of the graph\ncomponents = find_components(adj)\n\n# we find the number of companies\nr = (n - 1) // k - components + 1\n\n# we print the number of companies\nprint(r)\n\n# we print the companies of each edge\nfor i in range(n - 1):\n    print(i % r + 1, end = ' ')"]