2022-04-19 23:02:19.316554 """
Given are positive integers N, M, Q, and Q quadruples of integers ( a_i , b_i , c_i , d_i ).
Consider a sequence A satisfying the following conditions:
 - A is a sequence of N positive integers.
 - 1 \leq A_1 \leq A_2 \le \cdots \leq A_N \leq M.
Let us define a score of this sequence as follows:
 - The score is the sum of d_i over all indices i such that A_{b_i} - A_{a_i} = c_i. (If there is no such i, the score is 0.)
Find the maximum possible score of A.

-----Constraints-----
 - All values in input are integers.
 - 2 ≤ N ≤ 10
 - 1 \leq M \leq 10
 - 1 \leq Q \leq 50
 - 1 \leq a_i < b_i \leq N ( i = 1, 2, ..., Q )
 - 0 \leq c_i \leq M - 1 ( i = 1, 2, ..., Q )
 - (a_i, b_i, c_i) \neq (a_j, b_j, c_j) (where i \neq j)
 - 1 \leq d_i \leq 10^5 ( i = 1, 2, ..., Q )

-----Input-----
Input is given from Standard Input in the following format:
N M Q
a_1 b_1 c_1 d_1
:
a_Q b_Q c_Q d_Q

-----Output-----
Print the maximum possible score of A.

-----Sample Input-----
3 4 3
1 3 3 100
1 2 2 10
2 3 2 10

-----Sample Output-----
110

When A = \{1, 3, 4\}, its score is 110. Under these conditions, no sequence has a score greater than 110, so the answer is 110.
"""
2022-04-19 23:02:19.316567 --------------------------
2022-04-19 23:02:19.316678 using api key sourya
2022-04-19 23:02:42.715410 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nN, M, Q = map(int, input().split())\n\n# dp[i][j] = A_i\u307e\u3067\u3067\u3001A_i\u304cj\u306e\u6642\u306e\u6700\u5927\u30b9\u30b3\u30a2\ndp = [[0] * (M+1) for _ in range(N+1)]\n\nfor _ in range(Q):\n    ai, bi, ci, di = map(int, input().split())\n    if ai == 1:\n        dp[bi][ci] = max(dp[bi][ci], di)\n    else:\n        for j in range(ci+1):\n            dp[bi][j] = max(dp[bi][j], dp[ai-1][ci-j] + di)\n\nprint(max(dp[N]))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    # input\n    N, M, Q = map(int, sys.stdin.readline().strip().split())\n    abcd = []\n    for _ in range(Q):\n        abcd.append(tuple(map(int, sys.stdin.readline().strip().split())))\n\n    # initialize\n    dp = [[0] * (M+1) for _ in range(N+1)]\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0]\n        for j in range(1, M+1):\n            dp[i][j] = dp[i][j-1]\n            for a, b, c, d in abcd:\n                if i == b and j == c:\n                    dp[i][j] = max(dp[i][j], dp[a-1][c] + d)\n\n    # output\n    print(dp[-1][-1])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nfrom itertools import accumulate\nfrom bisect import bisect_right\n\ndef main():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\ndef main2():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\ndef main3():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\ndef main4():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# --- Input --- #\nN, M, Q = map(int, input().split())\n\n# --- Initialization --- #\na, b, c, d = [], [], [], []\nfor i in range(Q):\n    ai, bi, ci, di = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n    c.append(ci)\n    d.append(di)\n\n# --- Main --- #\n# dp[i][j] : maximum score of a sequence whose length is i and the maximum value is j\ndp = [[0 for i in range(M+1)] for j in range(N+1)]\n\n# Initialization\nfor i in range(N+1):\n    for j in range(M+1):\n        for k in range(Q):\n            if i == a[k] and j == c[k] + 1:\n                dp[i][j] = d[k]\n\n# Update\nfor i in range(1, N+1):\n    for j in range(1, M+1):\n        dp[i][j] = max(dp[i][j], dp[i][j-1])\n        for k in range(Q):\n            if i == b[k] and j == c[k] + 1:\n                dp[i][j] = max(dp[i][j], dp[a[k]][j-c[k]] + d[k])\n\nprint(dp[N][M])"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"main function\"\"\"\n    # read input\n    n, m, q = map(int, input().split())\n    a, b, c, d = [], [], [], []\n    for _ in range(q):\n        tmpa, tmpb, tmpc, tmpd = map(int, input().split())\n        a.append(tmpa)\n        b.append(tmpb)\n        c.append(tmpc)\n        d.append(tmpd)\n\n    # calculate\n    ans = 0\n    for _ in range(2**n):\n        seq = [0] * n\n        for j in range(n):\n            seq[j] = int(bin(i >> j)[2:])\n        score = 0\n        for j in range(q):\n            if seq[b[j] - 1] - seq[a[j] - 1] == c[j]:\n                score += d[j]\n        ans = max(ans, score)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn, m, q = map(int, input().split())\n\n# \u5165\u529b\nabcd = []\nfor i in range(q):\n    a, b, c, d = map(int, input().split())\n    abcd.append([a, b, c, d])\n\n# \u30b9\u30b3\u30a2\u8a08\u7b97\nscore = 0\nfor i in range(q):\n    a, b, c, d = abcd[i]\n    if b - a == c:\n        score += d\n\n# \u51fa\u529b\nprint(score)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n#import sys\n#sys.setrecursionlimit(10**9)\n\nn, m, q = [int(i) for i in input().split()]\n\na = [[0 for i in range(m)] for j in range(n+1)]\n\nfor i in range(1, n+1):\n    a[i][0] = 1\n\nfor i in range(q):\n    ai, bi, ci, di = [int(i) for i in input().split()]\n    a[ai][ci] += di\n\nfor i in range(1, n+1):\n    for j in range(1, m):\n        a[i][j] += a[i][j-1]\n\nfor i in range(1, n+1):\n    for j in range(1, m):\n        a[i][j] += a[i-1][j]\n\nprint(a[n][m-1])"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nN, M, Q = map(int, input().split())\n\n# \u5165\u529b\u3092\u30ea\u30b9\u30c8\u306b\u683c\u7d0d\nabcd = []\nfor i in range(Q):\n    abcd.append(list(map(int, input().split())))\n\n# \u7d44\u307f\u5408\u308f\u305b\u3092\u5168\u63a2\u7d22\nans = 0\nfor i in range(1, M + 1):\n    for j in range(i, M + 1):\n        for k in range(j, M + 1):\n            score = 0\n            for l in range(Q):\n                if (abcd[l][0] == 1 and abcd[l][1] == 2 and abcd[l][2] == i - 1) or (abcd[l][0] == 1 and abcd[l][1] == 3 and abcd[l][2] == j - 1) or (abcd[l][0] == 2 and abcd[l][1] == 3 and abcd[l][2] == k - 1):\n                    score += abcd[l][3]\n            ans = max(ans, score)\nprint(ans)"
    }
  ],
  "created": 1650409339,
  "id": "cmpl-4yr9Pd1FA2ECApehM6DRgUkZcDxbA",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 23:02:42.715757 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nN, M, Q = map(int, input().split())\n\n# dp[i][j] = A_i\u307e\u3067\u3067\u3001A_i\u304cj\u306e\u6642\u306e\u6700\u5927\u30b9\u30b3\u30a2\ndp = [[0] * (M+1) for _ in range(N+1)]\n\nfor _ in range(Q):\n    ai, bi, ci, di = map(int, input().split())\n    if ai == 1:\n        dp[bi][ci] = max(dp[bi][ci], di)\n    else:\n        for j in range(ci+1):\n            dp[bi][j] = max(dp[bi][j], dp[ai-1][ci-j] + di)\n\nprint(max(dp[N]))"
}
2022-04-19 23:02:42.715906 REASON stop
2022-04-19 23:02:42.718329 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    # input\n    N, M, Q = map(int, sys.stdin.readline().strip().split())\n    abcd = []\n    for _ in range(Q):\n        abcd.append(tuple(map(int, sys.stdin.readline().strip().split())))\n\n    # initialize\n    dp = [[0] * (M+1) for _ in range(N+1)]\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0]\n        for j in range(1, M+1):\n            dp[i][j] = dp[i][j-1]\n            for a, b, c, d in abcd:\n                if i == b and j == c:\n                    dp[i][j] = max(dp[i][j], dp[a-1][c] + d)\n\n    # output\n    print(dp[-1][-1])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:02:42.718501 REASON stop
2022-04-19 23:02:42.719094 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nfrom itertools import accumulate\nfrom bisect import bisect_right\n\ndef main():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\ndef main2():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\ndef main3():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\ndef main4():\n    N, M, Q = map(int, input().split())\n    abcd = [list(map(int, input().split())) for _ in range(Q)]\n    ans = 0\n    for i in range(M):\n        for j in range(i, M):\n            score = 0\n            for a, b, c, d in abcd:\n                if i <= c < j:\n                    score += d\n            ans = max(ans, score)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:02:42.719178 REASON stop
2022-04-19 23:02:42.734937 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# --- Input --- #\nN, M, Q = map(int, input().split())\n\n# --- Initialization --- #\na, b, c, d = [], [], [], []\nfor i in range(Q):\n    ai, bi, ci, di = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n    c.append(ci)\n    d.append(di)\n\n# --- Main --- #\n# dp[i][j] : maximum score of a sequence whose length is i and the maximum value is j\ndp = [[0 for i in range(M+1)] for j in range(N+1)]\n\n# Initialization\nfor i in range(N+1):\n    for j in range(M+1):\n        for k in range(Q):\n            if i == a[k] and j == c[k] + 1:\n                dp[i][j] = d[k]\n\n# Update\nfor i in range(1, N+1):\n    for j in range(1, M+1):\n        dp[i][j] = max(dp[i][j], dp[i][j-1])\n        for k in range(Q):\n            if i == b[k] and j == c[k] + 1:\n                dp[i][j] = max(dp[i][j], dp[a[k]][j-c[k]] + d[k])\n\nprint(dp[N][M])"
}
2022-04-19 23:02:42.735079 REASON stop
2022-04-19 23:02:42.736316 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"main function\"\"\"\n    # read input\n    n, m, q = map(int, input().split())\n    a, b, c, d = [], [], [], []\n    for _ in range(q):\n        tmpa, tmpb, tmpc, tmpd = map(int, input().split())\n        a.append(tmpa)\n        b.append(tmpb)\n        c.append(tmpc)\n        d.append(tmpd)\n\n    # calculate\n    ans = 0\n    for _ in range(2**n):\n        seq = [0] * n\n        for j in range(n):\n            seq[j] = int(bin(i >> j)[2:])\n        score = 0\n        for j in range(q):\n            if seq[b[j] - 1] - seq[a[j] - 1] == c[j]:\n                score += d[j]\n        ans = max(ans, score)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:02:42.736404 REASON stop
2022-04-19 23:02:42.758148 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn, m, q = map(int, input().split())\n\n# \u5165\u529b\nabcd = []\nfor i in range(q):\n    a, b, c, d = map(int, input().split())\n    abcd.append([a, b, c, d])\n\n# \u30b9\u30b3\u30a2\u8a08\u7b97\nscore = 0\nfor i in range(q):\n    a, b, c, d = abcd[i]\n    if b - a == c:\n        score += d\n\n# \u51fa\u529b\nprint(score)"
}
2022-04-19 23:02:42.758287 REASON stop
2022-04-19 23:02:42.759815 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n#import sys\n#sys.setrecursionlimit(10**9)\n\nn, m, q = [int(i) for i in input().split()]\n\na = [[0 for i in range(m)] for j in range(n+1)]\n\nfor i in range(1, n+1):\n    a[i][0] = 1\n\nfor i in range(q):\n    ai, bi, ci, di = [int(i) for i in input().split()]\n    a[ai][ci] += di\n\nfor i in range(1, n+1):\n    for j in range(1, m):\n        a[i][j] += a[i][j-1]\n\nfor i in range(1, n+1):\n    for j in range(1, m):\n        a[i][j] += a[i-1][j]\n\nprint(a[n][m-1])"
}
2022-04-19 23:02:42.759930 REASON stop
2022-04-19 23:02:42.761245 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nN, M, Q = map(int, input().split())\n\n# \u5165\u529b\u3092\u30ea\u30b9\u30c8\u306b\u683c\u7d0d\nabcd = []\nfor i in range(Q):\n    abcd.append(list(map(int, input().split())))\n\n# \u7d44\u307f\u5408\u308f\u305b\u3092\u5168\u63a2\u7d22\nans = 0\nfor i in range(1, M + 1):\n    for j in range(i, M + 1):\n        for k in range(j, M + 1):\n            score = 0\n            for l in range(Q):\n                if (abcd[l][0] == 1 and abcd[l][1] == 2 and abcd[l][2] == i - 1) or (abcd[l][0] == 1 and abcd[l][1] == 3 and abcd[l][2] == j - 1) or (abcd[l][0] == 2 and abcd[l][1] == 3 and abcd[l][2] == k - 1):\n                    score += abcd[l][3]\n            ans = max(ans, score)\nprint(ans)"
}
2022-04-19 23:02:42.761439 REASON stop
