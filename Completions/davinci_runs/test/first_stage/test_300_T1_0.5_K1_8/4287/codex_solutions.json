["\n\n\n\ndef main():\n    a,n,m = map(int,input().split())\n    rain = []\n    for i in range(n):\n        rain.append(list(map(int,input().split())))\n    umbrellas = []\n    for i in range(m):\n        umbrellas.append(list(map(int,input().split())))\n    umbrellas.sort()\n    rain.sort()\n    if rain[0][0] == 0:\n        print(-1)\n        return\n    umbrellas.insert(0,[0,0])\n    umbrellas.append([a,0])\n    rain.insert(0,[0,0])\n    rain.append([a,a])\n    dp = [[] for i in range(n+2)]\n    dp[0] = [0,0]\n    for i in range(1,n+2):\n        for j in range(1,m+2):\n            if rain[i-1][1] <= umbrellas[j][0]:\n                dp[i].append(dp[i-1][j-1])\n            else:\n                dp[i].append(min(dp[i-1][j-1],dp[i][j-1]+umbrellas[j][1]))\n    if dp[n+1][m+1] != dp[n][m+1]:\n        print(-1)\n        return\n    ans = dp[n+1][m+1]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    \"\"\"\n    The main function.\n    \"\"\"\n    # Read the input.\n    a, n, m = map(int, input().split())\n    rain = []\n    for _ in range(n):\n        rain.append(list(map(int, input().split())))\n    umbrellas = []\n    for _ in range(m):\n        umbrellas.append(list(map(int, input().split())))\n    # Run the algorithm.\n    answer = solve(a, rain, umbrellas)\n    # Print the answer.\n    print(answer)\n\ndef solve(a, rain, umbrellas):\n    \"\"\"\n    The solution function.\n    \"\"\"\n    # Sort the umbrellas by weight.\n    umbrellas.sort(key=lambda x: x[1])\n    # Build the graph.\n    graph = build_graph(a, rain, umbrellas)\n    # Find the shortest path from 0 to a.\n    if not graph.a in graph.shortest_paths(graph.zero):\n        return -1\n    # Find the answer.\n    return graph.shortest_paths(graph.zero)[graph.a]\n\ndef build_graph(a, rain, umbrellas):\n    \"\"\"\n    Builds the graph.\n    \"\"\"\n    # Build the graph.\n    graph = Graph()\n    # Add the zero node.\n    graph.zero = graph.add_node(0)\n    # Add the a node.\n    graph.a = graph.add_node(a)\n    # Add the rain nodes.\n    for segment in rain:\n        graph.add_node(segment[0])\n        graph.add_node(segment[1])\n    # Add the umbrella nodes.\n    for umbrella in umbrellas:\n        graph.add_node(umbrella[0])\n    # Add the edges.\n    for segment in rain:\n        graph.add_edge(segment[0], segment[1], None, 0)\n    for umbrella in umbrellas:\n        graph.add_edge(graph.zero, umbrella[0], None, 0)\n        graph.add_edge(umbrella[0], graph.a, None, umbrella[1])\n    # Return the graph.\n    return graph\n\nclass Graph:\n    \"\"\"\n    A simple graph class.\n    \"\"\"\n    class Node:\n        \"\"\"\n        A simple node class.\n        \"\"\"\n        def __init__(self, value):\n            self.value = value\n            self.edges = []\n\n        def __str__(self):\n            return str(self.value)\n\n        def __hash__(self):\n            return hash(self.value)\n\n    class Edge:\n        \"\"\"\n        A simple edge class.\n        \"\"\"\n        def __init__(self, node, weight):\n            self.node = node\n            self.weight = weight\n\n        def __str__(self):\n            return '{0}:{1}'.format(self.node.value, self.weight)\n\n    def __init__(self):\n        self.nodes = {}\n\n    def __str__(self):\n        result = ''\n        for node in self.nodes.values():\n            result += '{0} -> ['.format(node)\n            for edge in node.edges[:-1]:\n                result += '{0}, '.format(edge)\n            if node.edges:\n                result += '{0}'.format(node.edges[-1])\n            result += ']\\n'\n        return result[:-1]\n\n    def add_node(self, value):\n        node = self.Node(value)\n        self.nodes[value] = node\n        return node\n\n    def add_edge(self, source, target, bidirectional=True, weight=1):\n        source = self.nodes[source]\n        target = self.nodes[target]\n        source.edges.append(self.Edge(target, weight))\n        if bidirectional:\n            target.edges.append(self.Edge(source, weight))\n\n    def shortest_paths(self, source):\n        \"\"\"\n        Finds all shortest paths from the source.\n        \"\"\"\n        # Initialize the distance to infinity.\n        distances = {}\n        for node in self.nodes.values():\n            distances[node] = float('inf')\n        # Initialize the distance to the source to zero.\n        distances[source] = 0\n        # Initialize the queue.\n        queue = [source]\n        # Run the algorithm.\n        while queue:\n            # Get the next node.\n            node = queue.pop(0)\n            # Update the distances.\n            for edge in node.edges:\n                if distances[node] + edge.weight < distances[edge.node]:\n                    distances[edge.node] = distances[node] + edge.weight\n                    queue.append(edge.node)\n        # Return the distances.\n        return distances\n\nif __name__ == '__main__':\n    main()", "\n\n#-------------------------------------------------------------------------------\n\n\"\"\"\n    Approach : \n        - Greedy\n        - We need to move in the rain with at least one umbrella.\n        - We can't move in the rain with two umbrella.\n        - We can move in the rain with one umbrella.\n        - We can move outside the rain without umbrella.\n        - We can move outside the rain with umbrella.\n        - We can't move in the rain without umbrella.\n        - We can't move outside the rain with two umbrella.\n\n\n    Complexity Analysis :\n        - Time Complexity: O(N * M)\n        - Space Complexity: O(N + M)\n\"\"\"\n\n#-------------------------------------------------------------------------------\n\n# Python3 program to find minimum fatigue \n# to travel from 0 to a \n\n# Function to find minimum fatigue \ndef findMinFatigue(a, n, m, l, r, x, p): \n\n\t# dp[i][j] is the minimum fatigue \n\t# to travel from 0 to i if we have \n\t# j umbrellas with us \n\tdp = [[float('inf') for i in range(m + 1)] \n\t\t\tfor j in range(a + 1)] \n\n\t# Initialize dp[0][j] = 0 \n\t# It is already 0 \n\n\t# Initialize dp[i][1] \n\tfor i in range(a + 1): \n\t\tif i not in l: \n\t\t\tdp[i][1] = 0\n\n\t# Initialize dp[i][0] \n\t# It is impossible to travel \n\t# from 0 to i with 0 umbrellas \n\tfor i in range(1, a + 1): \n\t\tdp[i][0] = float('inf') \n\n\t# Calculate dp[i][j] \n\tfor i in range(1, a + 1): \n\t\tfor j in range(1, m + 1): \n\n\t\t\t# If we can travel from 0 to i \n\t\t\t# with j - 1 umbrellas \n\t\t\tif dp[i][j - 1] != float('inf'): \n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j - 1]) \n\n\t\t\t# If we can travel from 0 to i \n\t\t\t# without umbrella \n\t\t\tif i not in l: \n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j]) \n\n\t\t\t# If we can travel from 0 to i \n\t\t\t# with j - 1 umbrella and we can \n\t\t\t# travel from i - 1 to i with umbrella \n\t\t\tif dp[i][j - 1] != float('inf') and i - 1 in l: \n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + p[x.index(i - 1)]) \n\n\t# If we can't travel from 0 to a \n\tif dp[a][m] == float('inf'): \n\t\treturn -1\n\n\t# Else return minimum fatigue \n\treturn dp[a][m] \n\n# Driver Code \nif __name__ == '__main__': \n\ta, n, m = 10, 2, 4\n\tl = [3, 8] \n\tr = [7, 10] \n\tx = [0, 10, 3, 4, 8, 1, 1, 2] \n\tp = [10, 5, 4, 1, 1, 2] \n\tprint(findMinFatigue(a, n, m, l, r, x, p)) \n\n# This code is contributed by AnkitRai01", "\n\ndef main():\n    a, n, m = map(int, input().split())\n    rain = []\n    umbrellas = []\n    for _ in range(n):\n        rain.append(list(map(int, input().split())))\n    for _ in range(m):\n        umbrellas.append(list(map(int, input().split())))\n    umbrellas.sort()\n    rain.sort()\n    # print(rain)\n    # print(umbrellas)\n\n    # dp[i][j] = min fatigue to reach point i with j umbrellas\n    # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + weight)\n    dp = [[float('inf') for _ in range(m+1)] for _ in range(a+1)]\n    dp[0][0] = 0\n    for i in range(1, a+1):\n        for j in range(m+1):\n            dp[i][j] = dp[i-1][j]\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + umbrellas[j-1][1])\n        for r in rain:\n            if r[0] <= i <= r[1]:\n                dp[i][0] = float('inf')\n\n    # print(dp)\n    if dp[a][0] == float('inf'):\n        print(-1)\n    else:\n        print(dp[a][0])\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(a,n,m,segs,umbrellas):\n    pass\n\ndef main():\n    pass\n\nmain()", "\n\na, n, m = map(int, input().split())\n\nsegments = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\numbrellas = []\nfor _ in range(m):\n    x, p = map(int, input().split())\n    umbrellas.append((x, p))\n\n# print(a, n, m)\n# print(segments)\n# print(umbrellas)\n\n# dp[i][j] = min fatigue if we start at segment i and have umbrella j\ndp = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n\n# base case: no segments and no umbrellas\ndp[0][0] = 0\n\nfor i in range(n):\n    l, r = segments[i]\n    for j in range(m + 1):\n        x, p = umbrellas[j - 1] if j > 0 else (0, 0)\n        dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])\n        if l <= x <= r:\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + p)\n        if l <= x + 1 <= r:\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + p)\n\n# print(dp)\n\n# find min of all possible final states\nans = min(dp[n][j] for j in range(m + 1))\n\nprint(ans)", "\n\n# SOLUTION\n\nimport sys\n\ndef main():\n    a, n, m = map(int, sys.stdin.readline().split())\n    rain = [0] * (a + 1)\n    for i in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        rain[l] += 1\n        rain[r] -= 1\n    for i in range(a):\n        rain[i + 1] += rain[i]\n    umbrellas = []\n    for i in range(m):\n        x, p = map(int, sys.stdin.readline().split())\n        umbrellas.append((x, p))\n    umbrellas.sort()\n    dp = [0] * (a + 1)\n    umbrellas.append((a + 1, 0))\n    for i in range(a + 1):\n        dp[i] = (1 << 30)\n        if rain[i] == 0:\n            continue\n        for j in range(m + 1):\n            if umbrellas[j][0] > i:\n                break\n            dp[i] = min(dp[i], dp[max(0, umbrellas[j][0] - 1)] + umbrellas[j][1])\n    if dp[a] >= (1 << 30):\n        print(-1)\n    else:\n        print(dp[a])\n\nthreading.Thread(target=main).start()", "\n\nimport sys\n\ndef solve(a, n, m, l, r, x, p):\n    # dp[i] = (min_fatigue, min_fatigue_with_umbrella)\n    # dp[i][0] = min(dp[i-1][0] + p[i], dp[i-1][1])\n    # dp[i][1] = min(dp[i-1][0] + p[i], dp[i-1][1] + p[i])\n    dp = [[0, 0] for _ in range(m)]\n    for i in range(m):\n        if i == 0:\n            dp[i][0] = sys.maxsize\n            dp[i][1] = p[i]\n        else:\n            dp[i][0] = min(dp[i-1][0], dp[i-1][1])\n            dp[i][1] = min(dp[i-1][0] + p[i], dp[i-1][1] + p[i])\n    # print(dp)\n    min_fatigue = sys.maxsize\n    for i in range(m):\n        if l[i] <= 0 and 0 <= r[i]:\n            min_fatigue = min(min_fatigue, dp[i][1])\n        else:\n            min_fatigue = min(min_fatigue, dp[i][0])\n    return min_fatigue if min_fatigue != sys.maxsize else -1\n\nif __name__ == '__main__':\n    a, n, m = map(int, input().split())\n    l = []\n    r = []\n    for _ in range(n):\n        l_i, r_i = map(int, input().split())\n        l.append(l_i)\n        r.append(r_i)\n    x = []\n    p = []\n    for _ in range(m):\n        x_i, p_i = map(int, input().split())\n        x.append(x_i)\n        p.append(p_i)\n    print(solve(a, n, m, l, r, x, p))"]