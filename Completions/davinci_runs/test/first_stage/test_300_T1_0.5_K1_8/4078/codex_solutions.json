["", "\n\nimport sys\n\ndef main():\n    n, m = map(int, raw_input().split())\n    a = map(int, raw_input().split())\n\n    l = [0] * n\n    r = [0] * n\n    for i in range(m):\n        ll, rr = map(int, raw_input().split())\n        l[ll-1] += 1\n        r[rr-1] += 1\n\n    for i in range(1, n):\n        l[i] += l[i-1]\n        r[i] += r[i-1]\n\n    r.reverse()\n\n    for i in range(n-1, 0, -1):\n        r[i-1] += r[i]\n\n    r.reverse()\n\n    d = 0\n    for i in range(n):\n        d = max(d, abs(a[i] + l[i] - r[i]))\n\n    print d\n    print 0\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    segs = []\n    for i in range(m):\n        l, r = [int(x) for x in input().split()]\n        segs.append([l, r])\n    segs = sorted(segs, key=lambda x: (x[1] - x[0], x[0]))\n    #print(segs)\n    mn = min(a)\n    mx = max(a)\n    ans = mx - mn\n    print(ans)\n    if ans == 0:\n        print(0)\n        return\n    used = [False for _ in range(m)]\n    for i in range(m):\n        if not used[i] and a[segs[i][0]-1] == mn and a[segs[i][1]-1] == mx:\n            used[i] = True\n            break\n        if not used[i] and a[segs[i][0]-1] == mn:\n            for j in range(i+1, m):\n                if not used[j] and a[segs[j][1]-1] == mx:\n                    used[j] = True\n                    break\n            used[i] = True\n            break\n        if not used[i] and a[segs[i][1]-1] == mx:\n            for j in range(i+1, m):\n                if not used[j] and a[segs[j][0]-1] == mn:\n                    used[j] = True\n                    break\n            used[i] = True\n            break\n    print(used.count(True))\n    for i in range(m):\n        if used[i]:\n            print(i+1, end=' ')\n    print()\n    #print(used)\n    #print(segs)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\n# Read in the input\nraw_input = sys.stdin.read()\ntokens = raw_input.split()\n\nn = int(tokens[0])\nm = int(tokens[1])\n\na = list(map(int, tokens[2:2+n]))\n\nl = [None] * m\nr = [None] * m\n\nfor i in range(m):\n    l[i] = int(tokens[2+n+2*i])\n    r[i] = int(tokens[2+n+2*i+1])\n\n# This is the maximum possible value for the difference\n# of the min and max elements in the array.\nd = 0\n\n# This is the number of segments to apply.\nq = 0\n\n# This is the list of segments to apply.\nc = []\n\n# This is the index of the segment that is currently\n# being considered.\ni = 0\n\n# This is the index of the element in the array that\n# is currently being considered.\nj = 0\n\n# This is the current minimum element in the array.\nmin = a[0]\n\n# This is the current maximum element in the array.\nmax = a[0]\n\n# Find the maximum value for the difference of the min\n# and max elements in the array.\nwhile i < m:\n    # If the current element is in the current segment,\n    # then update the min and max values.\n    if j >= l[i] and j <= r[i]:\n        if a[j] < min:\n            min = a[j]\n        if a[j] > max:\n            max = a[j]\n    # If the current element is not in the current segment,\n    # then check if adding the current segment would increase\n    # the maximum difference of the min and max elements.\n    else:\n        # If the current segment is within the current min and max\n        # values, then adding the current segment would not increase\n        # the maximum difference of the min and max elements.\n        if min <= a[l[i]-1] and a[r[i]-1] <= max:\n            pass\n        # Otherwise, adding the current segment would increase the\n        # maximum difference of the min and max elements.\n        else:\n            # If the current difference of the min and max elements\n            # is less than the maximum difference of the min and max\n            # elements, then update the maximum difference and the\n            # list of segments to apply.\n            if max - min < max - a[l[i]-1] + a[r[i]-1] - min:\n                d = max - a[l[i]-1] + a[r[i]-1] - min\n                q = 1\n                c = [i+1]\n            # If the current difference of the min and max elements\n            # is equal to the maximum difference of the min and max\n            # elements, then add the current segment to the list of\n            # segments to apply.\n            elif max - min == max - a[l[i]-1] + a[r[i]-1] - min:\n                q += 1\n                c.append(i+1)\n        # Move on to the next segment.\n        i += 1\n    # Move on to the next element in the array.\n    j += 1\n\n# Print out the results.\nprint(d)\nprint(q)\nfor i in range(q):\n    print(c[i], end='')\n    if i < q-1:\n        print(' ', end='')\nprint()", "\n\n# SOLUTION\n# Input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Preprocessing\nfor i in range(m):\n    l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n\n    a[l] -= 1\n    if r < n - 1:\n        a[r + 1] += 1\n\n# Calculate\nfor i in range(1, n):\n    a[i] += a[i - 1]\n\n# Output\nprint(max(a) - min(a))\nprint(0)", "\n\nimport sys\nimport math\n\ndef read_ints():\n  temp = input().split()\n  temp = [int(t) for t in temp]\n  return temp\n\ndef read_tuple(convert_func):\n  temp = input().split()\n  temp = [convert_func(t) for t in temp]\n  return tuple(temp)\n\ndef read_int():\n  temp = input().split()\n  return int(temp[0])\n\ndef max_diff(a, b):\n  return max(a) - min(a)\n\ndef solve():\n  n, m = read_tuple(int)\n  a = read_ints()\n  segments = [read_tuple(int) for _ in range(m)]\n\n  # print(n, m)\n  # print(a)\n  # print(segments)\n\n  max_diffs = [0] * m\n  for i in range(m):\n    segment = segments[i]\n    l, r = segment\n    max_diffs[i] = max_diff(a[l-1:r])\n\n  # print(max_diffs)\n\n  max_diff_val = max(max_diffs)\n  max_diff_indices = []\n  for i in range(m):\n    if max_diffs[i] == max_diff_val:\n      max_diff_indices.append(i+1)\n\n  print(max_diff_val)\n  print(len(max_diff_indices))\n  print(' '.join([str(i) for i in max_diff_indices]))\n\nsolve()"]