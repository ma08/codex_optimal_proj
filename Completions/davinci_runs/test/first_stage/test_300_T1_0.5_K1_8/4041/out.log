2022-04-19 21:19:44.963353 """
The only difference between easy and hard versions is the length of the string.

You are given a string $s$ and a string $t$, both consisting only of lowercase Latin letters. It is guaranteed that $t$ can be obtained from $s$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $s$ without changing order of remaining characters (in other words, it is guaranteed that $t$ is a subsequence of $s$).

For example, the strings "test", "tst", "tt", "et" and "" are subsequences of the string "test". But the strings "tset", "se", "contest" are not subsequences of the string "test".

You want to remove some substring (contiguous subsequence) from $s$ of maximum possible length such that after removing this substring $t$ will remain a subsequence of $s$.

If you want to remove the substring $s[l;r]$ then the string $s$ will be transformed to $s_1 s_2 \dots s_{l-1} s_{r+1} s_{r+2} \dots s_{|s|-1} s_{|s|}$ (where $|s|$ is the length of $s$).

Your task is to find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.


-----Input-----

The first line of the input contains one string $s$ consisting of at least $1$ and at most $200$ lowercase Latin letters.

The second line of the input contains one string $t$ consisting of at least $1$ and at most $200$ lowercase Latin letters.

It is guaranteed that $t$ is a subsequence of $s$.


-----Output-----

Print one integer â€” the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.


-----Examples-----
Input
bbaba
bb

Output
3

Input
baaba
ab

Output
2

Input
abcde
abcde

Output
0

Input
asdfasdf
fasd

Output
3
"""
2022-04-19 21:19:44.963378 --------------------------
2022-04-19 21:19:44.963487 using api key sourya
2022-04-19 21:20:11.572264 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# s = input()\n# t = input()\n\ns = \"bbaba\"\nt = \"bb\"\n\nl = [0 for _ in range(len(s))]\n\nfor i in range(len(s)):\n    if s[i] in t:\n        l[i] = 1\n\nfor i in range(1, len(l)):\n    l[i] += l[i - 1]\n\nmax_len = 0\nfor i in range(len(l)):\n    for j in range(i, len(l)):\n        if l[j] - l[i] + l[i] == len(t):\n            max_len = max(max_len, j - i + 1)\nprint(max_len)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    len_s = len(s)\n    len_t = len(t)\n    # dp[i][j] means the max length of substring of s[0:i] and t[0:j]\n    dp = [[0 for j in range(len_t + 1)] for i in range(len_s + 1)]\n    for i in range(len_s + 1):\n        for j in range(len_t + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    print(len_s - dp[len_s][len_t])\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nsys.stdin = open('input.txt', 'r')\n\ndef find(s, t):\n\tl = 0\n\tr = len(s)\n\twhile l < r:\n\t\tm = (l + r) // 2\n\t\tif s[m] == t:\n\t\t\treturn m\n\t\telif s[m] > t:\n\t\t\tr = m\n\t\telse:\n\t\t\tl = m + 1\n\treturn -1\n\ns = input()\nt = input()\n\ni = 0\nwhile i < len(t):\n\tpos = find(s[i:], t[i])\n\tif pos == -1:\n\t\tbreak\n\telse:\n\t\ti += pos + 1\n\nprint(len(t) - i)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# Solution 1\n\ns = input()\nt = input()\n\nlst = []\n\nfor i in range(len(s)):\n    if s[i] in t:\n        lst.append(i)\n\nif len(lst) == len(t):\n    print(0)\nelse:\n    print(len(s) - max([lst[i+1] - lst[i] for i in range(len(lst)-1)]))\n\n# Solution 2\n\ns = input()\nt = input()\n\nlst = []\n\nfor i in range(len(s)):\n    if s[i] in t:\n        lst.append(i)\n\nif len(lst) == len(t):\n    print(0)\nelse:\n    print(len(s) - max([lst[i+1] - lst[i] for i in range(len(lst)-1)]))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef subsequence(s, t):\n    \"\"\" Returns the maximum length of a substring of s that can be removed\n    so that t remains a subsequence of s. \"\"\"\n    # We use dynamic programming. Our state is (i, j), where i is the index\n    # of the character in s and j is the index of the character in t. We\n    # want to know the longest substring that can be removed from s[:i] so\n    # that t[:j] is a subsequence of s[:i].\n    #\n    # We can make the transition by considering whether s[i] == t[j]. If so,\n    # then we need to remove a substring from s[:i-1] so that t[:j-1] is a\n    # subsequence of s[:i-1]. If not, then we need to remove a substring from\n    # s[:i-1] so that t[:j] is a subsequence of s[:i-1].\n    #\n    # The base case is when i == 0, in which case we can remove the entire\n    # substring s[:i] and t[:j] is a subsequence.\n    #\n    # The answer is the maximum value of dp[i][j] over all i and j.\n    n = len(s)\n    m = len(t)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n    return dp[n][m]\n\nprint(subsequence(input(), input()))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ns = input()\nt = input()\n\ndp = [[0 for i in range(len(s))] for j in range(len(t))]\n\nfor i in range(len(t)):\n    for j in range(len(s)):\n        if i == 0 and j == 0:\n            if t[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = 0\n        elif i == 0:\n            if t[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i][j-1]\n        elif j == 0:\n            if t[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j]\n        else:\n            if t[i] == s[j]:\n                dp[i][j] = max(dp[i-1][j-1]+1, dp[i-1][j], dp[i][j-1])\n            else:\n                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\n\nprint(len(s)-dp[-1][-1])"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef solve(s, t):\n    i = 0\n    j = 0\n    count = 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            j += 1\n        else:\n            count += 1\n        i += 1\n    return count + len(s) - i\n\ns = input()\nt = input()\nprint(solve(s, t))"
    }
  ],
  "created": 1650403185,
  "id": "cmpl-4ypY97wtP4OxyAVgICg9ZdrdkodaX",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:20:11.572626 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# s = input()\n# t = input()\n\ns = \"bbaba\"\nt = \"bb\"\n\nl = [0 for _ in range(len(s))]\n\nfor i in range(len(s)):\n    if s[i] in t:\n        l[i] = 1\n\nfor i in range(1, len(l)):\n    l[i] += l[i - 1]\n\nmax_len = 0\nfor i in range(len(l)):\n    for j in range(i, len(l)):\n        if l[j] - l[i] + l[i] == len(t):\n            max_len = max(max_len, j - i + 1)\nprint(max_len)"
}
2022-04-19 21:20:11.572668 REASON stop
2022-04-19 21:20:11.573314 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": ""
}
2022-04-19 21:20:11.573380 REASON stop
2022-04-19 21:20:11.573927 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    len_s = len(s)\n    len_t = len(t)\n    # dp[i][j] means the max length of substring of s[0:i] and t[0:j]\n    dp = [[0 for j in range(len_t + 1)] for i in range(len_s + 1)]\n    for i in range(len_s + 1):\n        for j in range(len_t + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    print(len_s - dp[len_s][len_t])\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:20:11.574026 REASON stop
2022-04-19 21:20:11.610626 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nsys.stdin = open('input.txt', 'r')\n\ndef find(s, t):\n\tl = 0\n\tr = len(s)\n\twhile l < r:\n\t\tm = (l + r) // 2\n\t\tif s[m] == t:\n\t\t\treturn m\n\t\telif s[m] > t:\n\t\t\tr = m\n\t\telse:\n\t\t\tl = m + 1\n\treturn -1\n\ns = input()\nt = input()\n\ni = 0\nwhile i < len(t):\n\tpos = find(s[i:], t[i])\n\tif pos == -1:\n\t\tbreak\n\telse:\n\t\ti += pos + 1\n\nprint(len(t) - i)"
}
2022-04-19 21:20:11.610775 REASON stop
2022-04-19 21:20:11.611489 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# Solution 1\n\ns = input()\nt = input()\n\nlst = []\n\nfor i in range(len(s)):\n    if s[i] in t:\n        lst.append(i)\n\nif len(lst) == len(t):\n    print(0)\nelse:\n    print(len(s) - max([lst[i+1] - lst[i] for i in range(len(lst)-1)]))\n\n# Solution 2\n\ns = input()\nt = input()\n\nlst = []\n\nfor i in range(len(s)):\n    if s[i] in t:\n        lst.append(i)\n\nif len(lst) == len(t):\n    print(0)\nelse:\n    print(len(s) - max([lst[i+1] - lst[i] for i in range(len(lst)-1)]))"
}
2022-04-19 21:20:11.611575 REASON stop
2022-04-19 21:20:11.635153 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef subsequence(s, t):\n    \"\"\" Returns the maximum length of a substring of s that can be removed\n    so that t remains a subsequence of s. \"\"\"\n    # We use dynamic programming. Our state is (i, j), where i is the index\n    # of the character in s and j is the index of the character in t. We\n    # want to know the longest substring that can be removed from s[:i] so\n    # that t[:j] is a subsequence of s[:i].\n    #\n    # We can make the transition by considering whether s[i] == t[j]. If so,\n    # then we need to remove a substring from s[:i-1] so that t[:j-1] is a\n    # subsequence of s[:i-1]. If not, then we need to remove a substring from\n    # s[:i-1] so that t[:j] is a subsequence of s[:i-1].\n    #\n    # The base case is when i == 0, in which case we can remove the entire\n    # substring s[:i] and t[:j] is a subsequence.\n    #\n    # The answer is the maximum value of dp[i][j] over all i and j.\n    n = len(s)\n    m = len(t)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n    return dp[n][m]\n\nprint(subsequence(input(), input()))"
}
2022-04-19 21:20:11.635288 REASON stop
2022-04-19 21:20:11.636490 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ns = input()\nt = input()\n\ndp = [[0 for i in range(len(s))] for j in range(len(t))]\n\nfor i in range(len(t)):\n    for j in range(len(s)):\n        if i == 0 and j == 0:\n            if t[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = 0\n        elif i == 0:\n            if t[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i][j-1]\n        elif j == 0:\n            if t[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j]\n        else:\n            if t[i] == s[j]:\n                dp[i][j] = max(dp[i-1][j-1]+1, dp[i-1][j], dp[i][j-1])\n            else:\n                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\n\nprint(len(s)-dp[-1][-1])"
}
2022-04-19 21:20:11.636606 REASON stop
2022-04-19 21:20:11.640987 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef solve(s, t):\n    i = 0\n    j = 0\n    count = 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            j += 1\n        else:\n            count += 1\n        i += 1\n    return count + len(s) - i\n\ns = input()\nt = input()\nprint(solve(s, t))"
}
2022-04-19 21:20:11.641186 REASON stop
