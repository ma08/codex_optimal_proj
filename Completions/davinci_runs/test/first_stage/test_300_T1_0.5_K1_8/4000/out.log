2022-04-19 20:47:23.716343 """
You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.

Your task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.

The simple path is the path that visits each vertex at most once.


-----Input-----

The first line contains one integer number $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of vertices in the tree. 

Next $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \le a_i$, $b_i \le n$, $a_i \ne b_i$). It is guaranteed that given graph is a tree.


-----Output-----

In the first line print one integer $res$ — the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.

In the second line print three integers $a, b, c$ such that $1 \le a, b, c \le n$ and $a \ne, b \ne c, a \ne c$.

If there are several answers, you can print any.


-----Example-----
Input
8
1 2
2 3
3 4
4 5
4 6
3 7
3 8

Output
5
1 8 6



-----Note-----

The picture corresponding to the first example (and another one correct answer):

[Image]

If you choose vertices $1, 5, 6$ then the path between $1$ and $5$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 5)$, the path between $1$ and $6$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 6)$ and the path between $5$ and $6$ consists of edges $(4, 5), (4, 6)$. The union of these paths is $(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)$ so the answer is $5$. It can be shown that there is no better answer.
"""
2022-04-19 20:47:23.716360 --------------------------
2022-04-19 20:47:23.716481 using api key derek
2022-04-19 20:48:51.884605 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nn = int(sys.stdin.readline())\n\n# read edges\nedges = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a, b = map(int, sys.stdin.readline().split())\n    edges[a].append(b)\n    edges[b].append(a)\n\n# get the degree of each node\ndegree = [0] * (n+1)\nfor i in range(1, n+1):\n    degree[i] = len(edges[i])\n\n# get the node with maximum degree\nmax_degree = max(degree)\nmax_degree_node = degree.index(max_degree)\n\n# get the second node with maximum degree\n# and remove the edge between the two nodes\nsecond_max_degree = 0\nsecond_max_degree_node = 0\nfor i in edges[max_degree_node]:\n    if degree[i] > second_max_degree:\n        second_max_degree = degree[i]\n        second_max_degree_node = i\nedges[max_degree_node].remove(second_max_degree_node)\nedges[second_max_degree_node].remove(max_degree_node)\n\n# get the third node with maximum degree\n# and remove the edge between the two nodes\nthird_max_degree = 0\nthird_max_degree_node = 0\nfor i in edges[max_degree_node]:\n    if degree[i] > third_max_degree:\n        third_max_degree = degree[i]\n        third_max_degree_node = i\nedges[max_degree_node].remove(third_max_degree_node)\nedges[third_max_degree_node].remove(max_degree_node)\n\nprint(max_degree + second_max_degree + third_max_degree)\nprint(max_degree_node, second_max_degree_node, third_max_degree_node)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n\ndef read_graph(n):\n    nodes = [Node(i) for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        a, b = a-1, b-1\n        nodes[a].children.append(b)\n        nodes[b].children.append(a)\n    return nodes\n\ndef find_path(nodes, start, end):\n    path = []\n    visited = set()\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            break\n        visited.add(node)\n        path.append(node)\n        for child in nodes[node].children:\n            if child not in visited:\n                queue.append(child)\n    return path\n\ndef find_max_path_size(nodes):\n    n = len(nodes)\n    max_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                path1 = find_path(nodes, i, j)\n                path2 = find_path(nodes, j, k)\n                path3 = find_path(nodes, i, k)\n                path_size = len(set(path1 + path2 + path3))\n                max_size = max(max_size, path_size)\n    return max_size\n\ndef find_max_path_size_optimized(nodes):\n    n = len(nodes)\n    max_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                path1 = find_path(nodes, i, j)\n                path2 = find_path(nodes, j, k)\n                path3 = find_path(nodes, i, k)\n                #path_size = len(set(path1 + path2 + path3))\n                path_size = len(set(path1 + path2))\n                path_size += len(set(path1 + path3))\n                path_size += len(set(path2 + path3))\n                path_size -= len(set(path1))\n                path_size -= len(set(path2))\n                path_size -= len(set(path3))\n                path_size += len(set(path1) & set(path2))\n                path_size += len(set(path1) & set(path3))\n                path_size += len(set(path2) & set(path3))\n                path_size += len(set(path1) & set(path2) & set(path3))\n                max_size = max(max_size, path_size)\n    return max_size\n\ndef main():\n    n = int(sys.stdin.readline())\n    assert 3 <= n <= 200000\n    nodes = read_graph(n)\n    max_size = find_max_path_size_optimized(nodes)\n    print(max_size)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            if dp[u] > 0:\n                dp[v] += dp[u]\n                if dp[u] > 1:\n                    dp[v] += 1\n                if dp[v] > res[0]:\n                    res[0] = dp[v]\n                    res[1] = v\n                    res[2] = u\n                    res[3] = -1\n                elif dp[v] == res[0] and res[3] == -1:\n                    res[3] = u\n\nn = int(input())\ng = [[] for i in range(n + 1)]\ndp = [0] * (n + 1)\nres = [0, 0, 0, -1]\n\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n\ndfs(1, -1)\n\nprint(res[0])\nprint(res[1], res[3], res[2])"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# Solution:\n\nn = int(input())\nedges = []\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n\npath = [[0] * n for i in range(n)]\nfor i in edges:\n    path[i[0]-1][i[1]-1] = 1\n    path[i[1]-1][i[0]-1] = 1\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            path[i][j] = path[i][j] or path[i][k] and path[k][j]\n\nmax_path = 0\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i != j and j != k and k != i:\n                max_path = max(max_path, path[i][j] + path[j][k] + path[k][i])\n\nprint(max_path)\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i != j and j != k and k != i:\n                if path[i][j] + path[j][k] + path[k][i] == max_path:\n                    print(i+1, j+1, k+1)\n                    exit()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 5,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\nfrom sys import setrecursionlimit\nfrom sys import stdin\n\nsetrecursionlimit(10 ** 6)\n\nn = int(input())\n\nedges = defaultdict(set)\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    edges[a].add(b)\n    edges[b].add(a)\n\nvisited = set()\n\ndef dfs(v):\n    visited.add(v)\n    for u in edges[v]:\n        if u not in visited:\n            dfs(u)\n\ndfs(1)\n\nif len(visited) != n:\n    print(0)\n    print(*visited)\n    exit()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nif len(visited) == n:\n    print(0)\n    print(1, 2, 3)\n    exit()\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport os\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_int():\n    return int(input())\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return list(map(str, input().split()))\n\ndef read_str_list():\n    return input().split()\n\ndef read_grid(rows, read_item):\n    return [read_item() for _ in range(rows)]\n\ndef read_ints_grid(rows):\n    return read_grid(rows, read_int)\n\ndef read_strs_grid(rows):\n    return read_grid(rows, read_str)\n\ndef read_str_list_grid(rows):\n    return read_grid(rows, read_str_list)\n\ndef read_lines(n, read_item):\n    return [read_item() for _ in range(n)]\n\ndef read_ints_lines(n):\n    return read_lines(n, read_int)\n\ndef read_strs_lines(n):\n    return read_lines(n, read_str)\n\ndef read_str_list_lines(n):\n    return read_lines(n, read_str_list)\n\ndef write_case_ans(i, ans):\n    print(\"Case #{}: {}\".format(i, ans))\n\ndef write_line_ans(ans):\n    print(ans)\n\ndef write_grid(rows):\n    for row in rows:\n        print(\" \".join(map(str, row)))\n\ndef write_grid_ans(ans):\n    write_grid(ans)\n\ndef write_str_list_ans(ans):\n    print(\" \".join(ans))\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, a, b):\n        self.edges[a].append(b)\n        self.edges[b].append(a)\n\n\ndef read_graph(n, read_edge):\n    g = Graph(n)\n    for _ in range(n - 1):\n        a, b = read_edge()\n        g.add_edge(a - 1, b - 1)\n    return g\n\ndef read_graph_ints(n):\n    return read_graph(n, read_ints)\n\ndef read_graph_strs(n):\n    return read_graph(n, read_strs)\n\ndef read_graph_str_list(n):\n    return read_graph(n, read_str_list)\n\ndef dfs(g, v, p, c):\n    c[v] = 1\n    for u in g.edges[v]:\n        if u == p:\n            continue\n        dfs(g, u, v, c)\n\ndef solve_small(g):\n    n = g.n\n    c = [0] * n\n    dfs(g, 0, -1, c)\n    a = c.index(1)\n    c = [0] * n\n    dfs(g, a, -1, c)\n    b = c.index(1)\n    c = [0] * n\n    dfs(g, b, -1, c)\n    c = c.index(1)\n    d = [0] * n\n    dfs(g, c, -1, d)\n    d = d.index(1)\n    e = [0] * n\n    dfs(g, d, -1, e)\n    e = e.index(1)\n    f = [0] * n\n    dfs(g, e, -1, f)\n    f = f.index(1)\n    ans = n - 1\n    if c in g.edges[d]:\n        ans -= 1\n    if d in g.edges[e]:\n        ans -= 1\n    if e in g.edges[f]:\n        ans -= 1\n    return ans, [a + 1, b + 1, c + 1]\n\ndef solve(g):\n    n = g.n\n    if n <= 10:\n        return solve_small(g)\n    a = 0\n    b = 1\n    c = 2\n    d = 3\n    e = 4\n    f = 5\n    ans = n - 1\n    if b in g.edges[c]:\n        ans -= 1\n    if c in g.edges[d]:\n        ans -= 1\n    if d in g.edges[e]:\n        ans -= 1\n    if e in g.edges[f]:\n        ans -= 1\n    return ans, [a + 1, b + 1, c + 1]\n\ndef main():\n    g = read_graph_ints(read_int())\n    ans, abc = solve(g)\n    write_line_ans(ans)\n    write_str_list_ans(map(str, abc))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650401246,
  "id": "cmpl-4yp2sASiFwmUSPf87UPRpbAKYcvao",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 20:48:51.885134 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nn = int(sys.stdin.readline())\n\n# read edges\nedges = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a, b = map(int, sys.stdin.readline().split())\n    edges[a].append(b)\n    edges[b].append(a)\n\n# get the degree of each node\ndegree = [0] * (n+1)\nfor i in range(1, n+1):\n    degree[i] = len(edges[i])\n\n# get the node with maximum degree\nmax_degree = max(degree)\nmax_degree_node = degree.index(max_degree)\n\n# get the second node with maximum degree\n# and remove the edge between the two nodes\nsecond_max_degree = 0\nsecond_max_degree_node = 0\nfor i in edges[max_degree_node]:\n    if degree[i] > second_max_degree:\n        second_max_degree = degree[i]\n        second_max_degree_node = i\nedges[max_degree_node].remove(second_max_degree_node)\nedges[second_max_degree_node].remove(max_degree_node)\n\n# get the third node with maximum degree\n# and remove the edge between the two nodes\nthird_max_degree = 0\nthird_max_degree_node = 0\nfor i in edges[max_degree_node]:\n    if degree[i] > third_max_degree:\n        third_max_degree = degree[i]\n        third_max_degree_node = i\nedges[max_degree_node].remove(third_max_degree_node)\nedges[third_max_degree_node].remove(max_degree_node)\n\nprint(max_degree + second_max_degree + third_max_degree)\nprint(max_degree_node, second_max_degree_node, third_max_degree_node)"
}
2022-04-19 20:48:51.885188 REASON stop
2022-04-19 20:48:51.920256 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\nimport sys\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n\ndef read_graph(n):\n    nodes = [Node(i) for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        a, b = a-1, b-1\n        nodes[a].children.append(b)\n        nodes[b].children.append(a)\n    return nodes\n\ndef find_path(nodes, start, end):\n    path = []\n    visited = set()\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            break\n        visited.add(node)\n        path.append(node)\n        for child in nodes[node].children:\n            if child not in visited:\n                queue.append(child)\n    return path\n\ndef find_max_path_size(nodes):\n    n = len(nodes)\n    max_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                path1 = find_path(nodes, i, j)\n                path2 = find_path(nodes, j, k)\n                path3 = find_path(nodes, i, k)\n                path_size = len(set(path1 + path2 + path3))\n                max_size = max(max_size, path_size)\n    return max_size\n\ndef find_max_path_size_optimized(nodes):\n    n = len(nodes)\n    max_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                path1 = find_path(nodes, i, j)\n                path2 = find_path(nodes, j, k)\n                path3 = find_path(nodes, i, k)\n                #path_size = len(set(path1 + path2 + path3))\n                path_size = len(set(path1 + path2))\n                path_size += len(set(path1 + path3))\n                path_size += len(set(path2 + path3))\n                path_size -= len(set(path1))\n                path_size -= len(set(path2))\n                path_size -= len(set(path3))\n                path_size += len(set(path1) & set(path2))\n                path_size += len(set(path1) & set(path3))\n                path_size += len(set(path2) & set(path3))\n                path_size += len(set(path1) & set(path2) & set(path3))\n                max_size = max(max_size, path_size)\n    return max_size\n\ndef main():\n    n = int(sys.stdin.readline())\n    assert 3 <= n <= 200000\n    nodes = read_graph(n)\n    max_size = find_max_path_size_optimized(nodes)\n    print(max_size)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 20:48:51.920402 REASON stop
2022-04-19 20:48:51.921099 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            if dp[u] > 0:\n                dp[v] += dp[u]\n                if dp[u] > 1:\n                    dp[v] += 1\n                if dp[v] > res[0]:\n                    res[0] = dp[v]\n                    res[1] = v\n                    res[2] = u\n                    res[3] = -1\n                elif dp[v] == res[0] and res[3] == -1:\n                    res[3] = u\n\nn = int(input())\ng = [[] for i in range(n + 1)]\ndp = [0] * (n + 1)\nres = [0, 0, 0, -1]\n\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n\ndfs(1, -1)\n\nprint(res[0])\nprint(res[1], res[3], res[2])"
}
2022-04-19 20:48:51.921205 REASON stop
2022-04-19 20:48:51.939423 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# Solution:\n\nn = int(input())\nedges = []\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n\npath = [[0] * n for i in range(n)]\nfor i in edges:\n    path[i[0]-1][i[1]-1] = 1\n    path[i[1]-1][i[0]-1] = 1\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            path[i][j] = path[i][j] or path[i][k] and path[k][j]\n\nmax_path = 0\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i != j and j != k and k != i:\n                max_path = max(max_path, path[i][j] + path[j][k] + path[k][i])\n\nprint(max_path)\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i != j and j != k and k != i:\n                if path[i][j] + path[j][k] + path[k][i] == max_path:\n                    print(i+1, j+1, k+1)\n                    exit()"
}
2022-04-19 20:48:51.939568 REASON stop
2022-04-19 20:48:51.940619 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:48:51.940765 REASON stop
2022-04-19 20:48:51.955707 5 {
  "finish_reason": "length",
  "index": 5,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\nfrom sys import setrecursionlimit\nfrom sys import stdin\n\nsetrecursionlimit(10 ** 6)\n\nn = int(input())\n\nedges = defaultdict(set)\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    edges[a].add(b)\n    edges[b].add(a)\n\nvisited = set()\n\ndef dfs(v):\n    visited.add(v)\n    for u in edges[v]:\n        if u not in visited:\n            dfs(u)\n\ndfs(1)\n\nif len(visited) != n:\n    print(0)\n    print(*visited)\n    exit()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nif len(visited) == n:\n    print(0)\n    print(1, 2, 3)\n    exit()\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n\ndfs(1, 0)\n\nvisited = set()\n\ndef dfs(v, p):\n    visited.add(v)\n    for u in edges[v]:"
}
2022-04-19 20:48:51.955911 REASON length
2022-04-19 20:48:51.955922 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport os\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_int():\n    return int(input())\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return list(map(str, input().split()))\n\ndef read_str_list():\n    return input().split()\n\ndef read_grid(rows, read_item):\n    return [read_item() for _ in range(rows)]\n\ndef read_ints_grid(rows):\n    return read_grid(rows, read_int)\n\ndef read_strs_grid(rows):\n    return read_grid(rows, read_str)\n\ndef read_str_list_grid(rows):\n    return read_grid(rows, read_str_list)\n\ndef read_lines(n, read_item):\n    return [read_item() for _ in range(n)]\n\ndef read_ints_lines(n):\n    return read_lines(n, read_int)\n\ndef read_strs_lines(n):\n    return read_lines(n, read_str)\n\ndef read_str_list_lines(n):\n    return read_lines(n, read_str_list)\n\ndef write_case_ans(i, ans):\n    print(\"Case #{}: {}\".format(i, ans))\n\ndef write_line_ans(ans):\n    print(ans)\n\ndef write_grid(rows):\n    for row in rows:\n        print(\" \".join(map(str, row)))\n\ndef write_grid_ans(ans):\n    write_grid(ans)\n\ndef write_str_list_ans(ans):\n    print(\" \".join(ans))\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, a, b):\n        self.edges[a].append(b)\n        self.edges[b].append(a)\n\n\ndef read_graph(n, read_edge):\n    g = Graph(n)\n    for _ in range(n - 1):\n        a, b = read_edge()\n        g.add_edge(a - 1, b - 1)\n    return g\n\ndef read_graph_ints(n):\n    return read_graph(n, read_ints)\n\ndef read_graph_strs(n):\n    return read_graph(n, read_strs)\n\ndef read_graph_str_list(n):\n    return read_graph(n, read_str_list)\n\ndef dfs(g, v, p, c):\n    c[v] = 1\n    for u in g.edges[v]:\n        if u == p:\n            continue\n        dfs(g, u, v, c)\n\ndef solve_small(g):\n    n = g.n\n    c = [0] * n\n    dfs(g, 0, -1, c)\n    a = c.index(1)\n    c = [0] * n\n    dfs(g, a, -1, c)\n    b = c.index(1)\n    c = [0] * n\n    dfs(g, b, -1, c)\n    c = c.index(1)\n    d = [0] * n\n    dfs(g, c, -1, d)\n    d = d.index(1)\n    e = [0] * n\n    dfs(g, d, -1, e)\n    e = e.index(1)\n    f = [0] * n\n    dfs(g, e, -1, f)\n    f = f.index(1)\n    ans = n - 1\n    if c in g.edges[d]:\n        ans -= 1\n    if d in g.edges[e]:\n        ans -= 1\n    if e in g.edges[f]:\n        ans -= 1\n    return ans, [a + 1, b + 1, c + 1]\n\ndef solve(g):\n    n = g.n\n    if n <= 10:\n        return solve_small(g)\n    a = 0\n    b = 1\n    c = 2\n    d = 3\n    e = 4\n    f = 5\n    ans = n - 1\n    if b in g.edges[c]:\n        ans -= 1\n    if c in g.edges[d]:\n        ans -= 1\n    if d in g.edges[e]:\n        ans -= 1\n    if e in g.edges[f]:\n        ans -= 1\n    return ans, [a + 1, b + 1, c + 1]\n\ndef main():\n    g = read_graph_ints(read_int())\n    ans, abc = solve(g)\n    write_line_ans(ans)\n    write_str_list_ans(map(str, abc))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:48:51.955970 REASON stop
2022-04-19 20:48:51.958411 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:48:51.958590 REASON stop
