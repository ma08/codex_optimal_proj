["\n\nimport os\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_int():\n    return int(input())\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return list(map(str, input().split()))\n\ndef read_str_list():\n    return input().split()\n\ndef read_grid(rows, read_item):\n    return [read_item() for _ in range(rows)]\n\ndef read_ints_grid(rows):\n    return read_grid(rows, read_int)\n\ndef read_strs_grid(rows):\n    return read_grid(rows, read_str)\n\ndef read_str_list_grid(rows):\n    return read_grid(rows, read_str_list)\n\ndef read_lines(n, read_item):\n    return [read_item() for _ in range(n)]\n\ndef read_ints_lines(n):\n    return read_lines(n, read_int)\n\ndef read_strs_lines(n):\n    return read_lines(n, read_str)\n\ndef read_str_list_lines(n):\n    return read_lines(n, read_str_list)\n\ndef write_case_ans(i, ans):\n    print(\"Case #{}: {}\".format(i, ans))\n\ndef write_line_ans(ans):\n    print(ans)\n\ndef write_grid(rows):\n    for row in rows:\n        print(\" \".join(map(str, row)))\n\ndef write_grid_ans(ans):\n    write_grid(ans)\n\ndef write_str_list_ans(ans):\n    print(\" \".join(ans))\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, a, b):\n        self.edges[a].append(b)\n        self.edges[b].append(a)\n\n\ndef read_graph(n, read_edge):\n    g = Graph(n)\n    for _ in range(n - 1):\n        a, b = read_edge()\n        g.add_edge(a - 1, b - 1)\n    return g\n\ndef read_graph_ints(n):\n    return read_graph(n, read_ints)\n\ndef read_graph_strs(n):\n    return read_graph(n, read_strs)\n\ndef read_graph_str_list(n):\n    return read_graph(n, read_str_list)\n\ndef dfs(g, v, p, c):\n    c[v] = 1\n    for u in g.edges[v]:\n        if u == p:\n            continue\n        dfs(g, u, v, c)\n\ndef solve_small(g):\n    n = g.n\n    c = [0] * n\n    dfs(g, 0, -1, c)\n    a = c.index(1)\n    c = [0] * n\n    dfs(g, a, -1, c)\n    b = c.index(1)\n    c = [0] * n\n    dfs(g, b, -1, c)\n    c = c.index(1)\n    d = [0] * n\n    dfs(g, c, -1, d)\n    d = d.index(1)\n    e = [0] * n\n    dfs(g, d, -1, e)\n    e = e.index(1)\n    f = [0] * n\n    dfs(g, e, -1, f)\n    f = f.index(1)\n    ans = n - 1\n    if c in g.edges[d]:\n        ans -= 1\n    if d in g.edges[e]:\n        ans -= 1\n    if e in g.edges[f]:\n        ans -= 1\n    return ans, [a + 1, b + 1, c + 1]\n\ndef solve(g):\n    n = g.n\n    if n <= 10:\n        return solve_small(g)\n    a = 0\n    b = 1\n    c = 2\n    d = 3\n    e = 4\n    f = 5\n    ans = n - 1\n    if b in g.edges[c]:\n        ans -= 1\n    if c in g.edges[d]:\n        ans -= 1\n    if d in g.edges[e]:\n        ans -= 1\n    if e in g.edges[f]:\n        ans -= 1\n    return ans, [a + 1, b + 1, c + 1]\n\ndef main():\n    g = read_graph_ints(read_int())\n    ans, abc = solve(g)\n    write_line_ans(ans)\n    write_str_list_ans(map(str, abc))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nn = int(sys.stdin.readline())\n\n# read edges\nedges = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a, b = map(int, sys.stdin.readline().split())\n    edges[a].append(b)\n    edges[b].append(a)\n\n# get the degree of each node\ndegree = [0] * (n+1)\nfor i in range(1, n+1):\n    degree[i] = len(edges[i])\n\n# get the node with maximum degree\nmax_degree = max(degree)\nmax_degree_node = degree.index(max_degree)\n\n# get the second node with maximum degree\n# and remove the edge between the two nodes\nsecond_max_degree = 0\nsecond_max_degree_node = 0\nfor i in edges[max_degree_node]:\n    if degree[i] > second_max_degree:\n        second_max_degree = degree[i]\n        second_max_degree_node = i\nedges[max_degree_node].remove(second_max_degree_node)\nedges[second_max_degree_node].remove(max_degree_node)\n\n# get the third node with maximum degree\n# and remove the edge between the two nodes\nthird_max_degree = 0\nthird_max_degree_node = 0\nfor i in edges[max_degree_node]:\n    if degree[i] > third_max_degree:\n        third_max_degree = degree[i]\n        third_max_degree_node = i\nedges[max_degree_node].remove(third_max_degree_node)\nedges[third_max_degree_node].remove(max_degree_node)\n\nprint(max_degree + second_max_degree + third_max_degree)\nprint(max_degree_node, second_max_degree_node, third_max_degree_node)", "\nimport sys\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.children = []\n\ndef read_graph(n):\n    nodes = [Node(i) for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        a, b = a-1, b-1\n        nodes[a].children.append(b)\n        nodes[b].children.append(a)\n    return nodes\n\ndef find_path(nodes, start, end):\n    path = []\n    visited = set()\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            break\n        visited.add(node)\n        path.append(node)\n        for child in nodes[node].children:\n            if child not in visited:\n                queue.append(child)\n    return path\n\ndef find_max_path_size(nodes):\n    n = len(nodes)\n    max_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                path1 = find_path(nodes, i, j)\n                path2 = find_path(nodes, j, k)\n                path3 = find_path(nodes, i, k)\n                path_size = len(set(path1 + path2 + path3))\n                max_size = max(max_size, path_size)\n    return max_size\n\ndef find_max_path_size_optimized(nodes):\n    n = len(nodes)\n    max_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                path1 = find_path(nodes, i, j)\n                path2 = find_path(nodes, j, k)\n                path3 = find_path(nodes, i, k)\n                #path_size = len(set(path1 + path2 + path3))\n                path_size = len(set(path1 + path2))\n                path_size += len(set(path1 + path3))\n                path_size += len(set(path2 + path3))\n                path_size -= len(set(path1))\n                path_size -= len(set(path2))\n                path_size -= len(set(path3))\n                path_size += len(set(path1) & set(path2))\n                path_size += len(set(path1) & set(path3))\n                path_size += len(set(path2) & set(path3))\n                path_size += len(set(path1) & set(path2) & set(path3))\n                max_size = max(max_size, path_size)\n    return max_size\n\ndef main():\n    n = int(sys.stdin.readline())\n    assert 3 <= n <= 200000\n    nodes = read_graph(n)\n    max_size = find_max_path_size_optimized(nodes)\n    print(max_size)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n    for u in g[v]:\n        if u != p:\n            dfs(u, v)\n            if dp[u] > 0:\n                dp[v] += dp[u]\n                if dp[u] > 1:\n                    dp[v] += 1\n                if dp[v] > res[0]:\n                    res[0] = dp[v]\n                    res[1] = v\n                    res[2] = u\n                    res[3] = -1\n                elif dp[v] == res[0] and res[3] == -1:\n                    res[3] = u\n\nn = int(input())\ng = [[] for i in range(n + 1)]\ndp = [0] * (n + 1)\nres = [0, 0, 0, -1]\n\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n\ndfs(1, -1)\n\nprint(res[0])\nprint(res[1], res[3], res[2])", "\n\n# Solution:\n\nn = int(input())\nedges = []\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n\npath = [[0] * n for i in range(n)]\nfor i in edges:\n    path[i[0]-1][i[1]-1] = 1\n    path[i[1]-1][i[0]-1] = 1\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            path[i][j] = path[i][j] or path[i][k] and path[k][j]\n\nmax_path = 0\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i != j and j != k and k != i:\n                max_path = max(max_path, path[i][j] + path[j][k] + path[k][i])\n\nprint(max_path)\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if i != j and j != k and k != i:\n                if path[i][j] + path[j][k] + path[k][i] == max_path:\n                    print(i+1, j+1, k+1)\n                    exit()", "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"]