2022-04-19 21:08:54.171035 """
This is a hard version of the problem. The actual problems are different, but the easy version is almost a subtask of the hard version. Note that the constraints and the output format are different.

You are given a string $s$ consisting of $n$ lowercase Latin letters.

You have to color all its characters the minimum number of colors (each character to exactly one color, the same letters can be colored the same or different colors, i.e. you can choose exactly one color for each index in $s$).

After coloring, you can swap any two neighboring characters of the string that are colored different colors. You can perform such an operation arbitrary (possibly, zero) number of times.

The goal is to make the string sorted, i.e. all characters should be in alphabetical order.

Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by some sequence of swaps. Note that you have to restore only coloring, not the sequence of swaps.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the length of $s$.

The second line of the input contains the string $s$ consisting of exactly $n$ lowercase Latin letters.


-----Output-----

In the first line print one integer $res$ ($1 \le res \le n$) — the minimum number of colors in which you have to color the given string so that after coloring it can become sorted by some sequence of swaps.

In the second line print any possible coloring that can be used to sort the string using some sequence of swaps described in the problem statement. The coloring is the array $c$ of length $n$, where $1 \le c_i \le res$ and $c_i$ means the color of the $i$-th character.


-----Examples-----
Input
9
abacbecfd

Output
2
1 1 2 1 2 1 2 1 2 

Input
8
aaabbcbb

Output
2
1 2 1 2 1 2 1 1

Input
7
abcdedc

Output
3
1 1 1 1 1 2 3 

Input
5
abcde

Output
1
1 1 1 1 1
"""
2022-04-19 21:08:54.171053 --------------------------
2022-04-19 21:08:54.171163 using api key derek
2022-04-19 21:08:54.289638 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 21:08:59.294996 """
This is a hard version of the problem. The actual problems are different, but the easy version is almost a subtask of the hard version. Note that the constraints and the output format are different.

You are given a string $s$ consisting of $n$ lowercase Latin letters.

You have to color all its characters the minimum number of colors (each character to exactly one color, the same letters can be colored the same or different colors, i.e. you can choose exactly one color for each index in $s$).

After coloring, you can swap any two neighboring characters of the string that are colored different colors. You can perform such an operation arbitrary (possibly, zero) number of times.

The goal is to make the string sorted, i.e. all characters should be in alphabetical order.

Your task is to find the minimum number of colors which you have to color the given string in so that after coloring it can become sorted by some sequence of swaps. Note that you have to restore only coloring, not the sequence of swaps.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the length of $s$.

The second line of the input contains the string $s$ consisting of exactly $n$ lowercase Latin letters.


-----Output-----

In the first line print one integer $res$ ($1 \le res \le n$) — the minimum number of colors in which you have to color the given string so that after coloring it can become sorted by some sequence of swaps.

In the second line print any possible coloring that can be used to sort the string using some sequence of swaps described in the problem statement. The coloring is the array $c$ of length $n$, where $1 \le c_i \le res$ and $c_i$ means the color of the $i$-th character.


-----Examples-----
Input
9
abacbecfd

Output
2
1 1 2 1 2 1 2 1 2 

Input
8
aaabbcbb

Output
2
1 2 1 2 1 2 1 1

Input
7
abcdedc

Output
3
1 1 1 1 1 2 3 

Input
5
abcde

Output
1
1 1 1 1 1
"""
2022-04-19 21:08:59.295037 --------------------------
2022-04-19 21:08:59.295171 using api key gabby
2022-04-19 21:09:34.275231 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\n# Because we can swap any two neighboring characters of the string that are colored different colors.\n# We can just sort the string by character.\n# Then we can color the string by the sorted order.\ns = sorted(s)\n\n# Because we can swap any two neighboring characters of the string that are colored different colors.\n# We can just color the string by the sorted order.\n# Then we can sort the string by color.\nc = [0] * n\nfor i in range(n):\n    c[i] = s.index(s[i]) + 1\n\nprint(max(c))\nprint(*c)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\nc = [0] * n\nres = 1\nprev = s[0]\nfor i, v in enumerate(s):\n    if v == prev:\n        c[i] = c[i - 1]\n    else:\n        c[i] = c[i - 1] + 1\n        res = c[i]\n    prev = v\n\n\nprint(res)\nprint(*c)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# SOLUTION\nn = int(input())\ns = input()\n\ncolors = [1] * n\n\nfor i in range(1, n):\n    if s[i] == s[i-1]:\n        colors[i] = colors[i-1]\n    else:\n        colors[i] = colors[i-1] + 1\n\nprint(colors[-1])\nprint(*colors)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # the sorted string and the number of swaps needed to sort it\n    sorted_str, num_swaps = sort_string(s)\n\n    # the minimum number of colors needed to sort the string\n    min_colors = len(set(sorted_str))\n\n    # the coloring of the string\n    coloring = get_coloring(sorted_str, min_colors)\n\n    # print the results\n    print(min_colors)\n    print(' '.join(map(str, coloring)))\n\n\ndef sort_string(s):\n    \"\"\"\n    Returns the sorted string and the number of swaps needed to sort it.\n    \"\"\"\n    # the sorted string\n    sorted_str = sorted(s)\n\n    # the number of swaps needed to sort it\n    num_swaps = 0\n\n    # the number of swaps needed to sort the string\n    # will be the sum of the distances of each letter to its sorted position\n    for i in range(len(s)):\n        num_swaps += abs(i - sorted_str.index(s[i]))\n\n    return (sorted_str, num_swaps)\n\n\ndef get_coloring(sorted_str, min_colors):\n    \"\"\"\n    Returns the coloring of the string.\n    \"\"\"\n    # the coloring of the string\n    coloring = [None] * len(sorted_str)\n\n    # the color of the current letter\n    curr_color = 1\n\n    # the first letter of the current color\n    first_letter = sorted_str[0]\n\n    # the color of the first letter\n    coloring[0] = curr_color\n\n    # iterate through the sorted string\n    for i in range(1, len(sorted_str)):\n        # if the current letter is the same as the first letter of the current color\n        if sorted_str[i] == first_letter:\n            # increment the current color\n            curr_color = (curr_color + 1) % min_colors\n            # if the current color is 0, set it to the minimum color\n            if curr_color == 0:\n                curr_color = min_colors\n            # set the first letter of the current color to the current letter\n            first_letter = sorted_str[i]\n        # set the color of the current letter to the current color\n        coloring[i] = curr_color\n\n    return coloring\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom collections import Counter\n\nn = int(input())\ns = input()\n\n# count the number of each character\n# if there are more than 2 characters, the answer is 2\n# if there are 2 characters, the answer is 1\n# if there is 1 character, the answer is 1\n# in any case, the answer is the number of distinct characters\n\nc = Counter(s)\n\nif len(c) == 1:\n    print(1)\n    print(' '.join([str(1)] * n))\nelif len(c) == 2:\n    print(1)\n    for i in range(n):\n        if c[s[i]] == 1:\n            print(2, end=' ')\n        else:\n            print(1, end=' ')\n    print()\nelse:\n    print(2)\n    for i in range(n):\n        if c[s[i]] == 1:\n            print(2, end=' ')\n        else:\n            print(1, end=' ')\n    print()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    The main function that reads input and calls the other functions\n    \"\"\"\n    n = int(sys.stdin.readline())\n    string = sys.stdin.readline().rstrip()\n    solution = string_sorting(n, string)\n    print(len(solution))\n    print(*solution)\n\ndef string_sorting(n, string):\n    \"\"\"\n    Takes the number of characters and the string and returns the solution\n    \"\"\"\n    solution = [1]\n    for i in range(1, n):\n        if string[i] != string[i - 1]:\n            solution.append(solution[i - 1] + 1)\n        else:\n            solution.append(solution[i - 1])\n    return solution\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # count the number of times each character appears\n    counts = defaultdict(int)\n    for c in s:\n        counts[c] += 1\n\n    # build the coloring\n    coloring = []\n    for c in s:\n        if counts[c] == 0:\n            continue\n        counts[c] -= 1\n        coloring.append(c)\n    print(len(coloring))\n    print(*coloring)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n#-----SOLUTION-----\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\ns = input()\n\nans = [1] * n\nfor i in range(1, n):\n    if s[i] == s[i-1]:\n        ans[i] = ans[i-1]\n    else:\n        ans[i] = ans[i-1] + 1\nprint(max(ans))\nprint(*ans)"
    }
  ],
  "created": 1650402539,
  "id": "cmpl-4ypNjpFgP6jUAiszR45JTMBC1N9gk",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:09:34.275754 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\n# Because we can swap any two neighboring characters of the string that are colored different colors.\n# We can just sort the string by character.\n# Then we can color the string by the sorted order.\ns = sorted(s)\n\n# Because we can swap any two neighboring characters of the string that are colored different colors.\n# We can just color the string by the sorted order.\n# Then we can sort the string by color.\nc = [0] * n\nfor i in range(n):\n    c[i] = s.index(s[i]) + 1\n\nprint(max(c))\nprint(*c)"
}
2022-04-19 21:09:34.275829 REASON stop
2022-04-19 21:09:34.276388 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\nc = [0] * n\nres = 1\nprev = s[0]\nfor i, v in enumerate(s):\n    if v == prev:\n        c[i] = c[i - 1]\n    else:\n        c[i] = c[i - 1] + 1\n        res = c[i]\n    prev = v\n\n\nprint(res)\nprint(*c)"
}
2022-04-19 21:09:34.276451 REASON stop
2022-04-19 21:09:34.277023 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# SOLUTION\nn = int(input())\ns = input()\n\ncolors = [1] * n\n\nfor i in range(1, n):\n    if s[i] == s[i-1]:\n        colors[i] = colors[i-1]\n    else:\n        colors[i] = colors[i-1] + 1\n\nprint(colors[-1])\nprint(*colors)"
}
2022-04-19 21:09:34.277106 REASON stop
2022-04-19 21:09:34.305196 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # the sorted string and the number of swaps needed to sort it\n    sorted_str, num_swaps = sort_string(s)\n\n    # the minimum number of colors needed to sort the string\n    min_colors = len(set(sorted_str))\n\n    # the coloring of the string\n    coloring = get_coloring(sorted_str, min_colors)\n\n    # print the results\n    print(min_colors)\n    print(' '.join(map(str, coloring)))\n\n\ndef sort_string(s):\n    \"\"\"\n    Returns the sorted string and the number of swaps needed to sort it.\n    \"\"\"\n    # the sorted string\n    sorted_str = sorted(s)\n\n    # the number of swaps needed to sort it\n    num_swaps = 0\n\n    # the number of swaps needed to sort the string\n    # will be the sum of the distances of each letter to its sorted position\n    for i in range(len(s)):\n        num_swaps += abs(i - sorted_str.index(s[i]))\n\n    return (sorted_str, num_swaps)\n\n\ndef get_coloring(sorted_str, min_colors):\n    \"\"\"\n    Returns the coloring of the string.\n    \"\"\"\n    # the coloring of the string\n    coloring = [None] * len(sorted_str)\n\n    # the color of the current letter\n    curr_color = 1\n\n    # the first letter of the current color\n    first_letter = sorted_str[0]\n\n    # the color of the first letter\n    coloring[0] = curr_color\n\n    # iterate through the sorted string\n    for i in range(1, len(sorted_str)):\n        # if the current letter is the same as the first letter of the current color\n        if sorted_str[i] == first_letter:\n            # increment the current color\n            curr_color = (curr_color + 1) % min_colors\n            # if the current color is 0, set it to the minimum color\n            if curr_color == 0:\n                curr_color = min_colors\n            # set the first letter of the current color to the current letter\n            first_letter = sorted_str[i]\n        # set the color of the current letter to the current color\n        coloring[i] = curr_color\n\n    return coloring\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:09:34.305347 REASON stop
2022-04-19 21:09:34.306337 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom collections import Counter\n\nn = int(input())\ns = input()\n\n# count the number of each character\n# if there are more than 2 characters, the answer is 2\n# if there are 2 characters, the answer is 1\n# if there is 1 character, the answer is 1\n# in any case, the answer is the number of distinct characters\n\nc = Counter(s)\n\nif len(c) == 1:\n    print(1)\n    print(' '.join([str(1)] * n))\nelif len(c) == 2:\n    print(1)\n    for i in range(n):\n        if c[s[i]] == 1:\n            print(2, end=' ')\n        else:\n            print(1, end=' ')\n    print()\nelse:\n    print(2)\n    for i in range(n):\n        if c[s[i]] == 1:\n            print(2, end=' ')\n        else:\n            print(1, end=' ')\n    print()"
}
2022-04-19 21:09:34.306451 REASON stop
2022-04-19 21:09:34.326935 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    The main function that reads input and calls the other functions\n    \"\"\"\n    n = int(sys.stdin.readline())\n    string = sys.stdin.readline().rstrip()\n    solution = string_sorting(n, string)\n    print(len(solution))\n    print(*solution)\n\ndef string_sorting(n, string):\n    \"\"\"\n    Takes the number of characters and the string and returns the solution\n    \"\"\"\n    solution = [1]\n    for i in range(1, n):\n        if string[i] != string[i - 1]:\n            solution.append(solution[i - 1] + 1)\n        else:\n            solution.append(solution[i - 1])\n    return solution\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:09:34.327081 REASON stop
2022-04-19 21:09:34.334093 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # count the number of times each character appears\n    counts = defaultdict(int)\n    for c in s:\n        counts[c] += 1\n\n    # build the coloring\n    coloring = []\n    for c in s:\n        if counts[c] == 0:\n            continue\n        counts[c] -= 1\n        coloring.append(c)\n    print(len(coloring))\n    print(*coloring)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:09:34.334297 REASON stop
2022-04-19 21:09:34.335195 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n#-----SOLUTION-----\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\ns = input()\n\nans = [1] * n\nfor i in range(1, n):\n    if s[i] == s[i-1]:\n        ans[i] = ans[i-1]\n    else:\n        ans[i] = ans[i-1] + 1\nprint(max(ans))\nprint(*ans)"
}
2022-04-19 21:09:34.335287 REASON stop
