["\n\n\ndef main():\n    N, D = map(int, input().split())\n\n    # \u89b3\u6e2c\u8005\u306e\u6570\n    inspector = 0\n\n    # \u89b3\u6e2c\u8005\u3092\u914d\u7f6e\u3059\u308b\u4f4d\u7f6e\n    position = 0\n\n    for i in range(N):\n        # \u89b3\u6e2c\u8005\u304c\u3044\u306a\u3044\u5834\u5408\u306f\u89b3\u6e2c\u8005\u3092\u914d\u7f6e\u3059\u308b\n        if i > position + D:\n            inspector += 1\n            position = i\n        # \u89b3\u6e2c\u8005\u304c\u3044\u308b\u5834\u5408\u306f\u89b3\u6e2c\u8005\u304c\u914d\u7f6e\u3057\u305f\u4f4d\u7f6e\u3092\u66f4\u65b0\u3059\u308b\n        else:\n            position = max(i, position)\n\n    print(inspector)\n\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n, d = [int(x) for x in input().split()]\n    print((n + d - 1) // d)\n\n\nif __name__ == '__main__':\n    main()", "\nimport math\n\nN, D = map(int, input().split())\n\n# first, we need to find the number of trees that each inspector can inspect\ntrees_inspected = (2 * D) + 1\n\n# then, we need to find the number of inspectors required to inspect all the trees\nnum_inspectors = math.ceil(N / trees_inspected)\n\nprint(num_inspectors)", "\n\nn, d = map(int, input().split())\n\n# Number of inspectors\nnum = 0\n\n# Tree indices\nindices = list(range(1, n + 1))\n\n# While there are still trees to inspect\nwhile indices:\n    # Get the first tree index\n    tree = indices.pop(0)\n\n    # While the tree is within range of the inspector\n    while indices and indices[0] <= tree + d:\n        # Remove the tree index\n        indices.pop(0)\n    \n    # Increase the number of inspectors\n    num += 1\n\nprint(num)", "\nimport math\n\nn, d = map(int, input().split())\n\nnum_inspectors = math.ceil(n / (d * 2 + 1))\nprint(num_inspectors)", "\n\nimport sys\n\n\ndef get_input():\n    \"\"\"\n    Gets input from command line.\n    :return: number of trees and the distance an inspector can cover.\n    \"\"\"\n    n, d = [int(x) for x in sys.stdin.readline().split()]\n    return n, d\n\n\ndef get_min_inspectors(n, d):\n    \"\"\"\n    Calculates the minimum number of inspectors needed to cover all trees.\n    :param n: number of trees\n    :param d: the distance an inspector can cover.\n    :return: number of inspectors\n    \"\"\"\n    if n <= 2 * d:\n        return 1\n    elif n % (2 * d + 1) == 0:\n        return int(n / (2 * d + 1))\n    else:\n        return int(n / (2 * d + 1)) + 1\n\n\nif __name__ == '__main__':\n    n, d = get_input()\n    print(get_min_inspectors(n, d))", "\nimport math\n\nN, D = map(int, input().split())\n\nprint(math.ceil(N / (2 * D + 1)))", "\n\n\ndef main():\n    n, d = map(int, input().split())\n    if d == 0:\n        print(1)\n    else:\n        print(n // (2 * d + 1) + 1)\n\n\nif __name__ == '__main__':\n    main()"]