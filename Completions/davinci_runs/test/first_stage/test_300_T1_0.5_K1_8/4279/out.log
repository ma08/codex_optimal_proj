2022-04-19 23:33:23.620343 """
The only difference between the easy and the hard versions is the maximum value of $k$.

You are given an infinite sequence of form "112123123412345$\dots$" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $1$ to $1$, the second one — from $1$ to $2$, the third one — from $1$ to $3$, $\dots$, the $i$-th block consists of all numbers from $1$ to $i$. 

So the first $56$ elements of the sequence are "11212312341234512345612345671234567812345678912345678910". Elements of the sequence are numbered from one. For example, the $1$-st element of the sequence is $1$, the $3$-rd element of the sequence is $2$, the $20$-th element of the sequence is $5$, the $38$-th element is $2$, the $56$-th element of the sequence is $0$.

Your task is to answer $q$ independent queries. In the $i$-th query you are given one integer $k_i$. Calculate the digit at the position $k_i$ of the sequence.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) — the number of queries.

The $i$-th of the following $q$ lines contains one integer $k_i$ $(1 \le k_i \le 10^9)$ — the description of the corresponding query.


-----Output-----

Print $q$ lines. In the $i$-th line print one digit $x_i$ $(0 \le x_i \le 9)$ — the answer to the query $i$, i.e. $x_i$ should be equal to the element at the position $k_i$ of the sequence.


-----Examples-----
Input
5
1
3
20
38
56

Output
1
2
5
2
0

Input
4
2132
506
999999999
1000000000

Output
8
2
9
8



-----Note-----

Answers on queries from the first example are described in the problem statement.
"""
2022-04-19 23:33:23.620362 --------------------------
2022-04-19 23:33:23.620475 using api key sourya
2022-04-19 23:33:23.786107 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 23:33:28.791527 """
The only difference between the easy and the hard versions is the maximum value of $k$.

You are given an infinite sequence of form "112123123412345$\dots$" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $1$ to $1$, the second one — from $1$ to $2$, the third one — from $1$ to $3$, $\dots$, the $i$-th block consists of all numbers from $1$ to $i$. 

So the first $56$ elements of the sequence are "11212312341234512345612345671234567812345678912345678910". Elements of the sequence are numbered from one. For example, the $1$-st element of the sequence is $1$, the $3$-rd element of the sequence is $2$, the $20$-th element of the sequence is $5$, the $38$-th element is $2$, the $56$-th element of the sequence is $0$.

Your task is to answer $q$ independent queries. In the $i$-th query you are given one integer $k_i$. Calculate the digit at the position $k_i$ of the sequence.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) — the number of queries.

The $i$-th of the following $q$ lines contains one integer $k_i$ $(1 \le k_i \le 10^9)$ — the description of the corresponding query.


-----Output-----

Print $q$ lines. In the $i$-th line print one digit $x_i$ $(0 \le x_i \le 9)$ — the answer to the query $i$, i.e. $x_i$ should be equal to the element at the position $k_i$ of the sequence.


-----Examples-----
Input
5
1
3
20
38
56

Output
1
2
5
2
0

Input
4
2132
506
999999999
1000000000

Output
8
2
9
8



-----Note-----

Answers on queries from the first example are described in the problem statement.
"""
2022-04-19 23:33:28.791567 --------------------------
2022-04-19 23:33:28.791687 using api key gabby
2022-04-19 23:33:28.828884 in retry 5 10 <class 'Exception'>, Retrying in 10 seconds...
2022-04-19 23:33:38.839292 """
The only difference between the easy and the hard versions is the maximum value of $k$.

You are given an infinite sequence of form "112123123412345$\dots$" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $1$ to $1$, the second one — from $1$ to $2$, the third one — from $1$ to $3$, $\dots$, the $i$-th block consists of all numbers from $1$ to $i$. 

So the first $56$ elements of the sequence are "11212312341234512345612345671234567812345678912345678910". Elements of the sequence are numbered from one. For example, the $1$-st element of the sequence is $1$, the $3$-rd element of the sequence is $2$, the $20$-th element of the sequence is $5$, the $38$-th element is $2$, the $56$-th element of the sequence is $0$.

Your task is to answer $q$ independent queries. In the $i$-th query you are given one integer $k_i$. Calculate the digit at the position $k_i$ of the sequence.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) — the number of queries.

The $i$-th of the following $q$ lines contains one integer $k_i$ $(1 \le k_i \le 10^9)$ — the description of the corresponding query.


-----Output-----

Print $q$ lines. In the $i$-th line print one digit $x_i$ $(0 \le x_i \le 9)$ — the answer to the query $i$, i.e. $x_i$ should be equal to the element at the position $k_i$ of the sequence.


-----Examples-----
Input
5
1
3
20
38
56

Output
1
2
5
2
0

Input
4
2132
506
999999999
1000000000

Output
8
2
9
8



-----Note-----

Answers on queries from the first example are described in the problem statement.
"""
2022-04-19 23:33:38.839332 --------------------------
2022-04-19 23:33:38.839476 using api key derek
2022-04-19 23:33:38.876976 in retry 4 20 <class 'Exception'>, Retrying in 20 seconds...
2022-04-19 23:33:58.881415 """
The only difference between the easy and the hard versions is the maximum value of $k$.

You are given an infinite sequence of form "112123123412345$\dots$" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $1$ to $1$, the second one — from $1$ to $2$, the third one — from $1$ to $3$, $\dots$, the $i$-th block consists of all numbers from $1$ to $i$. 

So the first $56$ elements of the sequence are "11212312341234512345612345671234567812345678912345678910". Elements of the sequence are numbered from one. For example, the $1$-st element of the sequence is $1$, the $3$-rd element of the sequence is $2$, the $20$-th element of the sequence is $5$, the $38$-th element is $2$, the $56$-th element of the sequence is $0$.

Your task is to answer $q$ independent queries. In the $i$-th query you are given one integer $k_i$. Calculate the digit at the position $k_i$ of the sequence.


-----Input-----

The first line of the input contains one integer $q$ ($1 \le q \le 500$) — the number of queries.

The $i$-th of the following $q$ lines contains one integer $k_i$ $(1 \le k_i \le 10^9)$ — the description of the corresponding query.


-----Output-----

Print $q$ lines. In the $i$-th line print one digit $x_i$ $(0 \le x_i \le 9)$ — the answer to the query $i$, i.e. $x_i$ should be equal to the element at the position $k_i$ of the sequence.


-----Examples-----
Input
5
1
3
20
38
56

Output
1
2
5
2
0

Input
4
2132
506
999999999
1000000000

Output
8
2
9
8



-----Note-----

Answers on queries from the first example are described in the problem statement.
"""
2022-04-19 23:33:58.881455 --------------------------
2022-04-19 23:33:58.881606 using api key gabby
2022-04-19 23:34:15.846798 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n# The idea is to find the number that is at the given position\n# Then find the digit at the given position\n# The number at the given position can be found by using binary search\n\nq = int(input())\nfor i in range(q):\n    k = int(input())\n    start = 1\n    end = 2**31 - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if (mid * (mid + 1)) // 2 < k:\n            start = mid + 1\n        else:\n            end = mid - 1\n    # print(start)\n    num = start\n    num_digits = len(str(num))\n    # print(num_digits)\n    # print((num * (num + 1)) // 2 - (num_digits * 45))\n    # print(k - ((num * (num + 1)) // 2 - (num_digits * 45)))\n    # print(str(num)[k - ((num * (num + 1)) // 2 - (num_digits * 45)) - 1])\n    print(str(num)[k - ((num * (num + 1)) // 2 - (num_digits * 45)) - 1])"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    block_size = 1\n    cur_block_start = 1\n    while cur_block_start + block_size < k:\n        cur_block_start += block_size\n        block_size += 1\n    return str(block_size)[k - cur_block_start - 1]\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\n#This solution uses a formula to calculate the value of the digit at a given position\n\n#The value of the digit at a given position is calculated by finding the block in which the digit is present\n#and then finding the position of the digit within the block\n\n#The value of the digit at a given position can be calculated by finding the value of the digit at the start of the block\n#and then adding the position of the digit within the block\n\n#The value of the digit at the start of the block can be calculated by finding the sum of the digits of all the numbers from 1 to the block number\n\n#The sum of the digits of all the numbers from 1 to n can be calculated by using the formula (1+n)*n/2\n\n#The block in which the digit is present can be calculated by finding the value of n for which (1+n)*n/2 is less than or equal to the position\n\n#The position of the digit within the block can be calculated by finding the difference between the position and the value of the digit at the start of the block\n\n#The following code implements the above algorithm\n\nq = int(input())\n\nfor i in range(q):\n    k = int(input())\n    n = int(((-1+((1+8*k)**0.5))/2)//1)\n    print(str((1+n)*n//2-k)[-1])"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    total = 1\n    i = 1\n    while total < k:\n        i += 1\n        total += i\n    total -= i\n    diff = k - total\n    num = i - diff + 1\n    return int(str(num)[-1])\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# Solution\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    sum_digits = 9\n    digits = 1\n    while True:\n        sum_digits = sum_digits + (9 * digits * 10**(digits-1))\n        if k <= sum_digits:\n            break\n        digits += 1\n    # print(digits)\n    num = 10**(digits-1)\n    # print(num)\n    number_of_digits = sum_digits - k + 1\n    # print(number_of_digits)\n    if number_of_digits % digits == 0:\n        number_of_digits = digits\n        num -= 1\n    else:\n        number_of_digits = number_of_digits % digits\n    # print(number_of_digits)\n    # print(num)\n    num = str(num)\n    return num[number_of_digits-1]\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(int(get_digit(k)))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n# This is a very easy problem. The only thing to do is to calculate the number of digits in the block and then calculate the block number\n\ndef solve(k):\n    # Calculate the number of digits in the block\n    n = 1\n    while n*(n+1)/2 < k:\n        n += 1\n    # Calculate the number of digits in the previous block\n    prev_n = n - 1\n    # Calculate the block number\n    block_number = (k - prev_n*(prev_n+1)/2) // n\n    # Calculate the number in the block\n    number = (k - prev_n*(prev_n+1)/2) % n\n    # Calculate the digit in the number\n    digit = str(block_number+1)[number]\n    return int(digit)\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(solve(k))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    start = 1\n    end = 1\n    while end < k:\n        start = end + 1\n        end = end + 9*10**(int(math.log10(end)) + 1)*(int(math.log10(end)) + 1)\n    start_block = start\n    end_block = end\n    block_number = int(math.log10(start_block)) + 1\n    while start_block < k:\n        k -= start_block\n        start_block += block_number\n    number = int(math.floor(start_block / block_number))\n    return int(str(number)[k-1])\n\nmain()"
    }
  ],
  "created": 1650411238,
  "id": "cmpl-4yre28qM74PwoKuYnm0kyRa2hZ4ge",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 23:34:15.847239 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n# The idea is to find the number that is at the given position\n# Then find the digit at the given position\n# The number at the given position can be found by using binary search\n\nq = int(input())\nfor i in range(q):\n    k = int(input())\n    start = 1\n    end = 2**31 - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if (mid * (mid + 1)) // 2 < k:\n            start = mid + 1\n        else:\n            end = mid - 1\n    # print(start)\n    num = start\n    num_digits = len(str(num))\n    # print(num_digits)\n    # print((num * (num + 1)) // 2 - (num_digits * 45))\n    # print(k - ((num * (num + 1)) // 2 - (num_digits * 45)))\n    # print(str(num)[k - ((num * (num + 1)) // 2 - (num_digits * 45)) - 1])\n    print(str(num)[k - ((num * (num + 1)) // 2 - (num_digits * 45)) - 1])"
}
2022-04-19 23:34:15.847287 REASON stop
2022-04-19 23:34:15.847976 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    block_size = 1\n    cur_block_start = 1\n    while cur_block_start + block_size < k:\n        cur_block_start += block_size\n        block_size += 1\n    return str(block_size)[k - cur_block_start - 1]\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 23:34:15.848053 REASON stop
2022-04-19 23:34:15.848496 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\n#This solution uses a formula to calculate the value of the digit at a given position\n\n#The value of the digit at a given position is calculated by finding the block in which the digit is present\n#and then finding the position of the digit within the block\n\n#The value of the digit at a given position can be calculated by finding the value of the digit at the start of the block\n#and then adding the position of the digit within the block\n\n#The value of the digit at the start of the block can be calculated by finding the sum of the digits of all the numbers from 1 to the block number\n\n#The sum of the digits of all the numbers from 1 to n can be calculated by using the formula (1+n)*n/2\n\n#The block in which the digit is present can be calculated by finding the value of n for which (1+n)*n/2 is less than or equal to the position\n\n#The position of the digit within the block can be calculated by finding the difference between the position and the value of the digit at the start of the block\n\n#The following code implements the above algorithm\n\nq = int(input())\n\nfor i in range(q):\n    k = int(input())\n    n = int(((-1+((1+8*k)**0.5))/2)//1)\n    print(str((1+n)*n//2-k)[-1])"
}
2022-04-19 23:34:15.848566 REASON stop
2022-04-19 23:34:15.885295 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    total = 1\n    i = 1\n    while total < k:\n        i += 1\n        total += i\n    total -= i\n    diff = k - total\n    num = i - diff + 1\n    return int(str(num)[-1])\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 23:34:15.885420 REASON stop
2022-04-19 23:34:15.886405 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# Solution\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    sum_digits = 9\n    digits = 1\n    while True:\n        sum_digits = sum_digits + (9 * digits * 10**(digits-1))\n        if k <= sum_digits:\n            break\n        digits += 1\n    # print(digits)\n    num = 10**(digits-1)\n    # print(num)\n    number_of_digits = sum_digits - k + 1\n    # print(number_of_digits)\n    if number_of_digits % digits == 0:\n        number_of_digits = digits\n        num -= 1\n    else:\n        number_of_digits = number_of_digits % digits\n    # print(number_of_digits)\n    # print(num)\n    num = str(num)\n    return num[number_of_digits-1]\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(int(get_digit(k)))"
}
2022-04-19 23:34:15.886520 REASON stop
2022-04-19 23:34:15.913133 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n# This is a very easy problem. The only thing to do is to calculate the number of digits in the block and then calculate the block number\n\ndef solve(k):\n    # Calculate the number of digits in the block\n    n = 1\n    while n*(n+1)/2 < k:\n        n += 1\n    # Calculate the number of digits in the previous block\n    prev_n = n - 1\n    # Calculate the block number\n    block_number = (k - prev_n*(prev_n+1)/2) // n\n    # Calculate the number in the block\n    number = (k - prev_n*(prev_n+1)/2) % n\n    # Calculate the digit in the number\n    digit = str(block_number+1)[number]\n    return int(digit)\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(solve(k))"
}
2022-04-19 23:34:15.913267 REASON stop
2022-04-19 23:34:15.915888 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": ""
}
2022-04-19 23:34:15.916090 REASON stop
2022-04-19 23:34:15.917499 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    start = 1\n    end = 1\n    while end < k:\n        start = end + 1\n        end = end + 9*10**(int(math.log10(end)) + 1)*(int(math.log10(end)) + 1)\n    start_block = start\n    end_block = end\n    block_number = int(math.log10(start_block)) + 1\n    while start_block < k:\n        k -= start_block\n        start_block += block_number\n    number = int(math.floor(start_block / block_number))\n    return int(str(number)[k-1])\n\nmain()"
}
2022-04-19 23:34:15.917605 REASON stop
