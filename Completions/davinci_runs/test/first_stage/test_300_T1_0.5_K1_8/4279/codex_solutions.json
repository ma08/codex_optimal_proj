["", "\n\nimport math\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    start = 1\n    end = 1\n    while end < k:\n        start = end + 1\n        end = end + 9*10**(int(math.log10(end)) + 1)*(int(math.log10(end)) + 1)\n    start_block = start\n    end_block = end\n    block_number = int(math.log10(start_block)) + 1\n    while start_block < k:\n        k -= start_block\n        start_block += block_number\n    number = int(math.floor(start_block / block_number))\n    return int(str(number)[k-1])\n\nmain()", "\n\n# SOLUTION\n\n# This is a very easy problem. The only thing to do is to calculate the number of digits in the block and then calculate the block number\n\ndef solve(k):\n    # Calculate the number of digits in the block\n    n = 1\n    while n*(n+1)/2 < k:\n        n += 1\n    # Calculate the number of digits in the previous block\n    prev_n = n - 1\n    # Calculate the block number\n    block_number = (k - prev_n*(prev_n+1)/2) // n\n    # Calculate the number in the block\n    number = (k - prev_n*(prev_n+1)/2) % n\n    # Calculate the digit in the number\n    digit = str(block_number+1)[number]\n    return int(digit)\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(solve(k))", "\n\n#-----Solution-----\n\n#This solution uses a formula to calculate the value of the digit at a given position\n\n#The value of the digit at a given position is calculated by finding the block in which the digit is present\n#and then finding the position of the digit within the block\n\n#The value of the digit at a given position can be calculated by finding the value of the digit at the start of the block\n#and then adding the position of the digit within the block\n\n#The value of the digit at the start of the block can be calculated by finding the sum of the digits of all the numbers from 1 to the block number\n\n#The sum of the digits of all the numbers from 1 to n can be calculated by using the formula (1+n)*n/2\n\n#The block in which the digit is present can be calculated by finding the value of n for which (1+n)*n/2 is less than or equal to the position\n\n#The position of the digit within the block can be calculated by finding the difference between the position and the value of the digit at the start of the block\n\n#The following code implements the above algorithm\n\nq = int(input())\n\nfor i in range(q):\n    k = int(input())\n    n = int(((-1+((1+8*k)**0.5))/2)//1)\n    print(str((1+n)*n//2-k)[-1])", "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    total = 1\n    i = 1\n    while total < k:\n        i += 1\n        total += i\n    total -= i\n    diff = k - total\n    num = i - diff + 1\n    return int(str(num)[-1])\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    q = int(input())\n    for i in range(q):\n        k = int(input())\n        print(get_digit(k))\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    block_size = 1\n    cur_block_start = 1\n    while cur_block_start + block_size < k:\n        cur_block_start += block_size\n        block_size += 1\n    return str(block_size)[k - cur_block_start - 1]\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n\n# The idea is to find the number that is at the given position\n# Then find the digit at the given position\n# The number at the given position can be found by using binary search\n\nq = int(input())\nfor i in range(q):\n    k = int(input())\n    start = 1\n    end = 2**31 - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if (mid * (mid + 1)) // 2 < k:\n            start = mid + 1\n        else:\n            end = mid - 1\n    # print(start)\n    num = start\n    num_digits = len(str(num))\n    # print(num_digits)\n    # print((num * (num + 1)) // 2 - (num_digits * 45))\n    # print(k - ((num * (num + 1)) // 2 - (num_digits * 45)))\n    # print(str(num)[k - ((num * (num + 1)) // 2 - (num_digits * 45)) - 1])\n    print(str(num)[k - ((num * (num + 1)) // 2 - (num_digits * 45)) - 1])", "\n\n# Solution\n\ndef get_digit(k):\n    if k == 1:\n        return 1\n    sum_digits = 9\n    digits = 1\n    while True:\n        sum_digits = sum_digits + (9 * digits * 10**(digits-1))\n        if k <= sum_digits:\n            break\n        digits += 1\n    # print(digits)\n    num = 10**(digits-1)\n    # print(num)\n    number_of_digits = sum_digits - k + 1\n    # print(number_of_digits)\n    if number_of_digits % digits == 0:\n        number_of_digits = digits\n        num -= 1\n    else:\n        number_of_digits = number_of_digits % digits\n    # print(number_of_digits)\n    # print(num)\n    num = str(num)\n    return num[number_of_digits-1]\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(int(get_digit(k)))"]