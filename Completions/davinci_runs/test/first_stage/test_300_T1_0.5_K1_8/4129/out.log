2022-04-19 22:13:55.876153 """
There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.

What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?

New roads will also be one-way.


-----Input-----

The first line of input consists of three integers $n$, $m$ and $s$ ($1 \le n \le 5000, 0 \le m \le 5000, 1 \le s \le n$) — the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.

The following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).


-----Output-----

Print one integer — the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.


-----Examples-----
Input
9 9 1
1 2
1 3
2 3
1 5
5 6
6 1
1 8
9 8
7 1

Output
3

Input
5 4 5
1 2
2 3
3 4
4 1

Output
1



-----Note-----

The first example is illustrated by the following: [Image] 

For example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.

The second example is illustrated by the following: [Image] 

In this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.
"""
2022-04-19 22:13:55.876174 --------------------------
2022-04-19 22:13:55.876282 using api key derek
2022-04-19 22:14:14.054473 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    graph = {}\n    for i in range(m):\n        u, v = map(int, input().split())\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n\n    visited = [0] * (n+1)\n    queue = []\n    queue.append(s)\n    visited[s] = 1\n\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if visited[v] == 0:\n                queue.append(v)\n                visited[v] = 1\n\n    print(n - sum(visited))\n\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef solve(n, m, s, roads):\n    # Write your code here\n    pass\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    n = int(next(tokens))  # type: int\n    m = int(next(tokens))  # type: int\n    s = int(next(tokens))  # type: int\n    roads = [None] * (m)  # type: \"List[List[int]]\" \n    for i in range(m):\n        roads[i] = [int(next(tokens)) for _ in range(2)]\n    result = solve(n, m, s, roads)\n    if isinstance(result, Iterable) and not isinstance(result, str):\n        result = '\\n'.join([str(v) for v in result])\n    print(result)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# Solution\n\nimport sys\n\ndef dfs(adj, visited, v):\n    visited[v] = True\n    for u in adj[v]:\n        if not visited[u]:\n            dfs(adj, visited, u)\n\nn, m, s = [int(x) for x in sys.stdin.readline().split()]\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = [int(x) for x in sys.stdin.readline().split()]\n    adj[u - 1].append(v - 1)\n\nvisited = [False] * n\ndfs(adj, visited, s - 1)\n\nnot_visited = [i for i in range(n) if not visited[i]]\n\nprint(len(not_visited))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return [int(x) for x in input().split(\" \")]\n\ndef read_lines(n):\n    return [input() for _ in range(n)]\n\ndef read_ints_lines(n):\n    return [[int(x) for x in input().split(\" \")] for _ in range(n)]\n\ndef solve(n, roads):\n    #print(roads)\n    #print(n, roads)\n    adj = [[] for _ in range(n+1)]\n    for src, dest in roads:\n        adj[src].append(dest)\n    #print(adj)\n    visited = [False for _ in range(n+1)]\n    visited[1] = True\n    q = [1]\n    while q:\n        u = q.pop()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n    #print(visited)\n    ans = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            ans += 1\n    return ans\n\nif __name__ == \"__main__\":\n    n, m, s = read_ints()\n    roads = read_ints_lines(m)\n    print(solve(n, roads))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    N, M, S = map(int, input().split())\n    g = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, input().split())\n        g[u-1].append(v-1)\n    S -= 1\n    visited = [0]*N\n    stack = [S]\n    while stack:\n        u = stack.pop()\n        visited[u] = 1\n        for v in g[u]:\n            if not visited[v]:\n                stack.append(v)\n    print(N-1-sum(visited))\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef dfs(graph, start, visited):\n    if visited[start]: return\n    visited[start] = 1\n    for node in graph[start]:\n        dfs(graph, node, visited)\n\ndef main():\n    n, m, start = [int(x) for x in sys.stdin.readline().split()]\n    graph = [[] for i in range(n)]\n    visited = [0] * n\n    for i in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        graph[u - 1].append(v - 1)\n    dfs(graph, start - 1, visited)\n    print(visited.count(0) - 1)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, input().split())\n    roads = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n    reachable = {s}\n    for i in range(m):\n        if roads[i][0] in reachable:\n            reachable.add(roads[i][1])\n    extra = 0\n    for i in range(1, n + 1):\n        if i not in reachable:\n            extra += 1\n    print(extra)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650406436,
  "id": "cmpl-4yqOabJMrSPiVWIbyTP9HPes6NEuz",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 22:14:14.054797 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    graph = {}\n    for i in range(m):\n        u, v = map(int, input().split())\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n\n    visited = [0] * (n+1)\n    queue = []\n    queue.append(s)\n    visited[s] = 1\n\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if visited[v] == 0:\n                queue.append(v)\n                visited[v] = 1\n\n    print(n - sum(visited))\n\n\nmain()"
}
2022-04-19 22:14:14.054835 REASON stop
2022-04-19 22:14:14.055530 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef solve(n, m, s, roads):\n    # Write your code here\n    pass\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    n = int(next(tokens))  # type: int\n    m = int(next(tokens))  # type: int\n    s = int(next(tokens))  # type: int\n    roads = [None] * (m)  # type: \"List[List[int]]\" \n    for i in range(m):\n        roads[i] = [int(next(tokens)) for _ in range(2)]\n    result = solve(n, m, s, roads)\n    if isinstance(result, Iterable) and not isinstance(result, str):\n        result = '\\n'.join([str(v) for v in result])\n    print(result)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 22:14:14.055635 REASON stop
2022-04-19 22:14:14.056123 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# Solution\n\nimport sys\n\ndef dfs(adj, visited, v):\n    visited[v] = True\n    for u in adj[v]:\n        if not visited[u]:\n            dfs(adj, visited, u)\n\nn, m, s = [int(x) for x in sys.stdin.readline().split()]\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = [int(x) for x in sys.stdin.readline().split()]\n    adj[u - 1].append(v - 1)\n\nvisited = [False] * n\ndfs(adj, visited, s - 1)\n\nnot_visited = [i for i in range(n) if not visited[i]]\n\nprint(len(not_visited))"
}
2022-04-19 22:14:14.056193 REASON stop
2022-04-19 22:14:14.079887 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return [int(x) for x in input().split(\" \")]\n\ndef read_lines(n):\n    return [input() for _ in range(n)]\n\ndef read_ints_lines(n):\n    return [[int(x) for x in input().split(\" \")] for _ in range(n)]\n\ndef solve(n, roads):\n    #print(roads)\n    #print(n, roads)\n    adj = [[] for _ in range(n+1)]\n    for src, dest in roads:\n        adj[src].append(dest)\n    #print(adj)\n    visited = [False for _ in range(n+1)]\n    visited[1] = True\n    q = [1]\n    while q:\n        u = q.pop()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n    #print(visited)\n    ans = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            ans += 1\n    return ans\n\nif __name__ == \"__main__\":\n    n, m, s = read_ints()\n    roads = read_ints_lines(m)\n    print(solve(n, roads))"
}
2022-04-19 22:14:14.080015 REASON stop
2022-04-19 22:14:14.102525 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    N, M, S = map(int, input().split())\n    g = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, input().split())\n        g[u-1].append(v-1)\n    S -= 1\n    visited = [0]*N\n    stack = [S]\n    while stack:\n        u = stack.pop()\n        visited[u] = 1\n        for v in g[u]:\n            if not visited[v]:\n                stack.append(v)\n    print(N-1-sum(visited))\n\nmain()"
}
2022-04-19 22:14:14.102658 REASON stop
2022-04-19 22:14:14.103505 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 22:14:14.103617 REASON stop
2022-04-19 22:14:14.104454 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef dfs(graph, start, visited):\n    if visited[start]: return\n    visited[start] = 1\n    for node in graph[start]:\n        dfs(graph, node, visited)\n\ndef main():\n    n, m, start = [int(x) for x in sys.stdin.readline().split()]\n    graph = [[] for i in range(n)]\n    visited = [0] * n\n    for i in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        graph[u - 1].append(v - 1)\n    dfs(graph, start - 1, visited)\n    print(visited.count(0) - 1)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 22:14:14.104546 REASON stop
2022-04-19 22:14:14.105640 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, input().split())\n    roads = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n    reachable = {s}\n    for i in range(m):\n        if roads[i][0] in reachable:\n            reachable.add(roads[i][1])\n    extra = 0\n    for i in range(1, n + 1):\n        if i not in reachable:\n            extra += 1\n    print(extra)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 22:14:14.105816 REASON stop
