["\n\n# Solution\n\nimport sys\n\ndef dfs(adj, visited, v):\n    visited[v] = True\n    for u in adj[v]:\n        if not visited[u]:\n            dfs(adj, visited, u)\n\nn, m, s = [int(x) for x in sys.stdin.readline().split()]\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = [int(x) for x in sys.stdin.readline().split()]\n    adj[u - 1].append(v - 1)\n\nvisited = [False] * n\ndfs(adj, visited, s - 1)\n\nnot_visited = [i for i in range(n) if not visited[i]]\n\nprint(len(not_visited))", "\n\ndef main():\n    n, m, s = map(int, input().split())\n    graph = {}\n    for i in range(m):\n        u, v = map(int, input().split())\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n\n    visited = [0] * (n+1)\n    queue = []\n    queue.append(s)\n    visited[s] = 1\n\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if visited[v] == 0:\n                queue.append(v)\n                visited[v] = 1\n\n    print(n - sum(visited))\n\n\nmain()", "\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return [int(x) for x in input().split(\" \")]\n\ndef read_lines(n):\n    return [input() for _ in range(n)]\n\ndef read_ints_lines(n):\n    return [[int(x) for x in input().split(\" \")] for _ in range(n)]\n\ndef solve(n, roads):\n    #print(roads)\n    #print(n, roads)\n    adj = [[] for _ in range(n+1)]\n    for src, dest in roads:\n        adj[src].append(dest)\n    #print(adj)\n    visited = [False for _ in range(n+1)]\n    visited[1] = True\n    q = [1]\n    while q:\n        u = q.pop()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n    #print(visited)\n    ans = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            ans += 1\n    return ans\n\nif __name__ == \"__main__\":\n    n, m, s = read_ints()\n    roads = read_ints_lines(m)\n    print(solve(n, roads))", "\n\ndef main():\n    N, M, S = map(int, input().split())\n    g = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, input().split())\n        g[u-1].append(v-1)\n    S -= 1\n    visited = [0]*N\n    stack = [S]\n    while stack:\n        u = stack.pop()\n        visited[u] = 1\n        for v in g[u]:\n            if not visited[v]:\n                stack.append(v)\n    print(N-1-sum(visited))\n\nmain()", "\n\nimport sys\n\ndef dfs(graph, start, visited):\n    if visited[start]: return\n    visited[start] = 1\n    for node in graph[start]:\n        dfs(graph, node, visited)\n\ndef main():\n    n, m, start = [int(x) for x in sys.stdin.readline().split()]\n    graph = [[] for i in range(n)]\n    visited = [0] * n\n    for i in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        graph[u - 1].append(v - 1)\n    dfs(graph, start - 1, visited)\n    print(visited.count(0) - 1)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, input().split())\n    roads = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n    reachable = {s}\n    for i in range(m):\n        if roads[i][0] in reachable:\n            reachable.add(roads[i][1])\n    extra = 0\n    for i in range(1, n + 1):\n        if i not in reachable:\n            extra += 1\n    print(extra)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef solve(n, m, s, roads):\n    # Write your code here\n    pass\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    n = int(next(tokens))  # type: int\n    m = int(next(tokens))  # type: int\n    s = int(next(tokens))  # type: int\n    roads = [None] * (m)  # type: \"List[List[int]]\" \n    for i in range(m):\n        roads[i] = [int(next(tokens)) for _ in range(2)]\n    result = solve(n, m, s, roads)\n    if isinstance(result, Iterable) and not isinstance(result, str):\n        result = '\\n'.join([str(v) for v in result])\n    print(result)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"]