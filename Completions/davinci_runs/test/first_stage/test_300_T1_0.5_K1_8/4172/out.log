2022-04-19 22:43:10.569598 """
You are given the array $a$ consisting of $n$ elements and the integer $k \le n$.

You want to obtain at least $k$ equal elements in the array $a$. In one move, you can make one of the following two operations:

  Take one of the minimum elements of the array and increase its value by one (more formally, if the minimum value of $a$ is $mn$ then you choose such index $i$ that $a_i = mn$ and set $a_i := a_i + 1$);  take one of the maximum elements of the array and decrease its value by one (more formally, if the maximum value of $a$ is $mx$ then you choose such index $i$ that $a_i = mx$ and set $a_i := a_i - 1$). 

Your task is to calculate the minimum number of moves required to obtain at least $k$ equal elements in the array.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of elements in $a$ and the required number of equal elements.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print one integer — the minimum number of moves required to obtain at least $k$ equal elements in the array.


-----Examples-----
Input
6 5
1 2 2 4 2 3

Output
3

Input
7 5
3 3 2 1 1 1 3

Output
4
"""
2022-04-19 22:43:10.569612 --------------------------
2022-04-19 22:43:10.569719 using api key derek
2022-04-19 22:43:10.735340 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 22:43:15.740772 """
You are given the array $a$ consisting of $n$ elements and the integer $k \le n$.

You want to obtain at least $k$ equal elements in the array $a$. In one move, you can make one of the following two operations:

  Take one of the minimum elements of the array and increase its value by one (more formally, if the minimum value of $a$ is $mn$ then you choose such index $i$ that $a_i = mn$ and set $a_i := a_i + 1$);  take one of the maximum elements of the array and decrease its value by one (more formally, if the maximum value of $a$ is $mx$ then you choose such index $i$ that $a_i = mx$ and set $a_i := a_i - 1$). 

Your task is to calculate the minimum number of moves required to obtain at least $k$ equal elements in the array.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of elements in $a$ and the required number of equal elements.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print one integer — the minimum number of moves required to obtain at least $k$ equal elements in the array.


-----Examples-----
Input
6 5
1 2 2 4 2 3

Output
3

Input
7 5
3 3 2 1 1 1 3

Output
4
"""
2022-04-19 22:43:15.740812 --------------------------
2022-04-19 22:43:15.740933 using api key derek
2022-04-19 22:43:40.089381 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nm = min(a)\nM = max(a)\n\nif M-m+1 < k:\n    print(-1)\nelse:\n    print(M-m-k+1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# Use the idea of sorting\n# 1. If the min and max are equal, then return 0 as the answer\n# 2. If the min and max are not equal, then we have to increase the min and decrease the max\n# 3. The number of times we have to do this is the difference between the min and max\n# 4. We keep doing this until the difference between the min and max is zero\n# 5. We keep track of the number of times we do this.\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmax_val = max(a)\n\nif min_val == max_val:\n    print(0)\nelse:\n    print(max_val - min_val)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    line = input()\n    n, k = map(int, line.split())\n    line = input()\n    a = list(map(int, line.split()))\n    a = sorted(a)\n    \n    if a[0] == a[-1]:\n        print(0)\n        return\n    \n    i = 0\n    j = n - 1\n    count = 0\n    while True:\n        if a[i] == a[j]:\n            break\n        if i == j:\n            count += 1\n            a[i] += 1\n        else:\n            count += 2\n            a[i] += 1\n            a[j] -= 1\n        i += 1\n        j -= 1\n        a = sorted(a)\n    \n    print(count)\n    \nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef get_min_moves(n, k, a):\n    min_a = min(a)\n    max_a = max(a)\n    if min_a == max_a:\n        return 0\n    if n == k:\n        return max_a-min_a\n    min_moves = sys.maxsize\n    for i in range(min_a, max_a+1):\n        moves = 0\n        for j in range(n):\n            if a[j] > i:\n                moves += a[j]-i\n            else:\n                moves += i-a[j]\n        if moves < min_moves:\n            min_moves = moves\n    return min_moves\n\n\nif __name__ == '__main__':\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(get_min_moves(n, k, a))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif k == 1:\n    print(0)\n    exit()\n\na.sort()\n\nif a[0] == a[-1]:\n    print(0)\n    exit()\n\nif k == n:\n    print(a[-1] - a[0])\n    exit()\n\nd = a[-1] - a[0]\n\n# print(a)\n\nfirst_min = a[0]\nlast_max = a[-1]\n\n# print(first_min, last_max)\n\nfor i in range(1, n):\n    if a[i] > first_min:\n        break\n\n\n# print(i)\n\nfor j in range(n-2, -1, -1):\n    if a[j] < last_max:\n        break\n\n\n# print(j)\n\nif i == 0 or j == n-1:\n    print(d)\n    exit()\n\nif i >= k:\n    print(d)\n    exit()\n\nif j <= n - k:\n    print(d)\n    exit()\n\nif i + n - j < k:\n    print(d)\n    exit()\n\nif i + n - j == k:\n    print(d - (n - j - i))\n    exit()\n\nif i + n - j > k:\n    print(d - (i + n - j - k))\n    exit()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = map(int, sys.stdin.readline().split())\n    mn = min(a)\n    mx = max(a)\n    if mn == mx:\n        print 0\n        return\n\n    if k == n:\n        print mx - mn\n        return\n\n    d = sorted([(a[i] - mn, i) for i in range(n)], reverse=True)\n    c = 1\n    for i in range(1, n):\n        if d[i][0] == d[i - 1][0]:\n            c += 1\n        else:\n            break\n    o = c\n    if c >= k:\n        print d[c - 1][0]\n        return\n\n    c = 1\n    for i in range(1, n):\n        if d[i][0] == d[i - 1][0] and d[i][1] < d[i - 1][1]:\n            c += 1\n        else:\n            break\n    if c >= k:\n        print d[c - 1][0]\n        return\n\n    mx = min(mx - mn, d[c - 1][0])\n    for i in range(c, n):\n        if d[i][0] > mx or d[i][0] <= d[c - 1][0]:\n            break\n        if d[i][1] > d[c - 1][1]:\n            c += 1\n        if c >= k:\n            break\n    if c >= k:\n        print mx\n        return\n\n    print mx + (k - c)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    min_a, max_a = min(a), max(a)\n    if k == 1:\n        print(0)\n    elif k == n:\n        print(max_a - min_a)\n    else:\n        count = 0\n        for i in range(min_a, max_a):\n            if i == min_a:\n                count += (a.count(i) - 1)\n            else:\n                count += a.count(i)\n            if count >= k:\n                print(i - min_a)\n                break\n\nmain()\n\n\"\"\"\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    min_a, max_a = min(a), max(a)\n    if k == 1:\n        print(0)\n    elif k == n:\n        print(max_a - min_a)\n    else:\n        count = 0\n        for i in range(min_a, max_a):\n            if i == min_a:\n                count += (a.count(i) - 1)\n            else:\n                count += a.count(i)\n            if count >= k:\n                print(i - min_a)\n                break\n\nmain()\n\"\"\""
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif k == n:\n\tprint(0)\n\texit()\n\nminValue = min(a)\nmaxValue = max(a)\n\nif maxValue - minValue + 1 < k:\n\tprint(-1)\n\texit()\n\nd = {}\nfor i in a:\n\tif i in d:\n\t\td[i] += 1\n\telse:\n\t\td[i] = 1\n\nvalues = list(d.keys())\nvalues.sort()\n\nif len(values) == 1:\n\tprint(0)\n\texit()\n\nif values[0] == values[1]:\n\tprint(0)\n\texit()\n\nif values[-1] == values[-2]:\n\tprint(0)\n\texit()\n\ncount = 0\n\nwhile True:\n\tif d[values[0]] >= k:\n\t\tbreak\n\telse:\n\t\tcount += 1\n\t\td[values[0]] += 1\n\t\td[values[1]] -= 1\n\t\tif d[values[1]] == 0:\n\t\t\tdel d[values[1]]\n\t\t\tvalues.pop(1)\n\nwhile True:\n\tif d[values[-1]] >= k:\n\t\tbreak\n\telse:\n\t\tcount += 1\n\t\td[values[-1]] += 1\n\t\td[values[-2]] -= 1\n\t\tif d[values[-2]] == 0:\n\t\t\tdel d[values[-2]]\n\t\t\tvalues.pop(-2)\n\nprint(count)"
    }
  ],
  "created": 1650408195,
  "id": "cmpl-4yqqx5dLW7gPTfjEIVNoIHDQGOR95",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 22:43:40.089884 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nm = min(a)\nM = max(a)\n\nif M-m+1 < k:\n    print(-1)\nelse:\n    print(M-m-k+1)"
}
2022-04-19 22:43:40.089961 REASON stop
2022-04-19 22:43:40.090533 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# Use the idea of sorting\n# 1. If the min and max are equal, then return 0 as the answer\n# 2. If the min and max are not equal, then we have to increase the min and decrease the max\n# 3. The number of times we have to do this is the difference between the min and max\n# 4. We keep doing this until the difference between the min and max is zero\n# 5. We keep track of the number of times we do this.\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmax_val = max(a)\n\nif min_val == max_val:\n    print(0)\nelse:\n    print(max_val - min_val)"
}
2022-04-19 22:43:40.090597 REASON stop
2022-04-19 22:43:40.091132 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    line = input()\n    n, k = map(int, line.split())\n    line = input()\n    a = list(map(int, line.split()))\n    a = sorted(a)\n    \n    if a[0] == a[-1]:\n        print(0)\n        return\n    \n    i = 0\n    j = n - 1\n    count = 0\n    while True:\n        if a[i] == a[j]:\n            break\n        if i == j:\n            count += 1\n            a[i] += 1\n        else:\n            count += 2\n            a[i] += 1\n            a[j] -= 1\n        i += 1\n        j -= 1\n        a = sorted(a)\n    \n    print(count)\n    \nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 22:43:40.091197 REASON stop
2022-04-19 22:43:40.113401 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef get_min_moves(n, k, a):\n    min_a = min(a)\n    max_a = max(a)\n    if min_a == max_a:\n        return 0\n    if n == k:\n        return max_a-min_a\n    min_moves = sys.maxsize\n    for i in range(min_a, max_a+1):\n        moves = 0\n        for j in range(n):\n            if a[j] > i:\n                moves += a[j]-i\n            else:\n                moves += i-a[j]\n        if moves < min_moves:\n            min_moves = moves\n    return min_moves\n\n\nif __name__ == '__main__':\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(get_min_moves(n, k, a))"
}
2022-04-19 22:43:40.113534 REASON stop
2022-04-19 22:43:40.114743 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif k == 1:\n    print(0)\n    exit()\n\na.sort()\n\nif a[0] == a[-1]:\n    print(0)\n    exit()\n\nif k == n:\n    print(a[-1] - a[0])\n    exit()\n\nd = a[-1] - a[0]\n\n# print(a)\n\nfirst_min = a[0]\nlast_max = a[-1]\n\n# print(first_min, last_max)\n\nfor i in range(1, n):\n    if a[i] > first_min:\n        break\n\n\n# print(i)\n\nfor j in range(n-2, -1, -1):\n    if a[j] < last_max:\n        break\n\n\n# print(j)\n\nif i == 0 or j == n-1:\n    print(d)\n    exit()\n\nif i >= k:\n    print(d)\n    exit()\n\nif j <= n - k:\n    print(d)\n    exit()\n\nif i + n - j < k:\n    print(d)\n    exit()\n\nif i + n - j == k:\n    print(d - (n - j - i))\n    exit()\n\nif i + n - j > k:\n    print(d - (i + n - j - k))\n    exit()"
}
2022-04-19 22:43:40.114844 REASON stop
2022-04-19 22:43:40.115635 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = map(int, sys.stdin.readline().split())\n    mn = min(a)\n    mx = max(a)\n    if mn == mx:\n        print 0\n        return\n\n    if k == n:\n        print mx - mn\n        return\n\n    d = sorted([(a[i] - mn, i) for i in range(n)], reverse=True)\n    c = 1\n    for i in range(1, n):\n        if d[i][0] == d[i - 1][0]:\n            c += 1\n        else:\n            break\n    o = c\n    if c >= k:\n        print d[c - 1][0]\n        return\n\n    c = 1\n    for i in range(1, n):\n        if d[i][0] == d[i - 1][0] and d[i][1] < d[i - 1][1]:\n            c += 1\n        else:\n            break\n    if c >= k:\n        print d[c - 1][0]\n        return\n\n    mx = min(mx - mn, d[c - 1][0])\n    for i in range(c, n):\n        if d[i][0] > mx or d[i][0] <= d[c - 1][0]:\n            break\n        if d[i][1] > d[c - 1][1]:\n            c += 1\n        if c >= k:\n            break\n    if c >= k:\n        print mx\n        return\n\n    print mx + (k - c)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 22:43:40.115716 REASON stop
2022-04-19 22:43:40.117807 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    min_a, max_a = min(a), max(a)\n    if k == 1:\n        print(0)\n    elif k == n:\n        print(max_a - min_a)\n    else:\n        count = 0\n        for i in range(min_a, max_a):\n            if i == min_a:\n                count += (a.count(i) - 1)\n            else:\n                count += a.count(i)\n            if count >= k:\n                print(i - min_a)\n                break\n\nmain()\n\n\"\"\"\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    min_a, max_a = min(a), max(a)\n    if k == 1:\n        print(0)\n    elif k == n:\n        print(max_a - min_a)\n    else:\n        count = 0\n        for i in range(min_a, max_a):\n            if i == min_a:\n                count += (a.count(i) - 1)\n            else:\n                count += a.count(i)\n            if count >= k:\n                print(i - min_a)\n                break\n\nmain()\n\"\"\""
}
2022-04-19 22:43:40.117976 REASON stop
2022-04-19 22:43:40.119274 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif k == n:\n\tprint(0)\n\texit()\n\nminValue = min(a)\nmaxValue = max(a)\n\nif maxValue - minValue + 1 < k:\n\tprint(-1)\n\texit()\n\nd = {}\nfor i in a:\n\tif i in d:\n\t\td[i] += 1\n\telse:\n\t\td[i] = 1\n\nvalues = list(d.keys())\nvalues.sort()\n\nif len(values) == 1:\n\tprint(0)\n\texit()\n\nif values[0] == values[1]:\n\tprint(0)\n\texit()\n\nif values[-1] == values[-2]:\n\tprint(0)\n\texit()\n\ncount = 0\n\nwhile True:\n\tif d[values[0]] >= k:\n\t\tbreak\n\telse:\n\t\tcount += 1\n\t\td[values[0]] += 1\n\t\td[values[1]] -= 1\n\t\tif d[values[1]] == 0:\n\t\t\tdel d[values[1]]\n\t\t\tvalues.pop(1)\n\nwhile True:\n\tif d[values[-1]] >= k:\n\t\tbreak\n\telse:\n\t\tcount += 1\n\t\td[values[-1]] += 1\n\t\td[values[-2]] -= 1\n\t\tif d[values[-2]] == 0:\n\t\t\tdel d[values[-2]]\n\t\t\tvalues.pop(-2)\n\nprint(count)"
}
2022-04-19 22:43:40.119400 REASON stop
