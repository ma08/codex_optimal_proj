2022-04-19 21:07:49.403918 """
You are given a bracket sequence $s$ (not necessarily a regular one). A bracket sequence is a string containing only characters '(' and ')'.

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)"), and ")(", "(" and ")" are not.

Your problem is to calculate the number of regular bracket sequences of length $2n$ containing the given bracket sequence $s$ as a substring (consecutive sequence of characters) modulo $10^9+7$ ($1000000007$).


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 100$) — the half-length of the resulting regular bracket sequences (the resulting sequences must have length equal to $2n$).

The second line of the input contains one string $s$ ($1 \le |s| \le 200$) — the string $s$ that should be a substring in each of the resulting regular bracket sequences ($|s|$ is the length of $s$).


-----Output-----

Print only one integer — the number of regular bracket sequences containing the given bracket sequence $s$ as a substring. Since this number can be huge, print it modulo $10^9+7$ ($1000000007$).


-----Examples-----
Input
5
()))()

Output
5

Input
3
(()

Output
4

Input
2
(((

Output
0



-----Note-----

All regular bracket sequences satisfying the conditions above for the first example:   "(((()))())";  "((()()))()";  "((()))()()";  "(()(()))()";  "()((()))()". 

All regular bracket sequences satisfying the conditions above for the second example:   "((()))";  "(()())";  "(())()";  "()(())". 

And there is no regular bracket sequences of length $4$ containing "(((" as a substring in the third example.
"""
2022-04-19 21:07:49.403941 --------------------------
2022-04-19 21:07:49.404049 using api key gabby
2022-04-19 21:08:25.569081 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef count_regular_brackets(n, s):\n    \"\"\"\n    >>> count_regular_brackets(5, '()))()')\n    5\n    >>> count_regular_brackets(3, '(()')\n    4\n    >>> count_regular_brackets(2, '(((')\n    0\n    \"\"\"\n    MOD = 1000000007\n    result = 0\n    if s == '('*n + ')'*n:\n        return 1\n    if n <= len(s):\n        return result\n    for i in range(n-len(s)):\n        result = (result + count_regular_brackets(n-i-1, s+')')) % MOD\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef solve(n, s):\n    pass\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    print(solve(n, s))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\ns = s.replace('(', '0')\ns = s.replace(')', '1')\ns = int(s, 2)\n\nmod = 10**9 + 7\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef answer(n, s):\n    if n == 0:\n        return 1\n    else:\n        if s & (1 << (2 * n - 1)):\n            return 0\n        else:\n            return (answer(n-1, s) * (factorial(n-1) ** 2)) % mod\n\nprint(answer(n, s))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef count(n, s):\n    dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(0, n + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] += dp[i - 1][j + 1]\n            dp[i][j] %= 1000000007\n    cnt = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            cnt += 1\n        else:\n            cnt -= 1\n    return dp[n][cnt]\n\nn = int(input())\ns = input()\nprint(count(n, s))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # a[i][j] = number of regular bracket sequences of length 2i containing s[:j] as a substring\n    a = [[0] * (len(s) + 1) for _ in range(n + 1)]\n    a[0][0] = 1\n\n    for i in range(n):\n        for j in range(len(s) + 1):\n            if a[i][j] == 0:\n                continue\n\n            # case 1: add ')' to the end of s[:j]\n            if j < len(s) and s[j] == ')':\n                a[i + 1][j + 1] += a[i][j]\n\n            # case 2: add '()' to the end of s[:j]\n            if j < len(s) - 1 and s[j] == '(' and s[j + 1] == ')':\n                a[i + 1][j + 2] += a[i][j]\n\n            # case 3: add '(' to the end of s[:j]\n            a[i + 1][j] += a[i][j] * (i + 1)\n\n    print(a[n][len(s)] % 1000000007)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\ns = input()\n\n# Dynamic Programming\n# dp[i][j] = number of ways to fill in brackets for a sequence of length i, ending with j ')'s\n# dp[i][j] = sum_{k=0}^{j-1} dp[i-1][k]\n# Base case: dp[0][0] = 1\n#\n# Final answer is sum_{j=1}^n dp[2n][j]\n#\n# dp[i][j] = sum_{k=0}^{j-1} dp[i-1][k]\n#          = sum_{k=0}^{j-1} dp[i-2][k] + dp[i-2][k-1]\n#          = sum_{k=0}^{j-1} dp[i-2][k] + dp[i-2][k]\n#          = 2 * sum_{k=0}^{j-1} dp[i-2][k]\n#          = 2 * dp[i-2][j-1]\n\ndp = []\nfor i in range(n*2+1):\n    dp.append([0]*(n+1))\ndp[0][0] = 1\nfor i in range(2, n*2+1):\n    for j in range(1, n+1):\n        dp[i][j] = 2 * dp[i-2][j-1]\n\n# print(dp)\n# print(sum(dp[2*n]))\n\n# Brute-force\n# Create all possible sequences of length 2n\n# Check if the given sequence is a substring\n# Count the number of valid sequences\n#\n# Time limit exceeded\n\ndef check_validity(x):\n    # Check if x is a valid sequence\n    balance = 0\n    for c in x:\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            balance -= 1\n        else:\n            print(\"Error!\")\n        if balance < 0:\n            return False\n    if balance == 0:\n        return True\n    else:\n        return False\n\ndef generate_all_sequences(n, x, i):\n    if i == 2*n:\n        if x in s:\n            if check_validity(x):\n                global num_valid_sequences\n                num_valid_sequences += 1\n    else:\n        generate_all_sequences(n, x+'(', i+1)\n        generate_all_sequences(n, x+')', i+1)\n\nnum_valid_sequences = 0\ngenerate_all_sequences(n, '', 0)\nprint(num_valid_sequences)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": ""
    }
  ],
  "created": 1650402469,
  "id": "cmpl-4ypMbxMY82pRrSIPzmxxWF70A2tb8",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:08:25.569441 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef count_regular_brackets(n, s):\n    \"\"\"\n    >>> count_regular_brackets(5, '()))()')\n    5\n    >>> count_regular_brackets(3, '(()')\n    4\n    >>> count_regular_brackets(2, '(((')\n    0\n    \"\"\"\n    MOD = 1000000007\n    result = 0\n    if s == '('*n + ')'*n:\n        return 1\n    if n <= len(s):\n        return result\n    for i in range(n-len(s)):\n        result = (result + count_regular_brackets(n-i-1, s+')')) % MOD\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
}
2022-04-19 21:08:25.569482 REASON stop
2022-04-19 21:08:25.569977 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef solve(n, s):\n    pass\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    print(solve(n, s))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:08:25.570031 REASON stop
2022-04-19 21:08:25.570499 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": ""
}
2022-04-19 21:08:25.570566 REASON stop
2022-04-19 21:08:25.598759 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\ns = s.replace('(', '0')\ns = s.replace(')', '1')\ns = int(s, 2)\n\nmod = 10**9 + 7\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef answer(n, s):\n    if n == 0:\n        return 1\n    else:\n        if s & (1 << (2 * n - 1)):\n            return 0\n        else:\n            return (answer(n-1, s) * (factorial(n-1) ** 2)) % mod\n\nprint(answer(n, s))"
}
2022-04-19 21:08:25.598887 REASON stop
2022-04-19 21:08:25.599918 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef count(n, s):\n    dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(0, n + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] += dp[i - 1][j + 1]\n            dp[i][j] %= 1000000007\n    cnt = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            cnt += 1\n        else:\n            cnt -= 1\n    return dp[n][cnt]\n\nn = int(input())\ns = input()\nprint(count(n, s))"
}
2022-04-19 21:08:25.600028 REASON stop
2022-04-19 21:08:25.616284 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # a[i][j] = number of regular bracket sequences of length 2i containing s[:j] as a substring\n    a = [[0] * (len(s) + 1) for _ in range(n + 1)]\n    a[0][0] = 1\n\n    for i in range(n):\n        for j in range(len(s) + 1):\n            if a[i][j] == 0:\n                continue\n\n            # case 1: add ')' to the end of s[:j]\n            if j < len(s) and s[j] == ')':\n                a[i + 1][j + 1] += a[i][j]\n\n            # case 2: add '()' to the end of s[:j]\n            if j < len(s) - 1 and s[j] == '(' and s[j + 1] == ')':\n                a[i + 1][j + 2] += a[i][j]\n\n            # case 3: add '(' to the end of s[:j]\n            a[i + 1][j] += a[i][j] * (i + 1)\n\n    print(a[n][len(s)] % 1000000007)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:08:25.616455 REASON stop
2022-04-19 21:08:25.619839 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\ns = input()\n\n# Dynamic Programming\n# dp[i][j] = number of ways to fill in brackets for a sequence of length i, ending with j ')'s\n# dp[i][j] = sum_{k=0}^{j-1} dp[i-1][k]\n# Base case: dp[0][0] = 1\n#\n# Final answer is sum_{j=1}^n dp[2n][j]\n#\n# dp[i][j] = sum_{k=0}^{j-1} dp[i-1][k]\n#          = sum_{k=0}^{j-1} dp[i-2][k] + dp[i-2][k-1]\n#          = sum_{k=0}^{j-1} dp[i-2][k] + dp[i-2][k]\n#          = 2 * sum_{k=0}^{j-1} dp[i-2][k]\n#          = 2 * dp[i-2][j-1]\n\ndp = []\nfor i in range(n*2+1):\n    dp.append([0]*(n+1))\ndp[0][0] = 1\nfor i in range(2, n*2+1):\n    for j in range(1, n+1):\n        dp[i][j] = 2 * dp[i-2][j-1]\n\n# print(dp)\n# print(sum(dp[2*n]))\n\n# Brute-force\n# Create all possible sequences of length 2n\n# Check if the given sequence is a substring\n# Count the number of valid sequences\n#\n# Time limit exceeded\n\ndef check_validity(x):\n    # Check if x is a valid sequence\n    balance = 0\n    for c in x:\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            balance -= 1\n        else:\n            print(\"Error!\")\n        if balance < 0:\n            return False\n    if balance == 0:\n        return True\n    else:\n        return False\n\ndef generate_all_sequences(n, x, i):\n    if i == 2*n:\n        if x in s:\n            if check_validity(x):\n                global num_valid_sequences\n                num_valid_sequences += 1\n    else:\n        generate_all_sequences(n, x+'(', i+1)\n        generate_all_sequences(n, x+')', i+1)\n\nnum_valid_sequences = 0\ngenerate_all_sequences(n, '', 0)\nprint(num_valid_sequences)"
}
2022-04-19 21:08:25.619981 REASON stop
2022-04-19 21:08:25.620838 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": ""
}
2022-04-19 21:08:25.621027 REASON stop
