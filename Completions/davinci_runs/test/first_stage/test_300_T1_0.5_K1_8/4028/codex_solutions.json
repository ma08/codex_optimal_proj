["", "\n\ndef main():\n    n = int(input())\n    s = input()\n\n    # a[i][j] = number of regular bracket sequences of length 2i containing s[:j] as a substring\n    a = [[0] * (len(s) + 1) for _ in range(n + 1)]\n    a[0][0] = 1\n\n    for i in range(n):\n        for j in range(len(s) + 1):\n            if a[i][j] == 0:\n                continue\n\n            # case 1: add ')' to the end of s[:j]\n            if j < len(s) and s[j] == ')':\n                a[i + 1][j + 1] += a[i][j]\n\n            # case 2: add '()' to the end of s[:j]\n            if j < len(s) - 1 and s[j] == '(' and s[j + 1] == ')':\n                a[i + 1][j + 2] += a[i][j]\n\n            # case 3: add '(' to the end of s[:j]\n            a[i + 1][j] += a[i][j] * (i + 1)\n\n    print(a[n][len(s)] % 1000000007)\n\n\nif __name__ == '__main__':\n    main()", "\n\nn = int(input())\ns = input()\ns = s.replace('(', '0')\ns = s.replace(')', '1')\ns = int(s, 2)\n\nmod = 10**9 + 7\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef answer(n, s):\n    if n == 0:\n        return 1\n    else:\n        if s & (1 << (2 * n - 1)):\n            return 0\n        else:\n            return (answer(n-1, s) * (factorial(n-1) ** 2)) % mod\n\nprint(answer(n, s))", "\n\nimport sys\n\ndef solve(n, s):\n    pass\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    print(solve(n, s))\n\nif __name__ == '__main__':\n    main()", "\n\ndef count(n, s):\n    dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(0, n + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] += dp[i - 1][j + 1]\n            dp[i][j] %= 1000000007\n    cnt = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            cnt += 1\n        else:\n            cnt -= 1\n    return dp[n][cnt]\n\nn = int(input())\ns = input()\nprint(count(n, s))", "\n\ndef count_regular_brackets(n, s):\n    \"\"\"\n    >>> count_regular_brackets(5, '()))()')\n    5\n    >>> count_regular_brackets(3, '(()')\n    4\n    >>> count_regular_brackets(2, '(((')\n    0\n    \"\"\"\n    MOD = 1000000007\n    result = 0\n    if s == '('*n + ')'*n:\n        return 1\n    if n <= len(s):\n        return result\n    for i in range(n-len(s)):\n        result = (result + count_regular_brackets(n-i-1, s+')')) % MOD\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()", "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\ns = input()\n\n# Dynamic Programming\n# dp[i][j] = number of ways to fill in brackets for a sequence of length i, ending with j ')'s\n# dp[i][j] = sum_{k=0}^{j-1} dp[i-1][k]\n# Base case: dp[0][0] = 1\n#\n# Final answer is sum_{j=1}^n dp[2n][j]\n#\n# dp[i][j] = sum_{k=0}^{j-1} dp[i-1][k]\n#          = sum_{k=0}^{j-1} dp[i-2][k] + dp[i-2][k-1]\n#          = sum_{k=0}^{j-1} dp[i-2][k] + dp[i-2][k]\n#          = 2 * sum_{k=0}^{j-1} dp[i-2][k]\n#          = 2 * dp[i-2][j-1]\n\ndp = []\nfor i in range(n*2+1):\n    dp.append([0]*(n+1))\ndp[0][0] = 1\nfor i in range(2, n*2+1):\n    for j in range(1, n+1):\n        dp[i][j] = 2 * dp[i-2][j-1]\n\n# print(dp)\n# print(sum(dp[2*n]))\n\n# Brute-force\n# Create all possible sequences of length 2n\n# Check if the given sequence is a substring\n# Count the number of valid sequences\n#\n# Time limit exceeded\n\ndef check_validity(x):\n    # Check if x is a valid sequence\n    balance = 0\n    for c in x:\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            balance -= 1\n        else:\n            print(\"Error!\")\n        if balance < 0:\n            return False\n    if balance == 0:\n        return True\n    else:\n        return False\n\ndef generate_all_sequences(n, x, i):\n    if i == 2*n:\n        if x in s:\n            if check_validity(x):\n                global num_valid_sequences\n                num_valid_sequences += 1\n    else:\n        generate_all_sequences(n, x+'(', i+1)\n        generate_all_sequences(n, x+')', i+1)\n\nnum_valid_sequences = 0\ngenerate_all_sequences(n, '', 0)\nprint(num_valid_sequences)"]