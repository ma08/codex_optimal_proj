["\n\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    m = max(a)\n    ans = 0\n    for i in range(30, -1, -1):\n        if m >> i == 0:\n            break\n        cnt = [0] * (n + 1)\n        for j in range(n):\n            if a[j] >> i & 1:\n                cnt[j + 1] = 1\n        for j in range(1, n + 1):\n            cnt[j] += cnt[j - 1]\n        cnt = [cnt[i + k - 1] - cnt[i] for i in range(n - k + 1)]\n        if sum(cnt) >= k:\n            ans += 1\n            for j in range(n):\n                if a[j] >> i & 1:\n                    a[j] -= 1 << i\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n# Solution\nimport math\n\nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\n\n# Find the maximum element in the array\nmax_val = max(a)\n\n# Find the maximum number of operations required to make all elements equal\n# We can do this by finding the number of bits in the maximum element\nmax_op = math.floor(math.log(max_val, 2))\n\n# Find the minimum number of operations required to make all elements equal\n# We can do this by finding the number of bits in the minimum element\nmin_op = math.floor(math.log(min(a), 2))\n\n# If the number of operations required to make all elements equal is less than the number of operations required to make at least k elements equal, print the former\nif n * min_op <= k * max_op:\n    print(min_op)\n# Otherwise, print the latter\nelse:\n    print(max_op)", "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# First, find the maximum value in the array.\nmax_a = max(a)\n\n# Then, find the minimum number of operations needed to get all of the elements to be equal to the maximum value.\n# This is the same as finding the minimum number of operations needed to get all of the elements to be equal to 1,\n# since the maximum value is a power of 2.\ncount = 0\nfor i in range(n):\n    count += a[i] - 1\n\n# If the number of operations needed to get all of the elements to be equal to 1 is less than or equal to k,\n# then the minimum number of operations needed is simply the number of operations needed to get all of the elements\n# to be equal to 1.\nif count <= k:\n    print(count)\n\n# If the number of operations needed to get all of the elements to be equal to 1 is greater than k, then the minimum\n# number of operations needed is k, since that is the maximum number of operations that can be done.\nelse:\n    print(k)", "\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nif k == 1:\n    print(0)\n    exit()\n\n# a = [x // 2 for x in a]\n\n# print(a)\n\n# ans = 0\n# while len(set(a)) != 1:\n#     ans += 1\n#     a = [x // 2 for x in a]\n\n# print(ans)\n\n# print(set(a))\n\nans = 0\nwhile len(set(a)) >= k:\n    ans += 1\n    a = [x // 2 for x in a]\n\nprint(ans)", "\n\ndef read_ints():\n  temp = input().split()\n  temp = [int(t) for t in temp]\n  return temp\n\ndef solve(n, k, a):\n  count = 0\n  while True:\n    min_num = min(a)\n    if min_num == 0:\n      break\n    for i in range(len(a)):\n      a[i] = a[i] - min_num\n    count += 1\n  print(count)\n\nn, k = read_ints()\na = read_ints()\nsolve(n, k, a)", "\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef split(l):\n    a = []\n    b = []\n    for i in l:\n        if i % 2 == 0:\n            a.append(i)\n        else:\n            b.append(i)\n    return a, b\n\ndef get_min_ops(arr, k):\n    if k == 1:\n        return 0\n    if len(arr) < k:\n        return -1\n    if len(arr) == k:\n        return 1\n    if len(arr) == k + 1:\n        return 2\n    if len(arr) > k:\n        a, b = split(arr)\n        if len(a) >= k:\n            return get_min_ops(a, k)\n        if len(a) == k - 1:\n            return 1 + get_min_ops(b, k - len(a))\n        if len(a) < k - 1:\n            return 2 + get_min_ops(b, k - len(a))\n\nprint(get_min_ops(a, k))", "\n\n# Solution 1:\n# This is a greedy approach.\n# In order to get k equal numbers, the minimum number of operations is the number of operations needed to make all the numbers equal to the minimum number in the array.\n# So, we first find the minimum number in the array, and then find the number of operations needed to make all the numbers equal to the minimum number.\n# The time complexity is O(n).\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nmin_a = min(a)\nans = 0\nfor i in range(n):\n    ans += a[i] - min_a\nprint(ans)\n\n# Solution 2:\n# This is a greedy approach.\n# We first find the minimum number in the array, and then find the number of operations needed to make all the numbers equal to the minimum number.\n# The time complexity is O(n).\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nmin_a = min(a)\nans = 0\nfor i in range(n):\n    ans += (a[i] - min_a) // 2\n    a[i] -= (a[i] - min_a) // 2 * 2\nif min(a) == min_a:\n    print(ans)\nelse:\n    print(ans + 1)\n\n# Solution 3:\n# This is a greedy approach.\n# We first find the minimum number in the array, and then find the number of operations needed to make all the numbers equal to the minimum number.\n# The time complexity is O(n).\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nmin_a = min(a)\nans = 0\nfor i in range(n):\n    ans += (a[i] - min_a) // 2\n    a[i] -= (a[i] - min_a) // 2 * 2\nprint(ans + 1 if min(a) != min_a else ans)", "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    answer = 0\n\n    # Since we can only divide by 2, we take the highest element\n    # and divide it by 2 until it's equal to the lowest element\n    # or until it's less than the lowest element\n    # Then, we do this again with the new highest value\n    # This is the minimum number of operations\n    while max(a) != min(a):\n        highest = max(a)\n        lowest = min(a)\n        if highest % 2 == 1:\n            highest -= 1\n        highest //= 2\n        if highest < lowest:\n            highest = lowest\n        a.append(highest)\n        answer += 1\n\n    print(answer)\n\nmain()"]