["\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef get_min_moves(x):\n    return sum(x // 2 for x in a)\n\ndef is_valid(moves):\n    return get_min_moves(moves) <= moves\n\n# Binary search to find the minimum number of moves\nlow = 0\nhigh = 2 * 10 ** 5\nwhile low < high:\n    mid = (low + high) // 2\n    if is_valid(mid):\n        high = mid\n    else:\n        low = mid + 1\n\nprint(low)", "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef divide_all(a):\n    return [int(i/2) for i in a]\n\ndef is_all_equal(a):\n    return len(set(a)) == 1\n\ndef count_operations(a, k):\n    if is_all_equal(a):\n        return 0\n    if len(a) < k:\n        return -1\n    c = 0\n    while not is_all_equal(a):\n        a = divide_all(a)\n        c += 1\n    return c\n\nprint(count_operations(a, k))", "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# min_num = min(a)\n# max_num = max(a)\n# max_occ = a.count(max_num)\n#\n# if max_occ >= k:\n#     print(0)\n# else:\n#     print(max(0, max_num - min_num - (k - max_occ)))\n\n# def get_min_max(a):\n#     min_num = a[0]\n#     max_num = a[0]\n#     for i in range(1, len(a)):\n#         if a[i] < min_num:\n#             min_num = a[i]\n#         if a[i] > max_num:\n#             max_num = a[i]\n#     return min_num, max_num\n#\n#\n# def get_max_occ(a):\n#     max_num = a[0]\n#     max_occ = 1\n#     for i in range(1, len(a)):\n#         if a.count(a[i]) > max_occ:\n#             max_num = a[i]\n#             max_occ = a.count(a[i])\n#     return max_num, max_occ\n#\n#\n# def get_num_of_ops(a):\n#     min_num, max_num = get_min_max(a)\n#     max_num, max_occ = get_max_occ(a)\n#     if max_occ >= k:\n#         return 0\n#     else:\n#         return max(0, max_num - min_num - (k - max_occ))\n#\n#\n# print(get_num_of_ops(a))\n\ndef get_min_max(a):\n    min_num = a[0]\n    max_num = a[0]\n    for i in range(1, len(a)):\n        if a[i] < min_num:\n            min_num = a[i]\n        if a[i] > max_num:\n            max_num = a[i]\n    return min_num, max_num\n\n\ndef get_max_occ(a):\n    max_num = a[0]\n    max_occ = 1\n    for i in range(1, len(a)):\n        if a.count(a[i]) > max_occ:\n            max_num = a[i]\n            max_occ = a.count(a[i])\n    return max_num, max_occ\n\n\ndef get_num_of_ops(a):\n    min_num, max_num = get_min_max(a)\n    max_num, max_occ = get_max_occ(a)\n    if max_occ >= k:\n        return 0\n    else:\n        return max(0, max_num - min_num - (k - max_occ))\n\n\nprint(get_num_of_ops(a))", "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# First, find the gcd of the array\ngcd = a[0]\nfor i in range(1, n):\n    gcd = math.gcd(gcd, a[i])\n\n# Then, divide each element by the gcd, and count the number of times\n# we can divide by 2.\n# Since we can divide each element by 2 any number of times, we can\n# divide the gcd by 2 as many times as needed.\n\n# We do this by counting the number of 1s in the binary\n# representation of the gcd.\n\n# This is because the gcd is the product of the common prime factors\n# of each element of the array.\n# If we divide each element of the array by the gcd, we will have\n# the remaining prime factors.\n# The remaining prime factors of each element can be divided by 2 as\n# many times as needed.\n# Therefore, we can divide the gcd by 2 as many times as needed.\n\n# We count the number of 1s in the binary representation of the gcd\n# to find out how many times we can divide the gcd by 2.\ncount = 0\nwhile gcd % 2 == 0:\n    count += 1\n    gcd //= 2\n\n# Then, we find the minimum number of operations needed to get at\n# least k equal numbers in the array.\n# This is the number of operations needed to divide the gcd by 2\n# (count) plus the number of operations needed to get at least k\n# equal numbers in the array after dividing the gcd by 2.\nmin_operations = count + math.ceil(math.log(k, 2))\n\nprint(min_operations)", "\n\nfrom math import log2\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\n# if the largest number is already a multiple of 2^k, we don't need to do anything\nif a[-1] % 2 ** k == 0:\n    print(0)\n# if the largest number is not a multiple of 2^k, we need to divide it by 2^k\nelse:\n    # we need to find the number of times the largest number can be divided by 2\n    # if we divide the largest number by 2 enough times, we can make it a multiple of 2^k\n    # we can divide a number by 2 log2(a[-1]) times\n    # so, we need to find the number of times we can divide the largest number by 2 until it is a multiple of 2^k\n    # we can divide the largest number by 2 log2(a[-1]) times, but we can only divide it by 2 log2(2^k) times\n    # since 2^k is a multiple of 2, we can divide the largest number by 2 log2(2^k) times\n    # we can divide the largest number by 2 log2(2^k) times, but we need to divide it by 2 log2(a[-1]) times\n    # so, we need to divide the largest number by 2 (log2(a[-1]) - log2(2^k)) times\n    print(int(log2(a[-1]) - log2(2 ** k)))", "\n\nimport sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\n# The minimum number of operations is the minimum number of operations required to make all elements equal to the minimum element.\n# Since we can divide all elements by two, we need to find the largest power of two in the array.\n# We can do this by finding the maximum number of trailing zeros in the binary representation of all elements.\n\nmax_zeros = 0\nfor i in a:\n    cur_zeros = 0\n    while i % 2 == 0:\n        i //= 2\n        cur_zeros += 1\n    max_zeros = max(max_zeros, cur_zeros)\n\nprint(max_zeros)", "\nimport math\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nmax_num = max(arr)\n\nmin_num = max_num\n\nfor i in range(n):\n    if arr[i] < min_num:\n        min_num = arr[i]\n\nif min_num == max_num:\n    print(0)\n    exit(0)\n\nmin_divs = math.inf\n\nfor div in range(min_num, max_num+1):\n    divs = 0\n    for i in range(n):\n        if arr[i] % div != 0:\n            divs += math.ceil(arr[i] / div) - 1\n    if divs < min_divs:\n        min_divs = divs\n\nprint(min_divs)"]