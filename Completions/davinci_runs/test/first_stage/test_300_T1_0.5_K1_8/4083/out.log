2022-04-19 21:45:43.845394 """
The only difference between easy and hard versions is the number of elements in the array.

You are given an array $a$ consisting of $n$ integers. In one move you can choose any $a_i$ and divide it by $2$ rounding down (in other words, in one move you can set $a_i := \lfloor\frac{a_i}{2}\rfloor$).

You can perform such an operation any (possibly, zero) number of times with any $a_i$.

Your task is to calculate the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.

Don't forget that it is possible to have $a_i = 0$ after some operations, thus the answer always exists.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 50$) — the number of elements in the array and the number of equal numbers required.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 2 \cdot 10^5$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print one integer — the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.


-----Examples-----
Input
5 3
1 2 2 4 5

Output
1

Input
5 3
1 2 3 4 5

Output
2

Input
5 3
1 2 3 3 3

Output
0
"""
2022-04-19 21:45:43.845410 --------------------------
2022-04-19 21:45:43.845516 using api key derek
2022-04-19 21:47:11.260501 {
  "choices": [
    {
      "finish_reason": "length",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\n# The number of operations required to make all elements equal is the same as\n# the number of operations required to make all elements equal to the minimum\n# element of the array.\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 2, then we need to perform 2 operations (divide each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 3, then we need to perform 1 operation (divide each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 4, then we need to perform 0 operations.\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 5, then we need to perform 1 operation (multiply each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 6, then we need to perform 2 operations (multiply each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 7, then we need to perform 3 operations (multiply each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 8, then we need to perform 4 operations (multiply each element by 2).\n\n# We can see that the number of operations required to make all elements equal to\n# the minimum element of the array is always 0.\n\n# We can also see that the number of operations required to make all elements\n# equal to the maximum element of the array is always equal to the number of\n# elements in the array minus 1.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef get_min_moves(x):\n    return sum(x // 2 for x in a)\n\ndef is_valid(moves):\n    return get_min_moves(moves) <= moves\n\n# Binary search to find the minimum number of moves\nlow = 0\nhigh = 2 * 10 ** 5\nwhile low < high:\n    mid = (low + high) // 2\n    if is_valid(mid):\n        high = mid\n    else:\n        low = mid + 1\n\nprint(low)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\nimport math\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nmax_num = max(arr)\n\nmin_num = max_num\n\nfor i in range(n):\n    if arr[i] < min_num:\n        min_num = arr[i]\n\nif min_num == max_num:\n    print(0)\n    exit(0)\n\nmin_divs = math.inf\n\nfor div in range(min_num, max_num+1):\n    divs = 0\n    for i in range(n):\n        if arr[i] % div != 0:\n            divs += math.ceil(arr[i] / div) - 1\n    if divs < min_divs:\n        min_divs = divs\n\nprint(min_divs)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# First, find the gcd of the array\ngcd = a[0]\nfor i in range(1, n):\n    gcd = math.gcd(gcd, a[i])\n\n# Then, divide each element by the gcd, and count the number of times\n# we can divide by 2.\n# Since we can divide each element by 2 any number of times, we can\n# divide the gcd by 2 as many times as needed.\n\n# We do this by counting the number of 1s in the binary\n# representation of the gcd.\n\n# This is because the gcd is the product of the common prime factors\n# of each element of the array.\n# If we divide each element of the array by the gcd, we will have\n# the remaining prime factors.\n# The remaining prime factors of each element can be divided by 2 as\n# many times as needed.\n# Therefore, we can divide the gcd by 2 as many times as needed.\n\n# We count the number of 1s in the binary representation of the gcd\n# to find out how many times we can divide the gcd by 2.\ncount = 0\nwhile gcd % 2 == 0:\n    count += 1\n    gcd //= 2\n\n# Then, we find the minimum number of operations needed to get at\n# least k equal numbers in the array.\n# This is the number of operations needed to divide the gcd by 2\n# (count) plus the number of operations needed to get at least k\n# equal numbers in the array after dividing the gcd by 2.\nmin_operations = count + math.ceil(math.log(k, 2))\n\nprint(min_operations)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\n# The minimum number of operations is the minimum number of operations required to make all elements equal to the minimum element.\n# Since we can divide all elements by two, we need to find the largest power of two in the array.\n# We can do this by finding the maximum number of trailing zeros in the binary representation of all elements.\n\nmax_zeros = 0\nfor i in a:\n    cur_zeros = 0\n    while i % 2 == 0:\n        i //= 2\n        cur_zeros += 1\n    max_zeros = max(max_zeros, cur_zeros)\n\nprint(max_zeros)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# min_num = min(a)\n# max_num = max(a)\n# max_occ = a.count(max_num)\n#\n# if max_occ >= k:\n#     print(0)\n# else:\n#     print(max(0, max_num - min_num - (k - max_occ)))\n\n# def get_min_max(a):\n#     min_num = a[0]\n#     max_num = a[0]\n#     for i in range(1, len(a)):\n#         if a[i] < min_num:\n#             min_num = a[i]\n#         if a[i] > max_num:\n#             max_num = a[i]\n#     return min_num, max_num\n#\n#\n# def get_max_occ(a):\n#     max_num = a[0]\n#     max_occ = 1\n#     for i in range(1, len(a)):\n#         if a.count(a[i]) > max_occ:\n#             max_num = a[i]\n#             max_occ = a.count(a[i])\n#     return max_num, max_occ\n#\n#\n# def get_num_of_ops(a):\n#     min_num, max_num = get_min_max(a)\n#     max_num, max_occ = get_max_occ(a)\n#     if max_occ >= k:\n#         return 0\n#     else:\n#         return max(0, max_num - min_num - (k - max_occ))\n#\n#\n# print(get_num_of_ops(a))\n\ndef get_min_max(a):\n    min_num = a[0]\n    max_num = a[0]\n    for i in range(1, len(a)):\n        if a[i] < min_num:\n            min_num = a[i]\n        if a[i] > max_num:\n            max_num = a[i]\n    return min_num, max_num\n\n\ndef get_max_occ(a):\n    max_num = a[0]\n    max_occ = 1\n    for i in range(1, len(a)):\n        if a.count(a[i]) > max_occ:\n            max_num = a[i]\n            max_occ = a.count(a[i])\n    return max_num, max_occ\n\n\ndef get_num_of_ops(a):\n    min_num, max_num = get_min_max(a)\n    max_num, max_occ = get_max_occ(a)\n    if max_occ >= k:\n        return 0\n    else:\n        return max(0, max_num - min_num - (k - max_occ))\n\n\nprint(get_num_of_ops(a))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef divide_all(a):\n    return [int(i/2) for i in a]\n\ndef is_all_equal(a):\n    return len(set(a)) == 1\n\ndef count_operations(a, k):\n    if is_all_equal(a):\n        return 0\n    if len(a) < k:\n        return -1\n    c = 0\n    while not is_all_equal(a):\n        a = divide_all(a)\n        c += 1\n    return c\n\nprint(count_operations(a, k))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nfrom math import log2\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\n# if the largest number is already a multiple of 2^k, we don't need to do anything\nif a[-1] % 2 ** k == 0:\n    print(0)\n# if the largest number is not a multiple of 2^k, we need to divide it by 2^k\nelse:\n    # we need to find the number of times the largest number can be divided by 2\n    # if we divide the largest number by 2 enough times, we can make it a multiple of 2^k\n    # we can divide a number by 2 log2(a[-1]) times\n    # so, we need to find the number of times we can divide the largest number by 2 until it is a multiple of 2^k\n    # we can divide the largest number by 2 log2(a[-1]) times, but we can only divide it by 2 log2(2^k) times\n    # since 2^k is a multiple of 2, we can divide the largest number by 2 log2(2^k) times\n    # we can divide the largest number by 2 log2(2^k) times, but we need to divide it by 2 log2(a[-1]) times\n    # so, we need to divide the largest number by 2 (log2(a[-1]) - log2(2^k)) times\n    print(int(log2(a[-1]) - log2(2 ** k)))"
    }
  ],
  "created": 1650404743,
  "id": "cmpl-4ypxH3ViYoLWeOOHoCc9l71xZnBPw",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:47:11.261194 0 {
  "finish_reason": "length",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\n# The number of operations required to make all elements equal is the same as\n# the number of operations required to make all elements equal to the minimum\n# element of the array.\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 2, then we need to perform 2 operations (divide each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 3, then we need to perform 1 operation (divide each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 4, then we need to perform 0 operations.\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 5, then we need to perform 1 operation (multiply each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 6, then we need to perform 2 operations (multiply each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 7, then we need to perform 3 operations (multiply each element by 2).\n\n# If we have an array with elements [2, 3, 4, 5] and we want to make all elements\n# equal to 8, then we need to perform 4 operations (multiply each element by 2).\n\n# We can see that the number of operations required to make all elements equal to\n# the minimum element of the array is always 0.\n\n# We can also see that the number of operations required to make all elements\n# equal to the maximum element of the array is always equal to the number of\n# elements in the array minus 1.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the array plus the number of\n# operations required to make all elements equal to the maximum element of the\n# array minus the number of operations required to make all elements equal to $x$.\n\n# We can also see that the number of operations required to make all elements\n# equal to some value $x$ is equal to the number of operations required to make\n# all elements equal to the minimum element of the"
}
2022-04-19 21:47:11.261367 REASON length
2022-04-19 21:47:11.261379 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef get_min_moves(x):\n    return sum(x // 2 for x in a)\n\ndef is_valid(moves):\n    return get_min_moves(moves) <= moves\n\n# Binary search to find the minimum number of moves\nlow = 0\nhigh = 2 * 10 ** 5\nwhile low < high:\n    mid = (low + high) // 2\n    if is_valid(mid):\n        high = mid\n    else:\n        low = mid + 1\n\nprint(low)"
}
2022-04-19 21:47:11.261413 REASON stop
2022-04-19 21:47:11.262083 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\nimport math\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nmax_num = max(arr)\n\nmin_num = max_num\n\nfor i in range(n):\n    if arr[i] < min_num:\n        min_num = arr[i]\n\nif min_num == max_num:\n    print(0)\n    exit(0)\n\nmin_divs = math.inf\n\nfor div in range(min_num, max_num+1):\n    divs = 0\n    for i in range(n):\n        if arr[i] % div != 0:\n            divs += math.ceil(arr[i] / div) - 1\n    if divs < min_divs:\n        min_divs = divs\n\nprint(min_divs)"
}
2022-04-19 21:47:11.262160 REASON stop
2022-04-19 21:47:11.262639 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# First, find the gcd of the array\ngcd = a[0]\nfor i in range(1, n):\n    gcd = math.gcd(gcd, a[i])\n\n# Then, divide each element by the gcd, and count the number of times\n# we can divide by 2.\n# Since we can divide each element by 2 any number of times, we can\n# divide the gcd by 2 as many times as needed.\n\n# We do this by counting the number of 1s in the binary\n# representation of the gcd.\n\n# This is because the gcd is the product of the common prime factors\n# of each element of the array.\n# If we divide each element of the array by the gcd, we will have\n# the remaining prime factors.\n# The remaining prime factors of each element can be divided by 2 as\n# many times as needed.\n# Therefore, we can divide the gcd by 2 as many times as needed.\n\n# We count the number of 1s in the binary representation of the gcd\n# to find out how many times we can divide the gcd by 2.\ncount = 0\nwhile gcd % 2 == 0:\n    count += 1\n    gcd //= 2\n\n# Then, we find the minimum number of operations needed to get at\n# least k equal numbers in the array.\n# This is the number of operations needed to divide the gcd by 2\n# (count) plus the number of operations needed to get at least k\n# equal numbers in the array after dividing the gcd by 2.\nmin_operations = count + math.ceil(math.log(k, 2))\n\nprint(min_operations)"
}
2022-04-19 21:47:11.262696 REASON stop
2022-04-19 21:47:11.288502 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\n# The minimum number of operations is the minimum number of operations required to make all elements equal to the minimum element.\n# Since we can divide all elements by two, we need to find the largest power of two in the array.\n# We can do this by finding the maximum number of trailing zeros in the binary representation of all elements.\n\nmax_zeros = 0\nfor i in a:\n    cur_zeros = 0\n    while i % 2 == 0:\n        i //= 2\n        cur_zeros += 1\n    max_zeros = max(max_zeros, cur_zeros)\n\nprint(max_zeros)"
}
2022-04-19 21:47:11.288636 REASON stop
2022-04-19 21:47:11.289551 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# min_num = min(a)\n# max_num = max(a)\n# max_occ = a.count(max_num)\n#\n# if max_occ >= k:\n#     print(0)\n# else:\n#     print(max(0, max_num - min_num - (k - max_occ)))\n\n# def get_min_max(a):\n#     min_num = a[0]\n#     max_num = a[0]\n#     for i in range(1, len(a)):\n#         if a[i] < min_num:\n#             min_num = a[i]\n#         if a[i] > max_num:\n#             max_num = a[i]\n#     return min_num, max_num\n#\n#\n# def get_max_occ(a):\n#     max_num = a[0]\n#     max_occ = 1\n#     for i in range(1, len(a)):\n#         if a.count(a[i]) > max_occ:\n#             max_num = a[i]\n#             max_occ = a.count(a[i])\n#     return max_num, max_occ\n#\n#\n# def get_num_of_ops(a):\n#     min_num, max_num = get_min_max(a)\n#     max_num, max_occ = get_max_occ(a)\n#     if max_occ >= k:\n#         return 0\n#     else:\n#         return max(0, max_num - min_num - (k - max_occ))\n#\n#\n# print(get_num_of_ops(a))\n\ndef get_min_max(a):\n    min_num = a[0]\n    max_num = a[0]\n    for i in range(1, len(a)):\n        if a[i] < min_num:\n            min_num = a[i]\n        if a[i] > max_num:\n            max_num = a[i]\n    return min_num, max_num\n\n\ndef get_max_occ(a):\n    max_num = a[0]\n    max_occ = 1\n    for i in range(1, len(a)):\n        if a.count(a[i]) > max_occ:\n            max_num = a[i]\n            max_occ = a.count(a[i])\n    return max_num, max_occ\n\n\ndef get_num_of_ops(a):\n    min_num, max_num = get_min_max(a)\n    max_num, max_occ = get_max_occ(a)\n    if max_occ >= k:\n        return 0\n    else:\n        return max(0, max_num - min_num - (k - max_occ))\n\n\nprint(get_num_of_ops(a))"
}
2022-04-19 21:47:11.289661 REASON stop
2022-04-19 21:47:11.291200 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef divide_all(a):\n    return [int(i/2) for i in a]\n\ndef is_all_equal(a):\n    return len(set(a)) == 1\n\ndef count_operations(a, k):\n    if is_all_equal(a):\n        return 0\n    if len(a) < k:\n        return -1\n    c = 0\n    while not is_all_equal(a):\n        a = divide_all(a)\n        c += 1\n    return c\n\nprint(count_operations(a, k))"
}
2022-04-19 21:47:11.291284 REASON stop
2022-04-19 21:47:11.292517 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nfrom math import log2\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\n# if the largest number is already a multiple of 2^k, we don't need to do anything\nif a[-1] % 2 ** k == 0:\n    print(0)\n# if the largest number is not a multiple of 2^k, we need to divide it by 2^k\nelse:\n    # we need to find the number of times the largest number can be divided by 2\n    # if we divide the largest number by 2 enough times, we can make it a multiple of 2^k\n    # we can divide a number by 2 log2(a[-1]) times\n    # so, we need to find the number of times we can divide the largest number by 2 until it is a multiple of 2^k\n    # we can divide the largest number by 2 log2(a[-1]) times, but we can only divide it by 2 log2(2^k) times\n    # since 2^k is a multiple of 2, we can divide the largest number by 2 log2(2^k) times\n    # we can divide the largest number by 2 log2(2^k) times, but we need to divide it by 2 log2(a[-1]) times\n    # so, we need to divide the largest number by 2 (log2(a[-1]) - log2(2^k)) times\n    print(int(log2(a[-1]) - log2(2 ** k)))"
}
2022-04-19 21:47:11.292734 REASON stop
