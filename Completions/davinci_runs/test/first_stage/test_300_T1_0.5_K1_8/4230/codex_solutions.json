["\n\n# X is the number we are trying to find the closest to\n# N is the length of the sequence\n# p_1, ..., p_N is the sequence\n\nx, n = input().split()\nx = int(x)\nn = int(n)\n\np = input().split()\np = [int(i) for i in p]\n\n# First, we create a list with all the numbers between 1 and 100 (inclusive)\n# We then remove all the numbers that are in the sequence p_1, ..., p_N\n# This way, we are left with a list of all the numbers that are not in the sequence\n\nall_numbers = list(range(1, 101))\nfor i in p:\n    all_numbers.remove(i)\n\n# Next, we sort the list all_numbers.\n# This allows us to use binary search to find the closest number to x\n\nall_numbers.sort()\n\n# If x is smaller than the first number in all_numbers, then the closest number to x is the first number in all_numbers\n# If x is greater than the last number in all_numbers, then the closest number to x is the last number in all_numbers\n# Otherwise, we use binary search to find the closest number to x\n\nif x < all_numbers[0]:\n    print(all_numbers[0])\nelif x > all_numbers[-1]:\n    print(all_numbers[-1])\nelse:\n    # The following code is a modified version of binary search\n    # The modification is that instead of returning the index of the number we are looking for,\n    # it returns the index of the closest number to the number we are looking for\n    # We start by assuming that the closest number is at the beginning of all_numbers\n    # We then change the value of the closest number if we find a number that is closer\n    # We repeat this until we find the number we are looking for or we have narrowed our search down to one number\n\n    closest_number = 0\n    left = 0\n    right = len(all_numbers) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if all_numbers[mid] < x:\n            # If all_numbers[mid] < x, then we want to look at the numbers after all_numbers[mid]\n            # Check if all_numbers[mid] is closer than the closest number we have found so far\n            if abs(x - all_numbers[mid]) < abs(x - all_numbers[closest_number]):\n                closest_number = mid\n            left = mid + 1\n        elif all_numbers[mid] > x:\n            # If all_numbers[mid] > x, then we want to look at the numbers before all_numbers[mid]\n            # Check if all_numbers[mid] is closer than the closest number we have found so far\n            if abs(x - all_numbers[mid]) < abs(x - all_numbers[closest_number]):\n                closest_number = mid\n            right = mid\n        else:\n            # If all_numbers[mid] == x, then we have found the number we are looking for\n            print(x)\n            exit()\n    # If we reach this point, then we have narrowed our search down to one number\n    # This number is the closest number to the number we are looking for\n    print(all_numbers[closest_number])", "\n\nfrom sys import stdin\n\ndef main():\n    x, n = map(int, stdin.readline().split())\n    p = set(map(int, stdin.readline().split()))\n\n    ans = float('inf')\n    for i in range(x-n, x+n+1):\n        if i not in p:\n            ans = min(ans, i)\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\n#This is very simple.\n#Since all values are integers, we know that the nearest integer to X is either X-1 or X+1.\n#Thus, we just need to check if X-1 or X+1 is in the given sequence.\n#If neither are in it, then we know the answer is X+1.\n#If only one of them is in the sequence, then that one is the answer.\n#If both are in the sequence, then the answer is X-1.\n\nx = int(input().split()[0])\np = [int(i) for i in input().split()]\n\nif x-1 not in p and x+1 not in p:\n    print(x+1)\nelif x-1 not in p:\n    print(x-1)\nelif x+1 not in p:\n    print(x+1)\nelse:\n    print(x-1)", "\n\ndef main():\n    x, n = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n\n    for i in range(n):\n        if x <= p[i]:\n            print(p[i] - x)\n            break\n        elif i == n - 1:\n            print(x - p[i])\n\nif __name__ == '__main__':\n    main()", "\n\nX = int(input())\nN = int(input())\np = [int(i) for i in input().split()]\n\ndef nearest(X, N, p):\n    if N == 0:\n        return X\n    else:\n        ans = p[0]\n        for i in range(1, N):\n            if abs(X-p[i]) < abs(X-ans):\n                ans = p[i]\n        return ans\n\nans = nearest(X, N, p)\n\nprint(ans)", "\n\nX, N = input().split()\nX = int(X)\nN = int(N)\n\nP = input().split()\nP = [int(i) for i in P]\n\n#print(X, N, P)\n\nans = 101\nfor i in range(1, 101):\n    if i not in P:\n        if abs(X-i) < abs(X-ans):\n            ans = i\n\nprint(ans)", "\n\nx, n = map(int, input().split())\np = list(map(int, input().split()))\n\nif x not in p:\n    print(x)\nelse:\n    for i in range(101):\n        if x-i not in p:\n            print(x-i)\n            break\n        if x+i not in p:\n            print(x+i)\n            break", "\n\n# \u5165\u529b\nX, N = map(int, input().split())\np = [int(i) for i in input().split()]\n\n# \u8a08\u7b97\nfor i in range(1, 101):\n    if i not in p:\n        if abs(X - i) < abs(X - ans):\n            ans = i\n\n# \u51fa\u529b\nprint(ans)"]