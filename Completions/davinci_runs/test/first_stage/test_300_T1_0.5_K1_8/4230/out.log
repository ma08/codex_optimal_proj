2022-04-19 23:12:44.613577 """
Given are an integer X and an integer sequence of length N: p_1, \ldots, p_N.
Among the integers not contained in the sequence p_1, \ldots, p_N (not necessarily positive), find the integer nearest to X, that is, find the integer whose absolute difference with X is the minimum. If there are multiple such integers, report the smallest such integer.

-----Constraints-----
 - 1 \leq X \leq 100
 - 0 \leq N \leq 100
 - 1 \leq p_i \leq 100
 - p_1, \ldots, p_N are all distinct.
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
X N
p_1 ... p_N

-----Output-----
Print the answer.

-----Sample Input-----
6 5
4 7 10 6 5

-----Sample Output-----
8

Among the integers not contained in the sequence 4, 7, 10, 6, 5, the one nearest to 6 is 8.
"""
2022-04-19 23:12:44.613589 --------------------------
2022-04-19 23:12:44.613694 using api key gabby
2022-04-19 23:12:44.778597 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 23:12:49.783976 """
Given are an integer X and an integer sequence of length N: p_1, \ldots, p_N.
Among the integers not contained in the sequence p_1, \ldots, p_N (not necessarily positive), find the integer nearest to X, that is, find the integer whose absolute difference with X is the minimum. If there are multiple such integers, report the smallest such integer.

-----Constraints-----
 - 1 \leq X \leq 100
 - 0 \leq N \leq 100
 - 1 \leq p_i \leq 100
 - p_1, \ldots, p_N are all distinct.
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
X N
p_1 ... p_N

-----Output-----
Print the answer.

-----Sample Input-----
6 5
4 7 10 6 5

-----Sample Output-----
8

Among the integers not contained in the sequence 4, 7, 10, 6, 5, the one nearest to 6 is 8.
"""
2022-04-19 23:12:49.784008 --------------------------
2022-04-19 23:12:49.784128 using api key sourya
2022-04-19 23:13:26.558331 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    x, n = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n\n    for i in range(n):\n        if x <= p[i]:\n            print(p[i] - x)\n            break\n        elif i == n - 1:\n            print(x - p[i])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nX, N = input().split()\nX = int(X)\nN = int(N)\n\nP = input().split()\nP = [int(i) for i in P]\n\n#print(X, N, P)\n\nans = 101\nfor i in range(1, 101):\n    if i not in P:\n        if abs(X-i) < abs(X-ans):\n            ans = i\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# X is the number we are trying to find the closest to\n# N is the length of the sequence\n# p_1, ..., p_N is the sequence\n\nx, n = input().split()\nx = int(x)\nn = int(n)\n\np = input().split()\np = [int(i) for i in p]\n\n# First, we create a list with all the numbers between 1 and 100 (inclusive)\n# We then remove all the numbers that are in the sequence p_1, ..., p_N\n# This way, we are left with a list of all the numbers that are not in the sequence\n\nall_numbers = list(range(1, 101))\nfor i in p:\n    all_numbers.remove(i)\n\n# Next, we sort the list all_numbers.\n# This allows us to use binary search to find the closest number to x\n\nall_numbers.sort()\n\n# If x is smaller than the first number in all_numbers, then the closest number to x is the first number in all_numbers\n# If x is greater than the last number in all_numbers, then the closest number to x is the last number in all_numbers\n# Otherwise, we use binary search to find the closest number to x\n\nif x < all_numbers[0]:\n    print(all_numbers[0])\nelif x > all_numbers[-1]:\n    print(all_numbers[-1])\nelse:\n    # The following code is a modified version of binary search\n    # The modification is that instead of returning the index of the number we are looking for,\n    # it returns the index of the closest number to the number we are looking for\n    # We start by assuming that the closest number is at the beginning of all_numbers\n    # We then change the value of the closest number if we find a number that is closer\n    # We repeat this until we find the number we are looking for or we have narrowed our search down to one number\n\n    closest_number = 0\n    left = 0\n    right = len(all_numbers) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if all_numbers[mid] < x:\n            # If all_numbers[mid] < x, then we want to look at the numbers after all_numbers[mid]\n            # Check if all_numbers[mid] is closer than the closest number we have found so far\n            if abs(x - all_numbers[mid]) < abs(x - all_numbers[closest_number]):\n                closest_number = mid\n            left = mid + 1\n        elif all_numbers[mid] > x:\n            # If all_numbers[mid] > x, then we want to look at the numbers before all_numbers[mid]\n            # Check if all_numbers[mid] is closer than the closest number we have found so far\n            if abs(x - all_numbers[mid]) < abs(x - all_numbers[closest_number]):\n                closest_number = mid\n            right = mid\n        else:\n            # If all_numbers[mid] == x, then we have found the number we are looking for\n            print(x)\n            exit()\n    # If we reach this point, then we have narrowed our search down to one number\n    # This number is the closest number to the number we are looking for\n    print(all_numbers[closest_number])"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n    x, n = map(int, stdin.readline().split())\n    p = set(map(int, stdin.readline().split()))\n\n    ans = float('inf')\n    for i in range(x-n, x+n+1):\n        if i not in p:\n            ans = min(ans, i)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nx, n = map(int, input().split())\np = list(map(int, input().split()))\n\nif x not in p:\n    print(x)\nelse:\n    for i in range(101):\n        if x-i not in p:\n            print(x-i)\n            break\n        if x+i not in p:\n            print(x+i)\n            break"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# \u5165\u529b\nX, N = map(int, input().split())\np = [int(i) for i in input().split()]\n\n# \u8a08\u7b97\nfor i in range(1, 101):\n    if i not in p:\n        if abs(X - i) < abs(X - ans):\n            ans = i\n\n# \u51fa\u529b\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nX = int(input())\nN = int(input())\np = [int(i) for i in input().split()]\n\ndef nearest(X, N, p):\n    if N == 0:\n        return X\n    else:\n        ans = p[0]\n        for i in range(1, N):\n            if abs(X-p[i]) < abs(X-ans):\n                ans = p[i]\n        return ans\n\nans = nearest(X, N, p)\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n#This is very simple.\n#Since all values are integers, we know that the nearest integer to X is either X-1 or X+1.\n#Thus, we just need to check if X-1 or X+1 is in the given sequence.\n#If neither are in it, then we know the answer is X+1.\n#If only one of them is in the sequence, then that one is the answer.\n#If both are in the sequence, then the answer is X-1.\n\nx = int(input().split()[0])\np = [int(i) for i in input().split()]\n\nif x-1 not in p and x+1 not in p:\n    print(x+1)\nelif x-1 not in p:\n    print(x-1)\nelif x+1 not in p:\n    print(x+1)\nelse:\n    print(x-1)"
    }
  ],
  "created": 1650409969,
  "id": "cmpl-4yrJZEBNZVAzylPgMubtz6asDvwHG",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 23:13:26.558679 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    x, n = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n\n    for i in range(n):\n        if x <= p[i]:\n            print(p[i] - x)\n            break\n        elif i == n - 1:\n            print(x - p[i])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:13:26.558805 REASON stop
2022-04-19 23:13:26.559620 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nX, N = input().split()\nX = int(X)\nN = int(N)\n\nP = input().split()\nP = [int(i) for i in P]\n\n#print(X, N, P)\n\nans = 101\nfor i in range(1, 101):\n    if i not in P:\n        if abs(X-i) < abs(X-ans):\n            ans = i\n\nprint(ans)"
}
2022-04-19 23:13:26.559695 REASON stop
2022-04-19 23:13:26.560135 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# X is the number we are trying to find the closest to\n# N is the length of the sequence\n# p_1, ..., p_N is the sequence\n\nx, n = input().split()\nx = int(x)\nn = int(n)\n\np = input().split()\np = [int(i) for i in p]\n\n# First, we create a list with all the numbers between 1 and 100 (inclusive)\n# We then remove all the numbers that are in the sequence p_1, ..., p_N\n# This way, we are left with a list of all the numbers that are not in the sequence\n\nall_numbers = list(range(1, 101))\nfor i in p:\n    all_numbers.remove(i)\n\n# Next, we sort the list all_numbers.\n# This allows us to use binary search to find the closest number to x\n\nall_numbers.sort()\n\n# If x is smaller than the first number in all_numbers, then the closest number to x is the first number in all_numbers\n# If x is greater than the last number in all_numbers, then the closest number to x is the last number in all_numbers\n# Otherwise, we use binary search to find the closest number to x\n\nif x < all_numbers[0]:\n    print(all_numbers[0])\nelif x > all_numbers[-1]:\n    print(all_numbers[-1])\nelse:\n    # The following code is a modified version of binary search\n    # The modification is that instead of returning the index of the number we are looking for,\n    # it returns the index of the closest number to the number we are looking for\n    # We start by assuming that the closest number is at the beginning of all_numbers\n    # We then change the value of the closest number if we find a number that is closer\n    # We repeat this until we find the number we are looking for or we have narrowed our search down to one number\n\n    closest_number = 0\n    left = 0\n    right = len(all_numbers) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if all_numbers[mid] < x:\n            # If all_numbers[mid] < x, then we want to look at the numbers after all_numbers[mid]\n            # Check if all_numbers[mid] is closer than the closest number we have found so far\n            if abs(x - all_numbers[mid]) < abs(x - all_numbers[closest_number]):\n                closest_number = mid\n            left = mid + 1\n        elif all_numbers[mid] > x:\n            # If all_numbers[mid] > x, then we want to look at the numbers before all_numbers[mid]\n            # Check if all_numbers[mid] is closer than the closest number we have found so far\n            if abs(x - all_numbers[mid]) < abs(x - all_numbers[closest_number]):\n                closest_number = mid\n            right = mid\n        else:\n            # If all_numbers[mid] == x, then we have found the number we are looking for\n            print(x)\n            exit()\n    # If we reach this point, then we have narrowed our search down to one number\n    # This number is the closest number to the number we are looking for\n    print(all_numbers[closest_number])"
}
2022-04-19 23:13:26.560201 REASON stop
2022-04-19 23:13:26.579170 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\ndef main():\n    x, n = map(int, stdin.readline().split())\n    p = set(map(int, stdin.readline().split()))\n\n    ans = float('inf')\n    for i in range(x-n, x+n+1):\n        if i not in p:\n            ans = min(ans, i)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:13:26.579295 REASON stop
2022-04-19 23:13:26.606315 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nx, n = map(int, input().split())\np = list(map(int, input().split()))\n\nif x not in p:\n    print(x)\nelse:\n    for i in range(101):\n        if x-i not in p:\n            print(x-i)\n            break\n        if x+i not in p:\n            print(x+i)\n            break"
}
2022-04-19 23:13:26.606447 REASON stop
2022-04-19 23:13:26.607636 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# \u5165\u529b\nX, N = map(int, input().split())\np = [int(i) for i in input().split()]\n\n# \u8a08\u7b97\nfor i in range(1, 101):\n    if i not in p:\n        if abs(X - i) < abs(X - ans):\n            ans = i\n\n# \u51fa\u529b\nprint(ans)"
}
2022-04-19 23:13:26.607732 REASON stop
2022-04-19 23:13:26.608827 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nX = int(input())\nN = int(input())\np = [int(i) for i in input().split()]\n\ndef nearest(X, N, p):\n    if N == 0:\n        return X\n    else:\n        ans = p[0]\n        for i in range(1, N):\n            if abs(X-p[i]) < abs(X-ans):\n                ans = p[i]\n        return ans\n\nans = nearest(X, N, p)\n\nprint(ans)"
}
2022-04-19 23:13:26.609006 REASON stop
2022-04-19 23:13:26.609897 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n#This is very simple.\n#Since all values are integers, we know that the nearest integer to X is either X-1 or X+1.\n#Thus, we just need to check if X-1 or X+1 is in the given sequence.\n#If neither are in it, then we know the answer is X+1.\n#If only one of them is in the sequence, then that one is the answer.\n#If both are in the sequence, then the answer is X-1.\n\nx = int(input().split()[0])\np = [int(i) for i in input().split()]\n\nif x-1 not in p and x+1 not in p:\n    print(x+1)\nelif x-1 not in p:\n    print(x-1)\nelif x+1 not in p:\n    print(x+1)\nelse:\n    print(x-1)"
}
2022-04-19 23:13:26.609973 REASON stop
