["\n\nfrom sys import stdin\nfrom collections import deque\n\ndef main():\n    n, m, k = map(int, stdin.readline().split())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    dp2 = [[0] * (m + 1) for _ in range(n + 1)]\n    dp2[1][1] = a[0][0]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp2[i][j] = dp2[i - 1][j] ^ dp2[i][j - 1] ^ a[i - 1][j - 1]\n\n    ans = 0\n    q = deque([(0, 0, k)])\n    visited = [[[False] * (k + 1) for _ in range(m + 1)] for _ in range(n + 1)]\n    visited[0][0][k] = True\n    while q:\n        i, j, prev = q.popleft()\n        if i == n - 1 and j == m - 1:\n            ans += dp[i + 1][j + 1]\n            continue\n        ni, nj = i + 1, j + 1\n        if ni < n:\n            nk = prev ^ a[ni][j]\n            if not visited[ni][j][nk]:\n                visited[ni][j][nk] = True\n                q.append((ni, j, nk))\n        if nj < m:\n            nk = prev ^ a[i][nj]\n            if not visited[i][nj][nk]:\n                visited[i][nj][nk] = True\n                q.append((i, nj, nk))\n\n    print(ans)\n\nmain()", "\n\ndef solve(n, m, k, grid):\n  # TODO: Solve the problem!\n  return 0\n\nimport sys\n\ndef main():\n  n, m, k = map(int, sys.stdin.readline().split())\n  grid = []\n  for i in range(n):\n    row = map(int, sys.stdin.readline().split())\n    grid.append(row)\n  print solve(n, m, k, grid)\n\nif __name__ == '__main__':\n  main()", "\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for i in range(n)]\n    # print(grid)\n\n    dp = [[0 for i in range(m)] for j in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                dp[i][j] = dp[i][j-1]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    # print(dp)\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                if grid[i][j] ^ grid[i][j-1] == k:\n                    ans += dp[i][j-1]\n            elif j == 0:\n                if grid[i][j] ^ grid[i-1][j] == k:\n                    ans += dp[i-1][j]\n            else:\n                if grid[i][j] ^ grid[i-1][j] == k:\n                    ans += dp[i-1][j]\n                if grid[i][j] ^ grid[i][j-1] == k:\n                    ans += dp[i][j-1]\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(n, m, k, matrix):\n    # dp[i][j][b]: number of paths from (1, 1) to (i, j) with xor sum equal to b\n    dp = [[[0 for b in range(1024)] for j in range(m)] for i in range(n)]\n    dp[0][0][matrix[0][0]] = 1\n    for i in range(n):\n        for j in range(m):\n            for b in range(1024):\n                if i + 1 < n:\n                    dp[i + 1][j][b ^ matrix[i + 1][j]] += dp[i][j][b]\n                if j + 1 < m:\n                    dp[i][j + 1][b ^ matrix[i][j + 1]] += dp[i][j][b]\n    return dp[n - 1][m - 1][k]\n\nn, m, k = map(int, input().split())\nmatrix = [list(map(int, input().split())) for i in range(n)]\nprint(solve(n, m, k, matrix))", "\n\ndef xor_paths(n, m, k, grid):\n    \"\"\"\n    >>> xor_paths(3, 3, 11, [[2, 1, 5], [7, 10, 0], [12, 6, 4]])\n    3\n    >>> xor_paths(3, 4, 2, [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]])\n    5\n    >>> xor_paths(3, 4, 10**18, [[1, 3, 3, 3], [0, 3, 3, 2], [3, 0, 1, 1]])\n    0\n    \"\"\"\n    memo = {}\n    def xor_paths_helper(i, j, xor_so_far):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if i == n - 1 and j == m - 1:\n            if xor_so_far ^ grid[i][j] == k:\n                memo[(i, j)] = 1\n            else:\n                memo[(i, j)] = 0\n        else:\n            if xor_so_far ^ grid[i][j] == k:\n                memo[(i, j)] = 1\n            else:\n                memo[(i, j)] = 0\n            if i < n - 1:\n                memo[(i, j)] += xor_paths_helper(i + 1, j, xor_so_far ^ grid[i][j])\n            if j < m - 1:\n                memo[(i, j)] += xor_paths_helper(i, j + 1, xor_so_far ^ grid[i][j])\n        return memo[(i, j)]\n    return xor_paths_helper(0, 0, 0)\n\nif __name__ == \"__main__\":\n    n, m, k = [int(x) for x in input().split()]\n    grid = []\n    for i in range(n):\n        grid.append([int(x) for x in input().split()])\n    print(xor_paths(n, m, k, grid))", "\n\ndef main():\n    # read\n    n, m, k = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    # solve\n    dp = [[0] * (m+1) for _ in range(n+1)]\n    dp[1][1] = 1\n\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    dp2 = [[0] * (m+1) for _ in range(n+1)]\n    dp2[1][1] = 1\n\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            dp2[i][j] = dp2[i-1][j] + dp2[i][j-1]\n\n    ans = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            xor_sum = a[i-1][j-1] ^ k\n            if xor_sum > k:\n                continue\n            ans += dp[i-1][j] * dp2[n][m-j+1] + dp[i][j-1] * dp2[n-i+1][m]\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(10000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: \u96a3\u63a5\u884c\u5217(\u8ddd\u96e2\u4ed8\u304d)\n    N: \u30ce\u30fc\u30c9\u6570\n    K: \u59cb\u70b9\u30ce\u30fc\u30c9\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  \u73fe\u5728\u306e\u30ce\u30fc\u30c9\n    pre: \uff11\u3064\u524d\u306e\u30ce\u30fc\u30c9\n    dist: \u73fe\u5728\u306e\u8ddd\u96e2\n\n    \u4ee5\u4e0b\u306f\u5225\u9014\u7528\u610f\u3059\u308b\n    D: \u96a3\u63a5\u30ea\u30b9\u30c8(\u884c\u5217\u3067\u306f\u306a\u3044)\n    D_dfs_d: dfs_d\u95a2\u6570\u3067\u7528\u3044\u308b\uff0c\u59cb\u70b9\u30ce\u30fc\u30c9\u304b\u3089\u898b\u305f\u8ddd\u96e2\u30ea\u30b9\u30c8\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\ndef comb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r + 1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p - 1, r, p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\ndef bisearch(L, target):\n    low = 0\n    high = len(L) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        guess = L[mid]\n        if guess == target:\n            return True\n        elif guess < target:\n            low = mid + 1\n        elif guess > target:\n            high = mid - 1\n    if guess != target:\n        return False\n\n# --------------------------------------------\n\ndp = None\n\ndef main():\n    N, M, K = li_input()\n    A = [[0] * M for i in range(N)]\n\n    for i in range(N):\n        A[i] = li_input()\n\n    dp = [[0] * (M + 1) for i in range(N + 1)]\n    dp[0][1] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    print(dp)\n\n\nmain()", "\n\nimport sys\n\ndef read_line():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return [int(x) for x in read_line().split()]\n\ndef read_int():\n    return read_ints()[0]\n\ndef read_grid(n, m):\n    return [read_ints() for _ in range(n)]\n\ndef solve(n, m, k, a):\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j] = dp[i][j] if a[i][j] ^ k == 0 else 0\n    return dp[n - 1][m - 1]\n\ndef main():\n    n, m, k = read_ints()\n    a = read_grid(n, m)\n    print(solve(n, m, k, a))\n\nif __name__ == '__main__':\n    main()"]