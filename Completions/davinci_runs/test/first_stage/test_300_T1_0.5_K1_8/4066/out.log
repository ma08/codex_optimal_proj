2022-04-19 21:34:00.606714 """
You are given an array $a$ consisting of $n$ integers $a_1, a_2, \dots, a_n$.

Your problem is to find such pair of indices $i, j$ ($1 \le i < j \le n$) that $lcm(a_i, a_j)$ is minimum possible.

$lcm(x, y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number).


-----Input-----

The first line of the input contains one integer $n$ ($2 \le n \le 10^6$) — the number of elements in $a$.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^7$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print two integers $i$ and $j$ ($1 \le i < j \le n$) such that the value of $lcm(a_i, a_j)$ is minimum among all valid pairs $i, j$. If there are multiple answers, you can print any.


-----Examples-----
Input
5
2 4 8 3 6

Output
1 2

Input
5
5 2 11 3 7

Output
2 4

Input
6
2 5 10 1 10 2

Output
1 4
"""
2022-04-19 21:34:00.606732 --------------------------
2022-04-19 21:34:00.606851 using api key gabby
2022-04-19 21:34:00.721387 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 21:34:05.726783 """
You are given an array $a$ consisting of $n$ integers $a_1, a_2, \dots, a_n$.

Your problem is to find such pair of indices $i, j$ ($1 \le i < j \le n$) that $lcm(a_i, a_j)$ is minimum possible.

$lcm(x, y)$ is the least common multiple of $x$ and $y$ (minimum positive number such that both $x$ and $y$ are divisors of this number).


-----Input-----

The first line of the input contains one integer $n$ ($2 \le n \le 10^6$) — the number of elements in $a$.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^7$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print two integers $i$ and $j$ ($1 \le i < j \le n$) such that the value of $lcm(a_i, a_j)$ is minimum among all valid pairs $i, j$. If there are multiple answers, you can print any.


-----Examples-----
Input
5
2 4 8 3 6

Output
1 2

Input
5
5 2 11 3 7

Output
2 4

Input
6
2 5 10 1 10 2

Output
1 4
"""
2022-04-19 21:34:05.726822 --------------------------
2022-04-19 21:34:05.726940 using api key sourya
2022-04-19 21:34:34.708456 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a):\n    min_lcm = lcm(a[0], a[1])\n    min_pair = (0, 1)\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            _lcm = lcm(a[i], a[j])\n            if _lcm < min_lcm:\n                min_lcm = _lcm\n                min_pair = (i, j)\n    return min_pair\n\n\nn = int(input())\na = list(map(int, input().split()))\ni, j = solve(a)\nprint(i + 1, j + 1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef gcd(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a: int, b: int) -> int:\n    return a * b // gcd(a, b)\n\ndef main():\n    n = int(input())\n    numbers = [int(x) for x in input().split()]\n    assert len(numbers) == n\n    gcd_map = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd_map.get(numbers[i], numbers[j]) > gcd(numbers[i], numbers[j]):\n                gcd_map[numbers[i], numbers[j]] = gcd(numbers[i], numbers[j])\n                gcd_map[numbers[j], numbers[i]] = gcd(numbers[i], numbers[j])\n    min_lcm = float('inf')\n    min_lcm_pair = None\n    for key in gcd_map:\n        if lcm(key[0], key[1]) < min_lcm:\n            min_lcm = lcm(key[0], key[1])\n            min_lcm_pair = key\n    print(min_lcm_pair)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\ndef solution():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [0]\n    for i in range(1, n):\n        b.append(lcm(a[i - 1], a[i]))\n    min_lcm = min(b)\n    for i in range(1, n):\n        if b[i] == min_lcm:\n            print(i, i + 1)\n            return\n\n\nsolution()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef lcm(a, b):\n    return (a * b) // math.gcd(a, b)\n\ndef lcm_pair(a):\n    min_lcm = sys.maxsize\n    min_pair = None\n    for i, ai in enumerate(a):\n        for j, aj in enumerate(a[i+1:]):\n            aj_ = aj + i + 1\n            lcm_ = lcm(ai, aj)\n            if lcm_ < min_lcm:\n                min_lcm = lcm_\n                min_pair = (i+1, aj_)\n    return min_pair\n\nn = int(input())\na = [int(i) for i in input().split()]\n\nprint(*lcm_pair(a))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the minimum lcm to be the lcm of the first two elements\nmin_lcm = lcm(a[0], a[1])\n\n# Initialize the indices of the minimum lcm to be the first two elements\nmin_lcm_i = 0\nmin_lcm_j = 1\n\n# Iterate over the rest of the array\nfor i in range(n):\n    for j in range(i+1, n):\n        # Check if the lcm of the two elements is smaller than the current minimum\n        # If so, update the minimum lcm and the indices\n        if lcm(a[i], a[j]) < min_lcm:\n            min_lcm = lcm(a[i], a[j])\n            min_lcm_i = i\n            min_lcm_j = j\n\n# Print the indices of the minimum lcm\nprint(min_lcm_i+1, min_lcm_j+1)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nfrom math import gcd\nfrom functools import reduce\nfrom collections import defaultdict\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef lcm_list(l):\n    return reduce(lcm, l)\n\ndef naive_lcm_pair(a):\n    lcm_min = lcm_list(a)\n    pair = None\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            lcm_curr = lcm(a[i], a[j])\n            if lcm_curr < lcm_min:\n                lcm_min = lcm_curr\n                pair = (i + 1, j + 1)\n    return pair\n\ndef fast_lcm_pair(a):\n    lcm_min = lcm_list(a)\n    pair = None\n    factors = defaultdict(int)\n    for x in a:\n        for f in range(2, x + 1):\n            if x % f == 0:\n                factors[f] += 1\n    for i in range(len(a)):\n        for f in range(2, a[i] + 1):\n            if a[i] % f == 0:\n                factors[f] -= 1\n                if factors[f] == 0:\n                    del factors[f]\n                for j in range(i + 1, len(a)):\n                    lcm_curr = lcm(a[i], a[j])\n                    if lcm_curr < lcm_min:\n                        lcm_min = lcm_curr\n                        pair = (i + 1, j + 1)\n                factors[f] += 1\n    return pair\n\ndef main():\n    _ = int(input())\n    a = list(map(int, input().split()))\n    print(*fast_lcm_pair(a))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_lcm = lcm(a[0], a[1])\nmin_lcm_pair = (1, 2)\n\nfor i in range(n):\n    for j in range(i+1, n):\n        l = lcm(a[i], a[j])\n        if l < min_lcm:\n            min_lcm = l\n            min_lcm_pair = (i+1, j+1)\n\nprint(min_lcm_pair[0], min_lcm_pair[1])"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nn = int(input())\na = [int(x) for x in input().split()]\n\nmin_lcm = 10**7\nfor i in range(n):\n    for j in range(i + 1, n):\n        if lcm(a[i], a[j]) < min_lcm:\n            min_lcm = lcm(a[i], a[j])\n            ans = (i + 1, j + 1)\n\nprint(ans[0], ans[1])"
    }
  ],
  "created": 1650404045,
  "id": "cmpl-4ypm1djSSaf9uhT8lFcYXIVmcwAKR",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:34:34.708908 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a):\n    min_lcm = lcm(a[0], a[1])\n    min_pair = (0, 1)\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            _lcm = lcm(a[i], a[j])\n            if _lcm < min_lcm:\n                min_lcm = _lcm\n                min_pair = (i, j)\n    return min_pair\n\n\nn = int(input())\na = list(map(int, input().split()))\ni, j = solve(a)\nprint(i + 1, j + 1)"
}
2022-04-19 21:34:34.708964 REASON stop
2022-04-19 21:34:34.709543 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef gcd(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a: int, b: int) -> int:\n    return a * b // gcd(a, b)\n\ndef main():\n    n = int(input())\n    numbers = [int(x) for x in input().split()]\n    assert len(numbers) == n\n    gcd_map = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd_map.get(numbers[i], numbers[j]) > gcd(numbers[i], numbers[j]):\n                gcd_map[numbers[i], numbers[j]] = gcd(numbers[i], numbers[j])\n                gcd_map[numbers[j], numbers[i]] = gcd(numbers[i], numbers[j])\n    min_lcm = float('inf')\n    min_lcm_pair = None\n    for key in gcd_map:\n        if lcm(key[0], key[1]) < min_lcm:\n            min_lcm = lcm(key[0], key[1])\n            min_lcm_pair = key\n    print(min_lcm_pair)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:34:34.709612 REASON stop
2022-04-19 21:34:34.710052 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\ndef solution():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [0]\n    for i in range(1, n):\n        b.append(lcm(a[i - 1], a[i]))\n    min_lcm = min(b)\n    for i in range(1, n):\n        if b[i] == min_lcm:\n            print(i, i + 1)\n            return\n\n\nsolution()"
}
2022-04-19 21:34:34.710116 REASON stop
2022-04-19 21:34:34.733919 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef lcm(a, b):\n    return (a * b) // math.gcd(a, b)\n\ndef lcm_pair(a):\n    min_lcm = sys.maxsize\n    min_pair = None\n    for i, ai in enumerate(a):\n        for j, aj in enumerate(a[i+1:]):\n            aj_ = aj + i + 1\n            lcm_ = lcm(ai, aj)\n            if lcm_ < min_lcm:\n                min_lcm = lcm_\n                min_pair = (i+1, aj_)\n    return min_pair\n\nn = int(input())\na = [int(i) for i in input().split()]\n\nprint(*lcm_pair(a))"
}
2022-04-19 21:34:34.734046 REASON stop
2022-04-19 21:34:34.754037 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the minimum lcm to be the lcm of the first two elements\nmin_lcm = lcm(a[0], a[1])\n\n# Initialize the indices of the minimum lcm to be the first two elements\nmin_lcm_i = 0\nmin_lcm_j = 1\n\n# Iterate over the rest of the array\nfor i in range(n):\n    for j in range(i+1, n):\n        # Check if the lcm of the two elements is smaller than the current minimum\n        # If so, update the minimum lcm and the indices\n        if lcm(a[i], a[j]) < min_lcm:\n            min_lcm = lcm(a[i], a[j])\n            min_lcm_i = i\n            min_lcm_j = j\n\n# Print the indices of the minimum lcm\nprint(min_lcm_i+1, min_lcm_j+1)"
}
2022-04-19 21:34:34.754189 REASON stop
2022-04-19 21:34:34.754967 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nfrom math import gcd\nfrom functools import reduce\nfrom collections import defaultdict\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef lcm_list(l):\n    return reduce(lcm, l)\n\ndef naive_lcm_pair(a):\n    lcm_min = lcm_list(a)\n    pair = None\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            lcm_curr = lcm(a[i], a[j])\n            if lcm_curr < lcm_min:\n                lcm_min = lcm_curr\n                pair = (i + 1, j + 1)\n    return pair\n\ndef fast_lcm_pair(a):\n    lcm_min = lcm_list(a)\n    pair = None\n    factors = defaultdict(int)\n    for x in a:\n        for f in range(2, x + 1):\n            if x % f == 0:\n                factors[f] += 1\n    for i in range(len(a)):\n        for f in range(2, a[i] + 1):\n            if a[i] % f == 0:\n                factors[f] -= 1\n                if factors[f] == 0:\n                    del factors[f]\n                for j in range(i + 1, len(a)):\n                    lcm_curr = lcm(a[i], a[j])\n                    if lcm_curr < lcm_min:\n                        lcm_min = lcm_curr\n                        pair = (i + 1, j + 1)\n                factors[f] += 1\n    return pair\n\ndef main():\n    _ = int(input())\n    a = list(map(int, input().split()))\n    print(*fast_lcm_pair(a))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:34:34.755089 REASON stop
2022-04-19 21:34:34.755850 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_lcm = lcm(a[0], a[1])\nmin_lcm_pair = (1, 2)\n\nfor i in range(n):\n    for j in range(i+1, n):\n        l = lcm(a[i], a[j])\n        if l < min_lcm:\n            min_lcm = l\n            min_lcm_pair = (i+1, j+1)\n\nprint(min_lcm_pair[0], min_lcm_pair[1])"
}
2022-04-19 21:34:34.756063 REASON stop
2022-04-19 21:34:34.756494 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nn = int(input())\na = [int(x) for x in input().split()]\n\nmin_lcm = 10**7\nfor i in range(n):\n    for j in range(i + 1, n):\n        if lcm(a[i], a[j]) < min_lcm:\n            min_lcm = lcm(a[i], a[j])\n            ans = (i + 1, j + 1)\n\nprint(ans[0], ans[1])"
}
2022-04-19 21:34:34.756558 REASON stop
