2022-04-19 21:31:00.065456 """
You are given a bracket sequence $s$ consisting of $n$ opening '(' and closing ')' brackets.

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences "()()", "(())" are regular (the resulting expressions are: "(1)+(1)", "((1+1)+1)"), and ")(" and "(" are not.

You can change the type of some bracket $s_i$. It means that if $s_i = $ ')' then you can change it to '(' and vice versa.

Your task is to calculate the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 10^6$) — the length of the bracket sequence.

The second line of the input contains the string $s$ consisting of $n$ opening '(' and closing ')' brackets.


-----Output-----

Print one integer — the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.


-----Examples-----
Input
6
(((())

Output
3

Input
6
()()()

Output
0

Input
1
)

Output
0

Input
8
)))(((((

Output
0
"""
2022-04-19 21:31:00.065471 --------------------------
2022-04-19 21:31:00.065581 using api key sourya
2022-04-19 21:31:21.216533 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\ndef is_regular(s):\n    if s == \"\":\n        return True\n    if s[0] == \"(\":\n        i = 1\n        while i < len(s) and s[i] == \"(\":\n            i += 1\n        if i < len(s) and s[i] == \")\":\n            return is_regular(s[1:i]) and is_regular(s[i+1:])\n    return False\n\nif is_regular(s):\n    print(0)\n    exit()\n\ndp = [[0]*n for _ in range(n)]\nfor i in range(n):\n    if s[i] == \")\":\n        dp[i][i] = 1\n\nfor size in range(2, n+1):\n    for i in range(n-size+1):\n        j = i+size-1\n        if s[i] == \"(\":\n            dp[i][j] = dp[i+1][j]\n        elif s[j] == \")\":\n            dp[i][j] = dp[i][j-1]\n        else:\n            dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]\n\nprint(dp[0][n-1])"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef get_input():\n    n = int(input())\n    s = input()\n    return n, s\n\ndef main():\n    n, s = get_input()\n    stack = []\n    count = 0\n    for i in range(n):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            if stack == []:\n                count += 1\n            else:\n                stack.pop()\n    print(count + len(stack))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef solve(s):\n    ans = 0\n    cur = 0\n    for i in s:\n        if i == '(':\n            cur += 1\n        else:\n            cur -= 1\n        if cur < 0:\n            ans += 1\n            cur = 0\n    return ans\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input()\n    print(solve(s))\n\n\"\"\"\nLet's fix the number of opening brackets. It's equal to the number of closing brackets.\n\nNow let's see the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.\n\nIt's clear that if the number of opening brackets is greater than the number of closing brackets, then the answer is $0$.\n\nNow let's consider the case when the number of opening brackets is equal to the number of closing brackets.\n\nLet's count the number of opening brackets before the $i$-th bracket. We'll denote it by $a_i$.\n\nIf $a_i > n/2$, then the answer is $0$.\n\nIf $a_i \\le n/2$, then the answer is $1$.\n\nSo the answer is equal to the number of positions $i$ such that $a_i \\le n/2$.\n\"\"\""
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    stack = 0\n    ans = 0\n    for i in range(n):\n        if s[i] == '(':\n            stack += 1\n        else:\n            stack -= 1\n        if stack == -1:\n            ans += 1\n        if stack < 0:\n            stack = 0\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\nif s[0] == ')':\n    print(0)\nelse:\n    count = 1\n    for i in range(1, n):\n        if s[i] == ')':\n            count -= 1\n        else:\n            count += 1\n        if count < 0:\n            print(0)\n            exit()\n    print(count)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# TODO: finish this problem\n\ndef main():\n    # read input\n    n = int(input())\n    s = input()\n\n    # find all places where you can flip a bracket to get a valid expression\n    ans = 0\n    stack = []\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                ans += 1\n\n    if len(stack) > 0:\n        ans += len(stack)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\n#!/usr/bin/python\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline()\n\nstack = []\n\nfor i in range(n):\n    if s[i] == '(':\n        stack.append('(')\n    else:\n        if len(stack) == 0:\n            stack.append(')')\n        else:\n            stack.pop()\n\nprint(len(stack))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\nif s.count(\"(\") != s.count(\")\"):\n    print(0)\n    exit()\n\n# count the number of open brackets\n# for each close bracket, if there are open brackets, the bracket can be either open or close\n# if there are no open brackets, it can only be open\n# if there are more close brackets than open brackets, it can only be open\n\n# count the number of close brackets\n# for each open bracket, if there are close brackets, the bracket can be either open or close\n# if there are no close brackets, it can only be close\n# if there are more open brackets than close brackets, it can only be close\n\nopen_brackets = 0\nclose_brackets = 0\n\nfor c in s:\n    if c == \"(\":\n        open_brackets += 1\n    elif c == \")\":\n        close_brackets += 1\n\nopen_count = 0\nclose_count = 0\nfor c in s:\n    if c == \"(\":\n        open_count += 1\n    elif c == \")\" and open_brackets > close_brackets:\n        open_count += 1\n\nfor c in s:\n    if c == \")\" and open_brackets > close_brackets:\n        close_count += 1\n    elif c == \")\":\n        close_count += 1\n\nprint(open_count + close_count)"
    }
  ],
  "created": 1650403860,
  "id": "cmpl-4ypj225JeKQ0rLFpphNSGQjtpWTA1",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:31:21.216919 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\ndef is_regular(s):\n    if s == \"\":\n        return True\n    if s[0] == \"(\":\n        i = 1\n        while i < len(s) and s[i] == \"(\":\n            i += 1\n        if i < len(s) and s[i] == \")\":\n            return is_regular(s[1:i]) and is_regular(s[i+1:])\n    return False\n\nif is_regular(s):\n    print(0)\n    exit()\n\ndp = [[0]*n for _ in range(n)]\nfor i in range(n):\n    if s[i] == \")\":\n        dp[i][i] = 1\n\nfor size in range(2, n+1):\n    for i in range(n-size+1):\n        j = i+size-1\n        if s[i] == \"(\":\n            dp[i][j] = dp[i+1][j]\n        elif s[j] == \")\":\n            dp[i][j] = dp[i][j-1]\n        else:\n            dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]\n\nprint(dp[0][n-1])"
}
2022-04-19 21:31:21.216965 REASON stop
2022-04-19 21:31:21.217670 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef get_input():\n    n = int(input())\n    s = input()\n    return n, s\n\ndef main():\n    n, s = get_input()\n    stack = []\n    count = 0\n    for i in range(n):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            if stack == []:\n                count += 1\n            else:\n                stack.pop()\n    print(count + len(stack))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:31:21.217744 REASON stop
2022-04-19 21:31:21.218981 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef solve(s):\n    ans = 0\n    cur = 0\n    for i in s:\n        if i == '(':\n            cur += 1\n        else:\n            cur -= 1\n        if cur < 0:\n            ans += 1\n            cur = 0\n    return ans\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input()\n    print(solve(s))\n\n\"\"\"\nLet's fix the number of opening brackets. It's equal to the number of closing brackets.\n\nNow let's see the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.\n\nIt's clear that if the number of opening brackets is greater than the number of closing brackets, then the answer is $0$.\n\nNow let's consider the case when the number of opening brackets is equal to the number of closing brackets.\n\nLet's count the number of opening brackets before the $i$-th bracket. We'll denote it by $a_i$.\n\nIf $a_i > n/2$, then the answer is $0$.\n\nIf $a_i \\le n/2$, then the answer is $1$.\n\nSo the answer is equal to the number of positions $i$ such that $a_i \\le n/2$.\n\"\"\""
}
2022-04-19 21:31:21.219082 REASON stop
2022-04-19 21:31:21.239631 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    stack = 0\n    ans = 0\n    for i in range(n):\n        if s[i] == '(':\n            stack += 1\n        else:\n            stack -= 1\n        if stack == -1:\n            ans += 1\n        if stack < 0:\n            stack = 0\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:31:21.239767 REASON stop
2022-04-19 21:31:21.240957 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\nif s[0] == ')':\n    print(0)\nelse:\n    count = 1\n    for i in range(1, n):\n        if s[i] == ')':\n            count -= 1\n        else:\n            count += 1\n        if count < 0:\n            print(0)\n            exit()\n    print(count)"
}
2022-04-19 21:31:21.241056 REASON stop
2022-04-19 21:31:21.242125 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# TODO: finish this problem\n\ndef main():\n    # read input\n    n = int(input())\n    s = input()\n\n    # find all places where you can flip a bracket to get a valid expression\n    ans = 0\n    stack = []\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(i)\n        else:\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                ans += 1\n\n    if len(stack) > 0:\n        ans += len(stack)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:31:21.242203 REASON stop
2022-04-19 21:31:21.243128 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\n#!/usr/bin/python\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline()\n\nstack = []\n\nfor i in range(n):\n    if s[i] == '(':\n        stack.append('(')\n    else:\n        if len(stack) == 0:\n            stack.append(')')\n        else:\n            stack.pop()\n\nprint(len(stack))"
}
2022-04-19 21:31:21.243207 REASON stop
2022-04-19 21:31:21.244018 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\nif s.count(\"(\") != s.count(\")\"):\n    print(0)\n    exit()\n\n# count the number of open brackets\n# for each close bracket, if there are open brackets, the bracket can be either open or close\n# if there are no open brackets, it can only be open\n# if there are more close brackets than open brackets, it can only be open\n\n# count the number of close brackets\n# for each open bracket, if there are close brackets, the bracket can be either open or close\n# if there are no close brackets, it can only be close\n# if there are more open brackets than close brackets, it can only be close\n\nopen_brackets = 0\nclose_brackets = 0\n\nfor c in s:\n    if c == \"(\":\n        open_brackets += 1\n    elif c == \")\":\n        close_brackets += 1\n\nopen_count = 0\nclose_count = 0\nfor c in s:\n    if c == \"(\":\n        open_count += 1\n    elif c == \")\" and open_brackets > close_brackets:\n        open_count += 1\n\nfor c in s:\n    if c == \")\" and open_brackets > close_brackets:\n        close_count += 1\n    elif c == \")\":\n        close_count += 1\n\nprint(open_count + close_count)"
}
2022-04-19 21:31:21.244180 REASON stop
