["\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    edges = []\n    for i in range(m):\n        x, y, w = [int(x) for x in input().split()]\n        edges.append((x-1, y-1, w))\n    edges.sort(key=lambda x: x[2])\n    uf = UF(n)\n    result = 0\n    for edge in edges:\n        if uf.find(edge[0]) != uf.find(edge[1]):\n            result += edge[2]\n            uf.union(edge[0], edge[1])\n    if uf.count != 1:\n        result += min(a)\n    print(result)\n\nclass UF:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n        self.count = n\n\n    def find(self, p):\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, p, q):\n        rootP = self.find(p)\n        rootQ = self.find(q)\n        if rootP == rootQ:\n            return\n        if self.size[rootP] < self.size[rootQ]:\n            self.parent[rootP] = rootQ\n            self.size[rootQ] += self.size[rootP]\n        else:\n            self.parent[rootQ] = rootP\n            self.size[rootP] += self.size[rootQ]\n        self.count -= 1\n\nif __name__ == \"__main__\":\n    main()", "\n\n# TODO: Solve this problem", "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    a = [int(x) for x in sys.stdin.readline().split()]\n    offers = {}\n    for i in range(m):\n        x, y, w = [int(x) for x in sys.stdin.readline().split()]\n        if (x, y) not in offers:\n            offers[(x, y)] = w\n        else:\n            offers[(x, y)] = min(offers[(x, y)], w)\n        if (y, x) not in offers:\n            offers[(y, x)] = w\n        else:\n            offers[(y, x)] = min(offers[(y, x)], w)\n\n    groups = []\n    for i in range(n):\n        groups.append([i])\n\n    def find(x):\n        for g in groups:\n            if x in g:\n                return g\n        return None\n\n    def union(g1, g2):\n        g = g1 + g2\n        groups.remove(g1)\n        groups.remove(g2)\n        groups.append(g)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) in offers:\n                g1 = find(i)\n                g2 = find(j)\n                if g1 != g2:\n                    union(g1, g2)\n\n    cost = 0\n    for g in groups:\n        g_cost = 10**18\n        for i in range(len(g)):\n            for j in range(i + 1, len(g)):\n                if (g[i], g[j]) in offers:\n                    g_cost = min(g_cost, offers[(g[i], g[j])])\n                else:\n                    g_cost = min(g_cost, a[g[i]] + a[g[j]])\n        cost += g_cost\n    print(cost)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for i in range(m):\n        x, y, w = map(int, input().split())\n        offers.append((x, y, w))\n    offers.sort(key=lambda x: x[2])\n    res = 0\n    for i in range(n):\n        res += a[i]\n    for i in range(m):\n        x, y, w = offers[i]\n        if a[x - 1] + a[y - 1] > w:\n            res -= a[x - 1] + a[y - 1] - w\n            a[x - 1] = min(a[x - 1], w - a[y - 1])\n            a[y - 1] = min(a[y - 1], w - a[x - 1])\n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef read_input():\n    n, m = map(int, raw_input().split())\n    a = map(int, raw_input().split())\n    offers = []\n    for i in range(m):\n        x, y, w = map(int, raw_input().split())\n        offers.append((x, y, w))\n    return n, m, a, offers\n\ndef solve(n, m, a, offers):\n    pass\n\ndef main():\n    n, m, a, offers = read_input()\n    print solve(n, m, a, offers)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\n\ndef find_set(x):\n    if x != parent[x]:\n        parent[x] = find_set(parent[x])\n    return parent[x]\n\n\ndef union_sets(x, y):\n    if rank[x] > rank[y]:\n        parent[y] = x\n    else:\n        parent[x] = y\n        if rank[x] == rank[y]:\n            rank[y] += 1\n\n\ndef kruskal(edges, n):\n    mst = 0\n    for edge in edges:\n        x, y, w = edge\n        x = find_set(x)\n        y = find_set(y)\n        if x != y:\n            union_sets(x, y)\n            mst += w\n    if len(set(parent)) == 1:\n        return mst\n    else:\n        return None\n\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    a = [int(x) for x in sys.stdin.readline().split()]\n    edges = []\n    for _ in range(m):\n        x, y, w = [int(x) for x in sys.stdin.readline().split()]\n        edges.append((x - 1, y - 1, w))\n    edges.sort(key=lambda x: x[2])\n    global parent\n    parent = [x for x in range(n)]\n    global rank\n    rank = [0] * n\n    mst = kruskal(edges, n)\n    if mst is not None:\n        print(mst)\n    else:\n        edges = [(x, y, a[x] + a[y]) for x, y, _ in edges]\n        edges.sort(key=lambda x: x[2])\n        parent = [x for x in range(n)]\n        rank = [0] * n\n        print(kruskal(edges, n))\n\n\nif __name__ == '__main__':\n    main()", "\n\nfrom sys import stdin\n\ndef main():\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    d = {}\n    for i in range(1, n+1):\n        d[i] = []\n    for i in range(m):\n        x, y, w = map(int, stdin.readline().split())\n        d[x].append((y, w))\n        d[y].append((x, w))\n    q = []\n    q.append(1)\n    used = [0] * (n+1)\n    used[1] = 1\n    ans = 0\n    while len(q) > 0:\n        v = q.pop(0)\n        for u, w in d[v]:\n            if not used[u]:\n                used[u] = 1\n                q.append(u)\n                ans += w\n    for i in range(1, n+1):\n        if not used[i]:\n            ans += a[i-1]\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    edges = []\n    offers = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        offers.append((x, y, w))\n    offers.sort(key=lambda x: x[2])\n    for i in range(n):\n        for j in range(i+1, n):\n            edges.append((i+1, j+1, a[i]+a[j]))\n    edges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    ans = 0\n    for i in range(m):\n        x, y, w = offers[i]\n        if not uf.is_connected(x-1, y-1):\n            uf.union(x-1, y-1)\n            ans += w\n    for i in range(n*(n-1)//2):\n        x, y, w = edges[i]\n        if not uf.is_connected(x-1, y-1):\n            uf.union(x-1, y-1)\n            ans += w\n    print(ans)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        self.size[px] += self.size[py]\n        self.parent[py] = px\n\n    def is_connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n\nif __name__ == \"__main__\":\n    main()"]