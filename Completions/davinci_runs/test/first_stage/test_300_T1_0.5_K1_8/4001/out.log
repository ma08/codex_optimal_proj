2022-04-19 20:48:52.394532 """
Recently you have received two positive integer numbers $x$ and $y$. You forgot them, but you remembered a shuffled list containing all divisors of $x$ (including $1$ and $x$) and all divisors of $y$ (including $1$ and $y$). If $d$ is a divisor of both numbers $x$ and $y$ at the same time, there are two occurrences of $d$ in the list.

For example, if $x=4$ and $y=6$ then the given list can be any permutation of the list $[1, 2, 4, 1, 2, 3, 6]$. Some of the possible lists are: $[1, 1, 2, 4, 6, 3, 2]$, $[4, 6, 1, 1, 2, 3, 2]$ or $[1, 6, 3, 2, 4, 1, 2]$.

Your problem is to restore suitable positive integer numbers $x$ and $y$ that would yield the same list of divisors (possibly in different order).

It is guaranteed that the answer exists, i.e. the given list of divisors corresponds to some positive integers $x$ and $y$.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 128$) — the number of divisors of $x$ and $y$.

The second line of the input contains $n$ integers $d_1, d_2, \dots, d_n$ ($1 \le d_i \le 10^4$), where $d_i$ is either divisor of $x$ or divisor of $y$. If a number is divisor of both numbers $x$ and $y$ then there are two copies of this number in the list.


-----Output-----

Print two positive integer numbers $x$ and $y$ — such numbers that merged list of their divisors is the permutation of the given list of integers. It is guaranteed that the answer exists.


-----Example-----
Input
10
10 2 8 1 2 4 1 20 4 5

Output
20 8
"""
2022-04-19 20:48:52.394550 --------------------------
2022-04-19 20:48:52.394661 using api key gabby
2022-04-19 20:49:28.485312 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\ndivisors = [int(x) for x in input().split()]\n\n# Find the number of occurrences of each divisor\noccurrences = {}\nfor d in divisors:\n    if d in occurrences:\n        occurrences[d] += 1\n    else:\n        occurrences[d] = 1\n\n# The number of occurrences of a number in the list of divisors is the number of\n# times that number appears in the prime factorization of the original number.\n# The prime factorization of the original number is the union of the prime\n# factorizations of the two numbers.\n#\n# If a number appears an odd number of times in the list of divisors, then it\n# must appear an odd number of times in the prime factorization of the original\n# number. Since the prime factorization of a number is unique, this means that\n# the number must appear an odd number of times in the prime factorization of\n# both of the original numbers.\n\ndivisors = {d: occurrences[d] for d in occurrences if occurrences[d] % 2 == 1}\n\n# Each number in the prime factorization of the original number must appear an\n# even number of times in the list of divisors. Since each number in the prime\n# factorization of the original number must appear an even number of times in\n# the prime factorization of both of the original numbers, this means that each\n# number in the prime factorization of both of the original numbers must appear\n# an even number of times in the list of divisors.\n\ndivisors2 = {d: occurrences[d] for d in occurrences if occurrences[d] % 2 == 0}\n\n# The prime factorization of the original number is the union of the prime\n# factorizations of the two numbers.\n#\n# If a number appears an odd number of times in the list of divisors, then it\n# must appear an odd number of times in the prime factorization of the original\n# number.\n#\n# If a number appears an even number of times in the list of divisors, then it\n# must appear an even number of times in the prime factorization of the original\n# number.\n#\n# This means that the prime factorization of the original number is the union of\n# the prime factorizations of the two numbers.\n#\n# The prime factorization of a number is unique, so the prime factorization of\n# the original number is unique. This means that the prime factorization of the\n# two numbers is also unique.\n#\n# This means that the two numbers can be uniquely determined from the list of\n# divisors.\n\nx = 1\ny = 1\nfor d in divisors:\n    x *= d\n    y *= d\nfor d in divisors2:\n    x *= d\n\nprint(x, y)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n\ndef get_divisors(x):\n    divisors = []\n    for i in range(1, x + 1):\n        if x % i == 0:\n            divisors.append(i)\n    return divisors\n\n\ndef get_x_y(divisors):\n    divisors_set = set(divisors)\n    divisors_set.remove(1)\n    for i in divisors_set:\n        if divisors.count(i) == 1:\n            return i, i\n    return 1, 1\n\n\ndef main():\n    n = int(input())\n    divisors = list(map(int, input().split()))\n    x, y = get_x_y(divisors)\n    print(x, y)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n = int(input())\n    divisors = list(map(int, input().split()))\n\n    x_divisors = []\n    y_divisors = []\n\n    for divisor in divisors:\n        if divisor in x_divisors:\n            y_divisors.append(divisor)\n        else:\n            x_divisors.append(divisor)\n\n    x = 1\n    for divisor in x_divisors:\n        x *= divisor\n\n    y = 1\n    for divisor in y_divisors:\n        y *= divisor\n\n    print(x, y)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\nd = [int(x) for x in input().split()]\n\nx = 1\ny = 1\n\nfor i in range(n):\n    x *= d[i]\n    if i % 2 == 1:\n        y *= d[i]\n\nprint(x, y)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    divs = [int(x) for x in input().split()]\n    res = []\n    for i in range(n):\n        if divs[i] not in res:\n            res.append(divs[i])\n    print(res[0], res[1])\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    divisors = list(map(int, input().split()))\n\n    x = 1\n    y = 1\n\n    for i in range(n):\n        if i > 0 and divisors[i] == divisors[i-1]:\n            x *= divisors[i]\n        elif i > 0 and divisors[i] != divisors[i-1]:\n            y *= divisors[i]\n        else:\n            x *= divisors[i]\n\n    print(\"{} {}\".format(x, y))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nfrom collections import Counter\n\ndef main():\n    n = int(input())\n    divisors = Counter(map(int, input().split()))\n    x = 1\n    y = 1\n    for d in sorted(divisors):\n        if divisors[d] == 1:\n            x *= d\n        else:\n            x *= d\n            y *= d\n    print(x, y)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport math\n\nn = int(input())\nd = list(map(int, input().split()))\n\nx = 1\ny = 1\nfor i in range(n):\n    if d[i] in d[i+1:]:\n        x = x * d[i]\n    else:\n        y = y * d[i]\n\nprint(x,y)"
    }
  ],
  "created": 1650401334,
  "id": "cmpl-4yp4IzmSZ5tNtMriG74JcQlaH97uk",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 20:49:28.485655 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\ndivisors = [int(x) for x in input().split()]\n\n# Find the number of occurrences of each divisor\noccurrences = {}\nfor d in divisors:\n    if d in occurrences:\n        occurrences[d] += 1\n    else:\n        occurrences[d] = 1\n\n# The number of occurrences of a number in the list of divisors is the number of\n# times that number appears in the prime factorization of the original number.\n# The prime factorization of the original number is the union of the prime\n# factorizations of the two numbers.\n#\n# If a number appears an odd number of times in the list of divisors, then it\n# must appear an odd number of times in the prime factorization of the original\n# number. Since the prime factorization of a number is unique, this means that\n# the number must appear an odd number of times in the prime factorization of\n# both of the original numbers.\n\ndivisors = {d: occurrences[d] for d in occurrences if occurrences[d] % 2 == 1}\n\n# Each number in the prime factorization of the original number must appear an\n# even number of times in the list of divisors. Since each number in the prime\n# factorization of the original number must appear an even number of times in\n# the prime factorization of both of the original numbers, this means that each\n# number in the prime factorization of both of the original numbers must appear\n# an even number of times in the list of divisors.\n\ndivisors2 = {d: occurrences[d] for d in occurrences if occurrences[d] % 2 == 0}\n\n# The prime factorization of the original number is the union of the prime\n# factorizations of the two numbers.\n#\n# If a number appears an odd number of times in the list of divisors, then it\n# must appear an odd number of times in the prime factorization of the original\n# number.\n#\n# If a number appears an even number of times in the list of divisors, then it\n# must appear an even number of times in the prime factorization of the original\n# number.\n#\n# This means that the prime factorization of the original number is the union of\n# the prime factorizations of the two numbers.\n#\n# The prime factorization of a number is unique, so the prime factorization of\n# the original number is unique. This means that the prime factorization of the\n# two numbers is also unique.\n#\n# This means that the two numbers can be uniquely determined from the list of\n# divisors.\n\nx = 1\ny = 1\nfor d in divisors:\n    x *= d\n    y *= d\nfor d in divisors2:\n    x *= d\n\nprint(x, y)"
}
2022-04-19 20:49:28.485775 REASON stop
2022-04-19 20:49:28.486210 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n\ndef get_divisors(x):\n    divisors = []\n    for i in range(1, x + 1):\n        if x % i == 0:\n            divisors.append(i)\n    return divisors\n\n\ndef get_x_y(divisors):\n    divisors_set = set(divisors)\n    divisors_set.remove(1)\n    for i in divisors_set:\n        if divisors.count(i) == 1:\n            return i, i\n    return 1, 1\n\n\ndef main():\n    n = int(input())\n    divisors = list(map(int, input().split()))\n    x, y = get_x_y(divisors)\n    print(x, y)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:49:28.486269 REASON stop
2022-04-19 20:49:28.486770 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n = int(input())\n    divisors = list(map(int, input().split()))\n\n    x_divisors = []\n    y_divisors = []\n\n    for divisor in divisors:\n        if divisor in x_divisors:\n            y_divisors.append(divisor)\n        else:\n            x_divisors.append(divisor)\n\n    x = 1\n    for divisor in x_divisors:\n        x *= divisor\n\n    y = 1\n    for divisor in y_divisors:\n        y *= divisor\n\n    print(x, y)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:49:28.486834 REASON stop
2022-04-19 20:49:28.515526 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\nd = [int(x) for x in input().split()]\n\nx = 1\ny = 1\n\nfor i in range(n):\n    x *= d[i]\n    if i % 2 == 1:\n        y *= d[i]\n\nprint(x, y)"
}
2022-04-19 20:49:28.515646 REASON stop
2022-04-19 20:49:28.532020 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    divs = [int(x) for x in input().split()]\n    res = []\n    for i in range(n):\n        if divs[i] not in res:\n            res.append(divs[i])\n    print(res[0], res[1])\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:49:28.532164 REASON stop
2022-04-19 20:49:28.533247 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    divisors = list(map(int, input().split()))\n\n    x = 1\n    y = 1\n\n    for i in range(n):\n        if i > 0 and divisors[i] == divisors[i-1]:\n            x *= divisors[i]\n        elif i > 0 and divisors[i] != divisors[i-1]:\n            y *= divisors[i]\n        else:\n            x *= divisors[i]\n\n    print(\"{} {}\".format(x, y))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 20:49:28.533352 REASON stop
2022-04-19 20:49:28.534316 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nfrom collections import Counter\n\ndef main():\n    n = int(input())\n    divisors = Counter(map(int, input().split()))\n    x = 1\n    y = 1\n    for d in sorted(divisors):\n        if divisors[d] == 1:\n            x *= d\n        else:\n            x *= d\n            y *= d\n    print(x, y)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 20:49:28.534420 REASON stop
2022-04-19 20:49:28.535382 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport math\n\nn = int(input())\nd = list(map(int, input().split()))\n\nx = 1\ny = 1\nfor i in range(n):\n    if d[i] in d[i+1:]:\n        x = x * d[i]\n    else:\n        y = y * d[i]\n\nprint(x,y)"
}
2022-04-19 20:49:28.535551 REASON stop
