["\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = 0\n        d[a[i]] += 1\n    ans = 1\n    for i in d:\n        ans *= d[i] + 1\n        ans %= 998244353\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\na = list(map(int, input().split()))\n\n#a = [1, 2, 1, 2, 3]\n#a = [100, 1]\n#a = [1, 3, 3, 7]\n\n#n = len(a)\n\nm = max(a)\nc = [0] * (m + 1)\n\nfor i in a:\n    c[i] += 1\n\nf = [0] * (m + 1)\n\nf[0] = 1\nf[1] = 1\n\nfor i in range(2, m + 1):\n    f[i] = f[i - 1] + f[i - 2]\n    f[i] %= 998244353\n\nans = 1\n\nfor i in c:\n    ans *= f[i]\n    ans %= 998244353\n\nprint(ans)", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n    d = {}\n    for i in a:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    l = len(d)\n    if l == 1:\n        print(1)\n        return\n    m = max(d.values())\n    if m == n:\n        print(l)\n        return\n    if m == n - 1:\n        print(l - 1)\n        return\n    if m == n - 2:\n        if l == 2:\n            print(1)\n            return\n        else:\n            print(l - 2)\n            return\n    print(0)\n\nif __name__ == '__main__':\n    main()", "\n\n# SOLUTION\n\nn = int(input())\narr = list(map(int, input().split()))\n\nd = {}\nfor i in arr:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n\ncount = 1\nfor i in d:\n    count *= (d[i]+1)\n    count %= 998244353\n\nprint(count)", "\n\nfrom collections import Counter\n\ndef solve(a):\n    c = Counter(a)\n    vals = sorted(c.values())\n    dp = [1]*len(vals)\n    dp[0] = vals[0] + 1\n    for i in range(1, len(vals)):\n        dp[i] = (dp[i-1] * (vals[i] + 1)) % 998244353\n    return dp[-1]\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(a))", "\n\ndef solve(a):\n    n = len(a)\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = [i]\n        else:\n            d[a[i]].append(i)\n    # print(d)\n\n    res = 1\n    for i in d:\n        res *= (2**(len(d[i])-1))\n        res %= 998244353\n    return res\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(a))", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    # see editorial for explanation\n    # we can't get the answer directly, but we can get the answer on the reverse of the array\n    # if we have the answer on the reverse of the array, we can get the answer on the original array\n    # let's solve it on the reverse of the array\n\n    # first, we need a function to calculate the number of different monotonic renumerations of an array\n    # we can use a dynamic programming approach\n    # let's say we have an array a[1..n]\n    # let's say we have an array dp[1..n][0..n]\n    # dp[i][j] is the number of different monotonic renumerations of a[1..i] such that the last number of the array is j\n    # we can calculate dp[i][j] as follows:\n    # if j > 0, then dp[i][j] = dp[i - 1][j - 1]\n    # if j == 0 and a[i] == a[i - 1], then dp[i][j] = dp[i - 1][j]\n    # if j == 0 and a[i] != a[i - 1], then dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1]\n    # the answer is dp[n][0]\n    # the complexity is O(n^2)\n\n    # now we have the function to calculate the number of different monotonic renumerations of an array\n    # let's use it to calculate the answer on the reverse of the array\n    # we can use a dynamic programming approach\n    # let's say we have an array a[1..n]\n    # let's say we have an array dp[1..n][0..n]\n    # dp[i][j] is the number of different monotonic renumerations of a[i..n] such that the first number of the array is j\n    # we can calculate dp[i][j] as follows:\n    # if j > 0, then dp[i][j] = dp[i + 1][j - 1]\n    # if j == 0 and a[i] == a[i + 1], then dp[i][j] = dp[i + 1][j]\n    # if j == 0 and a[i] != a[i + 1], then dp[i][j] = dp[i + 1][j] + dp[i + 1][j + 1]\n    # the answer is dp[1][0]\n    # the complexity is O(n^2)\n\n    # now we have the answer on the reverse of the array\n    # let's use it to calculate the answer on the original array\n    # let's say we have an array a[1..n]\n    # let's say we have an array dp[1..n][0..n]\n    # dp[i][j] is the number of different monotonic renumerations of a[1..i] such that the last number of the array is j\n    # we can calculate dp[i][j] as follows:\n    # if j > 0, then dp[i][j] = dp[i - 1][j - 1]\n    # if j == 0 and a[i] == a[i - 1], then dp[i][j] = dp[i - 1][j]\n    # if j == 0 and a[i] != a[i - 1], then dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1]\n    # the answer is dp[n][0]\n    # the complexity is O(n^2)\n\n    # now we have the answer on the original array\n    # the complexity is O(n^2)\n\n    # let's calculate the answer on the reverse of the array\n    a = a[::-1]\n\n    dp = [[0 for j in range(n + 1)] for i in range(n + 1)]\n    dp[n][0] = 1\n\n    for i in range(n - 1, 0, -1):\n        for j in range(n):\n            if j > 0:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                if a[i] == a[i + 1]:\n                    dp[i][j] = dp[i + 1][j]\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i + 1][j + 1]\n\n    answer = dp[1][0]\n\n    # now we have the answer on the reverse of the array\n    # let's use it to calculate the answer on the original array\n    a = a[::-1]\n\n    dp = [[0 for j in range(n + 1)] for i in range(n + 1)]\n    dp[n][0] = answer\n\n    for i in range(n - 1, 0, -1):\n        for j in range(n):\n            if j > 0:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                if a[i] == a[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1]\n\n    answer = dp[1][0]\n\n    # now we have the answer on the original array\n    # the complexity is O(n^2)\n\n    print(answer % 998244353)\n\nif __name__ == '__main__':\n    main()", "\n\nn = int(input())\na = list(map(int, input().split()))\n\n# find the number of distinct elements\ndistinct = []\nfor i in a:\n    if i not in distinct:\n        distinct.append(i)\n\n# find the number of occurences of each distinct element\noccurences = []\nfor i in distinct:\n    occurences.append(a.count(i))\n\n# find the number of ways to arrange the occurences\nways = 1\nfor i in occurences:\n    ways = (ways*(i+1)) % 998244353\n\n# print the answer\nprint(ways)"]