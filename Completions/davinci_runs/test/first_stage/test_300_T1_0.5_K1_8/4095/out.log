2022-04-19 21:56:29.610523 """
You are given a permutation $p_1, p_2, \dots, p_n$. A permutation of length $n$ is a sequence such that each integer between $1$ and $n$ occurs exactly once in the sequence.

Find the number of pairs of indices $(l, r)$ ($1 \le l \le r \le n$) such that the value of the median of $p_l, p_{l+1}, \dots, p_r$ is exactly the given number $m$.

The median of a sequence is the value of the element which is in the middle of the sequence after sorting it in non-decreasing order. If the length of the sequence is even, the left of two middle elements is used.

For example, if $a=[4, 2, 7, 5]$ then its median is $4$ since after sorting the sequence, it will look like $[2, 4, 5, 7]$ and the left of two middle elements is equal to $4$. The median of $[7, 1, 2, 9, 6]$ equals $6$ since after sorting, the value $6$ will be in the middle of the sequence.

Write a program to find the number of pairs of indices $(l, r)$ ($1 \le l \le r \le n$) such that the value of the median of $p_l, p_{l+1}, \dots, p_r$ is exactly the given number $m$.


-----Input-----

The first line contains integers $n$ and $m$ ($1 \le n \le 2\cdot10^5$, $1 \le m \le n$) â€” the length of the given sequence and the required value of the median.

The second line contains a permutation $p_1, p_2, \dots, p_n$ ($1 \le p_i \le n$). Each integer between $1$ and $n$ occurs in $p$ exactly once.


-----Output-----

Print the required number.


-----Examples-----
Input
5 4
2 4 5 3 1

Output
4

Input
5 5
1 2 3 4 5

Output
1

Input
15 8
1 15 2 14 3 13 4 8 12 5 11 6 10 7 9

Output
48



-----Note-----

In the first example, the suitable pairs of indices are: $(1, 3)$, $(2, 2)$, $(2, 3)$ and $(2, 4)$.
"""
2022-04-19 21:56:29.610538 --------------------------
2022-04-19 21:56:29.610641 using api key sourya
2022-04-19 21:56:54.756783 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n#\n#\n# def median(nums):\n#     \"\"\"\n#     >>> median([1,2,3,4,5])\n#     3\n#     >>> median([1,2,3,4])\n#     2\n#     >>> median([1,2,3])\n#     2\n#     >>> median([1,2])\n#     1\n#     >>> median([1])\n#     1\n#     \"\"\"\n#     sorted_nums = sorted(nums)\n#     length = len(sorted_nums)\n#     if length % 2:\n#         return sorted_nums[length // 2]\n#     else:\n#         return sorted_nums[length // 2 - 1]\n#\n#\n# def count_median_pairs(nums, median):\n#     \"\"\"\n#     >>> count_median_pairs([2, 4, 5, 3, 1], 4)\n#     4\n#     >>> count_median_pairs([1, 2, 3, 4, 5], 5)\n#     1\n#     >>> count_median_pairs([1, 15, 2, 14, 3, 13, 4, 8, 12, 5, 11, 6, 10, 7, 9], 8)\n#     48\n#     \"\"\"\n#     count = 0\n#     nums_length = len(nums)\n#     for i in range(nums_length):\n#         for j in range(i, nums_length):\n#             if median(nums[i:j + 1]) == median:\n#                 count += 1\n#     return count\n#\n#\n# def main():\n#     n, m = map(int, input().split())\n#     nums = list(map(int, input().split()))\n#     print(count_median_pairs(nums, m))\n#\n#\n# if __name__ == '__main__':\n#     main()\n\n\ndef main():\n    n, m = map(int, input().split())\n    nums = list(map(int, input().split()))\n    count = 0\n    nums_length = len(nums)\n    for i in range(nums_length):\n        for j in range(i, nums_length):\n            if sorted(nums[i:j + 1])[(j - i + 1) // 2] == m:\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\n\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ndef median(a):\n    if len(a) % 2 == 1:\n        return a[len(a) // 2]\n    else:\n        return a[len(a) // 2 - 1]\n\ndef preprocess(a):\n    d = defaultdict(list)\n    for i, val in enumerate(a):\n        d[val].append(i)\n    return d\n\nd = preprocess(a)\n\ndef get_indexes(val, d):\n    return d[val]\n\ndef get_median(a, l, r):\n    return median(a[l:r])\n\ndef get_pairs(a, m, d):\n    n = len(a)\n    pairs = []\n    for i, val in enumerate(a):\n        if val != m:\n            continue\n        for j in get_indexes(m, d):\n            l = min(i, j)\n            r = max(i, j)\n            if get_median(a, l, r) == m:\n                pairs.append((l, r))\n    return pairs\n\n\npairs = get_pairs(a, m, d)\n\nprint(len(pairs))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn,m = map(int,input().split())\np = list(map(int,input().split()))\nl = []\n\nfor i in range(n):\n    if p[i] == m:\n        l.append(i)\n\nif len(l) == 0:\n    print(0)\nelif len(l) == 1:\n    print(1)\nelse:\n    print(l[-1]-l[0]+1)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if p[i:j][len(p[i:j])//2] == m:\n                cnt += 1\n    print(cnt)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn,m = map(int,input().split())\na = list(map(int,input().split()))\n\n# Median is the middle element of a sorted array\n# If array length is even, median is the average of two middle elements\n\n# Find the number of times m appears in the array\n# If m appears in the array, then it is also a median\n# The number of times m appears in the array is the number of times it appears as a median\n\nm_count = a.count(m)\n\n# Find the number of times m appears as a median\n# If m is the median, then the number of elements less than m is equal to the number of elements greater than m\n# The number of elements less than m is equal to the number of elements less than or equal to m minus the number of elements equal to m\n# The number of elements greater than m is equal to the number of elements greater than or equal to m minus the number of elements equal to m\n# The number of elements less than or equal to m is equal to the index of m in the sorted array\n# The number of elements greater than or equal to m is equal to the number of elements in the array minus the index of m in the sorted array\n# The number of times m appears as a median is equal to the number of elements less than m times the number of elements greater than m\n\n# Sort the array\na.sort()\n\n# Find the number of times m appears as a median\nmedian_count = 0\nif m in a:\n    median_count = a.index(m)*(n-a.index(m))\n\nprint(m_count+median_count)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef median(array):\n    array.sort()\n    if len(array) % 2 == 0:\n        return (array[len(array) // 2 - 1] + array[len(array) // 2]) / 2\n    else:\n        return array[len(array) // 2]\n\ndef get_median(array, l, r):\n    return median(array[l-1:r])\n\ndef get_median_count(array, m):\n    count = 0\n    for i in range(1, len(array) + 1):\n        for j in range(i, len(array) + 1):\n            if get_median(array, i, j) == m:\n                count += 1\n    return count\n\ndef main():\n    n, m = map(int, input().split())\n    array = list(map(int, input().split()))\n    print(get_median_count(array, m))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport math\nfrom collections import Counter\n\ndef median(numbers):\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        return numbers[int(len(numbers)/2)-1]\n    else:\n        return numbers[int(math.floor(len(numbers)/2))]\n\ndef find_median(perm, m):\n    count = 0\n    for i in range(len(perm)):\n        for j in range(i, len(perm)):\n            if median(perm[i:j+1]) == m:\n                count += 1\n    return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    perm = [int(x) for x in input().split()]\n    print(find_median(perm, m))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].strip().split())\n    p = map(int, lines[1].strip().split())\n\n    #calculate the number of elements in the permutation that are less than m\n    count = 0\n    for i in range(n):\n        if p[i] < m:\n            count += 1\n\n    #if m is in the permutation, then the number of elements that are equal to m is also added to count\n    if m in p:\n        count += 1\n\n    #if count is in the middle of the permutation, then all the possible pairs of indices that have m as the median are given by:\n    #(1, count), (2, count), ..., (count-1, count), (count, count), (count, count+1), ..., (count, n)\n    if count == m:\n        print count * (n-count+1)\n    #if count is less than m, then all the possible pairs of indices that have m as the median are given by:\n    #(count+1, count+1), (count+1, count+2), ..., (count+1, n)\n    elif count < m:\n        print (n-count)\n    #if count is greater than m, then all the possible pairs of indices that have m as the median are given by:\n    #(1, count-1), (2, count-1), ..., (count-1, count-1)\n    else:\n        print count-1\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650405389,
  "id": "cmpl-4yq7hRW6YyL6LjaPAdjgKeo3IeMUU",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:56:54.757310 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n#\n#\n# def median(nums):\n#     \"\"\"\n#     >>> median([1,2,3,4,5])\n#     3\n#     >>> median([1,2,3,4])\n#     2\n#     >>> median([1,2,3])\n#     2\n#     >>> median([1,2])\n#     1\n#     >>> median([1])\n#     1\n#     \"\"\"\n#     sorted_nums = sorted(nums)\n#     length = len(sorted_nums)\n#     if length % 2:\n#         return sorted_nums[length // 2]\n#     else:\n#         return sorted_nums[length // 2 - 1]\n#\n#\n# def count_median_pairs(nums, median):\n#     \"\"\"\n#     >>> count_median_pairs([2, 4, 5, 3, 1], 4)\n#     4\n#     >>> count_median_pairs([1, 2, 3, 4, 5], 5)\n#     1\n#     >>> count_median_pairs([1, 15, 2, 14, 3, 13, 4, 8, 12, 5, 11, 6, 10, 7, 9], 8)\n#     48\n#     \"\"\"\n#     count = 0\n#     nums_length = len(nums)\n#     for i in range(nums_length):\n#         for j in range(i, nums_length):\n#             if median(nums[i:j + 1]) == median:\n#                 count += 1\n#     return count\n#\n#\n# def main():\n#     n, m = map(int, input().split())\n#     nums = list(map(int, input().split()))\n#     print(count_median_pairs(nums, m))\n#\n#\n# if __name__ == '__main__':\n#     main()\n\n\ndef main():\n    n, m = map(int, input().split())\n    nums = list(map(int, input().split()))\n    count = 0\n    nums_length = len(nums)\n    for i in range(nums_length):\n        for j in range(i, nums_length):\n            if sorted(nums[i:j + 1])[(j - i + 1) // 2] == m:\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:56:54.757400 REASON stop
2022-04-19 21:56:54.758240 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\n\na = list(map(int, input().split()))\n\nfrom collections import defaultdict\n\ndef median(a):\n    if len(a) % 2 == 1:\n        return a[len(a) // 2]\n    else:\n        return a[len(a) // 2 - 1]\n\ndef preprocess(a):\n    d = defaultdict(list)\n    for i, val in enumerate(a):\n        d[val].append(i)\n    return d\n\nd = preprocess(a)\n\ndef get_indexes(val, d):\n    return d[val]\n\ndef get_median(a, l, r):\n    return median(a[l:r])\n\ndef get_pairs(a, m, d):\n    n = len(a)\n    pairs = []\n    for i, val in enumerate(a):\n        if val != m:\n            continue\n        for j in get_indexes(m, d):\n            l = min(i, j)\n            r = max(i, j)\n            if get_median(a, l, r) == m:\n                pairs.append((l, r))\n    return pairs\n\n\npairs = get_pairs(a, m, d)\n\nprint(len(pairs))"
}
2022-04-19 21:56:54.758334 REASON stop
2022-04-19 21:56:54.759012 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn,m = map(int,input().split())\np = list(map(int,input().split()))\nl = []\n\nfor i in range(n):\n    if p[i] == m:\n        l.append(i)\n\nif len(l) == 0:\n    print(0)\nelif len(l) == 1:\n    print(1)\nelse:\n    print(l[-1]-l[0]+1)"
}
2022-04-19 21:56:54.759098 REASON stop
2022-04-19 21:56:54.790668 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n\n    cnt = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if p[i:j][len(p[i:j])//2] == m:\n                cnt += 1\n    print(cnt)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:56:54.790771 REASON stop
2022-04-19 21:56:54.795448 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn,m = map(int,input().split())\na = list(map(int,input().split()))\n\n# Median is the middle element of a sorted array\n# If array length is even, median is the average of two middle elements\n\n# Find the number of times m appears in the array\n# If m appears in the array, then it is also a median\n# The number of times m appears in the array is the number of times it appears as a median\n\nm_count = a.count(m)\n\n# Find the number of times m appears as a median\n# If m is the median, then the number of elements less than m is equal to the number of elements greater than m\n# The number of elements less than m is equal to the number of elements less than or equal to m minus the number of elements equal to m\n# The number of elements greater than m is equal to the number of elements greater than or equal to m minus the number of elements equal to m\n# The number of elements less than or equal to m is equal to the index of m in the sorted array\n# The number of elements greater than or equal to m is equal to the number of elements in the array minus the index of m in the sorted array\n# The number of times m appears as a median is equal to the number of elements less than m times the number of elements greater than m\n\n# Sort the array\na.sort()\n\n# Find the number of times m appears as a median\nmedian_count = 0\nif m in a:\n    median_count = a.index(m)*(n-a.index(m))\n\nprint(m_count+median_count)"
}
2022-04-19 21:56:54.795560 REASON stop
2022-04-19 21:56:54.798424 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef median(array):\n    array.sort()\n    if len(array) % 2 == 0:\n        return (array[len(array) // 2 - 1] + array[len(array) // 2]) / 2\n    else:\n        return array[len(array) // 2]\n\ndef get_median(array, l, r):\n    return median(array[l-1:r])\n\ndef get_median_count(array, m):\n    count = 0\n    for i in range(1, len(array) + 1):\n        for j in range(i, len(array) + 1):\n            if get_median(array, i, j) == m:\n                count += 1\n    return count\n\ndef main():\n    n, m = map(int, input().split())\n    array = list(map(int, input().split()))\n    print(get_median_count(array, m))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:56:54.798531 REASON stop
2022-04-19 21:56:54.799201 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport math\nfrom collections import Counter\n\ndef median(numbers):\n    numbers.sort()\n    if len(numbers) % 2 == 0:\n        return numbers[int(len(numbers)/2)-1]\n    else:\n        return numbers[int(math.floor(len(numbers)/2))]\n\ndef find_median(perm, m):\n    count = 0\n    for i in range(len(perm)):\n        for j in range(i, len(perm)):\n            if median(perm[i:j+1]) == m:\n                count += 1\n    return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    perm = [int(x) for x in input().split()]\n    print(find_median(perm, m))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:56:54.799276 REASON stop
2022-04-19 21:56:54.803070 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].strip().split())\n    p = map(int, lines[1].strip().split())\n\n    #calculate the number of elements in the permutation that are less than m\n    count = 0\n    for i in range(n):\n        if p[i] < m:\n            count += 1\n\n    #if m is in the permutation, then the number of elements that are equal to m is also added to count\n    if m in p:\n        count += 1\n\n    #if count is in the middle of the permutation, then all the possible pairs of indices that have m as the median are given by:\n    #(1, count), (2, count), ..., (count-1, count), (count, count), (count, count+1), ..., (count, n)\n    if count == m:\n        print count * (n-count+1)\n    #if count is less than m, then all the possible pairs of indices that have m as the median are given by:\n    #(count+1, count+1), (count+1, count+2), ..., (count+1, n)\n    elif count < m:\n        print (n-count)\n    #if count is greater than m, then all the possible pairs of indices that have m as the median are given by:\n    #(1, count-1), (2, count-1), ..., (count-1, count-1)\n    else:\n        print count-1\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:56:54.803261 REASON stop
