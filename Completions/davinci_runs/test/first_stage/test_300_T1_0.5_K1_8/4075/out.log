2022-04-19 21:39:11.866458 """
We have N switches with "on" and "off" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.
Bulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are "on" among these switches is congruent to p_i modulo 2.
How many combinations of "on" and "off" states of the switches light all the bulbs?

-----Constraints-----
 - 1 \leq N, M \leq 10
 - 1 \leq k_i \leq N
 - 1 \leq s_{ij} \leq N
 - s_{ia} \neq s_{ib} (a \neq b)
 - p_i is 0 or 1.
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N M
k_1 s_{11} s_{12} ... s_{1k_1}
:
k_M s_{M1} s_{M2} ... s_{Mk_M}
p_1 p_2 ... p_M

-----Output-----
Print the number of combinations of "on" and "off" states of the switches that light all the bulbs.

-----Sample Input-----
2 2
2 1 2
1 2
0 1

-----Sample Output-----
1

 - Bulb 1 is lighted when there is an even number of switches that are "on" among the following: Switch 1 and 2.
 - Bulb 2 is lighted when there is an odd number of switches that are "on" among the following: Switch 2.
There are four possible combinations of states of (Switch 1, Switch 2): (on, on), (on, off), (off, on) and (off, off). Among them, only (on, on) lights all the bulbs, so we should print 1.
"""
2022-04-19 21:39:11.866467 --------------------------
2022-04-19 21:39:11.866573 using api key sourya
2022-04-19 21:39:11.986913 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 21:39:16.992290 """
We have N switches with "on" and "off" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.
Bulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are "on" among these switches is congruent to p_i modulo 2.
How many combinations of "on" and "off" states of the switches light all the bulbs?

-----Constraints-----
 - 1 \leq N, M \leq 10
 - 1 \leq k_i \leq N
 - 1 \leq s_{ij} \leq N
 - s_{ia} \neq s_{ib} (a \neq b)
 - p_i is 0 or 1.
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N M
k_1 s_{11} s_{12} ... s_{1k_1}
:
k_M s_{M1} s_{M2} ... s_{Mk_M}
p_1 p_2 ... p_M

-----Output-----
Print the number of combinations of "on" and "off" states of the switches that light all the bulbs.

-----Sample Input-----
2 2
2 1 2
1 2
0 1

-----Sample Output-----
1

 - Bulb 1 is lighted when there is an even number of switches that are "on" among the following: Switch 1 and 2.
 - Bulb 2 is lighted when there is an odd number of switches that are "on" among the following: Switch 2.
There are four possible combinations of states of (Switch 1, Switch 2): (on, on), (on, off), (off, on) and (off, off). Among them, only (on, on) lights all the bulbs, so we should print 1.
"""
2022-04-19 21:39:16.992325 --------------------------
2022-04-19 21:39:16.992451 using api key sourya
2022-04-19 21:39:17.028830 in retry 5 10 <class 'Exception'>, Retrying in 10 seconds...
2022-04-19 21:39:27.039211 """
We have N switches with "on" and "off" state, and M bulbs. The switches are numbered 1 to N, and the bulbs are numbered 1 to M.
Bulb i is connected to k_i switches: Switch s_{i1}, s_{i2}, ..., and s_{ik_i}. It is lighted when the number of switches that are "on" among these switches is congruent to p_i modulo 2.
How many combinations of "on" and "off" states of the switches light all the bulbs?

-----Constraints-----
 - 1 \leq N, M \leq 10
 - 1 \leq k_i \leq N
 - 1 \leq s_{ij} \leq N
 - s_{ia} \neq s_{ib} (a \neq b)
 - p_i is 0 or 1.
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N M
k_1 s_{11} s_{12} ... s_{1k_1}
:
k_M s_{M1} s_{M2} ... s_{Mk_M}
p_1 p_2 ... p_M

-----Output-----
Print the number of combinations of "on" and "off" states of the switches that light all the bulbs.

-----Sample Input-----
2 2
2 1 2
1 2
0 1

-----Sample Output-----
1

 - Bulb 1 is lighted when there is an even number of switches that are "on" among the following: Switch 1 and 2.
 - Bulb 2 is lighted when there is an odd number of switches that are "on" among the following: Switch 2.
There are four possible combinations of states of (Switch 1, Switch 2): (on, on), (on, off), (off, on) and (off, off). Among them, only (on, on) lights all the bulbs, so we should print 1.
"""
2022-04-19 21:39:27.039247 --------------------------
2022-04-19 21:39:27.039371 using api key derek
2022-04-19 21:39:55.990110 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    N, M = [int(x) for x in lines[0].strip().split()]\n    k = [int(x) for x in lines[1:M+1]]\n    s = [[int(x) for x in line.strip().split()] for line in lines[M+1:2*M+1]]\n    p = [int(x) for x in lines[2*M+1].strip().split()]\n\n    count = 0\n    for i in range(2**N):\n        flag = True\n        for j in range(M):\n            if p[j] != sum([(i>>(s[j][k]-1))&1 for k in range(k[j])])%2:\n                flag = False\n                break\n        if flag:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nN, M = map(int, input().split())\n\nswitches = [[] for i in range(N + 1)]\nfor i in range(M):\n    k, *s = map(int, input().split())\n    switches[k].append(s)\n\np = list(map(int, input().split()))\n\n# print(switches)\n# print(p)\n\ndef check(s):\n    for i, c in enumerate(s):\n        # print(i, c)\n        # print(switches[i + 1])\n        # print([(1 if j in c else 0) for j in switches[i + 1]])\n        # print(list(map(lambda x: 1 if x in c else 0, switches[i + 1])))\n        if sum(1 if j in c else 0 for j in switches[i + 1]) % 2 != p[i]:\n            return False\n    return True\n\ncount = 0\nfor i in range(1 << N):\n    c = set()\n    for j in range(N):\n        if i & (1 << j):\n            c.add(j + 1)\n    if check(c):\n        count += 1\n\nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# N: number of switches\n# M: number of bulbs\n# k_i: number of switches connected to bulb i\n# s_ij: switch connected to bulb i\n# p_i: 0/1 whether bulb i is lit by even/odd number of switches connected to it\n\n# Input\nN, M = map(int, input().split())\nk_i = []\ns_ij = []\np_i = []\nfor i in range(M):\n    k_i.append(list(map(int, input().split()))[0])\n    s_ij.append(list(map(int, input().split()))[1:])\n    p_i.append(list(map(int, input().split()))[0])\n\n# Solve\n# The number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs is the number of combinations of \"on\" and \"off\" states of the switches that light each bulb.\n# Since the number of switches that are \"on\" among s_{i1}, s_{i2}, ..., and s_{ik_i} is congruent to p_i modulo 2, the number of combinations of \"on\" and \"off\" states of the switches that light bulb i is 2^{k_i-1}.\n# The total number of combinations is therefore 2^{k_1-1} \\times 2^{k_2-1} \\times ... \\times 2^{k_M-1}.\nans = 1\nfor i in range(M):\n    ans *= 2**(k_i[i]-1)\n\n# Output\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\n\nswitches = [[] for _ in range(n)]\nbulbs = [0] * m\n\nfor i in range(m):\n    temp = list(map(int, input().split()))\n    bulbs[i] = temp[0]\n    for j in range(1, temp[0] + 1):\n        switches[temp[j] - 1].append(i)\n\nbulb_states = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(2 ** n):\n    on_switches = []\n    for j in range(n):\n        if (i >> j) & 1:\n            on_switches.append(j)\n\n    flag = True\n\n    for k in range(m):\n        cnt = 0\n        for j in on_switches:\n            if k in switches[j]:\n                cnt += 1\n\n        if cnt % 2 != bulb_states[k]:\n            flag = False\n            break\n\n    if flag:\n        ans += 1\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n\n    bulbs = []\n    for i in range(M):\n        bulbs.append(list(map(int, sys.stdin.readline().split())))\n\n    p = list(map(int, sys.stdin.readline().split()))\n\n    ans = 0\n\n    # bit\u5168\u63a2\u7d22\n    for i in range(2**N):\n        lit = 0\n        for j in range(M):\n            cnt = 0\n            for k in range(1, len(bulbs[j])):\n                if (i>>(bulbs[j][k]-1))&1:\n                    cnt += 1\n            if cnt % 2 == p[j]:\n                lit += 1\n        if lit == M:\n            ans += 1\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN, M = map(int, sys.stdin.readline().split())\n\n# \u5404\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u30ea\u30b9\u30c8\n# bulbs[i][j] = i\u756a\u76ee\u306e\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308bj\u756a\u76ee\u306e\u30b9\u30a4\u30c3\u30c1\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, sys.stdin.readline().split()))[1:])\n\n# \u5404\u96fb\u7403\u306eON/OFF\n# on_off[i] = i\u756a\u76ee\u306e\u96fb\u7403\u304cON\u304b\u3069\u3046\u304b\non_off = list(map(int, sys.stdin.readline().split()))\n\n# \u5168\u3066\u306e\u96fb\u7403\u3092ON\u306b\u3059\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614b\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\ncount = 0\n\n# \u5168\u3066\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614b\u306e\u7d44\u307f\u5408\u308f\u305b\u3092bit\u5168\u63a2\u7d22\nfor i in range(2**N):\n    # \u5168\u3066\u306e\u96fb\u7403\u304cON\u306b\u306a\u3063\u3066\u3044\u308b\u304b\n    all_on = True\n    for j in range(M):\n        # j\u756a\u76ee\u306e\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u6570\n        k = len(bulbs[j])\n        # j\u756a\u76ee\u306e\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u30b9\u30a4\u30c3\u30c1\u306eON\u306e\u6570\n        on_num = 0\n        for l in range(k):\n            if i & (1 << (bulbs[j][l] - 1)) != 0:\n                on_num += 1\n        # j\u756a\u76ee\u306e\u96fb\u7403\u304cON\u306b\u306a\u3063\u3066\u3044\u308b\u304b\n        bulb_on = (on_num % 2) == on_off[j]\n        if not bulb_on:\n            all_on = False\n            break\n    if all_on:\n        count += 1\nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# Solve using bitwise operation\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    switches = [[] for i in range(m)]\n    for i in range(m):\n        tmp = list(map(int, sys.stdin.readline().split()))\n        switches[i] = tmp[1:]\n    p = list(map(int, sys.stdin.readline().split()))\n    count = 0\n    for i in range(1 << n):\n        flag = True\n        for j in range(m):\n            c = 0\n            for k in switches[j]:\n                if i & (1 << (k - 1)):\n                    c += 1\n            if c % 2 != p[j]:\n                flag = False\n                break\n        if flag:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    bulbs = defaultdict(set)\n    for i in range(1, m + 1):\n        k, *s = map(int, input().split())\n        bulbs[i] = set(s)\n    p = list(map(int, input().split()))\n    c = 0\n    for i in range(2 ** n):\n        valid = True\n        for j in range(1, m + 1):\n            on = sum(1 if i & (1 << (s - 1)) > 0 else 0 for s in bulbs[j])\n            if not on % 2 == p[j - 1]:\n                valid = False\n        if valid:\n            c += 1\n    print(c)\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650404367,
  "id": "cmpl-4yprDRVYroMXT9AGcdW26n4X4axa9",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:39:55.990555 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    lines = sys.stdin.readlines()\n    N, M = [int(x) for x in lines[0].strip().split()]\n    k = [int(x) for x in lines[1:M+1]]\n    s = [[int(x) for x in line.strip().split()] for line in lines[M+1:2*M+1]]\n    p = [int(x) for x in lines[2*M+1].strip().split()]\n\n    count = 0\n    for i in range(2**N):\n        flag = True\n        for j in range(M):\n            if p[j] != sum([(i>>(s[j][k]-1))&1 for k in range(k[j])])%2:\n                flag = False\n                break\n        if flag:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:39:55.990598 REASON stop
2022-04-19 21:39:55.991550 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nN, M = map(int, input().split())\n\nswitches = [[] for i in range(N + 1)]\nfor i in range(M):\n    k, *s = map(int, input().split())\n    switches[k].append(s)\n\np = list(map(int, input().split()))\n\n# print(switches)\n# print(p)\n\ndef check(s):\n    for i, c in enumerate(s):\n        # print(i, c)\n        # print(switches[i + 1])\n        # print([(1 if j in c else 0) for j in switches[i + 1]])\n        # print(list(map(lambda x: 1 if x in c else 0, switches[i + 1])))\n        if sum(1 if j in c else 0 for j in switches[i + 1]) % 2 != p[i]:\n            return False\n    return True\n\ncount = 0\nfor i in range(1 << N):\n    c = set()\n    for j in range(N):\n        if i & (1 << j):\n            c.add(j + 1)\n    if check(c):\n        count += 1\n\nprint(count)"
}
2022-04-19 21:39:55.991630 REASON stop
2022-04-19 21:39:55.992114 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# N: number of switches\n# M: number of bulbs\n# k_i: number of switches connected to bulb i\n# s_ij: switch connected to bulb i\n# p_i: 0/1 whether bulb i is lit by even/odd number of switches connected to it\n\n# Input\nN, M = map(int, input().split())\nk_i = []\ns_ij = []\np_i = []\nfor i in range(M):\n    k_i.append(list(map(int, input().split()))[0])\n    s_ij.append(list(map(int, input().split()))[1:])\n    p_i.append(list(map(int, input().split()))[0])\n\n# Solve\n# The number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs is the number of combinations of \"on\" and \"off\" states of the switches that light each bulb.\n# Since the number of switches that are \"on\" among s_{i1}, s_{i2}, ..., and s_{ik_i} is congruent to p_i modulo 2, the number of combinations of \"on\" and \"off\" states of the switches that light bulb i is 2^{k_i-1}.\n# The total number of combinations is therefore 2^{k_1-1} \\times 2^{k_2-1} \\times ... \\times 2^{k_M-1}.\nans = 1\nfor i in range(M):\n    ans *= 2**(k_i[i]-1)\n\n# Output\nprint(ans)"
}
2022-04-19 21:39:55.992181 REASON stop
2022-04-19 21:39:56.004408 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\n\nswitches = [[] for _ in range(n)]\nbulbs = [0] * m\n\nfor i in range(m):\n    temp = list(map(int, input().split()))\n    bulbs[i] = temp[0]\n    for j in range(1, temp[0] + 1):\n        switches[temp[j] - 1].append(i)\n\nbulb_states = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(2 ** n):\n    on_switches = []\n    for j in range(n):\n        if (i >> j) & 1:\n            on_switches.append(j)\n\n    flag = True\n\n    for k in range(m):\n        cnt = 0\n        for j in on_switches:\n            if k in switches[j]:\n                cnt += 1\n\n        if cnt % 2 != bulb_states[k]:\n            flag = False\n            break\n\n    if flag:\n        ans += 1\n\nprint(ans)"
}
2022-04-19 21:39:56.004537 REASON stop
2022-04-19 21:39:56.017225 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n\n    bulbs = []\n    for i in range(M):\n        bulbs.append(list(map(int, sys.stdin.readline().split())))\n\n    p = list(map(int, sys.stdin.readline().split()))\n\n    ans = 0\n\n    # bit\u5168\u63a2\u7d22\n    for i in range(2**N):\n        lit = 0\n        for j in range(M):\n            cnt = 0\n            for k in range(1, len(bulbs[j])):\n                if (i>>(bulbs[j][k]-1))&1:\n                    cnt += 1\n            if cnt % 2 == p[j]:\n                lit += 1\n        if lit == M:\n            ans += 1\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:39:56.017352 REASON stop
2022-04-19 21:39:56.019396 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN, M = map(int, sys.stdin.readline().split())\n\n# \u5404\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u30ea\u30b9\u30c8\n# bulbs[i][j] = i\u756a\u76ee\u306e\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308bj\u756a\u76ee\u306e\u30b9\u30a4\u30c3\u30c1\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, sys.stdin.readline().split()))[1:])\n\n# \u5404\u96fb\u7403\u306eON/OFF\n# on_off[i] = i\u756a\u76ee\u306e\u96fb\u7403\u304cON\u304b\u3069\u3046\u304b\non_off = list(map(int, sys.stdin.readline().split()))\n\n# \u5168\u3066\u306e\u96fb\u7403\u3092ON\u306b\u3059\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614b\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\ncount = 0\n\n# \u5168\u3066\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614b\u306e\u7d44\u307f\u5408\u308f\u305b\u3092bit\u5168\u63a2\u7d22\nfor i in range(2**N):\n    # \u5168\u3066\u306e\u96fb\u7403\u304cON\u306b\u306a\u3063\u3066\u3044\u308b\u304b\n    all_on = True\n    for j in range(M):\n        # j\u756a\u76ee\u306e\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u6570\n        k = len(bulbs[j])\n        # j\u756a\u76ee\u306e\u96fb\u7403\u306b\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u30b9\u30a4\u30c3\u30c1\u306eON\u306e\u6570\n        on_num = 0\n        for l in range(k):\n            if i & (1 << (bulbs[j][l] - 1)) != 0:\n                on_num += 1\n        # j\u756a\u76ee\u306e\u96fb\u7403\u304cON\u306b\u306a\u3063\u3066\u3044\u308b\u304b\n        bulb_on = (on_num % 2) == on_off[j]\n        if not bulb_on:\n            all_on = False\n            break\n    if all_on:\n        count += 1\nprint(count)"
}
2022-04-19 21:39:56.019521 REASON stop
2022-04-19 21:39:56.036324 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# Solve using bitwise operation\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    switches = [[] for i in range(m)]\n    for i in range(m):\n        tmp = list(map(int, sys.stdin.readline().split()))\n        switches[i] = tmp[1:]\n    p = list(map(int, sys.stdin.readline().split()))\n    count = 0\n    for i in range(1 << n):\n        flag = True\n        for j in range(m):\n            c = 0\n            for k in switches[j]:\n                if i & (1 << (k - 1)):\n                    c += 1\n            if c % 2 != p[j]:\n                flag = False\n                break\n        if flag:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:39:56.036572 REASON stop
2022-04-19 21:39:56.037944 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    bulbs = defaultdict(set)\n    for i in range(1, m + 1):\n        k, *s = map(int, input().split())\n        bulbs[i] = set(s)\n    p = list(map(int, input().split()))\n    c = 0\n    for i in range(2 ** n):\n        valid = True\n        for j in range(1, m + 1):\n            on = sum(1 if i & (1 << (s - 1)) > 0 else 0 for s in bulbs[j])\n            if not on % 2 == p[j - 1]:\n                valid = False\n        if valid:\n            c += 1\n    print(c)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 21:39:56.038030 REASON stop
