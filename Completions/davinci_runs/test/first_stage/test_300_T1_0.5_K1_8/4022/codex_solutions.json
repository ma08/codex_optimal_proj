["\nimport sys\nsys.stdin = open(\"input.txt\", \"r\")\n\nclass SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * size\n        self.lazy = [0] * size\n\n    def build(self, arr):\n        self.build_helper(arr, 0, 0, self.size - 1)\n\n    def build_helper(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build_helper(arr, node * 2 + 1, start, mid)\n            self.build_helper(arr, node * 2 + 2, mid + 1, end)\n            self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2])\n\n    def update(self, start, end, val):\n        self.update_helper(start, end, val, 0, 0, self.size - 1)\n\n    def update_helper(self, start, end, val, node, node_start, node_end):\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node]\n            if node_start != node_end:\n                self.lazy[node * 2 + 1] += self.lazy[node]\n                self.lazy[node * 2 + 2] += self.lazy[node]\n            self.lazy[node] = 0\n\n        if start > node_end or end < node_start:\n            return\n\n        if start <= node_start and end >= node_end:\n            self.tree[node] += val\n            if node_start != node_end:\n                self.lazy[node * 2 + 1] += val\n                self.lazy[node * 2 + 2] += val\n            return\n\n        mid = (node_start + node_end) // 2\n        self.update_helper(start, end, val, node * 2 + 1, node_start, mid)\n        self.update_helper(start, end, val, node * 2 + 2, mid + 1, node_end)\n        self.tree[node] = max(self.tree[node * 2 + 1], self.tree[node * 2 + 2])\n\n    def query(self, start, end):\n        return self.query_helper(start, end, 0, 0, self.size - 1)\n\n    def query_helper(self, start, end, node, node_start, node_end):\n        if self.lazy[node] != 0:\n            self.tree[node] += self.lazy[node]\n            if node_start != node_end:\n                self.lazy[node * 2 + 1] += self.lazy[node]\n                self.lazy[node * 2 + 2] += self.lazy[node]\n            self.lazy[node] = 0\n\n        if start > node_end or end < node_start:\n            return 0\n\n        if start <= node_start and end >= node_end:\n            return self.tree[node]\n\n        mid = (node_start + node_end) // 2\n        return max(self.query_helper(start, end, node * 2 + 1, node_start, mid),\n                   self.query_helper(start, end, node * 2 + 2, mid + 1, node_end))\n\n\ndef main():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n    segments.sort()\n\n    tree = SegmentTree(n)\n    tree.build([0] * n)\n    for i in range(n):\n        l, r = segments[i]\n        tree.update(i, i, r - l)\n        if i > 0 and segments[i][0] <= segments[i - 1][1]:\n            tree.update(i, i, -1)\n        if i < n - 1 and segments[i][1] >= segments[i + 1][0]:\n            tree.update(i, i, -1)\n    print(tree.query(0, n - 1))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n    segments = sorted(segments)\n    # print(segments)\n    max_intersection = 0\n    for i in range(n - 1):\n        l = segments[i][0]\n        r = segments[i][1]\n        l_next = segments[i + 1][0]\n        r_next = segments[i + 1][1]\n        if l_next > r:\n            if max_intersection < 0:\n                max_intersection = 0\n        elif l_next <= r:\n            if r_next <= r:\n                max_intersection = max(max_intersection, r_next - l_next)\n            else:\n                max_intersection = max(max_intersection, r - l_next)\n    print(max_intersection)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        segments.append([int(x) for x in input().split()])\n    segments.sort(key=lambda x: x[0])\n    print(max([segments[i][1] - segments[j][0] for i in range(n) for j in range(i + 1, n)]))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef intersection(segments):\n    segments.sort()\n    start = segments[0][0]\n    finish = segments[0][1]\n    for i in range(1, len(segments)):\n        if segments[i][0] <= finish:\n            finish = max(finish, segments[i][1])\n        else:\n            return finish - start\n    return finish - start\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        segments.append(list(map(int, input().split())))\n    max_intersection = 0\n    for i in range(n):\n        inter = intersection(segments[:i] + segments[i+1:])\n        if inter > max_intersection:\n            max_intersection = inter\n    print(max_intersection)\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n = int(input())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    a.sort()\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i][1] - a[i][0]\n    s = sum(b)\n    m = max(b)\n    print(s - m)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\nsegments.sort()\n\n#print(segments)\n\nlast = segments[0][1]\nsegments.pop(0)\n\nfor segment in segments:\n    if segment[0] <= last:\n        last = min(segment[1], last)\n    else:\n        break\n\nprint(last)", "\nfrom sys import stdin\n\ndef main():\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        l, r = [int(x) for x in stdin.readline().split()]\n        points.append((l, 1))\n        points.append((r, -1))\n    points.sort()\n    cnt = 0\n    ans = 0\n    for i in range(len(points)):\n        cnt += points[i][1]\n        if cnt == n - 1:\n            if i + 1 < len(points):\n                ans = max(ans, points[i + 1][0] - points[i][0])\n            else:\n                ans = max(ans, points[i][0] - points[i - 1][0])\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nfrom sys import stdin\nfrom math import inf\n\nif __name__ == '__main__':\n    n = int(stdin.readline())\n    l = [0] * n\n    r = [0] * n\n    for i in range(n):\n        l[i], r[i] = map(int, stdin.readline().split())\n\n    max_len = 0\n    for i in range(n):\n        max_len = max(max_len, max(r[i] - l[i], max(r[i] - l[i - 1], r[i - 1] - l[i])))\n    print(max_len)"]