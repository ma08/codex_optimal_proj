2022-04-19 23:11:32.310342 """
You are given an undirected unweighted graph with N vertices and M edges that contains neither self-loops nor double edges.

Here, a self-loop is an edge where a_i = b_i (1≤i≤M), and double edges are two edges where (a_i,b_i)=(a_j,b_j) or (a_i,b_i)=(b_j,a_j) (1≤i<j≤M).

How many different paths start from vertex 1 and visit all the vertices exactly once?

Here, the endpoints of a path are considered visited.  
For example, let us assume that the following undirected graph shown in Figure 1 is given.
Figure 1: an example of an undirected graph
The following path shown in Figure 2 satisfies the condition.
Figure 2: an example of a path that satisfies the condition
However, the following path shown in Figure 3 does not satisfy the condition, because it does not visit all the vertices.
Figure 3: an example of a path that does not satisfy the condition
Neither the following path shown in Figure 4, because it does not start from vertex 1.
Figure 4: another example of a path that does not satisfy the condition

-----Constraints-----
 - 2≦N≦8 
 - 0≦M≦N(N-1)/2 
 - 1≦a_i<b_i≦N 
 - The given graph contains neither self-loops nor double edges.

-----Input-----
The input is given from Standard Input in the following format:
N M  
a_1 b_1  
a_2 b_2
:  
a_M b_M  

-----Output-----
Print the number of the different paths that start from vertex 1 and visit all the vertices exactly once.

-----Sample Input-----
3 3
1 2
1 3
2 3

-----Sample Output-----
2

The given graph is shown in the following figure:
The following two paths satisfy the condition:
"""
2022-04-19 23:11:32.310372 --------------------------
2022-04-19 23:11:32.310488 using api key gabby
2022-04-19 23:11:51.820548 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport itertools\n\ndef is_path(path, edges):\n    for i in range(len(path)-1):\n        if (path[i], path[i+1]) not in edges and (path[i+1], path[i]) not in edges:\n            return False\n    return True\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    paths = itertools.permutations(range(2, n+1))\n    cnt = 0\n    for path in paths:\n        if is_path((1,) + path, edges):\n            cnt += 1\n    print(cnt)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(set)\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].add(b)\n        graph[b].add(a)\n    print(dfs(graph, n))\n\n\ndef dfs(graph, n):\n    visited = [False] * n\n    visited[0] = True\n    stack = [1]\n    path = 0\n    while stack:\n        v = stack[-1]\n        if len(stack) == n:\n            path += 1\n            stack.pop()\n            visited[v-1] = False\n            continue\n        for i in graph[v]:\n            if not visited[i-1]:\n                visited[i-1] = True\n                stack.append(i)\n                break\n        else:\n            stack.pop()\n            visited[v-1] = False\n    return path\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\n\nedges = [list(map(int, input().split())) for _ in range(m)]\n\ndef dfs(vertex, visited):\n    global edges\n    global n\n\n    if len(visited) == n:\n        return 1\n\n    cnt = 0\n    for edge in edges:\n        if edge[0] == vertex and edge[1] not in visited:\n            cnt += dfs(edge[1], visited + [vertex])\n        elif edge[1] == vertex and edge[0] not in visited:\n            cnt += dfs(edge[0], visited + [vertex])\n    return cnt\n\nprint(dfs(1, []))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n\n# print(edges)\n\ngraph = [[] for _ in range(N+1)]\n\nfor a, b in edges:\n    graph[a].append(b)\n    graph[b].append(a)\n\n# print(graph)\n\ndef dfs(graph, start, visited, path):\n    path.append(start)\n\n    if len(path) == N:\n        print(path)\n        return 1\n\n    ret = 0\n    for next in graph[start]:\n        if not visited[next]:\n            visited[next] = True\n            ret += dfs(graph, next, visited, path)\n            visited[next] = False\n            path.pop()\n\n    return ret\n\nvisited = [False for _ in range(N+1)]\nvisited[1] = True\nprint(dfs(graph, 1, visited, []))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef perm(n, k, l):\n    if k == 1:\n        yield [l[0]]\n    else:\n        for i in range(k):\n            for ss in perm(n, k-1, l[:i] + l[i+1:]):\n                yield [l[i]] + ss\n\ndef comb(n, k):\n    return perm(n, k, [i for i in range(1, n+1)])\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n\n    tree_edges = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i < j and (i, j) not in edges:\n                tree_edges.append((i, j))\n    tree_edges = list(set(tree_edges))\n\n    pathes = []\n    for c in comb(n-1, n-1):\n        pathes.append(c)\n\n    for p in pathes:\n        for i in range(1, len(p)):\n            if (p[i-1], p[i]) not in tree_edges:\n                pathes.remove(p)\n                break\n\n    print(len(pathes))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport itertools\n\ndef input():\n    return sys.stdin.readline().strip()\n\n# N: the number of vertices\n# M: the number of edges\nN, M = map(int, input().split())\n\n# a_i b_i: the i-th edge\nedges = []\nfor i in range(M):\n    a_i, b_i = map(int, input().split())\n    edges.append((a_i, b_i))\n\n#print(N, M, edges)\n\n# initialize the adjacency matrix\nadj_mat = [[0 for i in range(N)] for j in range(N)]\n\n# update the adjacency matrix\nfor edge in edges:\n    a_i, b_i = edge\n    adj_mat[a_i-1][b_i-1] = 1\n    adj_mat[b_i-1][a_i-1] = 1\n\n#print(adj_mat)\n\n# the number of paths\ncount = 0\n\n# count the number of paths\nfor path in itertools.permutations(range(1, N)):\n    #print(path)\n    path = [0] + list(path)\n    i = 0\n    j = 1\n    while True:\n        if adj_mat[path[i]][path[j]]:\n            i = j\n            j += 1\n            if j == N:\n                count += 1\n                break\n        else:\n            break\n\n#print(count)\nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\npath = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    path[a-1].append(b-1)\n    path[b-1].append(a-1)\n\n\ndef dfs(v, visited, path, count):\n    visited[v] = True\n    count += 1\n    if count == n:\n        return 1\n    ret = 0\n    for i in path[v]:\n        if not visited[i]:\n            ret += dfs(i, visited, path, count)\n    visited[v] = False\n    return ret\n\n\nvisited = [False for i in range(n)]\nprint(dfs(0, visited, path, 0))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    n,m = map(int,input().split())\n    edges = []\n    for _ in range(m):\n        a,b = map(int,input().split())\n        edges.append((a,b))\n    print(n,m)\n    print(edges)\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650409892,
  "id": "cmpl-4yrIKVaMQyvC9P6D11tMfyjdoFEfI",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 23:11:51.820940 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport itertools\n\ndef is_path(path, edges):\n    for i in range(len(path)-1):\n        if (path[i], path[i+1]) not in edges and (path[i+1], path[i]) not in edges:\n            return False\n    return True\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    paths = itertools.permutations(range(2, n+1))\n    cnt = 0\n    for path in paths:\n        if is_path((1,) + path, edges):\n            cnt += 1\n    print(cnt)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:11:51.821067 REASON stop
2022-04-19 23:11:51.822194 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(set)\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].add(b)\n        graph[b].add(a)\n    print(dfs(graph, n))\n\n\ndef dfs(graph, n):\n    visited = [False] * n\n    visited[0] = True\n    stack = [1]\n    path = 0\n    while stack:\n        v = stack[-1]\n        if len(stack) == n:\n            path += 1\n            stack.pop()\n            visited[v-1] = False\n            continue\n        for i in graph[v]:\n            if not visited[i-1]:\n                visited[i-1] = True\n                stack.append(i)\n                break\n        else:\n            stack.pop()\n            visited[v-1] = False\n    return path\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 23:11:51.822286 REASON stop
2022-04-19 23:11:51.822760 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\n\nedges = [list(map(int, input().split())) for _ in range(m)]\n\ndef dfs(vertex, visited):\n    global edges\n    global n\n\n    if len(visited) == n:\n        return 1\n\n    cnt = 0\n    for edge in edges:\n        if edge[0] == vertex and edge[1] not in visited:\n            cnt += dfs(edge[1], visited + [vertex])\n        elif edge[1] == vertex and edge[0] not in visited:\n            cnt += dfs(edge[0], visited + [vertex])\n    return cnt\n\nprint(dfs(1, []))"
}
2022-04-19 23:11:51.822822 REASON stop
2022-04-19 23:11:51.824599 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n\n# print(edges)\n\ngraph = [[] for _ in range(N+1)]\n\nfor a, b in edges:\n    graph[a].append(b)\n    graph[b].append(a)\n\n# print(graph)\n\ndef dfs(graph, start, visited, path):\n    path.append(start)\n\n    if len(path) == N:\n        print(path)\n        return 1\n\n    ret = 0\n    for next in graph[start]:\n        if not visited[next]:\n            visited[next] = True\n            ret += dfs(graph, next, visited, path)\n            visited[next] = False\n            path.pop()\n\n    return ret\n\nvisited = [False for _ in range(N+1)]\nvisited[1] = True\nprint(dfs(graph, 1, visited, []))"
}
2022-04-19 23:11:51.824665 REASON stop
2022-04-19 23:11:51.838426 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef perm(n, k, l):\n    if k == 1:\n        yield [l[0]]\n    else:\n        for i in range(k):\n            for ss in perm(n, k-1, l[:i] + l[i+1:]):\n                yield [l[i]] + ss\n\ndef comb(n, k):\n    return perm(n, k, [i for i in range(1, n+1)])\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n\n    tree_edges = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i < j and (i, j) not in edges:\n                tree_edges.append((i, j))\n    tree_edges = list(set(tree_edges))\n\n    pathes = []\n    for c in comb(n-1, n-1):\n        pathes.append(c)\n\n    for p in pathes:\n        for i in range(1, len(p)):\n            if (p[i-1], p[i]) not in tree_edges:\n                pathes.remove(p)\n                break\n\n    print(len(pathes))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:11:51.838540 REASON stop
2022-04-19 23:11:51.840249 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport itertools\n\ndef input():\n    return sys.stdin.readline().strip()\n\n# N: the number of vertices\n# M: the number of edges\nN, M = map(int, input().split())\n\n# a_i b_i: the i-th edge\nedges = []\nfor i in range(M):\n    a_i, b_i = map(int, input().split())\n    edges.append((a_i, b_i))\n\n#print(N, M, edges)\n\n# initialize the adjacency matrix\nadj_mat = [[0 for i in range(N)] for j in range(N)]\n\n# update the adjacency matrix\nfor edge in edges:\n    a_i, b_i = edge\n    adj_mat[a_i-1][b_i-1] = 1\n    adj_mat[b_i-1][a_i-1] = 1\n\n#print(adj_mat)\n\n# the number of paths\ncount = 0\n\n# count the number of paths\nfor path in itertools.permutations(range(1, N)):\n    #print(path)\n    path = [0] + list(path)\n    i = 0\n    j = 1\n    while True:\n        if adj_mat[path[i]][path[j]]:\n            i = j\n            j += 1\n            if j == N:\n                count += 1\n                break\n        else:\n            break\n\n#print(count)\nprint(count)"
}
2022-04-19 23:11:51.840341 REASON stop
2022-04-19 23:11:51.857372 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\npath = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    path[a-1].append(b-1)\n    path[b-1].append(a-1)\n\n\ndef dfs(v, visited, path, count):\n    visited[v] = True\n    count += 1\n    if count == n:\n        return 1\n    ret = 0\n    for i in path[v]:\n        if not visited[i]:\n            ret += dfs(i, visited, path, count)\n    visited[v] = False\n    return ret\n\n\nvisited = [False for i in range(n)]\nprint(dfs(0, visited, path, 0))"
}
2022-04-19 23:11:51.857492 REASON stop
2022-04-19 23:11:51.858915 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    n,m = map(int,input().split())\n    edges = []\n    for _ in range(m):\n        a,b = map(int,input().split())\n        edges.append((a,b))\n    print(n,m)\n    print(edges)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:11:51.859111 REASON stop
