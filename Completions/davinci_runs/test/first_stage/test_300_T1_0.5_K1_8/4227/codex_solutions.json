["\n\ndef perm(n, k, l):\n    if k == 1:\n        yield [l[0]]\n    else:\n        for i in range(k):\n            for ss in perm(n, k-1, l[:i] + l[i+1:]):\n                yield [l[i]] + ss\n\ndef comb(n, k):\n    return perm(n, k, [i for i in range(1, n+1)])\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n\n    tree_edges = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i < j and (i, j) not in edges:\n                tree_edges.append((i, j))\n    tree_edges = list(set(tree_edges))\n\n    pathes = []\n    for c in comb(n-1, n-1):\n        pathes.append(c)\n\n    for p in pathes:\n        for i in range(1, len(p)):\n            if (p[i-1], p[i]) not in tree_edges:\n                pathes.remove(p)\n                break\n\n    print(len(pathes))\n\nif __name__ == '__main__':\n    main()", "\n\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    edges.append([a, b])\n\n# print(edges)\n\ngraph = [[] for _ in range(N+1)]\n\nfor a, b in edges:\n    graph[a].append(b)\n    graph[b].append(a)\n\n# print(graph)\n\ndef dfs(graph, start, visited, path):\n    path.append(start)\n\n    if len(path) == N:\n        print(path)\n        return 1\n\n    ret = 0\n    for next in graph[start]:\n        if not visited[next]:\n            visited[next] = True\n            ret += dfs(graph, next, visited, path)\n            visited[next] = False\n            path.pop()\n\n    return ret\n\nvisited = [False for _ in range(N+1)]\nvisited[1] = True\nprint(dfs(graph, 1, visited, []))", "\n\nn, m = map(int, input().split())\npath = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    path[a-1].append(b-1)\n    path[b-1].append(a-1)\n\n\ndef dfs(v, visited, path, count):\n    visited[v] = True\n    count += 1\n    if count == n:\n        return 1\n    ret = 0\n    for i in path[v]:\n        if not visited[i]:\n            ret += dfs(i, visited, path, count)\n    visited[v] = False\n    return ret\n\n\nvisited = [False for i in range(n)]\nprint(dfs(0, visited, path, 0))", "\n\nn, m = map(int, input().split())\n\nedges = [list(map(int, input().split())) for _ in range(m)]\n\ndef dfs(vertex, visited):\n    global edges\n    global n\n\n    if len(visited) == n:\n        return 1\n\n    cnt = 0\n    for edge in edges:\n        if edge[0] == vertex and edge[1] not in visited:\n            cnt += dfs(edge[1], visited + [vertex])\n        elif edge[1] == vertex and edge[0] not in visited:\n            cnt += dfs(edge[0], visited + [vertex])\n    return cnt\n\nprint(dfs(1, []))", "\n\nimport sys\nimport itertools\n\ndef input():\n    return sys.stdin.readline().strip()\n\n# N: the number of vertices\n# M: the number of edges\nN, M = map(int, input().split())\n\n# a_i b_i: the i-th edge\nedges = []\nfor i in range(M):\n    a_i, b_i = map(int, input().split())\n    edges.append((a_i, b_i))\n\n#print(N, M, edges)\n\n# initialize the adjacency matrix\nadj_mat = [[0 for i in range(N)] for j in range(N)]\n\n# update the adjacency matrix\nfor edge in edges:\n    a_i, b_i = edge\n    adj_mat[a_i-1][b_i-1] = 1\n    adj_mat[b_i-1][a_i-1] = 1\n\n#print(adj_mat)\n\n# the number of paths\ncount = 0\n\n# count the number of paths\nfor path in itertools.permutations(range(1, N)):\n    #print(path)\n    path = [0] + list(path)\n    i = 0\n    j = 1\n    while True:\n        if adj_mat[path[i]][path[j]]:\n            i = j\n            j += 1\n            if j == N:\n                count += 1\n                break\n        else:\n            break\n\n#print(count)\nprint(count)", "\n\nimport sys\nfrom collections import defaultdict\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(set)\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].add(b)\n        graph[b].add(a)\n    print(dfs(graph, n))\n\n\ndef dfs(graph, n):\n    visited = [False] * n\n    visited[0] = True\n    stack = [1]\n    path = 0\n    while stack:\n        v = stack[-1]\n        if len(stack) == n:\n            path += 1\n            stack.pop()\n            visited[v-1] = False\n            continue\n        for i in graph[v]:\n            if not visited[i-1]:\n                visited[i-1] = True\n                stack.append(i)\n                break\n        else:\n            stack.pop()\n            visited[v-1] = False\n    return path\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n,m = map(int,input().split())\n    edges = []\n    for _ in range(m):\n        a,b = map(int,input().split())\n        edges.append((a,b))\n    print(n,m)\n    print(edges)\n\nif __name__ == '__main__':\n    main()", "\n\nimport itertools\n\ndef is_path(path, edges):\n    for i in range(len(path)-1):\n        if (path[i], path[i+1]) not in edges and (path[i+1], path[i]) not in edges:\n            return False\n    return True\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    paths = itertools.permutations(range(2, n+1))\n    cnt = 0\n    for path in paths:\n        if is_path((1,) + path, edges):\n            cnt += 1\n    print(cnt)\n\nif __name__ == '__main__':\n    main()"]