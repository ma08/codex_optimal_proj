["\n\n# SOLUTION\n# This is a small variation of the problem \"Almost Prime Numbers\"\n# https://codeforces.com/contest/1148/problem/C\n\n# The idea is to find the prime factors of the number x.\n# For that, we must find the largest prime factor of the product of all the divisors\n# We will use the sieve of Eratosthenes\n\n# This is a variation of the problem \"Almost Prime Numbers\"\n# https://codeforces.com/contest/1148/problem/C\n\n# The idea is to find the prime factors of the number x.\n# For that, we must find the largest prime factor of the product of all the divisors\n# We will use the sieve of Eratosthenes\n\n# The algorithm will be as follows:\n# 1. We will find the product of all the divisors\n# 2. We will use the sieve of Eratosthenes to find the largest prime factor of the product\n# 3. We will divide the product by the largest prime factor and repeat the process until it is 1\n# 4. We will multiply all the prime factors\n\n# This algorithm is O(n log log n)\n\n# If the product is 1, then the divisors are not divisors of any number\n# If the product is not 1 and we cannot find any prime factor, then the divisors are the divisors of a prime number\n\nimport math\n\nt = int(input())\n\ndef sieve(n):\n    # We will use an array to represent the sieve\n    # The value 0 means that the number is prime\n    # The value 1 means that the number is not prime\n    sieve = [0 for _ in range(n + 1)]\n    sieve[0] = 1\n    sieve[1] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if sieve[i] == 0:\n            j = i * i\n            while j <= n:\n                sieve[j] = 1\n                j += i\n    return sieve\n\nfor _ in range(t):\n    n = int(input())\n    divisors = [int(x) for x in input().split()]\n    product = 1\n    for divisor in divisors:\n        product *= divisor\n    sieve = sieve(product)\n    primes = []\n    while product != 1:\n        for i in range(product, 0, -1):\n            if sieve[i] == 0:\n                primes.append(i)\n                product //= i\n                break\n        if product == 1:\n            break\n    if len(primes) == 0:\n        print(-1)\n    else:\n        print(product * max(primes))", "\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    divisors = list(map(int, input().split()))\n    divisors.sort()\n    if n == 1:\n        print(divisors[0] * 2)\n    else:\n        x = divisors[0] * divisors[1]\n        for j in range(2, len(divisors)):\n            if divisors[j] * divisors[j - 1] != x:\n                print(-1)\n                break\n        else:\n            print(x)", "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        divisors = [int(x) for x in input().split()]\n        x = find_x(n, divisors)\n        print(x)\n\ndef find_x(n, divisors):\n    if n == 1:\n        return divisors[0] * 2\n    if n == 2:\n        return divisors[0] * divisors[1]\n    return -1\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef find_min(n, arr):\n    if n == 1:\n        return arr[0] * 2\n    for i in range(2, arr[-1]):\n        for j in range(len(arr)):\n            if i % arr[j] != 0:\n                break\n            if j == len(arr) - 1:\n                return i\n    return -1\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(find_min(n, arr))", "\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef main():\n    t = int(input())\n    for i in range(0, t):\n        n = int(input())\n        divisors = [int(x) for x in input().split(\" \")]\n        divisors.sort()\n        if n == 1:\n            print(divisors[0] * 2)\n        else:\n            lcm_ans = lcm(divisors[0], divisors[1])\n            if lcm_ans == divisors[0] * divisors[1]:\n                print(lcm_ans)\n            else:\n                print(-1)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef solve(n, d):\n    if n == 1:\n        return 2*d[0]\n    if n == 2:\n        return d[0] * d[1]\n\n    d.sort()\n    if d[0] * d[1] < d[-2] * d[-1]:\n        return -1\n    return d[-1] * d[-2]\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    print(solve(n, d))", "\n\n#Solution\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    if n == 1:\n        print(d[0]*2)\n    else:\n        print(-1)", "\n# SOLUTION\nfor _ in range(int(input())):\n    n = int(input())\n    d = list(map(int, input().split()))\n    d.sort()\n    if n == 1:\n        x = d[0] * 2\n    elif n == 2:\n        x = d[0] * d[1]\n    elif n == 3:\n        if d[1] % d[0] == 0:\n            x = d[1]\n        else:\n            x = -1\n    else:\n        x = -1\n    print(x)"]