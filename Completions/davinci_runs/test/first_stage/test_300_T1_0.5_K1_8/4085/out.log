2022-04-19 21:47:38.331777 """
We guessed some integer number $x$. You are given a list of almost all its divisors. Almost all means that there are all divisors except $1$ and $x$ in the list.

Your task is to find the minimum possible integer $x$ that can be the guessed number, or say that the input data is contradictory and it is impossible to find such number.

You have to answer $t$ independent queries.


-----Input-----

The first line of the input contains one integer $t$ ($1 \le t \le 25$) — the number of queries. Then $t$ queries follow.

The first line of the query contains one integer $n$ ($1 \le n \le 300$) — the number of divisors in the list.

The second line of the query contains $n$ integers $d_1, d_2, \dots, d_n$ ($2 \le d_i \le 10^6$), where $d_i$ is the $i$-th divisor of the guessed number. It is guaranteed that all values $d_i$ are distinct.


-----Output-----

For each query print the answer to it.

If the input data in the query is contradictory and it is impossible to find such number $x$ that the given list of divisors is the list of almost all its divisors, print -1. Otherwise print the minimum possible $x$.


-----Example-----
Input
2
8
8 2 12 6 4 24 16 3
1
2

Output
48
4
"""
2022-04-19 21:47:38.331788 --------------------------
2022-04-19 21:47:38.331895 using api key sourya
2022-04-19 21:48:12.211312 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n# SOLUTION\nfor _ in range(int(input())):\n    n = int(input())\n    d = list(map(int, input().split()))\n    d.sort()\n    if n == 1:\n        x = d[0] * 2\n    elif n == 2:\n        x = d[0] * d[1]\n    elif n == 3:\n        if d[1] % d[0] == 0:\n            x = d[1]\n        else:\n            x = -1\n    else:\n        x = -1\n    print(x)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    divisors = list(map(int, input().split()))\n    divisors.sort()\n    if n == 1:\n        print(divisors[0] * 2)\n    else:\n        x = divisors[0] * divisors[1]\n        for j in range(2, len(divisors)):\n            if divisors[j] * divisors[j - 1] != x:\n                print(-1)\n                break\n        else:\n            print(x)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        divisors = [int(x) for x in input().split()]\n        x = find_x(n, divisors)\n        print(x)\n\ndef find_x(n, divisors):\n    if n == 1:\n        return divisors[0] * 2\n    if n == 2:\n        return divisors[0] * divisors[1]\n    return -1\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef solve(n, d):\n    if n == 1:\n        return 2*d[0]\n    if n == 2:\n        return d[0] * d[1]\n\n    d.sort()\n    if d[0] * d[1] < d[-2] * d[-1]:\n        return -1\n    return d[-1] * d[-2]\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    print(solve(n, d))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# This is a small variation of the problem \"Almost Prime Numbers\"\n# https://codeforces.com/contest/1148/problem/C\n\n# The idea is to find the prime factors of the number x.\n# For that, we must find the largest prime factor of the product of all the divisors\n# We will use the sieve of Eratosthenes\n\n# This is a variation of the problem \"Almost Prime Numbers\"\n# https://codeforces.com/contest/1148/problem/C\n\n# The idea is to find the prime factors of the number x.\n# For that, we must find the largest prime factor of the product of all the divisors\n# We will use the sieve of Eratosthenes\n\n# The algorithm will be as follows:\n# 1. We will find the product of all the divisors\n# 2. We will use the sieve of Eratosthenes to find the largest prime factor of the product\n# 3. We will divide the product by the largest prime factor and repeat the process until it is 1\n# 4. We will multiply all the prime factors\n\n# This algorithm is O(n log log n)\n\n# If the product is 1, then the divisors are not divisors of any number\n# If the product is not 1 and we cannot find any prime factor, then the divisors are the divisors of a prime number\n\nimport math\n\nt = int(input())\n\ndef sieve(n):\n    # We will use an array to represent the sieve\n    # The value 0 means that the number is prime\n    # The value 1 means that the number is not prime\n    sieve = [0 for _ in range(n + 1)]\n    sieve[0] = 1\n    sieve[1] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if sieve[i] == 0:\n            j = i * i\n            while j <= n:\n                sieve[j] = 1\n                j += i\n    return sieve\n\nfor _ in range(t):\n    n = int(input())\n    divisors = [int(x) for x in input().split()]\n    product = 1\n    for divisor in divisors:\n        product *= divisor\n    sieve = sieve(product)\n    primes = []\n    while product != 1:\n        for i in range(product, 0, -1):\n            if sieve[i] == 0:\n                primes.append(i)\n                product //= i\n                break\n        if product == 1:\n            break\n    if len(primes) == 0:\n        print(-1)\n    else:\n        print(product * max(primes))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef find_min(n, arr):\n    if n == 1:\n        return arr[0] * 2\n    for i in range(2, arr[-1]):\n        for j in range(len(arr)):\n            if i % arr[j] != 0:\n                break\n            if j == len(arr) - 1:\n                return i\n    return -1\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(find_min(n, arr))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n#Solution\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    if n == 1:\n        print(d[0]*2)\n    else:\n        print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef main():\n    t = int(input())\n    for i in range(0, t):\n        n = int(input())\n        divisors = [int(x) for x in input().split(\" \")]\n        divisors.sort()\n        if n == 1:\n            print(divisors[0] * 2)\n        else:\n            lcm_ans = lcm(divisors[0], divisors[1])\n            if lcm_ans == divisors[0] * divisors[1]:\n                print(lcm_ans)\n            else:\n                print(-1)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650404858,
  "id": "cmpl-4ypz8bAYXyp6BRsVm5cLanO2fnPb9",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 21:48:12.211651 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n# SOLUTION\nfor _ in range(int(input())):\n    n = int(input())\n    d = list(map(int, input().split()))\n    d.sort()\n    if n == 1:\n        x = d[0] * 2\n    elif n == 2:\n        x = d[0] * d[1]\n    elif n == 3:\n        if d[1] % d[0] == 0:\n            x = d[1]\n        else:\n            x = -1\n    else:\n        x = -1\n    print(x)"
}
2022-04-19 21:48:12.211686 REASON stop
2022-04-19 21:48:12.212448 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    divisors = list(map(int, input().split()))\n    divisors.sort()\n    if n == 1:\n        print(divisors[0] * 2)\n    else:\n        x = divisors[0] * divisors[1]\n        for j in range(2, len(divisors)):\n            if divisors[j] * divisors[j - 1] != x:\n                print(-1)\n                break\n        else:\n            print(x)"
}
2022-04-19 21:48:12.212559 REASON stop
2022-04-19 21:48:12.213514 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        divisors = [int(x) for x in input().split()]\n        x = find_x(n, divisors)\n        print(x)\n\ndef find_x(n, divisors):\n    if n == 1:\n        return divisors[0] * 2\n    if n == 2:\n        return divisors[0] * divisors[1]\n    return -1\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:48:12.213607 REASON stop
2022-04-19 21:48:12.235037 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef solve(n, d):\n    if n == 1:\n        return 2*d[0]\n    if n == 2:\n        return d[0] * d[1]\n\n    d.sort()\n    if d[0] * d[1] < d[-2] * d[-1]:\n        return -1\n    return d[-1] * d[-2]\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    print(solve(n, d))"
}
2022-04-19 21:48:12.235176 REASON stop
2022-04-19 21:48:12.236037 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# This is a small variation of the problem \"Almost Prime Numbers\"\n# https://codeforces.com/contest/1148/problem/C\n\n# The idea is to find the prime factors of the number x.\n# For that, we must find the largest prime factor of the product of all the divisors\n# We will use the sieve of Eratosthenes\n\n# This is a variation of the problem \"Almost Prime Numbers\"\n# https://codeforces.com/contest/1148/problem/C\n\n# The idea is to find the prime factors of the number x.\n# For that, we must find the largest prime factor of the product of all the divisors\n# We will use the sieve of Eratosthenes\n\n# The algorithm will be as follows:\n# 1. We will find the product of all the divisors\n# 2. We will use the sieve of Eratosthenes to find the largest prime factor of the product\n# 3. We will divide the product by the largest prime factor and repeat the process until it is 1\n# 4. We will multiply all the prime factors\n\n# This algorithm is O(n log log n)\n\n# If the product is 1, then the divisors are not divisors of any number\n# If the product is not 1 and we cannot find any prime factor, then the divisors are the divisors of a prime number\n\nimport math\n\nt = int(input())\n\ndef sieve(n):\n    # We will use an array to represent the sieve\n    # The value 0 means that the number is prime\n    # The value 1 means that the number is not prime\n    sieve = [0 for _ in range(n + 1)]\n    sieve[0] = 1\n    sieve[1] = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if sieve[i] == 0:\n            j = i * i\n            while j <= n:\n                sieve[j] = 1\n                j += i\n    return sieve\n\nfor _ in range(t):\n    n = int(input())\n    divisors = [int(x) for x in input().split()]\n    product = 1\n    for divisor in divisors:\n        product *= divisor\n    sieve = sieve(product)\n    primes = []\n    while product != 1:\n        for i in range(product, 0, -1):\n            if sieve[i] == 0:\n                primes.append(i)\n                product //= i\n                break\n        if product == 1:\n            break\n    if len(primes) == 0:\n        print(-1)\n    else:\n        print(product * max(primes))"
}
2022-04-19 21:48:12.236130 REASON stop
2022-04-19 21:48:12.239615 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef find_min(n, arr):\n    if n == 1:\n        return arr[0] * 2\n    for i in range(2, arr[-1]):\n        for j in range(len(arr)):\n            if i % arr[j] != 0:\n                break\n            if j == len(arr) - 1:\n                return i\n    return -1\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(find_min(n, arr))"
}
2022-04-19 21:48:12.239709 REASON stop
2022-04-19 21:48:12.241211 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n#Solution\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    if n == 1:\n        print(d[0]*2)\n    else:\n        print(-1)"
}
2022-04-19 21:48:12.241301 REASON stop
2022-04-19 21:48:12.242046 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef main():\n    t = int(input())\n    for i in range(0, t):\n        n = int(input())\n        divisors = [int(x) for x in input().split(\" \")]\n        divisors.sort()\n        if n == 1:\n            print(divisors[0] * 2)\n        else:\n            lcm_ans = lcm(divisors[0], divisors[1])\n            if lcm_ans == divisors[0] * divisors[1]:\n                print(lcm_ans)\n            else:\n                print(-1)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 21:48:12.242231 REASON stop
