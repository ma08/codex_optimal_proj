2022-04-19 23:37:14.133965 """
There are $n$ kids, numbered from $1$ to $n$, dancing in a circle around the Christmas tree. Let's enumerate them in a clockwise direction as $p_1$, $p_2$, ..., $p_n$ (all these numbers are from $1$ to $n$ and are distinct, so $p$ is a permutation). Let the next kid for a kid $p_i$ be kid $p_{i + 1}$ if $i < n$ and $p_1$ otherwise. After the dance, each kid remembered two kids: the next kid (let's call him $x$) and the next kid for $x$. Each kid told you which kids he/she remembered: the kid $i$ remembered kids $a_{i, 1}$ and $a_{i, 2}$. However, the order of $a_{i, 1}$ and $a_{i, 2}$ can differ from their order in the circle. [Image] Example: 5 kids in a circle, $p=[3, 2, 4, 1, 5]$ (or any cyclic shift). The information kids remembered is: $a_{1,1}=3$, $a_{1,2}=5$; $a_{2,1}=1$, $a_{2,2}=4$; $a_{3,1}=2$, $a_{3,2}=4$; $a_{4,1}=1$, $a_{4,2}=5$; $a_{5,1}=2$, $a_{5,2}=3$. 

You have to restore the order of the kids in the circle using this information. If there are several answers, you may print any. It is guaranteed that at least one solution exists.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.


-----Input-----

The first line of the input contains one integer $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of the kids.

The next $n$ lines contain $2$ integers each. The $i$-th line contains two integers $a_{i, 1}$ and $a_{i, 2}$ ($1 \le a_{i, 1}, a_{i, 2} \le n, a_{i, 1} \ne a_{i, 2}$) — the kids the $i$-th kid remembered, given in arbitrary order.


-----Output-----

Print $n$ integers $p_1$, $p_2$, ..., $p_n$ — permutation of integers from $1$ to $n$, which corresponds to the order of kids in the circle. If there are several answers, you may print any (for example, it doesn't matter which kid is the first in the circle). It is guaranteed that at least one solution exists.


-----Examples-----
Input
5
3 5
1 4
2 4
1 5
2 3

Output
3 2 4 1 5 

Input
3
2 3
3 1
1 2

Output
3 1 2
"""
2022-04-19 23:37:14.133986 --------------------------
2022-04-19 23:37:14.134094 using api key sourya
2022-04-19 23:37:53.129161 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# Solution\nn = int(input())\na = [[0, 0] for i in range(n)]\nfor i in range(n):\n    a[i][0], a[i][1] = map(int, input().split())\n\n# a[i] = [a[i][0], a[i][1]]\n\n# print(a)\n\ndef check(a):\n    for i in range(n):\n        if a[i][0] == a[i][1] or a[i][0] == a[a[i][0]][0] or a[i][0] == a[a[i][0]][1]:\n            return False\n    return True\n\ndef get_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return j\n    return -1\n\ndef get_next_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return a[j][0] if a[j][1] == i else a[j][1]\n    return -1\n\ndef get_next_next_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return get_next(a, a[j][0] if a[j][1] == i else a[j][1])\n    return -1\n\ndef get_next_next_next_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return get_next_next(a, a[j][0] if a[j][1] == i else a[j][1])\n    return -1\n\n\ndef get_order(a):\n    order = [-1] * n\n    order[0] = 1\n    order[1] = get_next(a, order[0])\n    order[2] = get_next_next(a, order[0])\n    order[3] = get_next_next_next(a, order[0])\n    order[4] = get_next_next_next_next(a, order[0])\n    # print(order)\n    for i in range(n):\n        if order[i] == -1:\n            order[i] = get_next(order, i)\n    return order\n\n# print(check(a))\n\n# print(get_order(a))\n\ndef get_order_2(a):\n    order = [-1] * n\n    order[0] = get_next(a, a[0][0])\n    order[1] = a[order[0]][0] if a[order[0]][1] == a[0][0] else a[order[0]][1]\n    order[2] = get_next(a, order[0])\n    order[3] = get_next_next(a, order[0])\n    order[4] = get_next_next_next(a, order[0])\n    # print(order)\n    for i in range(n):\n        if order[i] == -1:\n            order[i] = get_next(order, i)\n    return order\n\nprint(get_order_2(a))\n\n# def get_order_3(a):\n#     order = [-1] * n\n#     order[0] = get_next(a, a[0][0])\n#     order[1] = get_next(a, a[0][1])\n#     order[2] = get_next_next(a, a[0][0])\n#     order[3] = get_next_next_next(a, a[0][0])\n#     order[4] = get_next_next_next_next(a, a[0][0])\n#     # print(order)\n#     for i in range(n):\n#         if order[i] == -1:\n#             order[i] = get_next(order, i)\n#     return order\n\n# print(get_order_3(a))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    p = [0] * n\n    p[0] = 1\n    p[1] = a[0][0]\n    p[2] = a[0][1]\n    for i in range(3, n):\n        if a[p[i - 1] - 1][0] == p[i - 2]:\n            p[i] = a[p[i - 1] - 1][1]\n        else:\n            p[i] = a[p[i - 1] - 1][0]\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    p = [0]*n\n    p[0] = 1\n    for i in range(n):\n        p[a[i][0]-1] = a[i][1]\n        p[a[i][1]-1] = a[i][0]\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = i+2\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for i in range(n):\n        a[i].sort()\n    print(a)\n    # for i in range(n):\n    #     a[i].sort()\n    # print(a)\n    # for i in range(n):\n    #     if a[i][0] == i+1 and a[i][1] == i+1:\n    #         print(i+1)\n    #         break\n    # else:\n    #     print(-1)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn = int(input())\n\n# create list of lists of size 2\na = [[0,0] for i in range(n)]\n\n# populate the list of lists\nfor i in range(n):\n    a[i][0], a[i][1] = map(int, input().split())\n\n# create a list of size n\np = [0 for i in range(n)]\n\n# p[0] can be any value from 1 to n\n# we will just choose 1 arbitrarily\np[0] = 1\n\n# populate the rest of the list\nfor i in range(1,n):\n    # if the value of the previous element in p is the same\n    # as the first element in a[i], then the value of the\n    # current element in p should be the second element in a[i]\n    if p[i-1] == a[i][0]:\n        p[i] = a[i][1]\n    # otherwise, the value of the current element in p\n    # should be the first element in a[i]\n    else:\n        p[i] = a[i][0]\n\n# print the list p\nfor i in range(n):\n    print(p[i], end=\" \")\nprint()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = []\nfor i in range(n):\n    x = input().split(' ')\n    a.append([int(x[0]), int(x[1])])\n\n# print(a)\n\ndef make_graph(a):\n    g = {}\n    for i in range(len(a)):\n        if a[i][0] not in g:\n            g[a[i][0]] = [a[i][1]]\n        else:\n            g[a[i][0]].append(a[i][1])\n\n        if a[i][1] not in g:\n            g[a[i][1]] = [a[i][0]]\n        else:\n            g[a[i][1]].append(a[i][0])\n    # print(g)\n    return g\n\ndef dfs(g, start):\n    visited, stack = [], [start]\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.append(vertex)\n            stack.extend(set(g[vertex]) - set(visited))\n    return visited\n\ng = make_graph(a)\n# print(g)\n\n# print(dfs(g, 1))\n\nvisited = dfs(g, 1)\n\ndef get_path(g, start, end):\n    stack = [(start, [start])]\n    while stack:\n        (vertex, path) = stack.pop()\n        for next in set(g[vertex]) - set(path):\n            if next == end:\n                yield path + [next]\n            else:\n                stack.append((next, path + [next]))\n\nvisited.sort()\n\nfor i in range(len(visited)):\n    if i == 0:\n        path = list(get_path(g, visited[i], visited[i+1]))\n    elif i == len(visited)-1:\n        path = list(get_path(g, visited[i], visited[0]))\n    else:\n        path = list(get_path(g, visited[i], visited[i+1]))\n    # print(path)\n    for j in range(len(path)):\n        if len(path[j]) == 2:\n            path[j] = [path[j][1], path[j][0]]\n    # print(path)\n    visited = list(set(visited) - set(path[0]))\n    visited = path[0] + visited\n\nprint(' '.join(map(str, visited)))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n# n = int(input())\n# a = [list(map(int, input().split())) for i in range(n)]\n\ndef main():\n    n = int(input())\n    a = [list(map(int, input().split())) for i in range(n)]\n    # a = [[3, 5], [1, 4], [2, 4], [1, 5], [2, 3]]\n    # a = [[2, 3], [3, 1], [1, 2]]\n    # a = [[2, 3], [3, 1], [1, 2]]\n\n    # print(a)\n\n    # start = a[0][0]\n    # end = a[0][1]\n\n    # for i in range(n):\n    #     for j in range(n):\n    #         if a[i][0] == start:\n    #             print(i, j)\n    #             start = a[i][1]\n    #             end = a[i][0]\n\n    # print(a)\n\n    p = [0] * n\n    p[0] = a[0][0]\n    p[1] = a[0][1]\n\n    for i in range(2, n):\n        for j in range(n):\n            if a[j][0] == p[i - 1]:\n                p[i] = a[j][1]\n                break\n            elif a[j][1] == p[i - 1]:\n                p[i] = a[j][0]\n                break\n\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650411434,
  "id": "cmpl-4yrhC2iXZ5lKNM6DQ7HQr9WVbh9zs",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 23:37:53.129634 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# Solution\nn = int(input())\na = [[0, 0] for i in range(n)]\nfor i in range(n):\n    a[i][0], a[i][1] = map(int, input().split())\n\n# a[i] = [a[i][0], a[i][1]]\n\n# print(a)\n\ndef check(a):\n    for i in range(n):\n        if a[i][0] == a[i][1] or a[i][0] == a[a[i][0]][0] or a[i][0] == a[a[i][0]][1]:\n            return False\n    return True\n\ndef get_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return j\n    return -1\n\ndef get_next_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return a[j][0] if a[j][1] == i else a[j][1]\n    return -1\n\ndef get_next_next_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return get_next(a, a[j][0] if a[j][1] == i else a[j][1])\n    return -1\n\ndef get_next_next_next_next(a, i):\n    for j in range(n):\n        if a[j][0] == i or a[j][1] == i:\n            return get_next_next(a, a[j][0] if a[j][1] == i else a[j][1])\n    return -1\n\n\ndef get_order(a):\n    order = [-1] * n\n    order[0] = 1\n    order[1] = get_next(a, order[0])\n    order[2] = get_next_next(a, order[0])\n    order[3] = get_next_next_next(a, order[0])\n    order[4] = get_next_next_next_next(a, order[0])\n    # print(order)\n    for i in range(n):\n        if order[i] == -1:\n            order[i] = get_next(order, i)\n    return order\n\n# print(check(a))\n\n# print(get_order(a))\n\ndef get_order_2(a):\n    order = [-1] * n\n    order[0] = get_next(a, a[0][0])\n    order[1] = a[order[0]][0] if a[order[0]][1] == a[0][0] else a[order[0]][1]\n    order[2] = get_next(a, order[0])\n    order[3] = get_next_next(a, order[0])\n    order[4] = get_next_next_next(a, order[0])\n    # print(order)\n    for i in range(n):\n        if order[i] == -1:\n            order[i] = get_next(order, i)\n    return order\n\nprint(get_order_2(a))\n\n# def get_order_3(a):\n#     order = [-1] * n\n#     order[0] = get_next(a, a[0][0])\n#     order[1] = get_next(a, a[0][1])\n#     order[2] = get_next_next(a, a[0][0])\n#     order[3] = get_next_next_next(a, a[0][0])\n#     order[4] = get_next_next_next_next(a, a[0][0])\n#     # print(order)\n#     for i in range(n):\n#         if order[i] == -1:\n#             order[i] = get_next(order, i)\n#     return order\n\n# print(get_order_3(a))"
}
2022-04-19 23:37:53.129688 REASON stop
2022-04-19 23:37:53.130407 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    p = [0] * n\n    p[0] = 1\n    p[1] = a[0][0]\n    p[2] = a[0][1]\n    for i in range(3, n):\n        if a[p[i - 1] - 1][0] == p[i - 2]:\n            p[i] = a[p[i - 1] - 1][1]\n        else:\n            p[i] = a[p[i - 1] - 1][0]\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 23:37:53.130474 REASON stop
2022-04-19 23:37:53.130890 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": ""
}
2022-04-19 23:37:53.130944 REASON stop
2022-04-19 23:37:53.167792 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    p = [0]*n\n    p[0] = 1\n    for i in range(n):\n        p[a[i][0]-1] = a[i][1]\n        p[a[i][1]-1] = a[i][0]\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = i+2\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 23:37:53.167946 REASON stop
2022-04-19 23:37:53.168861 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    for i in range(n):\n        a[i].sort()\n    print(a)\n    # for i in range(n):\n    #     a[i].sort()\n    # print(a)\n    # for i in range(n):\n    #     if a[i][0] == i+1 and a[i][1] == i+1:\n    #         print(i+1)\n    #         break\n    # else:\n    #     print(-1)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-19 23:37:53.168960 REASON stop
2022-04-19 23:37:53.174531 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn = int(input())\n\n# create list of lists of size 2\na = [[0,0] for i in range(n)]\n\n# populate the list of lists\nfor i in range(n):\n    a[i][0], a[i][1] = map(int, input().split())\n\n# create a list of size n\np = [0 for i in range(n)]\n\n# p[0] can be any value from 1 to n\n# we will just choose 1 arbitrarily\np[0] = 1\n\n# populate the rest of the list\nfor i in range(1,n):\n    # if the value of the previous element in p is the same\n    # as the first element in a[i], then the value of the\n    # current element in p should be the second element in a[i]\n    if p[i-1] == a[i][0]:\n        p[i] = a[i][1]\n    # otherwise, the value of the current element in p\n    # should be the first element in a[i]\n    else:\n        p[i] = a[i][0]\n\n# print the list p\nfor i in range(n):\n    print(p[i], end=\" \")\nprint()"
}
2022-04-19 23:37:53.174649 REASON stop
2022-04-19 23:37:53.183231 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = []\nfor i in range(n):\n    x = input().split(' ')\n    a.append([int(x[0]), int(x[1])])\n\n# print(a)\n\ndef make_graph(a):\n    g = {}\n    for i in range(len(a)):\n        if a[i][0] not in g:\n            g[a[i][0]] = [a[i][1]]\n        else:\n            g[a[i][0]].append(a[i][1])\n\n        if a[i][1] not in g:\n            g[a[i][1]] = [a[i][0]]\n        else:\n            g[a[i][1]].append(a[i][0])\n    # print(g)\n    return g\n\ndef dfs(g, start):\n    visited, stack = [], [start]\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.append(vertex)\n            stack.extend(set(g[vertex]) - set(visited))\n    return visited\n\ng = make_graph(a)\n# print(g)\n\n# print(dfs(g, 1))\n\nvisited = dfs(g, 1)\n\ndef get_path(g, start, end):\n    stack = [(start, [start])]\n    while stack:\n        (vertex, path) = stack.pop()\n        for next in set(g[vertex]) - set(path):\n            if next == end:\n                yield path + [next]\n            else:\n                stack.append((next, path + [next]))\n\nvisited.sort()\n\nfor i in range(len(visited)):\n    if i == 0:\n        path = list(get_path(g, visited[i], visited[i+1]))\n    elif i == len(visited)-1:\n        path = list(get_path(g, visited[i], visited[0]))\n    else:\n        path = list(get_path(g, visited[i], visited[i+1]))\n    # print(path)\n    for j in range(len(path)):\n        if len(path[j]) == 2:\n            path[j] = [path[j][1], path[j][0]]\n    # print(path)\n    visited = list(set(visited) - set(path[0]))\n    visited = path[0] + visited\n\nprint(' '.join(map(str, visited)))"
}
2022-04-19 23:37:53.183411 REASON stop
2022-04-19 23:37:53.183879 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n# n = int(input())\n# a = [list(map(int, input().split())) for i in range(n)]\n\ndef main():\n    n = int(input())\n    a = [list(map(int, input().split())) for i in range(n)]\n    # a = [[3, 5], [1, 4], [2, 4], [1, 5], [2, 3]]\n    # a = [[2, 3], [3, 1], [1, 2]]\n    # a = [[2, 3], [3, 1], [1, 2]]\n\n    # print(a)\n\n    # start = a[0][0]\n    # end = a[0][1]\n\n    # for i in range(n):\n    #     for j in range(n):\n    #         if a[i][0] == start:\n    #             print(i, j)\n    #             start = a[i][1]\n    #             end = a[i][0]\n\n    # print(a)\n\n    p = [0] * n\n    p[0] = a[0][0]\n    p[1] = a[0][1]\n\n    for i in range(2, n):\n        for j in range(n):\n            if a[j][0] == p[i - 1]:\n                p[i] = a[j][1]\n                break\n            elif a[j][1] == p[i - 1]:\n                p[i] = a[j][0]\n                break\n\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 23:37:53.184055 REASON stop
