["\nimport sys\n\ndef main():\n    # Read data\n    n, m, d = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    # Check if there exists a spanning tree with degree d for the first vertex\n    if d >= len(adj[0]):\n        print(\"NO\")\n        return\n\n    # Print the edges of a spanning tree\n    print(\"YES\")\n    for _ in range(d):\n        print(\"1\", adj[0][0] + 1)\n        adj[adj[0][0]].remove(0)\n        adj[0].remove(adj[0][0])\n    for i in range(1, n):\n        if adj[i]:\n            print(i + 1, adj[i][0] + 1)\n            adj[adj[i][0]].remove(i)\n            adj[i].remove(adj[i][0])\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\nsys.setrecursionlimit(200000)\n\ndef read_ints():\n\treturn [int(x) for x in sys.stdin.readline().strip().split()]\n\ndef read_edge():\n\treturn read_ints()\n\ndef read_edges(m):\n\treturn [read_edge() for _ in range(m)]\n\ndef write_edges(edges):\n\tsys.stdout.write('YES\\n')\n\tfor edge in edges:\n\t\tsys.stdout.write('{} {}\\n'.format(edge[0], edge[1]))\n\ndef dfs(start, graph, visited):\n\tvisited[start] = True\n\tfor neighbour in graph[start]:\n\t\tif not visited[neighbour]:\n\t\t\tdfs(neighbour, graph, visited)\n\ndef solve(n, m, D, edges):\n\t# TODO: Implement this function\n\tgraph = [[] for _ in range(n + 1)]\n\tfor edge in edges:\n\t\tgraph[edge[0]].append(edge[1])\n\t\tgraph[edge[1]].append(edge[0])\n\n\tvisited = [False for _ in range(n + 1)]\n\tdfs(1, graph, visited)\n\n\tif D == 0:\n\t\tif all(visited[1:]):\n\t\t\twrite_edges([])\n\t\t\treturn\n\t\telse:\n\t\t\tsys.stdout.write('NO\\n')\n\t\t\treturn\n\n\tfor edge in edges:\n\t\tif edge[0] == 1:\n\t\t\tgraph[edge[0]].remove(edge[1])\n\t\t\tgraph[edge[1]].remove(edge[0])\n\t\t\tvisited = [False for _ in range(n + 1)]\n\t\t\tdfs(1, graph, visited)\n\t\t\tif D == 1:\n\t\t\t\tif all(visited[1:]):\n\t\t\t\t\twrite_edges([edge])\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\tsys.stdout.write('NO\\n')\n\t\t\t\t\treturn\n\t\t\tgraph[edge[0]].append(edge[1])\n\t\t\tgraph[edge[1]].append(edge[0])\n\t\telif edge[1] == 1:\n\t\t\tgraph[edge[0]].remove(edge[1])\n\t\t\tgraph[edge[1]].remove(edge[0])\n\t\t\tvisited = [False for _ in range(n + 1)]\n\t\t\tdfs(1, graph, visited)\n\t\t\tif D == 1:\n\t\t\t\tif all(visited[1:]):\n\t\t\t\t\twrite_edges([edge])\n\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\tsys.stdout.write('NO\\n')\n\t\t\t\t\treturn\n\t\t\tgraph[edge[0]].append(edge[1])\n\t\t\tgraph[edge[1]].append(edge[0])\n\n\tfor edge in edges:\n\t\tif edge[0] == 1:\n\t\t\tfor edge_2 in edges:\n\t\t\t\tif edge_2[0] == 1 and edge_2[1] != edge[1]:\n\t\t\t\t\tgraph[edge[0]].remove(edge[1])\n\t\t\t\t\tgraph[edge[1]].remove(edge[0])\n\t\t\t\t\tgraph[edge_2[0]].remove(edge_2[1])\n\t\t\t\t\tgraph[edge_2[1]].remove(edge_2[0])\n\t\t\t\t\tvisited = [False for _ in range(n + 1)]\n\t\t\t\t\tdfs(1, graph, visited)\n\t\t\t\t\tif D == 2:\n\t\t\t\t\t\tif all(visited[1:]):\n\t\t\t\t\t\t\twrite_edges([edge, edge_2])\n\t\t\t\t\t\t\treturn\n\t\t\t\t\tgraph[edge[0]].append(edge[1])\n\t\t\t\t\tgraph[edge[1]].append(edge[0])\n\t\t\t\t\tgraph[edge_2[0]].append(edge_2[1])\n\t\t\t\t\tgraph[edge_2[1]].append(edge_2[0])\n\t\telif edge[1] == 1:\n\t\t\tfor edge_2 in edges:\n\t\t\t\tif edge_2[0] == 1 and edge_2[1] != edge[0]:\n\t\t\t\t\tgraph[edge[0]].remove(edge[1])\n\t\t\t\t\tgraph[edge[1]].remove(edge[0])\n\t\t\t\t\tgraph[edge_2[0]].remove(edge_2[1])\n\t\t\t\t\tgraph[edge_2[1]].remove(edge_2[0])\n\t\t\t\t\tvisited = [False for _ in range(n + 1)]\n\t\t\t\t\tdfs(1, graph, visited)\n\t\t\t\t\tif D == 2:\n\t\t\t\t\t\tif all(visited[1:]):\n\t\t\t\t\t\t\twrite_edges([edge, edge_2])\n\t\t\t\t\t\t\treturn\n\t\t\t\t\tgraph[edge[0]].append(edge[1])\n\t\t\t\t\tgraph[edge[1]].append(edge[0])\n\t\t\t\t\tgraph[edge_2[0]].append(edge_2[1])\n\t\t\t\t\tgraph[edge_2[1]].append(edge_2[0])\n\n\tsys.stdout.write('NO\\n')\n\nn, m, D = read_ints()\nedges = read_edges(m)\nsolve(n, m, D, edges)", "\n\nimport os\nimport sys\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()", "\n\ndef spanning_tree(n, m, D, edges):\n    if D == 0:\n        return \"NO\"\n    if D > n - 1:\n        return \"YES\"\n    if D == n - 1:\n        return \"YES\\n\" + \"\\n\".join([\"{} {}\".format(edge[0], edge[1]) for edge in edges])\n    if D == 1:\n        return \"YES\\n\" + \"\\n\".join([\"{} {}\".format(edge[1], edge[0]) for edge in edges])\n    if D == 2:\n        return \"YES\\n\" + \"\\n\".join([\"{} {}\".format(edge[0], edge[1]) for edge in edges[1:]])\n    return \"YES\\n\" + \"\\n\".join([\"{} {}\".format(edge[1], edge[0]) for edge in edges[:D-2]]) + \"\\n\" + \"\\n\".join([\"{} {}\".format(edge[0], edge[1]) for edge in edges[D-2:]])\n\nif __name__ == \"__main__\":\n    n, m, D = [int(x) for x in input().split()]\n    edges = [tuple([int(x) for x in input().split()]) for _ in range(m)]\n    print(spanning_tree(n, m, D, edges))", "\n\n#-----Solution-----\n\n#My solution\n\ndef find_spanning_tree(n, m, d, edges):\n    # If there are not enough edges to form a tree\n    if m < n - 1:\n        return 'NO'\n    # If the degree of the first vertex is already equal to d\n    elif d == 0:\n        return 'YES'\n    # If the degree of the first vertex is greater than d\n    elif d < 0:\n        return 'NO'\n    # If the degree of the first vertex is less than d\n    else:\n        # Find the edges that are connected to the first vertex\n        first_edges = [edge for edge in edges if edge[0] == 1 or edge[1] == 1]\n        # If there are not enough edges to form a tree\n        if len(first_edges) < n - 1:\n            return 'NO'\n        # If there are enough edges to form a tree\n        else:\n            # Check if there is a tree with the required degree\n            for i in range(len(first_edges)):\n                # Create a set of edges to form a tree\n                tree = set(first_edges[:i] + first_edges[i+1:])\n                # If the degree of the first vertex is equal to d\n                if d == len(tree):\n                    return 'YES'\n                # If the degree of the first vertex is less than d\n                else:\n                    # Check if there is a tree with the required degree\n                    for edge in first_edges[i+1:]:\n                        # Create a set of edges to form a tree\n                        tree = set(first_edges[:i] + [edge] + first_edges[i+2:])\n                        # If the degree of the first vertex is equal to d\n                        if d == len(tree):\n                            return 'YES'\n            return 'NO'\n\nn, m, d = map(int, input().split())\nedges = []\nfor i in range(m):\n    edges.append(list(map(int, input().split())))\n\nprint(find_spanning_tree(n, m, d, edges))\n\n#Solution from the editorial\n\ndef find_spanning_tree(n, m, d, edges):\n    if m < n - 1:\n        return 'NO'\n    if d == 0:\n        return 'YES'\n    if d < 0:\n        return 'NO'\n    # If there are enough edges to form a tree\n    else:\n        # Check if there is a tree with the required degree\n        for i in range(len(edges)):\n            # Create a set of edges to form a tree\n            tree = set(edges[:i] + edges[i+1:])\n            # If the degree of the first vertex is equal to d\n            if d == len(tree):\n                return 'YES'\n        return 'NO'\n\nn, m, d = map(int, input().split())\nedges = []\nfor i in range(m):\n    edges.append(list(map(int, input().split())))\n\nprint(find_spanning_tree(n, m, d, edges))", "\n\nimport sys\n\ndef main():\n    n, m, d = map(int, sys.stdin.readline().split())\n    edges = [sys.stdin.readline().split() for _ in range(m)]\n    if d == 0:\n        if n == 2:\n            print(\"YES\")\n            print(\"1 2\")\n        else:\n            print(\"NO\")\n    elif d == 1:\n        if n == 2:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(2, n + 1):\n                print(1, i)\n    elif d == n - 1:\n        if n == 2:\n            print(\"YES\")\n            print(\"1 2\")\n        else:\n            print(\"YES\")\n            for i in range(2, n):\n                print(i, i + 1)\n    elif d == n - 2:\n        if n == 3:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(2, n):\n                print(i, i + 1)\n            print(1, n)\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m, d = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, sys.stdin.readline().split())))\n    if d == 0:\n        print(\"YES\")\n        for i in range(2, n + 1):\n            print(1, i)\n        return\n    if d == n - 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(i, i + 1)\n        return\n    if d == 1:\n        for i in range(2, n + 1):\n            if (1, i) in edges:\n                print(\"YES\")\n                print(1, i)\n                for j in range(1, n + 1):\n                    if j != i:\n                        print(j, 1)\n                return\n        print(\"NO\")\n        return\n\nif __name__ == '__main__':\n    main()"]