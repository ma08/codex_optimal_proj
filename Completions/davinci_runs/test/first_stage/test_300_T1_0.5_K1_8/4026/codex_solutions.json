["\n\nimport sys\nimport re\n\ndef read_input(filename):\n    with open(filename, 'r') as f:\n        t = int(f.readline())\n        cases = []\n        for _ in range(t):\n            n, m = map(int, f.readline().split())\n            tiles = {}\n            for _ in range(n):\n                tile = []\n                for _ in range(2):\n                    tile.append(list(map(int, f.readline().split())))\n                tiles[str(tile)] = True\n            cases.append((n, m, tiles))\n        return cases\n\ndef solve(case):\n    n, m, tiles = case\n    if m % 2 == 1:\n        return \"NO\"\n    if n == 1:\n        return \"YES\"\n    for tile in tiles:\n        for t in tiles:\n            if t == tile:\n                continue\n            if str([tile[0][0], tile[1][0], t[0][0], t[1][0]]) in tiles and str([tile[0][1], tile[1][1], t[0][1], t[1][1]]) in tiles:\n                return \"YES\"\n    return \"NO\"\n\ndef write_output(filename, solutions):\n    with open(filename, 'w') as f:\n        for i, sol in enumerate(solutions):\n            f.write(\"Case #%d: %s\\n\" % (i+1, sol))\n\ndef main():\n    cases = read_input(sys.argv[1])\n    solutions = [solve(case) for case in cases]\n    write_output(sys.argv[2], solutions)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef check_if_possible(tile_types, matrix_size):\n    for tile in tile_types:\n        if tile[0][0] != tile[1][1] or tile[0][1] != tile[1][0]:\n            return False\n\n    if matrix_size % 2 == 0:\n        return True\n    else:\n        return False\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        tile_types = []\n        for __ in range(n):\n            tile_types.append([list(map(int, input().split())), list(map(int, input().split()))])\n        if check_if_possible(tile_types, m):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef check(matrix, n, m):\n    # print(matrix, n, m)\n    if n == m:\n        if n == 1:\n            return True\n        else:\n            return matrix[0][0] == matrix[0][1] and matrix[1][0] == matrix[1][1] and matrix[0][0] == matrix[1][0]\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != matrix[n - i - 1][m - j - 1] or matrix[i][j] != matrix[m - i - 1][n - j - 1]:\n                return False\n\n    return True\n\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        matrix = []\n        for j in range(n):\n            matrix.append(list(map(int, input().split())))\n            matrix.append(list(map(int, input().split())))\n\n        if check(matrix, n, m):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef get_input(t):\n    inputs = []\n    for i in range(t):\n        n, m = [int(x) for x in input().split()]\n        tiles = []\n        for j in range(n):\n            t1 = [int(x) for x in input().split()]\n            t2 = [int(x) for x in input().split()]\n            tiles.append([t1, t2])\n        inputs.append([n, m, tiles])\n    return inputs\n\ndef solve(n, m, tiles):\n    if m == 1:\n        return True\n    if n == 1:\n        return False\n    if m % 2:\n        return False\n    if m > 2:\n        if m % 4:\n            return False\n        else:\n            return True\n    if m == 2:\n        for tile in tiles:\n            if tile[0][0] == tile[1][1] and tile[0][1] == tile[1][0]:\n                return True\n        return False\n\ndef main():\n    t = int(input())\n    inputs = get_input(t)\n    for n, m, tiles in inputs:\n        print(\"YES\" if solve(n, m, tiles) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n# The solution is to check that the sum of the elements in each row and column is the same and that the sum of the elements along the diagonal is the same.\n# The sum of the elements in each row and column is the same because of the symmetric property.\n# The sum of the elements along the diagonal is the same because the first element of each row and column is the same.\n\ndef can_construct(tiles, m):\n    n = len(tiles)\n    sum_diagonal = 0\n    for i in range(n):\n        sum_diagonal += tiles[i][0]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if tiles[i][0] + tiles[i][1] != tiles[j][0] + tiles[j][1] or tiles[i][0] + tiles[j][1] != sum_diagonal:\n                return False\n    return True\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        tiles = []\n        for j in range(n):\n            row1 = list(map(int, input().split()))\n            row2 = list(map(int, input().split()))\n            tiles.append([row1[0], row1[1], row2[0], row2[1]])\n        if can_construct(tiles, m):\n            print('YES')\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    main()"]