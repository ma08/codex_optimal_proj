["\n\n#Solution\n\nn = int(input())\na = list(input())\nf = list(map(int, input().split()))\nfor i in range(n):\n    a[i] = str(f[int(a[i])-1])\nprint(''.join(a))", "\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\na = list(map(int, a))\n\ndef f_a(a, f):\n    res = 0\n    for i in range(len(a)):\n        res = res * 10 + f[a[i] - 1]\n    return res\n\nmax_f = 0\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        x = a[i:j]\n        x = f_a(x, f)\n        if x > max_f:\n            max_f = x\n\nprint(max_f)", "\n\nn = int(input())\na = input()\nf = [int(x) for x in input().split()]\n\na_list = [int(x) for x in a]\n\n# create a list of tuples\na_list_tuples = [(x, i) for i, x in enumerate(a_list)]\n\n# sort the list of tuples\na_list_tuples = sorted(a_list_tuples, key=lambda x: f[x[0]-1])\n\n# create a list of tuples for the sorted list of tuples\n# this will help us find the index of the element in the original list\na_list_tuples_sorted = [(x, i) for i, x in enumerate(a_list_tuples)]\n\n# sort the list of tuples by the original index\na_list_tuples_sorted = sorted(a_list_tuples_sorted, key=lambda x: x[1])\n\n# get a list of the values of the sorted list of tuples\na_list_sorted = [x[0] for x in a_list_tuples_sorted]\n\n# get the index of the first element in the sorted list which is not the same as the original list\nfor i in range(n):\n    if a_list[i] != a_list_sorted[i]:\n        break\n\n# if the index is the last element, we are done\nif i == n-1:\n    print(a)\nelse:\n    # otherwise, change the first element of the sorted list which is not the same as the original list\n    a_list_sorted[i] = a_list[i]\n    print(''.join([str(x) for x in a_list_sorted]))", "\n\ndef main():\n    n = int(input())\n    a = input()\n    f = [int(x) for x in input().split()]\n    f_inv = [0 for x in range(10)]\n    for i in range(1, 10):\n        f_inv[f[i-1]] = i\n    a = [int(x) for x in a]\n    a_inv = [f_inv[x] for x in a]\n    a_inv_str = \"\".join([str(x) for x in a_inv])\n    a_str = \"\".join([str(x) for x in a])\n    print(max(a_inv_str, a_str))\n\nif __name__ == \"__main__\":\n    main()", "\n\nN = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# find the first digit that can be increased\ni = 0\nwhile a[i] == '9' or f[int(a[i])-1] <= int(a[i]):\n    i += 1\n\n# find the last digit that can be increased\nj = N - 1\nwhile a[j] == '9' or f[int(a[j])-1] <= int(a[j]):\n    j -= 1\n\n# replace the digits in the range [i, j]\nfor k in range(i, j+1):\n    a = a[:k] + str(f[int(a[k])-1]) + a[k+1:]\n\nprint(a)", "\n\nimport sys\n\ndef solve(n, a, f):\n    a = list(a)\n    max_num = int(''.join(a))\n    for i in range(n):\n        for j in range(i, n):\n            b = a[:]\n            for k in range(i, j + 1):\n                b[k] = str(f[int(b[k]) - 1])\n            max_num = max(max_num, int(''.join(b)))\n    return max_num\n\nn = int(sys.stdin.readline())\na = sys.stdin.readline().strip()\nf = [int(x) for x in sys.stdin.readline().split()]\n\nprint(solve(n, a, f))", "\n\n#-----Solution-----\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# First determine the best segment to modify\n\n# Starting from the left, find the first digit that can be increased\nleft = 0\nwhile left < n and f[int(a[left]) - 1] <= int(a[left]):\n    left += 1\n\n# Starting from the right, find the first digit that can be increased\nright = n - 1\nwhile right >= 0 and f[int(a[right]) - 1] <= int(a[right]):\n    right -= 1\n\n# If no digits can be increased, the answer is just a\nif left == n or right == -1:\n    print(a)\n\n# If a digit can be increased, increase the first digit that can be increased\nelse:\n    print(a[:left] + str(f[int(a[left]) - 1]) + a[left + 1:])", "\n\n\ndef f():\n    n = int(input())\n    a = list(input())\n    f = list(map(int, input().split()))\n    f_dict = {}\n    for i in range(1, 10):\n        f_dict[i] = f[i - 1]\n    for i in range(n):\n        a[i] = f_dict[int(a[i])]\n    a = ''.join(a)\n    print(a)\n\n\nf()"]