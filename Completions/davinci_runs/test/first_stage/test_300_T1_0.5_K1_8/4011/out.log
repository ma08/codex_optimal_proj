2022-04-19 20:55:02.022778 """
You are given a long decimal number $a$ consisting of $n$ digits from $1$ to $9$. You also have a function $f$ that maps every digit from $1$ to $9$ to some (possibly the same) digit from $1$ to $9$.

You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $a$, and replace each digit $x$ from this segment with $f(x)$. For example, if $a = 1337$, $f(1) = 1$, $f(3) = 5$, $f(7) = 3$, and you choose the segment consisting of three rightmost digits, you get $1553$ as the result.

What is the maximum possible number you can obtain applying this operation no more than once?


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of digits in $a$.

The second line contains a string of $n$ characters, denoting the number $a$. Each character is a decimal digit from $1$ to $9$.

The third line contains exactly $9$ integers $f(1)$, $f(2)$, ..., $f(9)$ ($1 \le f(i) \le 9$).


-----Output-----

Print the maximum number you can get after applying the operation described in the statement no more than once.


-----Examples-----
Input
4
1337
1 2 5 4 6 6 3 1 9

Output
1557

Input
5
11111
9 8 7 6 5 4 3 2 1

Output
99999

Input
2
33
1 1 1 1 1 1 1 1 1

Output
33
"""
2022-04-19 20:55:02.022801 --------------------------
2022-04-19 20:55:02.022980 using api key derek
2022-04-19 20:55:02.201416 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-19 20:55:07.206832 """
You are given a long decimal number $a$ consisting of $n$ digits from $1$ to $9$. You also have a function $f$ that maps every digit from $1$ to $9$ to some (possibly the same) digit from $1$ to $9$.

You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $a$, and replace each digit $x$ from this segment with $f(x)$. For example, if $a = 1337$, $f(1) = 1$, $f(3) = 5$, $f(7) = 3$, and you choose the segment consisting of three rightmost digits, you get $1553$ as the result.

What is the maximum possible number you can obtain applying this operation no more than once?


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of digits in $a$.

The second line contains a string of $n$ characters, denoting the number $a$. Each character is a decimal digit from $1$ to $9$.

The third line contains exactly $9$ integers $f(1)$, $f(2)$, ..., $f(9)$ ($1 \le f(i) \le 9$).


-----Output-----

Print the maximum number you can get after applying the operation described in the statement no more than once.


-----Examples-----
Input
4
1337
1 2 5 4 6 6 3 1 9

Output
1557

Input
5
11111
9 8 7 6 5 4 3 2 1

Output
99999

Input
2
33
1 1 1 1 1 1 1 1 1

Output
33
"""
2022-04-19 20:55:07.206873 --------------------------
2022-04-19 20:55:07.206987 using api key derek
2022-04-19 20:55:07.243240 in retry 5 10 <class 'Exception'>, Retrying in 10 seconds...
2022-04-19 20:55:17.253623 """
You are given a long decimal number $a$ consisting of $n$ digits from $1$ to $9$. You also have a function $f$ that maps every digit from $1$ to $9$ to some (possibly the same) digit from $1$ to $9$.

You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $a$, and replace each digit $x$ from this segment with $f(x)$. For example, if $a = 1337$, $f(1) = 1$, $f(3) = 5$, $f(7) = 3$, and you choose the segment consisting of three rightmost digits, you get $1553$ as the result.

What is the maximum possible number you can obtain applying this operation no more than once?


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of digits in $a$.

The second line contains a string of $n$ characters, denoting the number $a$. Each character is a decimal digit from $1$ to $9$.

The third line contains exactly $9$ integers $f(1)$, $f(2)$, ..., $f(9)$ ($1 \le f(i) \le 9$).


-----Output-----

Print the maximum number you can get after applying the operation described in the statement no more than once.


-----Examples-----
Input
4
1337
1 2 5 4 6 6 3 1 9

Output
1557

Input
5
11111
9 8 7 6 5 4 3 2 1

Output
99999

Input
2
33
1 1 1 1 1 1 1 1 1

Output
33
"""
2022-04-19 20:55:17.253661 --------------------------
2022-04-19 20:55:17.253775 using api key gabby
2022-04-19 20:55:42.535320 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef solve(n, a, f):\n    a = list(a)\n    max_num = int(''.join(a))\n    for i in range(n):\n        for j in range(i, n):\n            b = a[:]\n            for k in range(i, j + 1):\n                b[k] = str(f[int(b[k]) - 1])\n            max_num = max(max_num, int(''.join(b)))\n    return max_num\n\nn = int(sys.stdin.readline())\na = sys.stdin.readline().strip()\nf = [int(x) for x in sys.stdin.readline().split()]\n\nprint(solve(n, a, f))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = input()\nf = [int(x) for x in input().split()]\n\na_list = [int(x) for x in a]\n\n# create a list of tuples\na_list_tuples = [(x, i) for i, x in enumerate(a_list)]\n\n# sort the list of tuples\na_list_tuples = sorted(a_list_tuples, key=lambda x: f[x[0]-1])\n\n# create a list of tuples for the sorted list of tuples\n# this will help us find the index of the element in the original list\na_list_tuples_sorted = [(x, i) for i, x in enumerate(a_list_tuples)]\n\n# sort the list of tuples by the original index\na_list_tuples_sorted = sorted(a_list_tuples_sorted, key=lambda x: x[1])\n\n# get a list of the values of the sorted list of tuples\na_list_sorted = [x[0] for x in a_list_tuples_sorted]\n\n# get the index of the first element in the sorted list which is not the same as the original list\nfor i in range(n):\n    if a_list[i] != a_list_sorted[i]:\n        break\n\n# if the index is the last element, we are done\nif i == n-1:\n    print(a)\nelse:\n    # otherwise, change the first element of the sorted list which is not the same as the original list\n    a_list_sorted[i] = a_list[i]\n    print(''.join([str(x) for x in a_list_sorted]))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = input()\n    f = [int(x) for x in input().split()]\n    f_inv = [0 for x in range(10)]\n    for i in range(1, 10):\n        f_inv[f[i-1]] = i\n    a = [int(x) for x in a]\n    a_inv = [f_inv[x] for x in a]\n    a_inv_str = \"\".join([str(x) for x in a_inv])\n    a_str = \"\".join([str(x) for x in a])\n    print(max(a_inv_str, a_str))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n\ndef f():\n    n = int(input())\n    a = list(input())\n    f = list(map(int, input().split()))\n    f_dict = {}\n    for i in range(1, 10):\n        f_dict[i] = f[i - 1]\n    for i in range(n):\n        a[i] = f_dict[int(a[i])]\n    a = ''.join(a)\n    print(a)\n\n\nf()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# First determine the best segment to modify\n\n# Starting from the left, find the first digit that can be increased\nleft = 0\nwhile left < n and f[int(a[left]) - 1] <= int(a[left]):\n    left += 1\n\n# Starting from the right, find the first digit that can be increased\nright = n - 1\nwhile right >= 0 and f[int(a[right]) - 1] <= int(a[right]):\n    right -= 1\n\n# If no digits can be increased, the answer is just a\nif left == n or right == -1:\n    print(a)\n\n# If a digit can be increased, increase the first digit that can be increased\nelse:\n    print(a[:left] + str(f[int(a[left]) - 1]) + a[left + 1:])"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nN = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# find the first digit that can be increased\ni = 0\nwhile a[i] == '9' or f[int(a[i])-1] <= int(a[i]):\n    i += 1\n\n# find the last digit that can be increased\nj = N - 1\nwhile a[j] == '9' or f[int(a[j])-1] <= int(a[j]):\n    j -= 1\n\n# replace the digits in the range [i, j]\nfor k in range(i, j+1):\n    a = a[:k] + str(f[int(a[k])-1]) + a[k+1:]\n\nprint(a)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\na = list(map(int, a))\n\ndef f_a(a, f):\n    res = 0\n    for i in range(len(a)):\n        res = res * 10 + f[a[i] - 1]\n    return res\n\nmax_f = 0\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        x = a[i:j]\n        x = f_a(x, f)\n        if x > max_f:\n            max_f = x\n\nprint(max_f)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n#Solution\n\nn = int(input())\na = list(input())\nf = list(map(int, input().split()))\nfor i in range(n):\n    a[i] = str(f[int(a[i])-1])\nprint(''.join(a))"
    }
  ],
  "created": 1650401717,
  "id": "cmpl-4ypAT2cL1FMRPpSMdkWEbetZmJ3hF",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-19 20:55:42.535742 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef solve(n, a, f):\n    a = list(a)\n    max_num = int(''.join(a))\n    for i in range(n):\n        for j in range(i, n):\n            b = a[:]\n            for k in range(i, j + 1):\n                b[k] = str(f[int(b[k]) - 1])\n            max_num = max(max_num, int(''.join(b)))\n    return max_num\n\nn = int(sys.stdin.readline())\na = sys.stdin.readline().strip()\nf = [int(x) for x in sys.stdin.readline().split()]\n\nprint(solve(n, a, f))"
}
2022-04-19 20:55:42.535787 REASON stop
2022-04-19 20:55:42.536227 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = input()\nf = [int(x) for x in input().split()]\n\na_list = [int(x) for x in a]\n\n# create a list of tuples\na_list_tuples = [(x, i) for i, x in enumerate(a_list)]\n\n# sort the list of tuples\na_list_tuples = sorted(a_list_tuples, key=lambda x: f[x[0]-1])\n\n# create a list of tuples for the sorted list of tuples\n# this will help us find the index of the element in the original list\na_list_tuples_sorted = [(x, i) for i, x in enumerate(a_list_tuples)]\n\n# sort the list of tuples by the original index\na_list_tuples_sorted = sorted(a_list_tuples_sorted, key=lambda x: x[1])\n\n# get a list of the values of the sorted list of tuples\na_list_sorted = [x[0] for x in a_list_tuples_sorted]\n\n# get the index of the first element in the sorted list which is not the same as the original list\nfor i in range(n):\n    if a_list[i] != a_list_sorted[i]:\n        break\n\n# if the index is the last element, we are done\nif i == n-1:\n    print(a)\nelse:\n    # otherwise, change the first element of the sorted list which is not the same as the original list\n    a_list_sorted[i] = a_list[i]\n    print(''.join([str(x) for x in a_list_sorted]))"
}
2022-04-19 20:55:42.536281 REASON stop
2022-04-19 20:55:42.536695 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = input()\n    f = [int(x) for x in input().split()]\n    f_inv = [0 for x in range(10)]\n    for i in range(1, 10):\n        f_inv[f[i-1]] = i\n    a = [int(x) for x in a]\n    a_inv = [f_inv[x] for x in a]\n    a_inv_str = \"\".join([str(x) for x in a_inv])\n    a_str = \"\".join([str(x) for x in a])\n    print(max(a_inv_str, a_str))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-19 20:55:42.536823 REASON stop
2022-04-19 20:55:42.561933 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n\ndef f():\n    n = int(input())\n    a = list(input())\n    f = list(map(int, input().split()))\n    f_dict = {}\n    for i in range(1, 10):\n        f_dict[i] = f[i - 1]\n    for i in range(n):\n        a[i] = f_dict[int(a[i])]\n    a = ''.join(a)\n    print(a)\n\n\nf()"
}
2022-04-19 20:55:42.562066 REASON stop
2022-04-19 20:55:42.565854 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# First determine the best segment to modify\n\n# Starting from the left, find the first digit that can be increased\nleft = 0\nwhile left < n and f[int(a[left]) - 1] <= int(a[left]):\n    left += 1\n\n# Starting from the right, find the first digit that can be increased\nright = n - 1\nwhile right >= 0 and f[int(a[right]) - 1] <= int(a[right]):\n    right -= 1\n\n# If no digits can be increased, the answer is just a\nif left == n or right == -1:\n    print(a)\n\n# If a digit can be increased, increase the first digit that can be increased\nelse:\n    print(a[:left] + str(f[int(a[left]) - 1]) + a[left + 1:])"
}
2022-04-19 20:55:42.565969 REASON stop
2022-04-19 20:55:42.568579 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nN = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# find the first digit that can be increased\ni = 0\nwhile a[i] == '9' or f[int(a[i])-1] <= int(a[i]):\n    i += 1\n\n# find the last digit that can be increased\nj = N - 1\nwhile a[j] == '9' or f[int(a[j])-1] <= int(a[j]):\n    j -= 1\n\n# replace the digits in the range [i, j]\nfor k in range(i, j+1):\n    a = a[:k] + str(f[int(a[k])-1]) + a[k+1:]\n\nprint(a)"
}
2022-04-19 20:55:42.568680 REASON stop
2022-04-19 20:55:42.569574 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\na = list(map(int, a))\n\ndef f_a(a, f):\n    res = 0\n    for i in range(len(a)):\n        res = res * 10 + f[a[i] - 1]\n    return res\n\nmax_f = 0\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        x = a[i:j]\n        x = f_a(x, f)\n        if x > max_f:\n            max_f = x\n\nprint(max_f)"
}
2022-04-19 20:55:42.569757 REASON stop
2022-04-19 20:55:42.571604 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n#Solution\n\nn = int(input())\na = list(input())\nf = list(map(int, input().split()))\nfor i in range(n):\n    a[i] = str(f[int(a[i])-1])\nprint(''.join(a))"
}
2022-04-19 20:55:42.571691 REASON stop
