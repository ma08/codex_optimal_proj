["\n\nimport sys\n\ndef main():\n    N, M, K = map(int, sys.stdin.readline().strip().split())\n    roads = []\n    for _ in range(M):\n        roads.append(tuple(map(int, sys.stdin.readline().strip().split())))\n    #print roads\n    road_dict = {}\n    for road in roads:\n        if road[0] in road_dict:\n            road_dict[road[0]].append(road[1])\n        else:\n            road_dict[road[0]] = [road[1]]\n        if road[1] in road_dict:\n            road_dict[road[1]].append(road[0])\n        else:\n            road_dict[road[1]] = [road[0]]\n    #print road_dict\n    #print N, M, K\n    #print road_dict\n\n    def dfs(road_dict, start_city, visited_cities, visited_roads):\n        if start_city not in road_dict:\n            return visited_roads\n        else:\n            for city in road_dict[start_city]:\n                if city not in visited_cities:\n                    visited_cities.append(city)\n                    visited_roads.append([start_city, city])\n                    visited_roads = dfs(road_dict, city, visited_cities, visited_roads)\n            return visited_roads\n\n    #print dfs(road_dict, 1, [1], [])\n    visited_roads = dfs(road_dict, 1, [1], [])\n    #print visited_roads\n\n    def dfs_prune(road_dict, start_city, visited_cities, visited_roads):\n        if start_city not in road_dict:\n            return visited_roads\n        else:\n            for city in road_dict[start_city]:\n                if city not in visited_cities:\n                    visited_cities.append(city)\n                    visited_roads.append([start_city, city])\n                    visited_roads = dfs_prune(road_dict, city, visited_cities, visited_roads)\n            return visited_roads\n\n    def prune_roads(road_dict, visited_roads):\n        #print visited_roads\n        pruned_roads = []\n        for road in visited_roads:\n            new_road_dict = dict(road_dict)\n            new_road_dict[road[0]].remove(road[1])\n            new_road_dict[road[1]].remove(road[0])\n            #print new_road_dict\n            visited_roads_pruned = dfs_prune(new_road_dict, 1, [1], [])\n            #print len(visited_roads_pruned), len(visited_roads)\n            if len(visited_roads_pruned) == len(visited_roads) - 1:\n                #print visited_roads_pruned\n                pruned_roads.append(road)\n        return pruned_roads\n\n    #print prune_roads(road_dict, visited_roads)\n    pruned_roads = prune_roads(road_dict, visited_roads)\n    #print pruned_roads\n    pruned_roads_set = set(map(tuple, pruned_roads))\n    #print pruned_roads_set\n\n    def binary_representation(roads, pruned_roads):\n        binary_rep = []\n        for road in roads:\n            if road in pruned_roads_set:\n                binary_rep.append('1')\n            else:\n                binary_rep.append('0')\n        return ''.join(binary_rep)\n\n    #print binary_representation(roads, pruned_roads)\n\n    binary_rep_set = set()\n    for i in range(len(pruned_roads)):\n        binary_rep_set.add(binary_representation(roads, pruned_roads[:i] + pruned_roads[i+1:]))\n        if len(binary_rep_set) == K:\n            break\n    #print binary_rep_set\n\n    print len(binary_rep_set)\n    for binary_rep in binary_rep_set:\n        print binary_rep\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn, m, k = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(lambda x: int(x) - 1, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nvisited = [False] * n\n\ndef dfs(v):\n    visited[v] = True\n    for w in graph[v]:\n        if not visited[w]:\n            dfs(w)\n\ndfs(0)\n\nif any(not visited):\n    print(0)\n    exit()\n\ndef dfs_for_dist(v, dist):\n    visited[v] = True\n    for w in graph[v]:\n        if not visited[w]:\n            dfs_for_dist(w, dist + 1)\n\nvisited = [False] * n\ndfs_for_dist(0, 0)\n\nif any(not visited):\n    print(0)\n    exit()\n\nvisited = [False] * n\n\ndef dfs_for_k(v, dist, k):\n    visited[v] = True\n    if dist > k:\n        return\n    if dist == k:\n        if all(visited):\n            print(1)\n            print('1' * m)\n            exit()\n        return\n\n    for w in graph[v]:\n        if not visited[w]:\n            dfs_for_k(w, dist + 1, k)\n\ndfs_for_k(0, 0, k)\n\nprint(0)", "\n\nimport heapq\nimport sys\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.adj = []\n        self.visited = False\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    nodes = [Node(i) for i in range(n)]\n    for i in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().split()]\n        nodes[a-1].adj.append(nodes[b-1])\n        nodes[b-1].adj.append(nodes[a-1])\n    #print(nodes[0].adj[0].id)\n    dists = dijkstra(nodes)\n    #print(dists)\n    print(len(dists))\n    for d in dists:\n        print(d)\n\ndef dijkstra(nodes):\n    dist = 0\n    dist_nodes = []\n    heapq.heappush(dist_nodes, (0, nodes[0]))\n    while dist_nodes:\n        #print(dist_nodes)\n        d, n = heapq.heappop(dist_nodes)\n        if n.visited:\n            continue\n        n.visited = True\n        dist += d\n        for node in n.adj:\n            if node.visited:\n                continue\n            heapq.heappush(dist_nodes, (1, node))\n    return dist\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport os\nfrom collections import defaultdict\nfrom heapq import *\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.vertices = set()\n        self.edges = []\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append((v, w))\n        self.graph[v].append((u, w))\n        self.vertices.add(u)\n        self.vertices.add(v)\n        self.edges.append((u, v, w))\n\n    def prim(self, start):\n        visited = set()\n        visited.add(start)\n        heap = []\n        for v, w in self.graph[start]:\n            heappush(heap, (w, v))\n        mst = []\n        while heap:\n            weight, v = heappop(heap)\n            if v not in visited:\n                visited.add(v)\n                mst.append((start, v, weight))\n                for v_, w_ in self.graph[v]:\n                    if v_ not in visited:\n                        heappush(heap, (w_, v_))\n        return mst\n\n    def kruskal(self):\n        self.edges.sort(key=lambda x: x[2])\n        mst = []\n        for u, v, w in self.edges:\n            if u not in self.vertices or v not in self.vertices:\n                continue\n            self.vertices.remove(u)\n            self.vertices.remove(v)\n            mst.append((u, v, w))\n            if len(self.vertices) == 0:\n                break\n        return mst\n\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    g = Graph()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().strip().split())\n        g.add_edge(u, v, 1)\n    mst = g.kruskal()\n    #print(mst)\n\n    mst_edges = set()\n    for u, v, w in mst:\n        mst_edges.add((u, v))\n        mst_edges.add((v, u))\n\n    for u, v, w in g.edges:\n        if (u, v) in mst_edges:\n            print(0, end='')\n        else:\n            print(1, end='')\n    print()\n\n\nif __name__ == '__main__':\n    main()", "\n\n# Use this class to create binary trees\nclass Node:\n    def __init__(self, value, parent):\n        self.value = value\n        self.parent = parent\n        self.left = None\n        self.right = None\n\n    # Use this function to add a new node to the binary tree\n    def add(self, val):\n        if val <= self.value:\n            if self.left is None:\n                self.left = Node(val, self)\n            else:\n                self.left.add(val)\n        else:\n            if self.right is None:\n                self.right = Node(val, self)\n            else:\n                self.right.add(val)\n\n    def get_min(self):\n        if self.left is None:\n            return self\n        else:\n            return self.left.get_min()\n\n    # Use this function to check if a node exists in the binary tree\n    def exists(self, val):\n        if val == self.value:\n            return True\n        elif val < self.value:\n            if self.left is None:\n                return False\n            else:\n                return self.left.exists(val)\n        else:\n            if self.right is None:\n                return False\n            else:\n                return self.right.exists(val)\n\n    # Use this function to remove a node from the binary tree\n    def remove(self, val, parent):\n        if val < self.value:\n            if self.left is not None:\n                self.left.remove(val, self)\n        elif val > self.value:\n            if self.right is not None:\n                self.right.remove(val, self)\n        else:\n            if self.left is not None and self.right is not None:\n                self.value = self.right.get_min().value\n                self.right.remove(self.value, self)\n            elif parent.left == self:\n                if self.left is not None:\n                    temp = self.left\n                else:\n                    temp = self.right\n                parent.left = temp\n            elif parent.right == self:\n                if self.left is not None:\n                    temp = self.left\n                else:\n                    temp = self.right\n                parent.right = temp\n\n\n# Use this function to check if a binary tree is a BST\ndef is_bst(root):\n    if root is None:\n        return True\n    if root.left is not None and root.left.value > root.value:\n        return False\n    if root.right is not None and root.right.value < root.value:\n        return False\n    if not is_bst(root.left) or not is_bst(root.right):\n        return False\n    return True\n\n\ndef main():\n    # Read input\n    n, m, k = [int(i) for i in input().split()]\n\n    # Create a binary tree with the first value\n    root = Node(int(input().split()[0]), None)\n\n    # Add the rest of the values to the binary tree\n    for i in range(n - 1):\n        root.add(int(input().split()[0]))\n\n    # Check if the binary tree is a BST\n    if is_bst(root):\n        print('YES')\n    else:\n        print('NO')\n\n\nif __name__ == '__main__':\n    main()", "\n\n# Solution\n\nimport sys\n\n# Build a graph from the input.\n# The graph is represented as a dictionary where each key is a node and the associated value is a list of its neighbors.\nn, m, k = map(int, sys.stdin.readline().split())\nedges = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\ngraph = {i: [] for i in range(1, n+1)}\nfor a, b in edges:\n    graph[a].append(b)\n    graph[b].append(a)\n\n# Find the shortest paths from the capital to all other cities.\n# The shortest paths are represented as a dictionary where each key is a city and the associated value is the length of the shortest path from the capital to the city.\ndistances = {i: -1 for i in range(1, n+1)}\ndistances[1] = 0\nto_visit = [1]\nwhile to_visit:\n    current = to_visit.pop(0)\n    for neighbor in graph[current]:\n        if distances[neighbor] == -1:\n            distances[neighbor] = distances[current] + 1\n            to_visit.append(neighbor)\n\n# Sort the edges by their length in increasing order.\n# Each edge is represented as a tuple (city1, city2, length).\nsorted_edges = sorted([(a, b, distances[a] + distances[b]) for a, b in edges], key=lambda x: x[2])\n\n# Find the $k$ shortest paths from the capital to all other cities.\n# Each path is represented as a dictionary where each key is a city and the associated value is the length of the path from the capital to the city.\n# The paths are stored in a list of dictionaries.\npaths = [{1: 0}]\nfor _ in range(k-1):\n    # Add the shortest edge that connects the current path with another city.\n    for edge in sorted_edges:\n        if edge[0] in paths[-1] and edge[1] not in paths[-1]:\n            paths[-1][edge[1]] = edge[2]\n            break\n        elif edge[1] in paths[-1] and edge[0] not in paths[-1]:\n            paths[-1][edge[0]] = edge[2]\n            break\n    # If no edge can be added, then there are no more paths.\n    else:\n        break\n    paths.append({1: 0})\n\n# Output the paths.\nprint(len(paths))\nfor path in paths:\n    print(''.join('1' if (a, b) in edges and b in path else '0' for a, b in edges))"]