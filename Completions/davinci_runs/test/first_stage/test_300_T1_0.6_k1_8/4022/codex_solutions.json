["\n\ndef main():\n    n = int(input())\n    l = []\n    r = []\n    for _ in range(n):\n        i, j = map(int, input().split())\n        l.append(i)\n        r.append(j)\n    # print(l, r)\n    # print(max(r[1:]))\n    print(max(max(r[:i]) - min(l[i+1:]) for i in range(n)))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(tuple(map(int,input().split())))\n    l.sort()\n    ans = 0\n    for i in range(1,n):\n        ans = max(ans,min(l[i][1],l[i-1][1])-max(l[i][0],l[i-1][0]))\n    print(ans)\n\nmain()", "\n\n# This problem is equivalent to finding the minimum of the following function:\n# f(x) = max(r_i - l_i) + max(r_j - l_j)\n# where i != j, l_i <= x <= r_i, l_j <= x <= r_j\n# Assume that the segments are sorted by l_i in ascending order.\n# We can find the max(r_i - l_i) + max(r_j - l_j) for all i, j by using two pointers\n# The answer is the minimum of f(x) for all x\n\nimport math\nimport sys\n\nn = int(input())\n# l = [int(num) for num in input().split()]\n# r = [int(num) for num in input().split()]\n\nsegments = []\nfor i in range(n):\n    l_i, r_i = map(int, input().split())\n    segments.append([l_i, r_i])\n\nsegments.sort()\n\n# print(segments)\n\nmax_length = 0\nright_bound = segments[0][1]\nleft_bound = segments[0][0]\n\n# print(left_bound)\n# print(right_bound)\n\nfor i in range(1, n):\n    left_bound = min(left_bound, segments[i][0])\n    right_bound = max(right_bound, segments[i][1])\n    # print(left_bound)\n    # print(right_bound)\n    max_length = max(max_length, right_bound - left_bound)\n\nprint(max_length)", "\n#Solution\ndef solve(A, l, r): \n    if l > r: \n        return 0\n    if l == r: \n        return A[l][1] - A[l][0]\n    mid = (l + r)//2\n    ans = max(solve(A, l, mid), solve(A, mid+1, r)) \n    mn = A[mid][1] \n    mx = A[mid+1][0] \n    ans = max(ans, mx - mn) \n    i = mid \n    j = mid + 1\n    cnt = 0\n    while i >= l and j <= r and cnt < 2: \n        if A[i][1] < A[j][0]: \n            break\n        mn = min(A[i][0], A[j][0]) \n        mx = max(A[i][1], A[j][1]) \n        ans = max(ans, mx - mn) \n        if A[i][1] > A[j][1]: \n            j += 1\n        else: \n            i -= 1\n        cnt += 1\n    return ans \nn = int(input())\nA = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    A.append([a, b])\nA.sort()\nans = solve(A, 0, n-1)\nprint(ans)", "\n\nn = int(input())\nsegments = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\n\ndef get_intersection_length(i, segments):\n    if i == 0:\n        l = segments[0][0]\n        r = segments[0][1]\n        for j in range(1, len(segments)):\n            l = max(l, segments[j][0])\n            r = min(r, segments[j][1])\n        return r - l + 1\n    else:\n        return get_intersection_length(0, segments[:i] + segments[i + 1:])\n\n\nmax_length = 0\nfor i in range(n):\n    max_length = max(max_length, get_intersection_length(i, segments))\n\nprint(max_length)", "\n\n# Solution 1\nn = int(input())\nl = [list(map(int, input().split())) for _ in range(n)]\nl.sort()\n\nans = 0\nfor i in range(1, n):\n    if l[i][0] <= l[i - 1][1]:\n        l[i][0] = l[i - 1][0]\n        ans = max(ans, l[i][1] - l[i][0])\n\nprint(ans)\n\n# Solution 2\nn = int(input())\nl = [list(map(int, input().split())) for _ in range(n)]\nl.sort()\n\nans = 0\nfor i in range(1, n):\n    if l[i][0] <= l[i - 1][1]:\n        l[i][0] = l[i - 1][0]\n        ans = max(ans, l[i][1] - l[i][0])\n    else:\n        ans = max(ans, l[i - 1][1] - l[i - 1][0])\n\nprint(ans)", "\n\ndef find_intersection(n, segs):\n    seg_pts = [0] * (2*n)\n    for i in range(n):\n        seg_pts[2*i] = segs[i][0]\n        seg_pts[2*i+1] = segs[i][1]\n    seg_pts.sort()\n    seg_pts.append(float('inf'))\n    seg_counts = [0] * (2*n+1)\n    seg_count = 0\n    seg_counts[0] = 1\n    max_len = 0\n    for i in range(2*n+1):\n        seg_count += seg_counts[i]\n        if seg_count == n:\n            max_len = max(max_len, seg_pts[i] - seg_pts[i-n])\n        elif seg_count == n - 1:\n            max_len = max(max_len, seg_pts[i] - seg_pts[i-n+1])\n        seg_count -= seg_counts[i]\n        seg_counts[i+1] = -seg_counts[i]\n    return max_len\n\n\nn = int(input())\nsegs = [[0,0] for _ in range(n)]\nfor i in range(n):\n    seg = [int(x) for x in input().split()]\n    segs[i][0] = seg[0]\n    segs[i][1] = seg[1]\nprint(find_intersection(n, segs))", "\n\n\ndef solve(n, segments):\n\tsegments.sort(key = lambda x: (x[1], x[0]))\n\tmax_intersect = 0\n\tfor i in range(n):\n\t\tintersect = segments[i][1] - segments[i][0] + 1\n\t\tif i > 0:\n\t\t\tintersect = min(intersect, segments[i][0] - segments[i - 1][1])\n\t\tif i < n - 1:\n\t\t\tintersect = min(intersect, segments[i + 1][0] - segments[i][1])\n\t\tmax_intersect = max(max_intersect, intersect)\n\treturn max_intersect\n\nif __name__ == '__main__':\n\tn = int(input())\n\tsegments = []\n\tfor _ in range(n):\n\t\tl, r = map(int, input().split())\n\t\tsegments.append((l, r))\n\tprint(solve(n, segments))"]