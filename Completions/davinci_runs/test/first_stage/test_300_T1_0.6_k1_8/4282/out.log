2022-04-16 20:41:42.921046 """
There are $n$ kids, numbered from $1$ to $n$, dancing in a circle around the Christmas tree. Let's enumerate them in a clockwise direction as $p_1$, $p_2$, ..., $p_n$ (all these numbers are from $1$ to $n$ and are distinct, so $p$ is a permutation). Let the next kid for a kid $p_i$ be kid $p_{i + 1}$ if $i < n$ and $p_1$ otherwise. After the dance, each kid remembered two kids: the next kid (let's call him $x$) and the next kid for $x$. Each kid told you which kids he/she remembered: the kid $i$ remembered kids $a_{i, 1}$ and $a_{i, 2}$. However, the order of $a_{i, 1}$ and $a_{i, 2}$ can differ from their order in the circle. [Image] Example: 5 kids in a circle, $p=[3, 2, 4, 1, 5]$ (or any cyclic shift). The information kids remembered is: $a_{1,1}=3$, $a_{1,2}=5$; $a_{2,1}=1$, $a_{2,2}=4$; $a_{3,1}=2$, $a_{3,2}=4$; $a_{4,1}=1$, $a_{4,2}=5$; $a_{5,1}=2$, $a_{5,2}=3$. 

You have to restore the order of the kids in the circle using this information. If there are several answers, you may print any. It is guaranteed that at least one solution exists.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.


-----Input-----

The first line of the input contains one integer $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of the kids.

The next $n$ lines contain $2$ integers each. The $i$-th line contains two integers $a_{i, 1}$ and $a_{i, 2}$ ($1 \le a_{i, 1}, a_{i, 2} \le n, a_{i, 1} \ne a_{i, 2}$) — the kids the $i$-th kid remembered, given in arbitrary order.


-----Output-----

Print $n$ integers $p_1$, $p_2$, ..., $p_n$ — permutation of integers from $1$ to $n$, which corresponds to the order of kids in the circle. If there are several answers, you may print any (for example, it doesn't matter which kid is the first in the circle). It is guaranteed that at least one solution exists.


-----Examples-----
Input
5
3 5
1 4
2 4
1 5
2 3

Output
3 2 4 1 5 

Input
3
2 3
3 1
1 2

Output
3 1 2
"""
2022-04-16 20:41:42.921074 --------------------------
2022-04-16 20:42:03.814301 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = []\nfor _ in range(n):\n    a.append(list(map(int,input().split())))\n\n# print(a)\n\n# first, find the first element\nfor i in range(n):\n    if a[i][0] in a[a[i][1] - 1]:\n        start = i + 1\n        break\n\n# print(start)\n\n\n# now, find the rest of the sequence\ncur = start\nres = [cur]\nwhile True:\n    for i in range(n):\n        if a[i][0] == cur:\n            if a[i][1] not in res:\n                cur = a[i][1]\n                res.append(cur)\n                break\n        elif a[i][1] == cur:\n            if a[i][0] not in res:\n                cur = a[i][0]\n                res.append(cur)\n                break\n    if len(res) == n:\n        break\n\n# print(res)\n\nfor i in range(n):\n    print(res[i], end=' ')\nprint()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = [[0,0] for i in range(n)]\n    for i in range(n):\n        a[i][0], a[i][1] = [int(x) - 1 for x in input().split()]\n    p = [0 for i in range(n)]\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = i + 1\n            d = a[i][1] - a[i][0]\n            if d < 0:\n                d += n\n            p[(i + d) % n] = (i + d + 1) % n + 1\n    print(' '.join([str(x) for x in p]))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.data = defaultdict(list)\n        self.visited = set()\n\n    def add_edge(self, u, v):\n        self.data[u].append(v)\n        self.data[v].append(u)\n\n    def dfs(self, u):\n        self.visited.add(u)\n        for v in self.data[u]:\n            if v not in self.visited:\n                self.dfs(v)\n        self.visited.remove(u)\n        print(u, end=\" \")\n\ndef main():\n    n = int(input())\n    g = Graph()\n    for i in range(1, n + 1):\n        a, b = map(int, input().split())\n        g.add_edge(i, a)\n        g.add_edge(i, b)\n    g.dfs(1)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = [[0, 0] for i in range(n)]\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n\np = [0 for i in range(n)]\np[0] = a[0][0]\np[1] = a[0][1]\n\nfor i in range(2, n):\n    p[i] = a[p[i - 1] - 1][1] if a[p[i - 1] - 1][0] == p[i - 2] else a[p[i - 1] - 1][0]\n\nprint(*p)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    1. get the number of kids\n    2. get the two kids each kid remembers\n    3. find a permutation of the kids that matches the input\n    4. print the permutation\n    \"\"\"\n    n = int(input())\n    if n < 3 or n > 200000:\n        return \"Error\"\n    kids = list(range(1, n+1))\n    kids_remembered = []\n    for _ in range(n):\n        kids_remembered.append(list(map(int, input().split())))\n    # print(kids_remembered)\n    # print(kids)\n    n = n - 1\n    while n > 0:\n        for i in range(n):\n            if kids[i] == kids_remembered[i][0]:\n                kids[i], kids[i+1] = kids[i+1], kids[i]\n            elif kids[i] == kids_remembered[i][1]:\n                kids[i], kids[i+1] = kids[i+1], kids[i]\n            else:\n                return \"Error\"\n        n = n - 1\n    # print(kids)\n    print(*kids)\n    return kids\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n# n = int(input())\n# a = [list(map(int, input().split())) for _ in range(n)]\n# a = [[3, 5], [1, 4], [2, 4], [1, 5], [2, 3]]\na = [[2, 3], [3, 1], [1, 2]]\n\n# build a graph\ngraph = [[] for _ in range(len(a) + 1)]\nfor i, j in enumerate(a):\n    graph[i + 1] = j\n\n# dfs\nvisited = set()\ndef dfs(v):\n    global visited\n    visited.add(v)\n    for u in graph[v]:\n        if u not in visited:\n            dfs(u)\n\n# find connected components\ncc = 0\nfor v in range(1, len(graph)):\n    if v not in visited:\n        cc += 1\n        dfs(v)\n\nif cc == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    p = [0] * n\n    p[0] = 1\n    i = 0\n    j = 0\n    while i < n and j < n:\n        if a[i][0] == p[j]:\n            p[i + 1] = a[i][1]\n            i += 1\n        elif a[i][1] == p[j]:\n            p[i + 1] = a[i][0]\n            i += 1\n        j += 1\n    for i in range(n):\n        print(p[i], end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650141703,
  "id": "cmpl-4xjWhC8BrL181SGxOtUi5zGtpCZaU",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:42:03.814611 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = []\nfor _ in range(n):\n    a.append(list(map(int,input().split())))\n\n# print(a)\n\n# first, find the first element\nfor i in range(n):\n    if a[i][0] in a[a[i][1] - 1]:\n        start = i + 1\n        break\n\n# print(start)\n\n\n# now, find the rest of the sequence\ncur = start\nres = [cur]\nwhile True:\n    for i in range(n):\n        if a[i][0] == cur:\n            if a[i][1] not in res:\n                cur = a[i][1]\n                res.append(cur)\n                break\n        elif a[i][1] == cur:\n            if a[i][0] not in res:\n                cur = a[i][0]\n                res.append(cur)\n                break\n    if len(res) == n:\n        break\n\n# print(res)\n\nfor i in range(n):\n    print(res[i], end=' ')\nprint()"
}
2022-04-16 20:42:03.814709 REASON stop
2022-04-16 20:42:03.851606 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = [[0,0] for i in range(n)]\n    for i in range(n):\n        a[i][0], a[i][1] = [int(x) - 1 for x in input().split()]\n    p = [0 for i in range(n)]\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = i + 1\n            d = a[i][1] - a[i][0]\n            if d < 0:\n                d += n\n            p[(i + d) % n] = (i + d + 1) % n + 1\n    print(' '.join([str(x) for x in p]))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:42:03.851779 REASON stop
2022-04-16 20:42:03.852325 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.data = defaultdict(list)\n        self.visited = set()\n\n    def add_edge(self, u, v):\n        self.data[u].append(v)\n        self.data[v].append(u)\n\n    def dfs(self, u):\n        self.visited.add(u)\n        for v in self.data[u]:\n            if v not in self.visited:\n                self.dfs(v)\n        self.visited.remove(u)\n        print(u, end=\" \")\n\ndef main():\n    n = int(input())\n    g = Graph()\n    for i in range(1, n + 1):\n        a, b = map(int, input().split())\n        g.add_edge(i, a)\n        g.add_edge(i, b)\n    g.dfs(1)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:42:03.852389 REASON stop
2022-04-16 20:42:03.867668 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = [[0, 0] for i in range(n)]\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n\np = [0 for i in range(n)]\np[0] = a[0][0]\np[1] = a[0][1]\n\nfor i in range(2, n):\n    p[i] = a[p[i - 1] - 1][1] if a[p[i - 1] - 1][0] == p[i - 2] else a[p[i - 1] - 1][0]\n\nprint(*p)"
}
2022-04-16 20:42:03.867805 REASON stop
2022-04-16 20:42:03.876912 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:42:03.877049 REASON stop
2022-04-16 20:42:03.878221 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    1. get the number of kids\n    2. get the two kids each kid remembers\n    3. find a permutation of the kids that matches the input\n    4. print the permutation\n    \"\"\"\n    n = int(input())\n    if n < 3 or n > 200000:\n        return \"Error\"\n    kids = list(range(1, n+1))\n    kids_remembered = []\n    for _ in range(n):\n        kids_remembered.append(list(map(int, input().split())))\n    # print(kids_remembered)\n    # print(kids)\n    n = n - 1\n    while n > 0:\n        for i in range(n):\n            if kids[i] == kids_remembered[i][0]:\n                kids[i], kids[i+1] = kids[i+1], kids[i]\n            elif kids[i] == kids_remembered[i][1]:\n                kids[i], kids[i+1] = kids[i+1], kids[i]\n            else:\n                return \"Error\"\n        n = n - 1\n    # print(kids)\n    print(*kids)\n    return kids\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:42:03.878308 REASON stop
2022-04-16 20:42:03.879214 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n# n = int(input())\n# a = [list(map(int, input().split())) for _ in range(n)]\n# a = [[3, 5], [1, 4], [2, 4], [1, 5], [2, 3]]\na = [[2, 3], [3, 1], [1, 2]]\n\n# build a graph\ngraph = [[] for _ in range(len(a) + 1)]\nfor i, j in enumerate(a):\n    graph[i + 1] = j\n\n# dfs\nvisited = set()\ndef dfs(v):\n    global visited\n    visited.add(v)\n    for u in graph[v]:\n        if u not in visited:\n            dfs(u)\n\n# find connected components\ncc = 0\nfor v in range(1, len(graph)):\n    if v not in visited:\n        cc += 1\n        dfs(v)\n\nif cc == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
}
2022-04-16 20:42:03.879417 REASON stop
2022-04-16 20:42:03.880200 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    p = [0] * n\n    p[0] = 1\n    i = 0\n    j = 0\n    while i < n and j < n:\n        if a[i][0] == p[j]:\n            p[i + 1] = a[i][1]\n            i += 1\n        elif a[i][1] == p[j]:\n            p[i + 1] = a[i][0]\n            i += 1\n        j += 1\n    for i in range(n):\n        print(p[i], end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:42:03.880314 REASON stop
