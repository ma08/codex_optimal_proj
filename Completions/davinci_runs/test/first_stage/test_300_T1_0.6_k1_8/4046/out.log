2022-04-16 19:04:02.543210 """
An array of integers $p_1, p_2, \dots, p_n$ is called a permutation if it contains each number from $1$ to $n$ exactly once. For example, the following arrays are permutations: $[3, 1, 2]$, $[1]$, $[1, 2, 3, 4, 5]$ and $[4, 3, 1, 2]$. The following arrays are not permutations: $[2]$, $[1, 1]$, $[2, 3, 4]$.

Polycarp invented a really cool permutation $p_1, p_2, \dots, p_n$ of length $n$. It is very disappointing, but he forgot this permutation. He only remembers the array $q_1, q_2, \dots, q_{n-1}$ of length $n-1$, where $q_i=p_{i+1}-p_i$.

Given $n$ and $q=q_1, q_2, \dots, q_{n-1}$, help Polycarp restore the invented permutation.


-----Input-----

The first line contains the integer $n$ ($2 \le n \le 2\cdot10^5$) â€” the length of the permutation to restore. The second line contains $n-1$ integers $q_1, q_2, \dots, q_{n-1}$ ($-n < q_i < n$).


-----Output-----

Print the integer -1 if there is no such permutation of length $n$ which corresponds to the given array $q$. Otherwise, if it exists, print $p_1, p_2, \dots, p_n$. Print any such permutation if there are many of them.


-----Examples-----
Input
3
-2 1

Output
3 1 2 
Input
5
1 1 1 1

Output
1 2 3 4 5 
Input
4
-1 2 2

Output
-1
"""
2022-04-16 19:04:02.543226 --------------------------
2022-04-16 19:04:20.887748 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    q = list(map(int, input().split()))\n    cnt = [0] * n\n    for i in q:\n        cnt[i + n + 1] += 1\n    pos = [0] * n\n    for i in range(n):\n        pos[i] = cnt[i] - cnt[i + 2]\n    if sum(pos) != 0:\n        print(-1)\n        return\n    ans = [0] * n\n    for i in range(n):\n        ans[i] = i + 1\n    for i in range(n - 1):\n        ans[i + 1] += q[i]\n        if ans[i + 1] <= 0 or ans[i + 1] > n:\n            print(-1)\n            return\n    print(*ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\nq = list(map(int, input().split()))\n\nif len(q) != n - 1:\n    print(-1)\nelse:\n    p = [0] * n\n    p[0] = q[0]\n    for i in range(1, n):\n        p[i] = p[i-1] + q[i-1]\n\n    if max(p) > n or min(p) < 1:\n        print(-1)\n    else:\n        for i in range(n):\n            print(p[i], end=\" \")"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    q = list(map(int, input().split()))\n    p = [0] * n\n    p[0] = q[0]\n    for i in range(1, n-1):\n        p[i] = p[i-1] + q[i]\n    p[n-1] = p[n-2] + q[n-2]\n    for i in range(n):\n        if p[i] > n or p[i] < 1:\n            print(-1)\n            exit()\n    if len(set(p)) != len(p):\n        print(-1)\n        exit()\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\nn = int(input())\nq = map(int, input().split())\n\ndef f(n, q):\n    if n == 1:\n        return [1]\n    else:\n        if q[-1] >= 0:\n            return [n] + f(n-1, q[:-1])\n        else:\n            return [1] + f(n-1, [q[-1] + x for x in q[:-1]])\n\nans = f(n, list(q))\nif ans[0] < 0:\n    print(-1)\nelse:\n    print(*ans)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef restore_permutation(n, q):\n    q = [q[0]] + q\n    p = [0 for x in range(n+1)]\n    p[0] = q[0]\n    p[1] = q[1]\n    i = 2\n    while i <= n:\n        p[i] = p[i-1] + q[i]\n        if p[i] < 1 or p[i] > n:\n            return [-1]\n        if p[i] in p[:i]:\n            return [-1]\n        i += 1\n    return p[1:]\n\nn = int(input())\nq = [int(x) for x in input().split()]\nprint(' '.join([str(x) for x in restore_permutation(n, q)]))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn = int(input())\nq = [int(x) for x in input().split()]\n\nif sum(q) != 0 or q[0] <= -n or q[-1] >= n or any(q[i] == q[i+1] == 0 for i in range(n-2)):\n    print(-1)\nelse:\n    p = [0]*n\n    p[0] = q[0]\n    p[-1] = -q[-1]\n    for i in range(1, n-1):\n        p[i] = q[i] - p[i-1]\n    print(*p)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    q = [int(item) for item in input().split()]\n    p = [0] * n\n    p[0] = q[0]\n    for i in range(1, len(q)):\n        p[i] = p[i-1] + q[i]\n    if any(i < 1 or i > n for i in p):\n        print(-1)\n    elif len(set(p)) != len(q):\n        print(-1)\n    else:\n        print(*p)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef permutation(n, q):\n    p = [0]*n\n    p[0] = q[0]\n    p[1] = q[1]\n    for i in range(2, n):\n        p[i] = q[i-1] + p[i-1]\n    for i in range(n):\n        if p[i] < 1 or p[i] > n:\n            return -1\n    for i in range(n):\n        for j in range(i+1, n):\n            if p[i] == p[j]:\n                return -1\n    return p\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    q = [int(x) for x in sys.stdin.readline().strip().split()]\n    p = permutation(n, q)\n    if p == -1:\n        print(p)\n    else:\n        for i in range(n):\n            p[i] += i+1\n        print(\" \".join(str(x) for x in p))\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650135842,
  "id": "cmpl-4xi0ADS16C3c6yEhsoU8KFpIgCeD1",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:04:20.888031 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    q = list(map(int, input().split()))\n    cnt = [0] * n\n    for i in q:\n        cnt[i + n + 1] += 1\n    pos = [0] * n\n    for i in range(n):\n        pos[i] = cnt[i] - cnt[i + 2]\n    if sum(pos) != 0:\n        print(-1)\n        return\n    ans = [0] * n\n    for i in range(n):\n        ans[i] = i + 1\n    for i in range(n - 1):\n        ans[i + 1] += q[i]\n        if ans[i + 1] <= 0 or ans[i + 1] > n:\n            print(-1)\n            return\n    print(*ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:04:20.888066 REASON stop
2022-04-16 19:04:20.905292 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\nq = list(map(int, input().split()))\n\nif len(q) != n - 1:\n    print(-1)\nelse:\n    p = [0] * n\n    p[0] = q[0]\n    for i in range(1, n):\n        p[i] = p[i-1] + q[i-1]\n\n    if max(p) > n or min(p) < 1:\n        print(-1)\n    else:\n        for i in range(n):\n            print(p[i], end=\" \")"
}
2022-04-16 19:04:20.905472 REASON stop
2022-04-16 19:04:20.905944 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    q = list(map(int, input().split()))\n    p = [0] * n\n    p[0] = q[0]\n    for i in range(1, n-1):\n        p[i] = p[i-1] + q[i]\n    p[n-1] = p[n-2] + q[n-2]\n    for i in range(n):\n        if p[i] > n or p[i] < 1:\n            print(-1)\n            exit()\n    if len(set(p)) != len(p):\n        print(-1)\n        exit()\n    print(*p)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:04:20.906010 REASON stop
2022-04-16 19:04:20.924316 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\nn = int(input())\nq = map(int, input().split())\n\ndef f(n, q):\n    if n == 1:\n        return [1]\n    else:\n        if q[-1] >= 0:\n            return [n] + f(n-1, q[:-1])\n        else:\n            return [1] + f(n-1, [q[-1] + x for x in q[:-1]])\n\nans = f(n, list(q))\nif ans[0] < 0:\n    print(-1)\nelse:\n    print(*ans)"
}
2022-04-16 19:04:20.924450 REASON stop
2022-04-16 19:04:20.925476 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef restore_permutation(n, q):\n    q = [q[0]] + q\n    p = [0 for x in range(n+1)]\n    p[0] = q[0]\n    p[1] = q[1]\n    i = 2\n    while i <= n:\n        p[i] = p[i-1] + q[i]\n        if p[i] < 1 or p[i] > n:\n            return [-1]\n        if p[i] in p[:i]:\n            return [-1]\n        i += 1\n    return p[1:]\n\nn = int(input())\nq = [int(x) for x in input().split()]\nprint(' '.join([str(x) for x in restore_permutation(n, q)]))"
}
2022-04-16 19:04:20.925628 REASON stop
2022-04-16 19:04:20.951969 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn = int(input())\nq = [int(x) for x in input().split()]\n\nif sum(q) != 0 or q[0] <= -n or q[-1] >= n or any(q[i] == q[i+1] == 0 for i in range(n-2)):\n    print(-1)\nelse:\n    p = [0]*n\n    p[0] = q[0]\n    p[-1] = -q[-1]\n    for i in range(1, n-1):\n        p[i] = q[i] - p[i-1]\n    print(*p)"
}
2022-04-16 19:04:20.952097 REASON stop
2022-04-16 19:04:20.953234 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    q = [int(item) for item in input().split()]\n    p = [0] * n\n    p[0] = q[0]\n    for i in range(1, len(q)):\n        p[i] = p[i-1] + q[i]\n    if any(i < 1 or i > n for i in p):\n        print(-1)\n    elif len(set(p)) != len(q):\n        print(-1)\n    else:\n        print(*p)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:04:20.953316 REASON stop
2022-04-16 19:04:20.954392 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef permutation(n, q):\n    p = [0]*n\n    p[0] = q[0]\n    p[1] = q[1]\n    for i in range(2, n):\n        p[i] = q[i-1] + p[i-1]\n    for i in range(n):\n        if p[i] < 1 or p[i] > n:\n            return -1\n    for i in range(n):\n        for j in range(i+1, n):\n            if p[i] == p[j]:\n                return -1\n    return p\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    q = [int(x) for x in sys.stdin.readline().strip().split()]\n    p = permutation(n, q)\n    if p == -1:\n        print(p)\n    else:\n        for i in range(n):\n            p[i] += i+1\n        print(\" \".join(str(x) for x in p))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:04:20.954520 REASON stop
