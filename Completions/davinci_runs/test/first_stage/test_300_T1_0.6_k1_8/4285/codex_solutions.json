["", "\n\n# If a question mark is replaced by c, then the number of subsequences is the number of subsequences ending in c.\n# If a question mark is replaced by a or b, then the number of subsequences is the number of subsequences not ending in c.\n# The number of subsequences ending in c and not ending in c can be calculated independently, so we can calculate them separately.\n# Let $a_n$ be the number of subsequences ending in c and $b_n$ be the number of subsequences not ending in c.\n# Then $a_n = a_{n - 1} + b_{n - 1}$ and $b_n = a_{n - 1} + b_{n - 1} - a_{n - 2}$.\n# The initial conditions are $a_0 = 1$, $a_1 = 1$, $b_0 = 1$ and $b_1 = 2$.\n#\n# Let $a_n = A_n + B_n$ and $b_n = 2 A_n + B_n$.\n# Then $A_n = A_{n - 1}$ and $B_n = A_{n - 1} + B_{n - 1}$.\n# The initial conditions are $A_0 = 1$, $A_1 = 1$, $B_0 = 0$ and $B_1 = 1$.\n# We can calculate the numbers $A_n$ and $B_n$ using the matrix formula $[A_n, B_n] = [1, 1] [A_{n - 1}, B_{n - 1}]$ for $n \\ge 2$.\n#\n# Now, we have $a_n = A_n + B_n$ and $3^k a_n = 2 A_n + B_n$.\n# So, the total number of subsequences is $3^k a_n + 3^k b_n = 3^k (a_n + b_n) = 3^k (A_n + 2 B_n) = 3^k (1, 2) [A_{k - 1}, B_{k - 1}]$.\n# The matrix formula for the numbers $A_n$ and $B_n$ can be used to calculate $[A_{k - 1}, B_{k - 1}]$ in $O(k \\log k)$ time.\n\nimport sys\n\ndef mod_pow(a, b, mod):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        b //= 2\n    return res\n\n\ndef solve(s):\n    n = len(s)\n    k = s.count(\"?\")\n    assert k >= 0\n\n    if k == 0:\n        res = 0\n        for i in range(n - 2):\n            if s[i] == \"a\" and s[i + 1] == \"b\" and s[i + 2] == \"c\":\n                res += 1\n        return res\n\n    mod = 10 ** 9 + 7\n\n    a = 1\n    b = 1\n    for i in range(k):\n        c = (a + b) % mod\n        a = b\n        b = c\n\n    A = 1\n    B = 0\n    for i in range(k):\n        C = (A + B) % mod\n        A = B\n        B = C\n\n    res = (3 ** k * (1 * A + 2 * B)) % mod\n    return res\n\n\nif __name__ == \"__main__\":\n    s = input()\n    print(solve(s))", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    s = input()\n    MOD = 10**9 + 7\n    a, b, c = 0, 0, 0\n    for i in range(n):\n        if s[i] == '?':\n            a, b, c = (a + b + c) % MOD, a, b\n        elif s[i] == 'a':\n            a = (a * 2 + b + c) % MOD\n        elif s[i] == 'b':\n            b = (b * 2 + a) % MOD\n        else:\n            c = (c * 2 + a + b) % MOD\n    print(a)\n\nif __name__ == '__main__':\n    main()", "\n\n\ndef main():\n    n = int(input())\n    s = input()\n    assert 3 <= n <= 200_000, \"n is out of range\"\n    assert \"?\" in s, \"no question marks\"\n    assert len(s) == n, \"n is not equal to s length\"\n    assert set(s) <= {\"?\", \"a\", \"b\", \"c\"}, \"s contains invalid characters\"\n    assert s.count(\"?\") < n, \"too many question marks\"\n\n    print(solve(s))\n\n\ndef solve(s: str) -> int:\n    \"\"\"\n    The idea is to split the string into at most 3 parts:\n    1. A prefix consisting of a's\n    2. A middle part consisting of b's and c's\n    3. A suffix consisting of c's\n\n    If the string contains only a's and c's, then the answer is the number of question marks in the string.\n    If the string contains only b's and c's, then the answer is the number of question marks in the string.\n\n    If the string contains a's and b's, then the number of subsequences abc is the product of the number of subsequences\n    abc of the prefix and the number of subsequences abc of the suffix.\n\n    If the string contains a's and c's, then the number of subsequences abc is the product of the number of subsequences\n    abc of the prefix and the number of subsequences abc of the suffix.\n\n    If the string contains b's and c's, then the number of subsequences abc is the product of the number of subsequences\n    abc of the prefix and the number of subsequences abc of the suffix.\n\n    If the string contains a's and b's and c's, then the number of subsequences abc is the product of the number of\n    subsequences abc of the prefix and the number of subsequences abc of the suffix and the number of subsequences abc\n    of the middle part.\n    \"\"\"\n    MOD = int(1e9 + 7)\n    if s.count(\"?\") == 0:\n        return 0\n    if s[0] != \"?\" and s[-1] != \"?\":\n        if s.count(\"a\") > 0 and s.count(\"b\") > 0 and s.count(\"c\") > 0:\n            return count_subsequences_abc(s[: s.index(\"?\") + 1]) * count_subsequences_abc(s[s.rindex(\"?\") :]) * (\n                s.count(\"?\") + 1\n            )\n        elif s.count(\"a\") > 0 and s.count(\"c\") > 0:\n            return count_subsequences_abc(s[: s.index(\"?\") + 1]) * count_subsequences_abc(s[s.rindex(\"?\") :])\n        elif s.count(\"b\") > 0 and s.count(\"c\") > 0:\n            return count_subsequences_abc(s[: s.index(\"?\") + 1]) * count_subsequences_abc(s[s.rindex(\"?\") :])\n    if s.count(\"a\") > 0 and s.count(\"c\") > 0:\n        return count_subsequences_abc(s[: s.index(\"?\") + 1]) * (s.count(\"?\") + 1)\n    if s.count(\"b\") > 0 and s.count(\"c\") > 0:\n        return count_subsequences_abc(s[: s.index(\"?\") + 1]) * (s.count(\"?\") + 1)\n    return s.count(\"?\")\n\n\ndef count_subsequences_abc(s: str) -> int:\n    \"\"\"\n    Count number of subsequences abc in a string containing only a's, b's, and c's\n    \"\"\"\n    MOD = int(1e9 + 7)\n    if s.count(\"a\") == 0 or s.count(\"b\") == 0 or s.count(\"c\") == 0:\n        return 0\n    return s.count(\"b\") + 1\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef solve(s):\n    N = len(s)\n    dp = [0] * N\n    if s[0] == '?':\n        dp[0] = 3\n    else:\n        dp[0] = 1\n\n    if s[1] == '?':\n        dp[1] = 3 * dp[0]\n    elif s[1] == 'a':\n        dp[1] = dp[0]\n    else:\n        dp[1] = 0\n\n    if s[2] == '?':\n        dp[2] = 3 * dp[1]\n    elif s[2] == 'b':\n        dp[2] = dp[1]\n    else:\n        dp[2] = 0\n\n    for i in range(3, N):\n        if s[i] == '?':\n            dp[i] = 3 * dp[i-1]\n        elif s[i] == 'c':\n            dp[i] = dp[i-1]\n        else:\n            dp[i] = 0\n\n    return dp[-1] % (10**9+7)\n\n\nif __name__ == '__main__':\n    N = int(input())\n    s = input()\n    print(solve(s))", "\nimport itertools\n\nn = int(input())\ns = input()\n\n# find all patterns\ndef find_patterns(s: str):\n    patterns = []\n    for i in range(len(s)):\n        patterns.append([])\n        for j in range(i, len(s)):\n            if s[j] == \"?\":\n                patterns[i].append(j)\n    return patterns\n\n# find all combinations\ndef find_combinations(n: int):\n    return itertools.product(\"abc\", repeat=n)\n\n# find patterns\npatterns = find_patterns(s)\n#print(patterns)\n\n# find all combinations for patterns\ncombinations = find_combinations(len(patterns))\n#print(combinations)\n\n# find all possible strings\nstrings = []\nfor combination in combinations:\n    string = s\n    for i in range(len(combination)):\n        string = string[:patterns[i][0]] + combination[i] + string[patterns[i][0]+1:]\n    strings.append(string)\n#print(strings)\n\ncounter = 0\nfor string in strings:\n    counter += string.count(\"abc\")\n\nprint(counter % 1000000007)"]