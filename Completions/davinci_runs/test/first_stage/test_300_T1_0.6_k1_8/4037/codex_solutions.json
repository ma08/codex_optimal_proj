["\n\nn, r = list(map(int, input().split()))\nprojects = []\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\ndef get_max_projects(n, r, projects):\n    projects = sorted(projects, key=lambda x: x[0])\n    result = 0\n    for project in projects:\n        if project[0] > r:\n            break\n        r += project[1]\n        result += 1\n    return result\n\nprint(get_max_projects(n, r, projects))", "\n\nraw_input()\nr = int(raw_input())\nlst = [map(int, raw_input().split()) for x in range(r)]\nlst.sort(key=lambda x: x[0] - x[1])\ncnt = 0\nfor a, b in lst:\n    if r < a:\n        break\n    r += b\n    cnt += 1\nprint cnt", "\n#------------------------------------------------------------------------------#\n\ndef polycarp(n, r, projects):\n    # sort the projects by the rating required to complete them\n    projects = sorted(projects, key = lambda x: x[0])\n    \n    # initialize count of projects\n    count = 0\n    \n    # iterate through the projects\n    for project in projects:\n        # if a project cannot be completed, break\n        if project[0] > r: break\n        \n        # add to the count of projects\n        count += 1\n        \n        # update the rating\n        r += project[1]\n        \n    return count\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    n, r = map(int, input().split())\n    projects = [list(map(int, input().split())) for _ in range(n)]\n    print(polycarp(n, r, projects))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    \"\"\"\n    This problem is solved by a greedy algorithm.\n    It is solved by a greedy algorithm because the optimal solution\n    to a subproblem is always part of the optimal solution to the\n    original problem.\n    \"\"\"\n    n, r = [int(x) for x in input().strip().split()]\n    projects = []\n    for i in range(n):\n        projects.append([int(x) for x in input().strip().split()])\n    projects.sort(key=lambda x: x[0])\n    # print(projects)\n    count = 0\n    for project in projects:\n        if project[1] + r >= project[0]:\n            r += project[1]\n            count += 1\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef compute():\n\tn, r = map(int, input().split())\n\ta = [0] * n\n\tb = [0] * n\n\tfor i in range(n):\n\t\ta[i], b[i] = map(int, input().split())\n\t\n\tdp = [None] * (r + 1)\n\tdp[r] = 0\n\tfor i in range(r - 1, -1, -1):\n\t\tdp[i] = dp[i + 1]\n\t\tfor j in range(n):\n\t\t\tif i + a[j] <= r and (dp[i] is None or dp[i + a[j]] + b[j] > dp[i]):\n\t\t\t\tdp[i] = dp[i + a[j]] + b[j]\n\t\n\tans = 0\n\tfor i in range(n):\n\t\tif dp[a[i]] + b[i] > 0:\n\t\t\tans += 1\n\treturn str(ans)\n\n\nif __name__ == \"__main__\":\n\tprint(compute())", "\n\nimport sys\n\n\ndef main():\n    data = sys.stdin.readlines()\n\n    _, r = map(int, data[0].split())\n\n    projects = []\n    for line in data[1:]:\n        ai, bi = map(int, line.split())\n        projects.append((ai, bi))\n\n    projects.sort(key=lambda x: x[0])\n\n    print(len(projects) - len(filter(lambda x: x[0] > r, projects)))\n\n\nif __name__ == '__main__':\n    main()", "\n\nn, r = map(int, input().split())\n\nprojects = []\n\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\nprojects.sort(key=lambda x: x[0])\n\nfor i in range(1, n):\n    projects[i][0] += projects[i-1][0]\n\ncount = 0\n\nfor i in range(n):\n    if projects[i][0] > r:\n        break\n        \n    count += 1\n    r += projects[i][1]\n    \n    if r < 0:\n        break\n        \nprint(count)", "\n\nn, r = [int(x) for x in input().split(' ')]\n\n# this is a classic knapsack problem\n# we can use the same DP table\n# but the only difference is that we will have a new column for each $i$\n# and the new row for each $j$\n# and the last column will be the one we are looking for\n\n\n# a = [int(x) for x in input().split(' ')]\n# b = [int(x) for x in input().split(' ')]\n\n# # create the DP table\n# DP = [[0 for x in range(r+1)] for x in range(n+1)]\n\n# # DP[i][j] means the maximum value we can get with $j$ dollars\n# # and the first $i$ items\n\n# # we will fill the table row by row\n# for i in range(1, n+1):\n#     for j in range(1, r+1):\n#         # if the item is too expensive, then we cannot buy it\n#         if a[i-1] > j:\n#             DP[i][j] = DP[i-1][j]\n#         else:\n#             # else we can either buy it or not\n#             # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n#             # if we don't buy it, then the value will be DP[i-1][j]\n#             # we will choose the maximum value of them\n#             DP[i][j] = max(b[i-1] + DP[i-1][j-a[i-1]], DP[i-1][j])\n\n# print(DP[n][r])\n\n# but the problem with this is that we need to find the maximum value in the last column\n# but this will not be a problem if we only keep the last two rows\n\n# a = [int(x) for x in input().split(' ')]\n# b = [int(x) for x in input().split(' ')]\n\n# # create the DP table\n# DP = [[0 for x in range(r+1)] for x in range(2)]\n\n# # DP[i][j] means the maximum value we can get with $j$ dollars\n# # and the first $i$ items\n\n# # we will fill the table row by row\n# for i in range(1, n+1):\n#     # fill the new row\n#     for j in range(1, r+1):\n#         # if the item is too expensive, then we cannot buy it\n#         if a[i-1] > j:\n#             DP[1][j] = DP[0][j]\n#         else:\n#             # else we can either buy it or not\n#             # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n#             # if we don't buy it, then the value will be DP[i-1][j]\n#             # we will choose the maximum value of them\n#             DP[1][j] = max(b[i-1] + DP[0][j-a[i-1]], DP[0][j])\n#     # copy the new row to the old row\n#     DP[0] = DP[1]\n\n# print(DP[1][r])\n\n# but the problem with this is that we need to find the maximum value in the last column\n# but this will not be a problem if we only keep the last two rows\n# and since we only need the last column to find the answer, we don't even need to keep the last two rows\n# we only need to keep the last column and the current column\n\na = [int(x) for x in input().split(' ')]\nb = [int(x) for x in input().split(' ')]\n\n# create the DP table\nDP = [[0 for x in range(r+1)] for x in range(2)]\n\n# DP[i][j] means the maximum value we can get with $j$ dollars\n# and the first $i$ items\n\n# we will fill the table row by row\nfor i in range(1, n+1):\n    # if the item is too expensive, then we cannot buy it\n    # else we can either buy it or not\n    # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n    # if we don't buy it, then the value will be DP[i-1][j]\n    # we will choose the maximum value of them\n    for j in range(1, r+1):\n        if a[i-1] > j:\n            DP[1][j] = DP[0][j]\n        else:\n            DP[1][j] = max(b[i-1] + DP[0][j-a[i-1]], DP[0][j])\n    # copy the new column to the old column\n    for j in range(1, r+1):\n        DP[0][j] = DP[1][j]\n\nmax_value = 0\nfor j in range(1, r+1):\n    if DP[1][j] > max_value:\n        max_value = DP[1][j]\n\n# print(DP[1][r])\nprint(max_value)"]