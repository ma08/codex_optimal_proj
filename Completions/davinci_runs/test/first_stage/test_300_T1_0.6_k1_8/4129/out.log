2022-04-16 19:39:56.146678 """
There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.

What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?

New roads will also be one-way.


-----Input-----

The first line of input consists of three integers $n$, $m$ and $s$ ($1 \le n \le 5000, 0 \le m \le 5000, 1 \le s \le n$) — the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.

The following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).


-----Output-----

Print one integer — the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.


-----Examples-----
Input
9 9 1
1 2
1 3
2 3
1 5
5 6
6 1
1 8
9 8
7 1

Output
3

Input
5 4 5
1 2
2 3
3 4
4 1

Output
1



-----Note-----

The first example is illustrated by the following: [Image] 

For example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.

The second example is illustrated by the following: [Image] 

In this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.
"""
2022-04-16 19:39:56.146692 --------------------------
2022-04-16 19:40:23.899104 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    # read input\n    n, m, s = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n\n    # get connected components\n    components = get_connected_components(roads, n)\n\n    # initialise counts\n    counts = collections.defaultdict(int)\n\n    # count the number of vertices in each component\n    for component in components:\n        if len(component) > 1:\n            for vertex in component:\n                counts[vertex] += 1\n\n    # initialise the number of extra roads\n    extra_roads = 0\n\n    # check if capital is in a component\n    if counts[s] > 0:\n        extra_roads += counts[s] - 1\n\n    # check if other vertices are in components\n    for vertex, count in counts.items():\n        if vertex == s:\n            continue\n        if count > 0:\n            extra_roads += count\n\n    # print result\n    print(extra_roads)\n\n\ndef get_connected_components(roads, n):\n    # initialise adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n\n    # populate adjacency list\n    for u, v in roads:\n        adj_list[u].append(v)\n\n    # initialise visited vertices\n    visited = set()\n\n    # initialise connected components\n    components = []\n\n    # find connected components\n    for vertex in range(1, n + 1):\n        if vertex in visited:\n            continue\n        component = []\n        stack = [vertex]\n        while stack:\n            u = stack.pop()\n            if u not in visited:\n                visited.add(u)\n                component.append(u)\n                stack.extend(adj_list[u])\n        components.append(component)\n\n    return components\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef get_input(infile):\n    n, m, s = [int(x) for x in infile.readline().strip().split()]\n    road_map = defaultdict(set)\n    for _ in range(m):\n        u, v = [int(x) for x in infile.readline().strip().split()]\n        road_map[u].add(v)\n    return n, m, s, road_map\n\ndef dfs(s, road_map, visited):\n    visited.add(s)\n    for v in road_map[s]:\n        if v not in visited:\n            visited.add(v)\n            dfs(v, road_map, visited)\n\ndef main():\n    n, m, s, road_map = get_input(sys.stdin)\n    visited = set()\n    dfs(s, road_map, visited)\n    print(n - len(visited))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin, stdout\nfrom collections import defaultdict, deque\n\n# from collections import defaultdict, deque\n\ndef main():\n    n, m, s = map(int, stdin.readline().split())\n    adj_list = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        adj_list[u].append(v)\n    reachable_from_s = set()\n    queue = deque()\n    queue.append(s)\n    reachable_from_s.add(s)\n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            if v not in reachable_from_s:\n                queue.append(v)\n                reachable_from_s.add(v)\n    stdout.write(str(n - len(reachable_from_s)) + \"\\n\")\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n\tn, m, start = [int(x) for x in stdin.readline().split()]\n\troads = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\tu, v = [int(x) for x in stdin.readline().split()]\n\t\troads[u-1].append(v-1)\n\t\n\tvisited = [False for _ in range(n)]\n\tstack = [start-1]\n\twhile stack:\n\t\tcurr = stack.pop()\n\t\tvisited[curr] = True\n\t\tfor to in roads[curr]:\n\t\t\tif not visited[to]:\n\t\t\t\tstack.append(to)\n\t\n\tprint(sum(visited))\n\nif __name__ == \"__main__\":\n\tmain()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    graph = [[] for i in range(n)]\n\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n\n    # run DFS from the source and mark all reachable nodes as visited\n    visited = [False]*n\n    dfs(s-1, graph, visited)\n\n    # run DFS again, but this time from all the nodes that were not visited\n    # and count the number of nodes that are not visited in the end\n    # the number of nodes that are not visited is the number of new roads\n    # that need to be built\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, graph, visited)\n            count += 1\n\n    print(count)\n\n\ndef dfs(node, graph, visited):\n    visited[node] = True\n\n    for i in graph[node]:\n        if not visited[i]:\n            dfs(i, graph, visited)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nclass Graph:\n    def __init__(self, vertices): \n        self.V = vertices \n        self.adj = [[] for i in range(vertices)] \n  \n    def addEdge(self, u, v): \n        self.adj[u].append(v) \n  \n    def DFSUtil(self, v, visited): \n        visited[v] = True\n        for i in self.adj[v]: \n            if visited[i] == False: \n                self.DFSUtil(i, visited) \n  \n    def DFS(self, v): \n        visited = [False]*(self.V) \n        self.DFSUtil(v, visited) \n        return visited.count(True) \n\ndef find_min_roads(n, m, s, paths):\n    g = Graph(n+1)\n    for p in paths:\n        g.addEdge(p[0], p[1])\n    return n - g.DFS(s)\n\nif __name__ == \"__main__\":\n    n, m, s = map(int, input().split())\n    paths = [list(map(int, input().split())) for _ in range(m)]\n    print(find_min_roads(n, m, s, paths))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n,m,s = map(int, readline().split())\n    adj = [[] for i in range(n+1)]\n    for i in range(m):\n        u,v = map(int, readline().split())\n        adj[u].append(v)\n    for i in range(n):\n        adj[i].append(i+1)\n    ans = 0\n    vis = [False]*(n+1)\n    vis[s] = True\n    queue = []\n    queue.append(s)\n    while len(queue) > 0:\n        u = queue.pop()\n        for v in adj[u]:\n            if not vis[v]:\n                vis[v] = True\n                ans += 1\n                queue.append(v)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\n# TODO: This is a minimum spanning tree problem.\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650137996,
  "id": "cmpl-4xiYuISHghKAfmsIDEPv48n6WzC8z",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:40:23.899513 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    # read input\n    n, m, s = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n\n    # get connected components\n    components = get_connected_components(roads, n)\n\n    # initialise counts\n    counts = collections.defaultdict(int)\n\n    # count the number of vertices in each component\n    for component in components:\n        if len(component) > 1:\n            for vertex in component:\n                counts[vertex] += 1\n\n    # initialise the number of extra roads\n    extra_roads = 0\n\n    # check if capital is in a component\n    if counts[s] > 0:\n        extra_roads += counts[s] - 1\n\n    # check if other vertices are in components\n    for vertex, count in counts.items():\n        if vertex == s:\n            continue\n        if count > 0:\n            extra_roads += count\n\n    # print result\n    print(extra_roads)\n\n\ndef get_connected_components(roads, n):\n    # initialise adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n\n    # populate adjacency list\n    for u, v in roads:\n        adj_list[u].append(v)\n\n    # initialise visited vertices\n    visited = set()\n\n    # initialise connected components\n    components = []\n\n    # find connected components\n    for vertex in range(1, n + 1):\n        if vertex in visited:\n            continue\n        component = []\n        stack = [vertex]\n        while stack:\n            u = stack.pop()\n            if u not in visited:\n                visited.add(u)\n                component.append(u)\n                stack.extend(adj_list[u])\n        components.append(component)\n\n    return components\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:40:23.899566 REASON stop
2022-04-16 19:40:23.921465 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef get_input(infile):\n    n, m, s = [int(x) for x in infile.readline().strip().split()]\n    road_map = defaultdict(set)\n    for _ in range(m):\n        u, v = [int(x) for x in infile.readline().strip().split()]\n        road_map[u].add(v)\n    return n, m, s, road_map\n\ndef dfs(s, road_map, visited):\n    visited.add(s)\n    for v in road_map[s]:\n        if v not in visited:\n            visited.add(v)\n            dfs(v, road_map, visited)\n\ndef main():\n    n, m, s, road_map = get_input(sys.stdin)\n    visited = set()\n    dfs(s, road_map, visited)\n    print(n - len(visited))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:40:23.921650 REASON stop
2022-04-16 19:40:23.922072 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin, stdout\nfrom collections import defaultdict, deque\n\n# from collections import defaultdict, deque\n\ndef main():\n    n, m, s = map(int, stdin.readline().split())\n    adj_list = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        adj_list[u].append(v)\n    reachable_from_s = set()\n    queue = deque()\n    queue.append(s)\n    reachable_from_s.add(s)\n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            if v not in reachable_from_s:\n                queue.append(v)\n                reachable_from_s.add(v)\n    stdout.write(str(n - len(reachable_from_s)) + \"\\n\")\n\nmain()"
}
2022-04-16 19:40:23.922131 REASON stop
2022-04-16 19:40:23.942804 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\ndef main():\n\tn, m, start = [int(x) for x in stdin.readline().split()]\n\troads = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\tu, v = [int(x) for x in stdin.readline().split()]\n\t\troads[u-1].append(v-1)\n\t\n\tvisited = [False for _ in range(n)]\n\tstack = [start-1]\n\twhile stack:\n\t\tcurr = stack.pop()\n\t\tvisited[curr] = True\n\t\tfor to in roads[curr]:\n\t\t\tif not visited[to]:\n\t\t\t\tstack.append(to)\n\t\n\tprint(sum(visited))\n\nif __name__ == \"__main__\":\n\tmain()"
}
2022-04-16 19:40:23.942935 REASON stop
2022-04-16 19:40:23.961620 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    graph = [[] for i in range(n)]\n\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n\n    # run DFS from the source and mark all reachable nodes as visited\n    visited = [False]*n\n    dfs(s-1, graph, visited)\n\n    # run DFS again, but this time from all the nodes that were not visited\n    # and count the number of nodes that are not visited in the end\n    # the number of nodes that are not visited is the number of new roads\n    # that need to be built\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, graph, visited)\n            count += 1\n\n    print(count)\n\n\ndef dfs(node, graph, visited):\n    visited[node] = True\n\n    for i in graph[node]:\n        if not visited[i]:\n            dfs(i, graph, visited)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:40:23.961736 REASON stop
2022-04-16 19:40:23.963009 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nclass Graph:\n    def __init__(self, vertices): \n        self.V = vertices \n        self.adj = [[] for i in range(vertices)] \n  \n    def addEdge(self, u, v): \n        self.adj[u].append(v) \n  \n    def DFSUtil(self, v, visited): \n        visited[v] = True\n        for i in self.adj[v]: \n            if visited[i] == False: \n                self.DFSUtil(i, visited) \n  \n    def DFS(self, v): \n        visited = [False]*(self.V) \n        self.DFSUtil(v, visited) \n        return visited.count(True) \n\ndef find_min_roads(n, m, s, paths):\n    g = Graph(n+1)\n    for p in paths:\n        g.addEdge(p[0], p[1])\n    return n - g.DFS(s)\n\nif __name__ == \"__main__\":\n    n, m, s = map(int, input().split())\n    paths = [list(map(int, input().split())) for _ in range(m)]\n    print(find_min_roads(n, m, s, paths))"
}
2022-04-16 19:40:23.963100 REASON stop
2022-04-16 19:40:23.963990 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n,m,s = map(int, readline().split())\n    adj = [[] for i in range(n+1)]\n    for i in range(m):\n        u,v = map(int, readline().split())\n        adj[u].append(v)\n    for i in range(n):\n        adj[i].append(i+1)\n    ans = 0\n    vis = [False]*(n+1)\n    vis[s] = True\n    queue = []\n    queue.append(s)\n    while len(queue) > 0:\n        u = queue.pop()\n        for v in adj[u]:\n            if not vis[v]:\n                vis[v] = True\n                ans += 1\n                queue.append(v)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:40:23.964074 REASON stop
2022-04-16 19:40:23.965061 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\n# TODO: This is a minimum spanning tree problem.\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:40:23.965141 REASON stop
