["", "\n\nimport sys\n\ndef main():\n\tnum_nums = int(sys.stdin.readline().strip())\n\tnums = sys.stdin.readline().strip().split()\n\tnums = [int(i) for i in nums]\n\t\n\tnums.sort(key=lambda x: x%3)\n\t\n\tfor i in nums:\n\t\tprint i,\n\nif __name__ == \"__main__\":\n\tmain()", "\n\n\ndef solution(n, sequence):\n    result = [0 for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        if sequence[i] % 3 != 0:\n            result[i] = sequence[i]\n            continue\n        for j in range(i-1, -1, -1):\n            if sequence[i] % 2 == 0 and sequence[j] * 2 == sequence[i]:\n                result[j] = sequence[j]\n                break\n            elif sequence[i] % 3 == 0 and sequence[j] * 3 == sequence[i]:\n                result[j] = sequence[j]\n                break\n    return result\n\n\nassert solution(6, [4, 8, 6, 3, 12, 9]) == [9, 3, 6, 12, 4, 8]\nassert solution(4, [42, 28, 84, 126]) == [126, 42, 84, 28]\nassert solution(2, [1000000000000000000, 3000000000000000000]) == [3000000000000000000, 1000000000000000000]", "\n\nimport sys\n\ndef next_possible(p, n):\n    if p * 2 == n:\n        return '*2'\n    elif p * 3 == n:\n        return '*3'\n    elif p % 2 == 0 and p / 2 == n:\n        return '/2'\n    elif p % 3 == 0 and p / 3 == n:\n        return '/3'\n    else:\n        return None\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = map(int, sys.stdin.readline().split())\n    b = [None] * n\n\n    b[0] = a[0]\n\n    for i in xrange(1, n):\n        prev = b[i - 1]\n        for j in xrange(n):\n            if a[j] == prev * 2 or a[j] == prev * 3 or a[j] == prev / 2 or a[j] == prev / 3:\n                b[i] = a[j]\n                break\n    \n    print ' '.join(map(str, b))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n = int(input())\n    arr = [int(i) for i in input().split(\" \")]\n    arr.sort(reverse=True)\n    print(\" \".join([str(i) for i in arr]))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n# Solution 1:\n# The problem is equivalent to finding the longest increasing subsequence\n# The difference between the original problem and this is that the original problem also allows dividing by 3\n# The catch is that the sequence must be strictly increasing, so you can't have repeats\n# This can be solved with a dynamic programming approach\n\nn = int(input())\nA = list(map(int, input().split()))\n\n# dp[i] represents the longest increasing subsequence ending at index i\ndp = [1 for _ in range(n)]\n# We don't need to store the actual indices, so we can use a set\n# This will allow us to avoid repeats\n# If the length of this set is 1, then we know that the element is unique\n# Otherwise, we know that the element is a repeat\n# If it is a repeat, we don't want to consider it\n# This is because the problem requires a strictly increasing subsequence\n# We can simply not consider the element if we find a repeat\nrepeats = [set() for _ in range(n)]\n\nfor i in range(n):\n    for j in range(i):\n        if A[j] < A[i] and dp[j] + 1 > dp[i]:\n            dp[i] = dp[j] + 1\n            repeats[i] = repeats[j].copy()\n            repeats[i].add(A[j])\n        elif A[j] == A[i] and dp[j] + 1 >= dp[i] and len(repeats[j]) == 1:\n            dp[i] = dp[j] + 1\n            repeats[i] = repeats[j].copy()\n            repeats[i].add(A[j])\n\n# Find the max value of dp\n# If there are multiple values with the same max value, we want the largest index\nmax_index = -1\nmax_value = -1\nfor i in range(n):\n    if dp[i] > max_value:\n        max_index = i\n        max_value = dp[i]\n    elif dp[i] == max_value:\n        max_index = i\n\n# Now we need to reconstruct the sequence\n# We can do this by backtracking\nsequence = [None for _ in range(n)]\nsequence[max_value - 1] = A[max_index]\nfor i in range(max_index - 1, -1, -1):\n    if dp[i] + 1 == dp[max_index] and len(repeats[i]) == 1:\n        sequence[dp[i] - 1] = A[i]\n        max_index = i\n\n# Print the sequence\nfor i in range(n):\n    print(sequence[i], end=' ')", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = list(map(int, sys.stdin.readline().split()))\n    l2 = []\n    for i in range(n):\n        l2.append((l[i], i))\n    l2.sort()\n    l3 = []\n    for i in range(n):\n        l3.append(l2[i][1])\n    l4 = []\n    for i in range(n):\n        l4.append(l[l3[i]])\n    print(' '.join(map(str, l4)))\n\nmain()"]