["\n\n# this is an example of the traveling salesman problem,\n# which is NP-hard, but there are some approximations\n# that can be done to find a solution in polynomial time\n\n# this is the greedy algorithm for the problem\n# we start at point x, and sort all other points by their distance from x\n# we then check if we can reach the next point from x\n# if we can, then we move to that point and repeat\n# if we cannot reach the next point, we add the distance of the next point to x to D\n# and then move to the next point and repeat\n# when we have reached all the points, the value of D is the answer\n# this is a 2-approximation of the optimal solution\n\n# read in the input\nn, x = map(int, input().split())\nxs = list(map(int, input().split()))\n\n# sort the points by their distance from x\nxs.sort(key=lambda y: abs(x - y))\n\n# start at x\nd = 0\nfor y in xs:\n    # check if the next point can be reached from the current point\n    if y - d <= x:\n        # if so, move to the next point and repeat\n        x = y\n    else:\n        # if not, add the distance from the current point to the next point to D\n        # and then move to the next point and repeat\n        d += y - x\n        x = y\n\n# print the answer\nprint(d)", "\nimport sys\nfrom itertools import accumulate\n\nn, x = map(int, input().split())\ncities = sorted(list(map(int, input().split())))\n\nif x in cities:\n    print(1)\n    sys.exit()\n\ndistances = [abs(x - c) for c in cities]\ndistances.sort()\n\ngaps = [distances[i] - distances[i - 1] for i in range(1, n)]\ngaps.sort()\n\nif len(gaps) == 1:\n    print(distances[0] + distances[-1])\nelse:\n    print(sum(distances) - sum(gaps[:n - 2]))", "\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ni = 0\n\nwhile True:\n    if a[i] > x:\n        break\n    i += 1\n\nanswer = a[i] - x\n\nfor i in range(n):\n    answer = min(answer, max(x - a[i], a[i] - x))\n\nprint(answer)", "\n\nN = int(input().split()[0])\nX = int(input().split()[0])\nx = [int(i) for i in input().split()]\n\n# Find the minimum distance between X and other cities\ndist = [abs(i - X) for i in x]\ndist.sort()\n\n# Find the maximum distance between cities\ndiff = [dist[i + 1] - dist[i] for i in range(N - 1)]\ndiff.sort()\n\n# The maximum value of D which enables us to visit all cities is the minimum of the maximum distance between cities\nprint(diff[-1] // 2)", "\n\nN, X = input().split()\nN, X = int(N), int(X)\nx_list = list(map(int, input().split()))\n\nx_list.append(X)\nx_list.sort()\n\ndistances = []\n\nfor i in range(len(x_list) - 1):\n    distances.append(x_list[i + 1] - x_list[i])\n\nprint(max(distances) // 2)", "\n\nimport sys\nfrom bisect import bisect_left\n\nnum_cities, start_coord = map(int, sys.stdin.readline().split())\ncities = sorted(list(map(int, sys.stdin.readline().split())))\n\n# binary search to find the max distance between two cities\ndef binary_search(start, end):\n    if start > end:\n        return start\n    mid = (start + end) // 2\n    min_dist = mid * 2\n    for i in range(num_cities):\n        # binary search to find the first city that is greater than or equal to current city + min_dist\n        idx = bisect_left(cities, cities[i] + mid)\n        if idx == num_cities:\n            continue\n        # update min_dist if the distance between two cities is less\n        min_dist = min(min_dist, cities[idx] - cities[i])\n    if min_dist <= mid:\n        return binary_search(start, mid - 1)\n    else:\n        return binary_search(mid + 1, end)\n\n# if start_coord is in the cities\nif start_coord in cities:\n    print(binary_search(1, 10**9))\nelse:\n    # binary search to find the city that is greater than or equal to start_coord\n    idx = bisect_left(cities, start_coord)\n    if idx == num_cities:\n        # the distance from the last city to start_coord\n        print(binary_search(1, cities[-1] - start_coord))\n    elif idx == 0:\n        # the distance from start_coord to the first city\n        print(binary_search(1, start_coord - cities[0]))\n    else:\n        # the distance between the two cities that are greater than or equal to start_coord\n        print(binary_search(1, (cities[idx] - start_coord) * 2))", "\n\nimport sys\nimport math\n\n# input\nN, X = map(int, sys.stdin.readline().rstrip().split())\nx = list(map(int, sys.stdin.readline().rstrip().split()))\n\n# solution\nx.sort()\nx = list(map(lambda x: abs(x - X), x))\nprint(math.ceil(max(x) / (N - 1)))", "\n\ndef main():\n    n, x = map(int, input().split())\n    xs = list(map(int, input().split()))\n    xs.append(x)\n    xs.sort()\n    idx = xs.index(x)\n    left = xs[:idx]\n    right = xs[idx+1:]\n    if len(left) > len(right):\n        left, right = right, left\n    d = 0\n    for l, r in zip(left, right):\n        d = max(d, (r - l)//2)\n    print(d)\n\nif __name__ == \"__main__\":\n    main()"]