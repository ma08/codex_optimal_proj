["", "\n\nn = int(input())\ns = input()\nif sorted(s)==s:\n    print(\"YES\")\n    print(\"0\"*n)\nelif sorted(s,reverse=True)==s:\n    print(\"YES\")\n    print(\"1\"*n)\nelse:\n    print(\"NO\")", "\n\nclass Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.color = None\n        self.left_child_color = None\n        self.right_child_color = None\n\n    def set_color(self, color):\n        self.color = color\n        if self.parent:\n            if self.parent.left == self:\n                self.parent.left_child_color = color\n            elif self.parent.right == self:\n                self.parent.right_child_color = color\n\n    def get_color(self):\n        return self.color\n\n    def set_left_child(self, left):\n        self.left = left\n        self.left.parent = self\n\n    def set_right_child(self, right):\n        self.right = right\n        self.right.parent = self\n\n    def get_left_child(self):\n        return self.left\n\n    def get_right_child(self):\n        return self.right\n\n    def has_left_child(self):\n        return self.left != None\n\n    def has_right_child(self):\n        return self.right != None\n\n    def is_left_child(self):\n        return self.parent and self.parent.left == self\n\n    def is_right_child(self):\n        return self.parent and self.parent.right == self\n\n    def is_root(self):\n        return not self.parent\n\n    def is_leaf(self):\n        return not (self.right or self.left)\n\n    def has_any_children(self):\n        return self.right or self.left\n\n    def has_both_children(self):\n        return self.right and self.left\n\n    def replace_node_data(self, key, value, lc, rc):\n        self.key = key\n        self.payload = value\n        self.left_child = lc\n        self.right_child = rc\n        if self.has_left_child():\n            self.left.parent = self\n        if self.has_right_child():\n            self.right.parent = self\n\n    def __iter__(self):\n        if self:\n            if self.has_left_child():\n                for elem in self.left:\n                    yield elem\n            yield self.key\n            if self.has_right_child():\n                for elem in self.right:\n                    yield elem\n\n    def __repr__(self):\n        return str(self.val)\n\n    def __str__(self):\n        return str(self.val)\n\n\nclass BinarySearchTree(object):\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n\n    def put(self, key, val):\n        if self.root:\n            self._put(key, val, self.root)\n        else:\n            self.root = Node(val)\n        self.size = self.size + 1\n\n    def _put(self, key, val, current_node):\n        if key < current_node.val:\n            if current_node.has_left_child():\n                self._put(key, val, current_node.left)\n            else:\n                current_node.set_left_child(Node(val))\n        else:\n            if current_node.has_right_child():\n                self._put(key, val, current_node.right)\n            else:\n                current_node.set_right_child(Node(val))\n\n    def __setitem__(self, k, v):\n        self.put(k, v)\n\n    def get(self, key):\n        if self.root:\n            res = self._get(key, self.root)\n            if res:\n                return res.get_color()\n            else:\n                return None\n        else:\n            return None\n\n    def _get(self, key, current_node):\n        if not current_node:\n            return None\n        elif current_node.val == key:\n            return current_node\n        elif key < current_node.val:\n            return self._get(key, current_node.left)\n        else:\n            return self._get(key, current_node.right)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __contains__(self, key):\n        if self._get(key, self.root):\n            return True\n        else:\n            return False\n\n    def delete(self, key):\n        if self.size > 1:\n            node_to_remove = self._get(key, self.root)\n            if node_to_remove:\n                self.remove(node_to_remove)\n                self.size = self.size - 1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.val == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self, key):\n        self.delete(key)\n\n    def splice_out(self):\n        if self.is_leaf():\n            if self.is_left_child():\n                self.parent.left = None\n            else:\n                self.parent.right = None\n        elif self.has_any_children():\n            if self.has_left_child():\n                if self.is_left_child():\n                    self.parent.left = self.left\n                else:\n                    self.parent.right = self.left\n                self.left.parent = self.parent\n            else:\n                if self.is_left_child():\n                    self.parent.left = self.right\n                else:\n                    self.parent.right = self.right\n                self.right.parent = self.parent\n\n    def find_successor(self):\n        succ = None\n        if self.has_right_child():\n            succ = self.right.find_min()\n        else:\n            if self.parent:\n                if self.is_left_child():\n                    succ = self.parent\n                else:\n                    self.parent.right = None\n                    succ = self.parent.find_successor()\n                    self.parent.right = self\n        return succ\n\n    def find_min(self):\n        current = self\n        while current.has_left_child():\n            current = current.left\n        return current\n\n    def remove(self, current_node):\n        if current_node.is_leaf():  # leaf\n            if current_node == current_node.parent.left:\n                current_node.parent.left = None\n            else:\n                current_node.parent.right = None\n        elif current_node.has_both_children():  # interior\n            succ = current_node.find_successor()\n            succ.splice_out()\n            current_node.key = succ.key\n            current_node.payload = succ.payload\n\n        else:  # this node has one child\n            if current_node.has_left_child():\n                if current_node.is_left_child():\n                    current_node.left.parent = current_node.parent\n                    current_node.parent.left = current_node.left\n                elif current_node.is_right_child():\n                    current_node.left.parent = current_node.parent\n                    current_node.parent.right = current_node.left\n                else:\n                    current_node.replace_node_data(current_node.left.key,\n                                                   current_node.left.payload,\n                                                   current_node.left.left_child,\n                                                   current_node.left.right_child)\n            else:\n                if current_node.is_left_child():\n                    current_node.right.parent = current_node.parent\n                    current_node.parent.left = current_node.right\n                elif current_node.is_right_child():\n                    current_node.right.parent = current_node.parent\n                    current_node.parent.right = current_node.right\n                else:\n                    current_node.replace_node_data(current_node.right.key,\n                                                   current_node.right.payload,\n                                                   current_node.right.left_child,\n                                                   current_node.right.right_child)\n\n\nn = int(input())\ns = input()\nbst = BinarySearchTree()\nfor i in range(n):\n    bst[ord(s[i])] = None\n\ndef dfs(node, color):\n    if node:\n        node.set_color(color)\n        if node.has_left_child():\n            dfs(node.left, color ^ 1)\n        if node.has_right_child():\n            dfs(node.right, color ^ 1)\n\ndef check(node):\n    if node:\n        if node.has_left_child():\n            if node.val <= node.left.val:\n                return False\n            if not check(node.left):\n                return False\n        if node.has_right_child():\n            if node.val >= node.right.val:\n                return False\n            if not check(node.right):\n                return False\n        return True\n    return True\n\ndfs(bst.root, 0)\nif check(bst.root):\n    print(\"YES\")\n    for i in range(n):\n        print(bst[ord(s[i])], end=\"\")\n    print()\nelse:\n    print(\"NO\")", "\n\n\ndef can_sort(s):\n    if s == ''.join(sorted(s)):\n        return 'YES', '0' * len(s)\n    if s == ''.join(sorted(s))[::-1]:\n        return 'YES', '1' * len(s)\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            continue\n        if s[i] > s[i + 1]:\n            return 'NO'\n        if s[i] < s[i + 1]:\n            return 'YES', '0' * (i + 1) + '1' * (len(s) - i - 1)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = input()\n    print(*can_sort(s))", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    s = input()\n\n    if n == 1:\n        print(\"YES\")\n        print(\"0\")\n        return\n\n    sorted_s = sorted(s)\n    if s == sorted_s:\n        print(\"YES\")\n        print(\"0\" * n)\n        return\n\n    print(\"YES\")\n    for c in s:\n        if c == sorted_s[0]:\n            print(\"0\", end=\"\")\n            sorted_s = sorted_s[1:]\n        else:\n            print(\"1\", end=\"\")\n    print()\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef read_str():\n    return input()\n\ndef read_int():\n    return int(input())\n\ndef read_str_list():\n    return input().split()\n\ndef read_int_list():\n    return [int(n) for n in input().split()]\n\ndef get_min_swap(s):\n    cnt = 0\n    while(s != s[::-1]):\n        i = 0\n        while(s[i] > s[i+1]):\n            i += 1\n        j = i + 1\n        while(j < len(s) and s[j] < s[j+1]):\n            j += 1\n        s = s[:i] + s[:i-1:-1] + s[j+1:]\n        cnt += 1\n    return cnt\n\nif __name__ == \"__main__\":\n    n = read_int()\n    s = read_str()\n    d = {}\n    for ch in s:\n        if ch not in d:\n            d[ch] = 1\n        else:\n            d[ch] += 1\n    ans = ''\n    for key in sorted(d.keys()):\n        ans += key * d[key]\n    min_swap = get_min_swap(ans)\n    if min_swap == 0:\n        print(\"YES\")\n        print(\"0\" * n)\n    elif min_swap == 1:\n        print(\"YES\")\n        print(\"0\" * (n-1) + \"1\")\n    elif min_swap % 2 == 0:\n        print(\"YES\")\n        print(\"1\" * (n-min_swap) + \"0\" * min_swap)\n    else:\n        print(\"NO\")", "\n\ndef swap(s, i):\n    return s[:i] + s[i+1] + s[i] + s[i+2:]\n\n\ndef color(s):\n    n = len(s)\n    if n == 1:\n        return \"\".join([\"0\"])\n\n    if s[0] > s[1]:\n        s = swap(s, 0)\n        return \"1\" + color(s[1:])\n\n    if s[-1] > s[-2]:\n        s = swap(s, -2)\n        return color(s[:-1]) + \"1\"\n\n    for i in range(1, n-1):\n        if s[i] > s[i+1]:\n            s = swap(s, i)\n            return color(s[:i]) + \"1\" + color(s[i+1:])\n\n    return \"\".join([\"0\"] * n)\n\n\ndef main():\n    n = int(input())\n    s = input()\n    print(\"YES\")\n    print(color(s))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef check_coloring(string):\n    # A simpler version of the algorithm from the main task.\n    # We just check if we can color in such a way that every character is at its correct position.\n    # If we can, we color the character with 0 and 1 otherwise.\n\n    coloring = ''\n\n    # If the string contains only one character, we can color it with 0.\n    if len(string) == 1:\n        return '0'\n\n    # We check if the character is at its correct position.\n    # If it is, we color it with 0 and 1 otherwise.\n    for i, char in enumerate(string):\n        # If the string contains only two characters and they are different, we can color them with 0 and 1.\n        if len(string) == 2 and char != string[i-1]:\n            coloring += '01'\n            return coloring\n\n        # If the character is not at its correct position, we color it with 1.\n        if char != chr(ord('a') + i):\n            coloring += '1'\n            continue\n\n        # If the first character is at its correct position, we color it with 0.\n        if i == 0:\n            coloring += '0'\n            continue\n\n        # If the character is at its correct position and it is not the first character and it is different from the\n        # previous character, we color it with 0.\n        if char != string[i-1]:\n            coloring += '0'\n            continue\n\n        # If the character is at its correct position and it is not the first character and it is the same as the\n        # previous character, we color it with 1.\n        coloring += '1'\n\n    return coloring\n\n\ndef main():\n    input_string = input().strip()\n    coloring = check_coloring(input_string)\n\n    if len(coloring) == 0:\n        print('NO')\n    else:\n        print('YES')\n        print(coloring)\n\n\nif __name__ == '__main__':\n    main()"]