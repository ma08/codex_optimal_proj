["\n\n__author__ = 'pandeesh'\n\ndef solve(a):\n    n = len(a)\n    dp = [0] * n\n    dp[0] = 1\n    for i in xrange(n):\n        for j in xrange(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[n-1]\n\n\nif __name__ == '__main__':\n    n = input()\n    a = [int(x) for x in raw_input().split()]\n    print solve(a)", "\n\nn = int(input())\na = list(map(int, input().split()))\n\nleft = []\nright = []\n\nfor i in range(n):\n    if i == 0:\n        left.append(a[0])\n    else:\n        if a[i] > left[-1]:\n            left.append(a[i])\n        else:\n            break\n\nfor i in range(n-1,-1,-1):\n    if i == n-1:\n        right.append(a[n-1])\n    else:\n        if a[i] > right[-1]:\n            right.append(a[i])\n        else:\n            break\n\nif len(left) > len(right):\n    print(len(left))\n    for i in range(len(left)):\n        print(\"L\", end='')\nelse:\n    print(len(right))\n    for i in range(len(right)):\n        print(\"R\", end='')", "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif len(set(a)) == n:\n    l = []\n    r = []\n    for i in range(n):\n        if a[i] not in l:\n            l.append(a[i])\n        else:\n            break\n    for i in range(n-1, -1, -1):\n        if a[i] not in r:\n            r.append(a[i])\n        else:\n            break\n    if len(l) == len(r):\n        print(len(l))\n        print('L' * len(l))\n    elif len(l) > len(r):\n        print(len(l))\n        print('L' * len(l))\n    else:\n        print(len(r))\n        print('R' * len(r))\nelse:\n    l = []\n    r = []\n    for i in range(n):\n        if a[i] not in l:\n            l.append(a[i])\n        else:\n            break\n    for i in range(n-1, -1, -1):\n        if a[i] not in r:\n            r.append(a[i])\n        else:\n            break\n    if len(l) == len(r):\n        print(len(l))\n        print('L' * len(l))\n    elif len(l) > len(r):\n        print(len(l))\n        print('L' * len(l))\n    else:\n        print(len(r))\n        print('R' * len(r))", "\n\n\ndef solution(input_list):\n    max_length = 1\n    max_list = [input_list[0]]\n    left = 0\n    right = len(input_list) - 1\n    while left < right:\n        if input_list[left] < input_list[right]:\n            if input_list[left] > max_list[-1]:\n                max_list.append(input_list[left])\n                left += 1\n            else:\n                max_list[-1] = input_list[right]\n                right -= 1\n        else:\n            if input_list[right] > max_list[-1]:\n                max_list.append(input_list[right])\n                right -= 1\n            else:\n                max_list[-1] = input_list[left]\n                left += 1\n        if len(max_list) > max_length:\n            max_length = len(max_list)\n            max_list = max_list[-max_length:]\n    return max_length, max_list\n\n\ndef main():\n    n = int(input())\n    input_list = list(map(int, input().split()))\n    length, answer = solution(input_list)\n    print(length)\n    print(''.join(['R' if x == input_list[-1] else 'L' for x in answer]))\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    with open('input.txt') as f:\n        n = int(f.readline().strip())\n        a = [int(x) for x in f.readline().strip().split()]\n\n    a.append(sys.maxsize)\n    i = 0\n    k = 0\n    s = ''\n    while i < n:\n        if a[i] < a[i+1]:\n            k += 1\n            s += 'L'\n            i += 1\n        else:\n            k += 1\n            s += 'R'\n            i += 1\n\n    print(k)\n    print(s)\n\nif __name__ == '__main__':\n    main()", "\n\n#-----Solution-----\n\n\"\"\"\nWe want to find the longest strictly increasing subsequence, which can be found using the dynamic programming algorithm.\n\nIt's easy to see that the answer can't contain both the leftmost and the rightmost elements, because in that case the subsequence would be strictly decreasing, so the answer is either the longest strictly increasing subsequence in the left part or in the right part.\n\nLet's define $dp_i$ as the length of the longest strictly increasing subsequence in the left part of the sequence ending at the $i$-th element. The answer is either $dp_n$ or $dp_1$ (if $n = 1$ then $dp_1$ is the answer).\n\nThe dynamic programming state $dp_i$ can be found as the maximum of $dp_j$ for all $j < i$ such that $a_j < a_i$ plus $1$ (if no such $j$ exists, then $dp_i = 1$).\n\nThe time complexity is $O(n^2)$ and the memory complexity is $O(n)$.\n\nFor the second part of the solution, we need to find the actual subsequence. We can keep track of the indices of the elements of the subsequence while going through the dynamic programming algorithm, and we can determine the direction of each move by the last element of the subsequence.\n\nThe overall time complexity is $O(n^2)$ and the overall memory complexity is $O(n)$.\n\"\"\"\n\n#-----Solution-----\n\nimport sys\nread = sys.stdin.readline\n\nn = int(input())\na = list(map(int, read().split()))\n\n# Dynamic programming state: the length of the longest strictly increasing subsequence in the left part of the sequence ending at the i-th element.\ndp = [1] * n\n\n# Indices of the elements of the subsequence.\nsubseq = []\n\nfor i in range(n):\n    for j in range(i):\n        if a[j] < a[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\n    if dp[i] > len(subseq):\n        subseq = [i]\n    elif dp[i] == len(subseq):\n        subseq.append(i)\n\nk = max(dp[-1], dp[0])\nprint(k)\n\n# Determine the direction of each move by the last element of the subsequence.\ns = ''\nfor _ in range(k - 1):\n    if subseq[-1] == n - 1:\n        s = 'L' + s\n        subseq = [subseq[0]]\n    else:\n        s = 'R' + s\n        subseq = [subseq[-1] + 1]\n\nprint(s)", "\n\n#-----Solution-----\n\nn = int(input())\narr = list(map(int,input().split()))\n\nleft = []\nright = []\n\nleft_max = 0\nright_max = 0\n\nfor i in range(n):\n    if arr[i] > left_max:\n        left_max = arr[i]\n        left.append(arr[i])\n    elif arr[i] > right_max:\n        right_max = arr[i]\n        right.append(arr[i])\n\nif len(left) > len(right):\n    print (len(left))\n    for i in range(len(left)):\n        if i == len(left) - 1:\n            print(\"L\")\n        else:\n            print(\"L\",end=\"\")\nelse:\n    print (len(right))\n    for i in range(len(right)):\n        if i == len(right) - 1:\n            print(\"R\")\n        else:\n            print(\"R\",end=\"\")", "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"]