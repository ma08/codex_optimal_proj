["\n\n# TODO: write solution", "\n\nimport sys, math\nfrom collections import deque\n\ndef calc_dist(a, b, dist):\n\tdist[a] = 0\n\tq = deque([a])\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor v in adj[u]:\n\t\t\tif dist[v] == -1:\n\t\t\t\tdist[v] = dist[u] + 1\n\t\t\t\tq.append(v)\n\treturn dist[b]\n\ndef solve():\n\tglobal cur, ans, res\n\tif cur == n:\n\t\tif ans < res:\n\t\t\tans = res\n\t\treturn\n\tfor i in range(cur+1, n+1):\n\t\td1 = calc_dist(cur, i, dist1)\n\t\td2 = calc_dist(i, cur, dist2)\n\t\tif d1 + d2 + 1 > ans:\n\t\t\tres += d1 + d2 + 1\n\t\t\tcur = i\n\t\t\tsolve()\n\t\t\tres -= d1 + d2 + 1\n\nn = int(input())\nadj = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n\ta, b = map(int, sys.stdin.readline().split())\n\tadj[a].append(b)\n\tadj[b].append(a)\n\ndist1 = [-1 for _ in range(n+1)]\ndist2 = [-1 for _ in range(n+1)]\ndist3 = [-1 for _ in range(n+1)]\n\nans = 0\nres = 0\ncur = 1\nsolve()\n\ncalc_dist(1, ans, dist1)\ncalc_dist(ans, 1, dist2)\n\nprint(ans)\nfor i in range(1, n+1):\n\tif dist1[i] + dist2[i] + 1 == ans:\n\t\tprint(i)", "\n\n# Solution 1\ndef dfs(u, p):\n    global G\n\n    sz = 1\n    M = 0\n    for v in G[u]:\n        if v == p:\n            continue\n        sz_v, M_v = dfs(v, u)\n        sz += sz_v\n        M = max(M, M_v)\n    M = max(M, len(G[u]) - 1 + N - sz)\n    if M < res[0]:\n        res = [M, u]\n    return sz, M\n\ndef dfs_ans(u, p):\n    global ans, G\n\n    for v in G[u]:\n        if v == p:\n            continue\n        if res[1] in (u, v):\n            ans.add(u)\n            return\n        dfs_ans(v, u)\n\nN = int(input())\nG = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nres = [N + 1, None]\ndfs(1, None)\nans = set()\ndfs_ans(1, None)\nans = [res[1]] + sorted(ans)\nprint(res[0])\nprint(*ans)\n\n\n# Solution 2\ndef dfs(u, p):\n    global G\n\n    sz = 1\n    M = 0\n    for v in G[u]:\n        if v == p:\n            continue\n        sz_v, M_v = dfs(v, u)\n        sz += sz_v\n        M = max(M, M_v)\n    M = max(M, len(G[u]) - 1 + N - sz)\n    if M < res[0]:\n        res = [M, u]\n    return sz, M\n\nN = int(input())\nG = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nres = [N + 1, None]\ndfs(1, None)\nans = [res[1]]\nfor v in G[res[1]]:\n    if len(G[v]) > 1:\n        ans.append(v)\n        break\nfor v in G[res[1]]:\n    if len(G[v]) > 1 and v != ans[1]:\n        ans.append(v)\n        break\nprint(res[0])\nprint(*ans)", "\n\nfrom collections import defaultdict\n\ndef find_path(start, end, parents):\n    path = [end]\n    while path[-1] != start:\n        path.append(parents[path[-1]])\n    return path[::-1]\n\ndef find_distance(start, end, parents):\n    path = find_path(start, end, parents)\n    return len(path) - 1\n\ndef solve(tree):\n    # Compute number of children and parent for each node\n    children = defaultdict(int)\n    parent = defaultdict(int)\n    for (a, b) in tree:\n        children[a] += 1\n        children[b] += 1\n        parent[b] = a\n\n    # Find two leaves with maximum distance between them\n    max_dist = 0\n    max_a = 0\n    max_b = 0\n    for (a, b) in tree:\n        if children[a] == 1 and children[b] == 1:\n            dist = find_distance(a, b, parent)\n            if dist > max_dist:\n                max_dist = dist\n                max_a = a\n                max_b = b\n\n    # Find middle vertex\n    middle_a = 0\n    middle_b = 0\n    middle_c = 0\n    max_dist = 0\n    for (a, b) in tree:\n        if children[a] == 1 and children[b] == 1:\n            dist_1 = find_distance(a, max_a, parent)\n            dist_2 = find_distance(b, max_a, parent)\n            dist_3 = find_distance(a, max_b, parent)\n            dist_4 = find_distance(b, max_b, parent)\n            dist = max(dist_1, dist_2, dist_3, dist_4)\n            if dist > max_dist:\n                max_dist = dist\n                middle_a = a\n                middle_b = b\n                middle_c = max_a if dist_1 == dist or dist_2 == dist else max_b\n\n    # Find two leaves with maximum distance from middle vertex\n    max_dist = 0\n    max_a = 0\n    max_b = 0\n    for (a, b) in tree:\n        if children[a] == 1 and children[b] == 1:\n            dist = find_distance(a, middle_c, parent)\n            if dist > max_dist:\n                max_dist = dist\n                max_a = a\n                max_b = b\n\n    return (max_dist - 1) + (max_dist - 1) + (max_dist)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    tree = []\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        tree.append((a, b))\n    print(solve(tree))", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    tree = []\n    for i in range(n-1):\n        edge = [int(x) for x in input().split()]\n        edge.sort()\n        tree.append(edge)\n    tree.sort()\n    print(tree)\n    \n    \n    # print(n)\n    # for i in range(n-1):\n    #     edge = input()\n    #     print(edge)\n\nif __name__ == \"__main__\":\n    main()", "\n\n# TODO: write your code here\nimport sys\nimport threading\n\nsys.setrecursionlimit(10**7) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nclass Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.connectedTo = {}\n        self.dist = 0\n        self.pred = None\n        self.color = 'white'\n        self.disc = 0\n        self.fin = 0\n        self.cost = sys.maxsize\n\n    def addNeighbor(self, nbr, weight=0):\n        self.connectedTo[nbr] = weight\n\n    def setColor(self, color):\n        self.color = color\n\n    def setDistance(self, d):\n        self.dist = d\n\n    def setPred(self, p):\n        self.pred = p\n\n    def setDiscovery(self, dtime):\n        self.disc = dtime\n\n    def setFinish(self, ftime):\n        self.fin = ftime\n\n    def getFinish(self):\n        return self.fin\n\n    def getDiscovery(self):\n        return self.disc\n\n    def getPred(self):\n        return self.pred\n\n    def getDistance(self):\n        return self.dist\n\n    def getColor(self):\n        return self.color\n\n    def getConnections(self):\n        return self.connectedTo.keys()\n\n    def getWeight(self, nbr):\n        return self.connectedTo[nbr]\n\n    def __str__(self):\n        return str(self.key) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n\n    def getCost(self):\n        return self.cost\n\n    def setCost(self,newcost):\n        self.cost = newcost\n\nclass Graph:\n    def __init__(self):\n        self.vertList = {}\n        self.numVertices = 0\n        self.time = 0\n\n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertList[key] = newVertex\n        return newVertex\n\n    def getVertex(self,n):\n        if n in self.vertList:\n            return self.vertList[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertList\n\n    def addEdge(self,f,t,cost=0):\n        if f not in self.vertList:\n            nv = self.addVertex(f)\n        if t not in self.vertList:\n            nv = self.addVertex(t)\n        self.vertList[f].addNeighbor(self.vertList[t], cost)\n\n    def getVertices(self):\n        return self.vertList.keys()\n\n    def __iter__(self):\n        return iter(self.vertList.values())\n\n    def dfs(self, start):\n        self.dfs_visit(start)\n\n    def dfs_visit(self, current):\n        current.setDistance(self.time)\n        current.setPred(None)\n        current.setColor('gray')\n        self.time += 1\n        for v in current.connectedTo:\n            if v.getColor() == 'white':\n                v.setPred(current)\n                self.dfs_visit(v)\n        current.setColor('black')\n        current.setFinish(self.time)\n        self.time += 1\n\n    def print_dfs(self):\n        for v in self:\n            print(v)\n\ndef main():\n    nodes_count = int(input())\n    edges_count = nodes_count - 1\n    graph = Graph()\n\n    for _ in range(edges_count):\n        a, b = [int(x) for x in input().split()]\n        graph.addEdge(a, b)\n        graph.addEdge(b, a)\n\n    graph.dfs(graph.getVertex(1))\n    for v in graph:\n        for n in v.getConnections():\n            if v.getDiscovery() < n.getDiscovery() and v.getFinish() > n.getFinish():\n                v.setCost(1)\n            else:\n                v.setCost(0)\n    max_cost = 0\n    v1 = 0\n    v2 = 0\n    v3 = 0\n    for v in graph:\n        for n in v.getConnections():\n            if v.getCost() + n.getCost() > max_cost:\n                v1 = v.key\n                v2 = n.key\n                max_cost = v.getCost() + n.getCost()\n            for p in n.getConnections():\n                if v.getCost() + n.getCost() + p.getCost() > max_cost:\n                    v1 = v.key\n                    v2 = n.key\n                    v3 = p.key\n                    max_cost = v.getCost() + n.getCost() + p.getCost()\n    print(max_cost)\n    print(v1, v2, v3)\n\nthreading.Thread(target=main).start()", "\n\nfrom collections import defaultdict\n\ndef dfs(node, parent):\n\tsubtree_size = 1\n\tsubtree_max = 0\n\tsubtree_second_max = 0\n\tfor child in graph[node]:\n\t\tif child != parent:\n\t\t\tsubtree_size_child, subtree_max_child, subtree_second_max_child = dfs(child, node)\n\t\t\tsubtree_size += subtree_size_child\n\t\t\tsubtree_max = max(subtree_max, subtree_max_child)\n\t\t\tsubtree_second_max = max(subtree_second_max, subtree_second_max_child)\n\tsubtree_max = max(subtree_max, n - subtree_size)\n\tsubtree_second_max = max(subtree_second_max, n - subtree_size)\n\tif subtree_max < subtree_second_max:\n\t\tsubtree_max, subtree_second_max = subtree_second_max, subtree_max\n\treturn subtree_size, subtree_max, subtree_second_max\n\ndef main():\n\tglobal n, graph\n\tn = int(input())\n\tgraph = defaultdict(set)\n\tfor i in range(n - 1):\n\t\ta, b = map(int, input().split())\n\t\tgraph[a].add(b)\n\t\tgraph[b].add(a)\n\tsize, _, second_max = dfs(1, 0)\n\tprint(n - 1 - second_max)\n\tprint(\"1 \" + str(size) + \" \" + str(second_max))\n\nmain()", "\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\nfrom tree_util import TreeUtil\n\nif __name__ == '__main__':\n    n = int(input())\n    tu = TreeUtil(n)\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tu.add_edge(a, b)\n    res = tu.max_path()\n    print(res)\n    print(*res)"]