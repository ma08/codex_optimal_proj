["\n\n\ndef max_sum(n, m, k, matrix):\n    max_sum = 0\n    for i in range(n):\n        max_sum += max_sum_in_row(matrix[i], m, k)\n    return max_sum\n\n\ndef max_sum_in_row(row, m, k):\n    half = m // 2\n    row = sorted(row, key=lambda x: x % k)\n    max_sum = 0\n    for i in range(half + 1):\n        if i == half and row[i] % k != 0:\n            continue\n        max_sum += row[i]\n    return max_sum\n\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, input().split())))\n    print(max_sum(n, m, k, matrix))", "\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\ndef read_int():\n    return int(input())\n\ndef read_matrix():\n    return [read_ints() for _ in range(read_int())]\n\ndef matrix_rows(matrix):\n    return len(matrix)\n\ndef matrix_cols(matrix):\n    return len(matrix[0])\n\ndef matrix_elems(matrix):\n    for row in matrix:\n        for elem in row:\n            yield elem\n\ndef matrix_max_sum_divisible_by(matrix, divisor):\n    return max(sum(row) for row in matrix if sum(row) % divisor == 0)\n\ndef matrix_elems_sum_divisible_by(matrix, divisor):\n    return sum(elem for elem in matrix_elems(matrix) if elem % divisor == 0)\n\ndef matrix_max_sum_divisible_by_k(matrix, k):\n    return max(matrix_elems_sum_divisible_by(matrix, k),\n        matrix_max_sum_divisible_by(matrix, k))\n\n#-----\n\nn, m, k = read_ints()\na = read_matrix()\n\nprint(matrix_max_sum_divisible_by_k(a, k))", "\n\nn, m, k = map(int, input().split())\n\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[0] * (m+1) for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n        if j > 1:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-2]+matrix[i-1][j-1])\n\nfor row in dp:\n    print(row)\n\nprint(dp[n][m])", "\n\n#SOLUTION\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\ndp = [[0] * (m + 1) for i in range(n + 1)]\n\nfor i in range(1, n + 1):\n    for j in range(1, min(m + 1, i * (m // 2) + 1)):\n        if j <= m // 2:\n            dp[i][j] = dp[i - 1][j]\n        else:\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - m // 2] + a[i - 1][j - m // 2 - 1])\n\nprint(dp[n][m // 2])", "\n\nfrom sys import stdin\nfrom itertools import product\nfrom collections import defaultdict\nfrom collections import deque\nfrom math import ceil\n\ndef read_ints():\n    return tuple(int(x) for x in stdin.readline().split())\n\ndef read_int_matrix(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_int_matrix_rows(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_int_matrix_cols(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_int_matrix_3d(rows, cols, depth):\n    return tuple(tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(cols)) for _ in range(depth))\n\ndef read_ints_cols(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_int_matrix_2d(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_int_matrix_one_line(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_str_matrix(rows):\n    return tuple(stdin.readline().split() for _ in range(rows))\n\ndef read_str_matrix_2d(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_str_matrix_cols(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_floats():\n    return tuple(float(x) for x in stdin.readline().split())\n\ndef read_floats_cols(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_floats_matrix(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_floats_matrix_cols(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_ints_matrix_cols(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_floats_matrix_2d(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_floats_matrix_one_line(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_ints_matrix(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_ints_matrix_2d(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_ints_matrix_3d(rows, cols, depth):\n    return tuple(tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(cols)) for _ in range(depth))\n\ndef read_ints_matrix_one_line(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_ints_cols_one_line(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_floats_cols_one_line(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_floats_matrix_cols_one_line(rows):\n    return tuple(tuple(float(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_ints_matrix_cols_one_line(rows):\n    return tuple(tuple(int(x) for x in stdin.readline().split()) for _ in range(rows))\n\ndef read_chars():\n    return tuple(stdin.readline().split())\n\ndef read_chars_cols(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_chars_matrix(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_chars_matrix_cols(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_chars_matrix_cols_one_line(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_chars_matrix_one_line(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef read_chars_cols_one_line(rows):\n    return tuple(tuple(stdin.readline().split()) for _ in range(rows))\n\ndef dp_algorithm(rows, cols, k, matrix):\n    # dp_table = [[0 for _ in range(cols+1)] for _ in range(rows+1)]\n    # for i in range(rows):\n    #     for j in range(cols):\n    #         for k in range(j, cols):\n    #             dp_table[i][k] = max(dp_table[i][k], matrix[i][j])\n    # print(dp_table)\n    # return dp_table\n    return [[0 for _ in range(cols+1)] for _ in range(rows+1)]\n\ndef main():\n    n, m, k = read_ints()\n    matrix = read_int_matrix(n)\n    dp_table = dp_algorithm(n, m, k, matrix)\n    print(dp_table)\n\nif __name__ == \"__main__\":\n    main()", "\n\nn, m, k = [int(x) for x in input().split()]\na = []\nfor i in range(n):\n    a.append([int(x) for x in input().split()])\n\ndp = [[0 for i in range(m+1)] for j in range(n+1)]\n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + a[i-1][j-1])\n\nprint(dp[n][m])", "\n\ndef main():\n    n, m, k = map(int, input().split())\n    matrix = [[int(el) for el in input().split()] for _ in range(n)]\n    dp = [[0] * (m // 2 + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(m // 2 + 1):\n            if i == 0:\n                dp[i][j] = sum(sorted(matrix[i])[-j:])\n            elif j == 0:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = max(dp[i - 1][j], sum(sorted(matrix[i])[-j:]) + dp[i - 1][j - 1])\n    print(dp[-1][-1] - dp[-1][-1] % k)\n\nif __name__ == \"__main__\":\n    main()", "\nimport sys\nfrom collections import deque\n\nn, m, k = map(int, input().split())\n\nmatrix = []\n\nfor i in range(n):\n    matrix.append(list(map(int, input().split())))\n\nans = 0\n\nfor i in range(1, k):\n    count_per_column = [0] * m\n    for row in matrix:\n        for j, val in enumerate(row):\n            if val % k == i:\n                count_per_column[j] += 1\n\n    # print('i:', i, 'count_per_column:', count_per_column)\n    count_per_column = deque(sorted(count_per_column))\n    # print('i:', i, 'count_per_column:', count_per_column)\n\n    max_column = m // 2\n    if m % 2 == 1:\n        max_column += 1\n    for _ in range(max_column):\n        val = count_per_column.popleft()\n        ans += val\n\nprint(ans)"]