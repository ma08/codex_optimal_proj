2022-04-16 19:46:43.969475 """
N tiles are arranged in a row from left to right. The initial color of each tile is represented by a string S of length N.
The i-th tile from the left is painted black if the i-th character of S is 0, and painted white if that character is 1.
You want to repaint some of the tiles black or white, so that any two adjacent tiles have different colors.
At least how many tiles need to be repainted to satisfy the condition?

-----Constraints-----
 - 1 \leq |S| \leq 10^5
 - S_i is 0 or 1.

-----Input-----
Input is given from Standard Input in the following format:
S

-----Output-----
Print the minimum number of tiles that need to be repainted to satisfy the condition.

-----Sample Input-----
000

-----Sample Output-----
1

The condition can be satisfied by repainting the middle tile white.
"""
2022-04-16 19:46:43.969483 --------------------------
2022-04-16 19:46:57.073296 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ns = input()\n\n# If there are no 0s or no 1s, no tiles need to be repainted\nif (s.count('0') == 0) or (s.count('1') == 0):\n    print(0)\n\n# Otherwise, the number of tiles that need to be repainted is the minimum of the number of 0s and the number of 1s\nelse:\n    print(min(s.count('0'), s.count('1')))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nprint(len(input()) - input().count('01') - input().count('10'))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    s = input()\n    result = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            result += 1\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nprint(input().count('01') + input().count('10'))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom collections import Counter\n\ndef main():\n    s = input()\n    counter = Counter(s)\n    print(min(counter.values()))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    s = list(sys.stdin.readline().rstrip())\n    if s[0] == s[-1]:\n        print(1)\n    else:\n        print(0)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ns = input()\n\nif s[0] == s[-1]:\n    print(len(s)-1)\nelse:\n    print(len(s))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ns = input()\n\nans = 0\n\nfor i in range(1, len(s)):\n    if s[i] == s[i-1]:\n        ans += 1\n\nprint(ans)"
    }
  ],
  "created": 1650138404,
  "id": "cmpl-4xifUeObkBfkK6gV9ZY9ROPZSeby8",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:46:57.073559 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ns = input()\n\n# If there are no 0s or no 1s, no tiles need to be repainted\nif (s.count('0') == 0) or (s.count('1') == 0):\n    print(0)\n\n# Otherwise, the number of tiles that need to be repainted is the minimum of the number of 0s and the number of 1s\nelse:\n    print(min(s.count('0'), s.count('1')))"
}
2022-04-16 19:46:57.073591 REASON stop
2022-04-16 19:46:57.115602 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nprint(len(input()) - input().count('01') - input().count('10'))"
}
2022-04-16 19:46:57.115772 REASON stop
2022-04-16 19:46:57.122595 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    s = input()\n    result = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            result += 1\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:46:57.122707 REASON stop
2022-04-16 19:46:57.131141 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nprint(input().count('01') + input().count('10'))"
}
2022-04-16 19:46:57.131245 REASON stop
2022-04-16 19:46:57.139175 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom collections import Counter\n\ndef main():\n    s = input()\n    counter = Counter(s)\n    print(min(counter.values()))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:46:57.139309 REASON stop
2022-04-16 19:46:57.149544 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    s = list(sys.stdin.readline().rstrip())\n    if s[0] == s[-1]:\n        print(1)\n    else:\n        print(0)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:46:57.149669 REASON stop
2022-04-16 19:46:57.157743 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ns = input()\n\nif s[0] == s[-1]:\n    print(len(s)-1)\nelse:\n    print(len(s))"
}
2022-04-16 19:46:57.157850 REASON stop
2022-04-16 19:46:57.166658 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ns = input()\n\nans = 0\n\nfor i in range(1, len(s)):\n    if s[i] == s[i-1]:\n        ans += 1\n\nprint(ans)"
}
2022-04-16 19:46:57.166777 REASON stop
