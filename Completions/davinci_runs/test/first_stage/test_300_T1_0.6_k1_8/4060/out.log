2022-04-16 19:10:43.638032 """
You are given a bracket sequence $s$ consisting of $n$ opening '(' and closing ')' brackets.

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences "()()", "(())" are regular (the resulting expressions are: "(1)+(1)", "((1+1)+1)"), and ")(" and "(" are not.

You can change the type of some bracket $s_i$. It means that if $s_i = $ ')' then you can change it to '(' and vice versa.

Your task is to calculate the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 10^6$) — the length of the bracket sequence.

The second line of the input contains the string $s$ consisting of $n$ opening '(' and closing ')' brackets.


-----Output-----

Print one integer — the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.


-----Examples-----
Input
6
(((())

Output
3

Input
6
()()()

Output
0

Input
1
)

Output
0

Input
8
)))(((((

Output
0
"""
2022-04-16 19:10:43.638044 --------------------------
2022-04-16 19:11:12.050832 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfrom collections import deque\nn = int(input())\nstack = deque()\nfor i in range(n):\n    c = input()\n    if c == ')':\n        if stack and stack[-1] == '(':\n            stack.pop()\n        else:\n            stack.append(c)\n    else:\n        stack.append(c)\n\nprint(n - len(stack))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\ncnt = 0\n\nfor i in range(n):\n    if s[i] == ')':\n        cnt -= 1\n    else:\n        cnt += 1\n    if cnt < 0:\n        print(i+1)\n        break\nelse:\n    if cnt > 0:\n        print(n)\n    else:\n        print(0)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = list(input())\n\nif n == 1:\n    print(0)\nelif n == 2 and s[0] == '(' and s[1] == ')':\n    print(1)\nelse:\n    count = 0\n    for i in range(n):\n        if (s[i] == ')' and i < n-1 and s[i+1] == ')') or (s[i] == '(' and i > 0 and s[i-1] == '('):\n            count += 1\n    print(count)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    res = 0\n    \n    if n == 1:\n        print(0)\n        return\n    \n    for i in range(n):\n        if s[i] == ')' and i > 0 and s[i-1] == ')' and i < n-1 and s[i+1] == '(':\n            res += 1\n        if s[i] == '(' and i > 0 and s[i-1] == '(' and i < n-1 and s[i+1] == ')':\n            res += 1\n    \n    print(res)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\nsys.setrecursionlimit(100000)\n\nn = int(input())\ns = input()\n\n\"\"\"\n(((())\n^^^^^\n\"\"\"\n\n# TLE\ndef solve(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# TLE\ndef solve2(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# TLE\ndef solve3(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# AC\ndef solve4(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve4(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve4(s[1:-1]) + 1\n    else:\n        return solve4(s[1:-1])\n\nprint(solve4(s))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline()\n\ndef get_ans(s):\n    cnt = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n        if cnt < 0:\n            return 1\n    if cnt == 0:\n        return 0\n    else:\n        return 2\n\nans = get_ans(s)\nif ans == 0:\n    print(0)\n    sys.exit(0)\n\nres = 0\nfor i in range(len(s)):\n    if s[i] == '(':\n        s1 = s[:i] + ')' + s[i+1:]\n    else:\n        s1 = s[:i] + '(' + s[i+1:]\n    if get_ans(s1) == 0:\n        res += 1\nprint(res)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\n\nstack = []\nans = 0\nfor i in range(n):\n    if s[i] == '(':\n        stack.append(s[i])\n    else:\n        if len(stack) == 0:\n            ans += 1\n        else:\n            stack.pop()\nprint(stack.count('('))\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef get_invalid_subsequences(brackets):\n    \"\"\"\n    Returns list of invalid subsequences of brackets.\n    An invalid subsequence is one that starts with ')' and ends with '('.\n    \"\"\"\n    subsequences = []\n    l = len(brackets)\n    current_subsequence = []\n    for i in range(l):\n        current_subsequence.append(brackets[i])\n        if brackets[i] == ')' and brackets[(i+1)%l] == '(':\n            subsequences.append(current_subsequence)\n            current_subsequence = []\n    return subsequences\n\n\ndef get_subsequence_score(subsequence):\n    \"\"\"\n    Returns score of a subsequence in terms of how many brackets\n    need to be swapped to make it valid.\n    \"\"\"\n    l = len(subsequence)\n    open_brackets = 0\n    close_brackets = 0\n    for i in range(l):\n        if subsequence[i] == '(':\n            open_brackets += 1\n        else:\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                close_brackets += 1\n    assert open_brackets == close_brackets\n    return open_brackets\n\n\ndef get_swapped_count(brackets):\n    \"\"\"\n    Returns the number of brackets that need to be swapped\n    to make a bracket sequence valid.\n    \"\"\"\n    invalid_subsequences = get_invalid_subsequences(brackets)\n    return sum(get_subsequence_score(subsequence) for subsequence in invalid_subsequences)\n\n\ndef get_swappable_count(brackets):\n    \"\"\"\n    Returns the number of brackets that can be swapped\n    to make a bracket sequence valid.\n    \"\"\"\n    invalid_subsequences = get_invalid_subsequences(brackets)\n    return 2 * sum(get_subsequence_score(subsequence) for subsequence in invalid_subsequences)\n\n\ndef main():\n    brackets = input()\n    swappable_count = get_swappable_count(brackets)\n    swapped_count = get_swapped_count(brackets)\n    print(swappable_count - swapped_count)\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650136243,
  "id": "cmpl-4xi6dVSmHTa6Zen529R7iLysgLlpi",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:11:12.051148 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfrom collections import deque\nn = int(input())\nstack = deque()\nfor i in range(n):\n    c = input()\n    if c == ')':\n        if stack and stack[-1] == '(':\n            stack.pop()\n        else:\n            stack.append(c)\n    else:\n        stack.append(c)\n\nprint(n - len(stack))"
}
2022-04-16 19:11:12.051186 REASON stop
2022-04-16 19:11:12.062963 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\ncnt = 0\n\nfor i in range(n):\n    if s[i] == ')':\n        cnt -= 1\n    else:\n        cnt += 1\n    if cnt < 0:\n        print(i+1)\n        break\nelse:\n    if cnt > 0:\n        print(n)\n    else:\n        print(0)"
}
2022-04-16 19:11:12.063174 REASON stop
2022-04-16 19:11:12.063700 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = list(input())\n\nif n == 1:\n    print(0)\nelif n == 2 and s[0] == '(' and s[1] == ')':\n    print(1)\nelse:\n    count = 0\n    for i in range(n):\n        if (s[i] == ')' and i < n-1 and s[i+1] == ')') or (s[i] == '(' and i > 0 and s[i-1] == '('):\n            count += 1\n    print(count)"
}
2022-04-16 19:11:12.063771 REASON stop
2022-04-16 19:11:12.091128 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    s = input()\n    res = 0\n    \n    if n == 1:\n        print(0)\n        return\n    \n    for i in range(n):\n        if s[i] == ')' and i > 0 and s[i-1] == ')' and i < n-1 and s[i+1] == '(':\n            res += 1\n        if s[i] == '(' and i > 0 and s[i-1] == '(' and i < n-1 and s[i+1] == ')':\n            res += 1\n    \n    print(res)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:11:12.091230 REASON stop
2022-04-16 19:11:12.092155 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\nsys.setrecursionlimit(100000)\n\nn = int(input())\ns = input()\n\n\"\"\"\n(((())\n^^^^^\n\"\"\"\n\n# TLE\ndef solve(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# TLE\ndef solve2(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# TLE\ndef solve3(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# AC\ndef solve4(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve4(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve4(s[1:-1]) + 1\n    else:\n        return solve4(s[1:-1])\n\nprint(solve4(s))"
}
2022-04-16 19:11:12.092247 REASON stop
2022-04-16 19:11:12.093254 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline()\n\ndef get_ans(s):\n    cnt = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n        if cnt < 0:\n            return 1\n    if cnt == 0:\n        return 0\n    else:\n        return 2\n\nans = get_ans(s)\nif ans == 0:\n    print(0)\n    sys.exit(0)\n\nres = 0\nfor i in range(len(s)):\n    if s[i] == '(':\n        s1 = s[:i] + ')' + s[i+1:]\n    else:\n        s1 = s[:i] + '(' + s[i+1:]\n    if get_ans(s1) == 0:\n        res += 1\nprint(res)"
}
2022-04-16 19:11:12.093334 REASON stop
2022-04-16 19:11:12.094334 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\n\nstack = []\nans = 0\nfor i in range(n):\n    if s[i] == '(':\n        stack.append(s[i])\n    else:\n        if len(stack) == 0:\n            ans += 1\n        else:\n            stack.pop()\nprint(stack.count('('))\nprint(ans)"
}
2022-04-16 19:11:12.094402 REASON stop
2022-04-16 19:11:12.095655 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef get_invalid_subsequences(brackets):\n    \"\"\"\n    Returns list of invalid subsequences of brackets.\n    An invalid subsequence is one that starts with ')' and ends with '('.\n    \"\"\"\n    subsequences = []\n    l = len(brackets)\n    current_subsequence = []\n    for i in range(l):\n        current_subsequence.append(brackets[i])\n        if brackets[i] == ')' and brackets[(i+1)%l] == '(':\n            subsequences.append(current_subsequence)\n            current_subsequence = []\n    return subsequences\n\n\ndef get_subsequence_score(subsequence):\n    \"\"\"\n    Returns score of a subsequence in terms of how many brackets\n    need to be swapped to make it valid.\n    \"\"\"\n    l = len(subsequence)\n    open_brackets = 0\n    close_brackets = 0\n    for i in range(l):\n        if subsequence[i] == '(':\n            open_brackets += 1\n        else:\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                close_brackets += 1\n    assert open_brackets == close_brackets\n    return open_brackets\n\n\ndef get_swapped_count(brackets):\n    \"\"\"\n    Returns the number of brackets that need to be swapped\n    to make a bracket sequence valid.\n    \"\"\"\n    invalid_subsequences = get_invalid_subsequences(brackets)\n    return sum(get_subsequence_score(subsequence) for subsequence in invalid_subsequences)\n\n\ndef get_swappable_count(brackets):\n    \"\"\"\n    Returns the number of brackets that can be swapped\n    to make a bracket sequence valid.\n    \"\"\"\n    invalid_subsequences = get_invalid_subsequences(brackets)\n    return 2 * sum(get_subsequence_score(subsequence) for subsequence in invalid_subsequences)\n\n\ndef main():\n    brackets = input()\n    swappable_count = get_swappable_count(brackets)\n    swapped_count = get_swapped_count(brackets)\n    print(swappable_count - swapped_count)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:11:12.095741 REASON stop
