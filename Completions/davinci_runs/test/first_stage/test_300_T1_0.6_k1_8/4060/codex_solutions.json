["\n\nimport sys\nimport math\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline()\n\ndef get_ans(s):\n    cnt = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n        if cnt < 0:\n            return 1\n    if cnt == 0:\n        return 0\n    else:\n        return 2\n\nans = get_ans(s)\nif ans == 0:\n    print(0)\n    sys.exit(0)\n\nres = 0\nfor i in range(len(s)):\n    if s[i] == '(':\n        s1 = s[:i] + ')' + s[i+1:]\n    else:\n        s1 = s[:i] + '(' + s[i+1:]\n    if get_ans(s1) == 0:\n        res += 1\nprint(res)", "\n\nn = int(input())\ns = input()\ncnt = 0\n\nfor i in range(n):\n    if s[i] == ')':\n        cnt -= 1\n    else:\n        cnt += 1\n    if cnt < 0:\n        print(i+1)\n        break\nelse:\n    if cnt > 0:\n        print(n)\n    else:\n        print(0)", "\n\nn = int(input())\ns = input()\n\nstack = []\nans = 0\nfor i in range(n):\n    if s[i] == '(':\n        stack.append(s[i])\n    else:\n        if len(stack) == 0:\n            ans += 1\n        else:\n            stack.pop()\nprint(stack.count('('))\nprint(ans)", "\n\nfrom collections import deque\nn = int(input())\nstack = deque()\nfor i in range(n):\n    c = input()\n    if c == ')':\n        if stack and stack[-1] == '(':\n            stack.pop()\n        else:\n            stack.append(c)\n    else:\n        stack.append(c)\n\nprint(n - len(stack))", "\n\ndef main():\n    n = int(input())\n    s = input()\n    res = 0\n    \n    if n == 1:\n        print(0)\n        return\n    \n    for i in range(n):\n        if s[i] == ')' and i > 0 and s[i-1] == ')' and i < n-1 and s[i+1] == '(':\n            res += 1\n        if s[i] == '(' and i > 0 and s[i-1] == '(' and i < n-1 and s[i+1] == ')':\n            res += 1\n    \n    print(res)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef get_invalid_subsequences(brackets):\n    \"\"\"\n    Returns list of invalid subsequences of brackets.\n    An invalid subsequence is one that starts with ')' and ends with '('.\n    \"\"\"\n    subsequences = []\n    l = len(brackets)\n    current_subsequence = []\n    for i in range(l):\n        current_subsequence.append(brackets[i])\n        if brackets[i] == ')' and brackets[(i+1)%l] == '(':\n            subsequences.append(current_subsequence)\n            current_subsequence = []\n    return subsequences\n\n\ndef get_subsequence_score(subsequence):\n    \"\"\"\n    Returns score of a subsequence in terms of how many brackets\n    need to be swapped to make it valid.\n    \"\"\"\n    l = len(subsequence)\n    open_brackets = 0\n    close_brackets = 0\n    for i in range(l):\n        if subsequence[i] == '(':\n            open_brackets += 1\n        else:\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                close_brackets += 1\n    assert open_brackets == close_brackets\n    return open_brackets\n\n\ndef get_swapped_count(brackets):\n    \"\"\"\n    Returns the number of brackets that need to be swapped\n    to make a bracket sequence valid.\n    \"\"\"\n    invalid_subsequences = get_invalid_subsequences(brackets)\n    return sum(get_subsequence_score(subsequence) for subsequence in invalid_subsequences)\n\n\ndef get_swappable_count(brackets):\n    \"\"\"\n    Returns the number of brackets that can be swapped\n    to make a bracket sequence valid.\n    \"\"\"\n    invalid_subsequences = get_invalid_subsequences(brackets)\n    return 2 * sum(get_subsequence_score(subsequence) for subsequence in invalid_subsequences)\n\n\ndef main():\n    brackets = input()\n    swappable_count = get_swappable_count(brackets)\n    swapped_count = get_swapped_count(brackets)\n    print(swappable_count - swapped_count)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\ns = list(input())\n\nif n == 1:\n    print(0)\nelif n == 2 and s[0] == '(' and s[1] == ')':\n    print(1)\nelse:\n    count = 0\n    for i in range(n):\n        if (s[i] == ')' and i < n-1 and s[i+1] == ')') or (s[i] == '(' and i > 0 and s[i-1] == '('):\n            count += 1\n    print(count)", "\n\nimport sys\nsys.setrecursionlimit(100000)\n\nn = int(input())\ns = input()\n\n\"\"\"\n(((())\n^^^^^\n\"\"\"\n\n# TLE\ndef solve(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# TLE\ndef solve2(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# TLE\ndef solve3(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve(s[1:-1]) + 1\n    else:\n        return solve(s[1:-1])\n\n# AC\ndef solve4(s):\n    if len(s) == 1:\n        return 0\n    elif s[0] == '(' and s[-1] == ')':\n        return solve4(s[1:-1]) + 1\n    elif s[0] == ')' and s[-1] == '(':\n        return solve4(s[1:-1]) + 1\n    else:\n        return solve4(s[1:-1])\n\nprint(solve4(s))"]