["\n\ndef DFS(v):\n\tused[v]=True\n\tfor u in graph[v]:\n\t\tif not used[u]:\n\t\t\tparent[u]=v\n\t\t\tDFS(u)\n\ndef main():\n\tn,k = [int(x) for x in input().split()]\n\tgraph = [[] for x in range(n+1)]\n\tfor i in range(n-1):\n\t\tx,y = [int(x) for x in input().split()]\n\t\tgraph[x].append(y)\n\t\tgraph[y].append(x)\n\tused = [False]*(n+1)\n\tparent = [-1]*(n+1)\n\tDFS(1)\n\tpath = []\n\tfor i in range(1,n+1):\n\t\tpath.append((i,parent[i]))\n\tpath.sort(key=lambda x: len(graph[x[0]]))\n\t\n\tfor i in range(len(path)):\n\t\tif i<k:\n\t\t\tprint(i+1, end=\" \")\n\t\telse:\n\t\t\tprint(k+1, end=\" \")\n\tprint()\n\nif __name__ == \"__main__\":\n\tmain()", "\n\nclass Node:\n    def __init__(self, parent, color):\n        self.parent = parent\n        self.color = color\n        self.children = []\n        self.is_not_good = False\n    def set_not_good(self):\n        self.is_not_good = True\n        if self.parent is not None:\n            self.parent.set_not_good()\n\ndef dfs(node, num_colors):\n    color = 1\n    for child in node.children:\n        if child.color == 0:\n            while color == node.color:\n                color += 1\n            child.color = color\n            color += 1\n        dfs(child, num_colors)\n    num_colors[node.color] += 1\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    nodes = [Node(None, 0) for _ in range(n+1)]\n    for _ in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        nodes[x].children.append(nodes[y])\n        nodes[y].children.append(nodes[x])\n    nodes[1].color = 1\n    num_colors = {}\n    dfs(nodes[1], num_colors)\n    print(len(num_colors))\n    for _ in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        node = nodes[x] if len(nodes[x].children) > len(nodes[y].children) else nodes[y]\n        colors = [c for c in num_colors if c != node.color]\n        colors.sort(key=lambda c: num_colors[c])\n        for child in node.children:\n            if child.color == node.color:\n                child.color = colors[0]\n                colors.append(colors.pop(0))\n        for color in colors:\n            num_colors[color] -= 1\n        num_colors[node.color] += 1\n        print(node.color, end=\" \")\n\nif __name__ == \"__main__\":\n    main()", "\nimport sys\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def solve(self, n: int, k: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        DFS\n        \"\"\"\n        graph = defaultdict(set)\n        for a,b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n\n        def dfs(v, p=None):\n            ret = []\n            for u in graph[v]:\n                if u == p:\n                    continue\n                ret.append(dfs(u, v))\n            if len(ret) == 0:\n                return 1\n            ret.sort()\n            ret.reverse()\n            return sum(ret[:min(len(ret), k)])\n\n        return dfs(1)\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for _ in range(n-1):\n        edges.append(list(map(int, input().split())))\n    print(Solution().solve(n, k, edges))\n\n\nif __name__ == '__main__':\n    main()", "\n\nn, k = map(int, input().split())\ngraph = {}\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  if a not in graph:\n    graph[a] = []\n  if b not in graph:\n    graph[b] = []\n  graph[a].append(b)\n  graph[b].append(a)\n\nvisited = [False for i in range(n+1)]\n\ndef dfs(node, parent, num):\n  visited[node] = True\n  for next in graph[node]:\n    if next != parent:\n      dfs(next, node, num)\n\ndef dfs_count(node, parent):\n  visited[node] = True\n  count = 0\n  for next in graph[node]:\n    if next != parent:\n      count += 1 + dfs_count(next, node)\n  return count\n\n# get components\ncomponents = []\nfor i in range(1, n+1):\n  if visited[i] == False:\n    dfs(i, -1, len(components))\n    components.append([])\nfor i in range(1, n+1):\n  components[visited[i]-1].append(i)\n\n# get sizes\nsizes = []\nfor component in components:\n  visited = [False for i in range(n+1)]\n  sizes.append(dfs_count(component[0], -1))\n\n# get answer\nans = min(k+1, len(components))\nprint(ans)\nfor component in components:\n  for node in component:\n    print(ans, end=' ')\n    ans -= 1\n    if ans == 0:\n      ans = min(k+1, len(components))\n  ans = min(k+1, len(components))", "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef dfs(cur, dp):\n    if dp[cur] != -1:\n        return dp[cur]\n    dp[cur] = 1\n    for i in range(len(adj[cur])):\n        dp[cur] = max(dp[cur], 1 + dfs(adj[cur][i], dp))\n    return dp[cur]\n\ndef dfs2(cur, color, dp):\n    if dp[cur] != -1:\n        return dp[cur]\n    dp[cur] = color\n    for i in range(len(adj[cur])):\n        dp[cur] = max(dp[cur], 1 + dfs2(adj[cur][i], color, dp))\n    return dp[cur]\n\nn, k = map(int, sys.stdin.readline().split())\nadj = [[] for _ in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, sys.stdin.readline().split())\n    x -= 1\n    y -= 1\n    adj[x].append(y)\n    adj[y].append(x)\n\ndp = [-1 for _ in range(n)]\n\nfor i in range(n):\n    dfs(i, dp)\n\ndp2 = [-1 for _ in range(n)]\nmax_color = 0\nfor i in range(n):\n    if dp2[i] == -1:\n        max_color = max(dfs2(i, max_color + 1, dp2), max_color)\n\ndp = [0 for _ in range(max_color + 1)]\nfor i in range(n):\n    dp[dp2[i]] += 1\n\nprint(max(1, max(dp) - k))\n\nfor i in range(n - 1):\n    print(dp2[i], end=' ')\nprint()", "\n\nimport sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\nn, k = map(int, input().split())\n\n# Get the adjacency list\nadj = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    adj[x-1].append(y-1)\n    adj[y-1].append(x-1)\n\n# Get the degrees of each vertex in the tree\ndeg = [len(adj[i]) for i in range(n)]\n\n# Get the number of subtrees of each vertex in the tree\nnum_subtrees = [1] * n\nfor i in range(n):\n    for j in adj[i]:\n        if j != i:\n            num_subtrees[i] += num_subtrees[j]\n\n# Get the number of edges in the subtree of each vertex in the tree\nnum_edges = [0] * n\nfor i in range(n):\n    for j in adj[i]:\n        if j != i:\n            num_edges[i] += num_edges[j] + num_subtrees[j]\n\n# Recursively assign the vertices to the companies\ndef assign(v, c):\n    # Assign the current vertex to the current company\n    c_assign[v] = c\n    for i in adj[v]:\n        # If the adjacent node is not assigned yet\n        if c_assign[i] == -1:\n            # If the number of edges in the subtree of the adjacent node is at least\n            # k, then assign the adjacent node to the current company\n            # Otherwise, assign the adjacent node to a new company\n            if num_edges[i] >= k:\n                assign(i, c)\n            else:\n                assign(i, c+1)\n\nc_assign = [-1] * n\nassign(0, 0)\n\n# Get the number of companies\nr = max(c_assign) + 1\n\n# Print the solution\nprint(r)\nprint(*c_assign)"]