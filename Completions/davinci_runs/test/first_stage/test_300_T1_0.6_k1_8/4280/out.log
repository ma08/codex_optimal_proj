2022-04-16 20:39:36.963355 """
Treeland consists of $n$ cities and $n-1$ roads. Each road is bidirectional and connects two distinct cities. From any city you can get to any other city by roads. Yes, you are right — the country's topology is an undirected tree.

There are some private road companies in Treeland. The government decided to sell roads to the companies. Each road will belong to one company and a company can own multiple roads.

The government is afraid to look unfair. They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city. The government wants to make such privatization that the number of such cities doesn't exceed $k$ and the number of companies taking part in the privatization is minimal.

Choose the number of companies $r$ such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most $k$. In other words, if for a city all the roads belong to the different companies then the city is good. Your task is to find the minimal $r$ that there is such assignment to companies from $1$ to $r$ that the number of cities which are not good doesn't exceed $k$. [Image] The picture illustrates the first example ($n=6, k=2$). The answer contains $r=2$ companies. Numbers on the edges denote edge indices. Edge colors mean companies: red corresponds to the first company, blue corresponds to the second company. The gray vertex (number $3$) is not good. The number of such vertices (just one) doesn't exceed $k=2$. It is impossible to have at most $k=2$ not good cities in case of one company. 


-----Input-----

The first line contains two integers $n$ and $k$ ($2 \le n \le 200000, 0 \le k \le n - 1$) — the number of cities and the maximal number of cities which can have two or more roads belonging to one company.

The following $n-1$ lines contain roads, one road per line. Each line contains a pair of integers $x_i$, $y_i$ ($1 \le x_i, y_i \le n$), where $x_i$, $y_i$ are cities connected with the $i$-th road.


-----Output-----

In the first line print the required $r$ ($1 \le r \le n - 1$). In the second line print $n-1$ numbers $c_1, c_2, \dots, c_{n-1}$ ($1 \le c_i \le r$), where $c_i$ is the company to own the $i$-th road. If there are multiple answers, print any of them.


-----Examples-----
Input
6 2
1 4
4 3
3 5
3 6
5 2

Output
2
1 2 1 1 2 
Input
4 2
3 1
1 4
1 2

Output
1
1 1 1 
Input
10 2
10 3
1 2
1 3
1 4
2 5
2 6
2 7
3 8
3 9

Output
3
1 1 2 3 2 3 1 3 1
"""
2022-04-16 20:39:36.963387 --------------------------
2022-04-16 20:41:20.673784 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef dfs(cur, dp):\n    if dp[cur] != -1:\n        return dp[cur]\n    dp[cur] = 1\n    for i in range(len(adj[cur])):\n        dp[cur] = max(dp[cur], 1 + dfs(adj[cur][i], dp))\n    return dp[cur]\n\ndef dfs2(cur, color, dp):\n    if dp[cur] != -1:\n        return dp[cur]\n    dp[cur] = color\n    for i in range(len(adj[cur])):\n        dp[cur] = max(dp[cur], 1 + dfs2(adj[cur][i], color, dp))\n    return dp[cur]\n\nn, k = map(int, sys.stdin.readline().split())\nadj = [[] for _ in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, sys.stdin.readline().split())\n    x -= 1\n    y -= 1\n    adj[x].append(y)\n    adj[y].append(x)\n\ndp = [-1 for _ in range(n)]\n\nfor i in range(n):\n    dfs(i, dp)\n\ndp2 = [-1 for _ in range(n)]\nmax_color = 0\nfor i in range(n):\n    if dp2[i] == -1:\n        max_color = max(dfs2(i, max_color + 1, dp2), max_color)\n\ndp = [0 for _ in range(max_color + 1)]\nfor i in range(n):\n    dp[dp2[i]] += 1\n\nprint(max(1, max(dp) - k))\n\nfor i in range(n - 1):\n    print(dp2[i], end=' ')\nprint()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, k = map(int, input().split())\ngraph = {}\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  if a not in graph:\n    graph[a] = []\n  if b not in graph:\n    graph[b] = []\n  graph[a].append(b)\n  graph[b].append(a)\n\nvisited = [False for i in range(n+1)]\n\ndef dfs(node, parent, num):\n  visited[node] = True\n  for next in graph[node]:\n    if next != parent:\n      dfs(next, node, num)\n\ndef dfs_count(node, parent):\n  visited[node] = True\n  count = 0\n  for next in graph[node]:\n    if next != parent:\n      count += 1 + dfs_count(next, node)\n  return count\n\n# get components\ncomponents = []\nfor i in range(1, n+1):\n  if visited[i] == False:\n    dfs(i, -1, len(components))\n    components.append([])\nfor i in range(1, n+1):\n  components[visited[i]-1].append(i)\n\n# get sizes\nsizes = []\nfor component in components:\n  visited = [False for i in range(n+1)]\n  sizes.append(dfs_count(component[0], -1))\n\n# get answer\nans = min(k+1, len(components))\nprint(ans)\nfor component in components:\n  for node in component:\n    print(ans, end=' ')\n    ans -= 1\n    if ans == 0:\n      ans = min(k+1, len(components))\n  ans = min(k+1, len(components))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\nn, k = map(int, input().split())\n\n# Get the adjacency list\nadj = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    adj[x-1].append(y-1)\n    adj[y-1].append(x-1)\n\n# Get the degrees of each vertex in the tree\ndeg = [len(adj[i]) for i in range(n)]\n\n# Get the number of subtrees of each vertex in the tree\nnum_subtrees = [1] * n\nfor i in range(n):\n    for j in adj[i]:\n        if j != i:\n            num_subtrees[i] += num_subtrees[j]\n\n# Get the number of edges in the subtree of each vertex in the tree\nnum_edges = [0] * n\nfor i in range(n):\n    for j in adj[i]:\n        if j != i:\n            num_edges[i] += num_edges[j] + num_subtrees[j]\n\n# Recursively assign the vertices to the companies\ndef assign(v, c):\n    # Assign the current vertex to the current company\n    c_assign[v] = c\n    for i in adj[v]:\n        # If the adjacent node is not assigned yet\n        if c_assign[i] == -1:\n            # If the number of edges in the subtree of the adjacent node is at least\n            # k, then assign the adjacent node to the current company\n            # Otherwise, assign the adjacent node to a new company\n            if num_edges[i] >= k:\n                assign(i, c)\n            else:\n                assign(i, c+1)\n\nc_assign = [-1] * n\nassign(0, 0)\n\n# Get the number of companies\nr = max(c_assign) + 1\n\n# Print the solution\nprint(r)\nprint(*c_assign)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef DFS(v):\n\tused[v]=True\n\tfor u in graph[v]:\n\t\tif not used[u]:\n\t\t\tparent[u]=v\n\t\t\tDFS(u)\n\ndef main():\n\tn,k = [int(x) for x in input().split()]\n\tgraph = [[] for x in range(n+1)]\n\tfor i in range(n-1):\n\t\tx,y = [int(x) for x in input().split()]\n\t\tgraph[x].append(y)\n\t\tgraph[y].append(x)\n\tused = [False]*(n+1)\n\tparent = [-1]*(n+1)\n\tDFS(1)\n\tpath = []\n\tfor i in range(1,n+1):\n\t\tpath.append((i,parent[i]))\n\tpath.sort(key=lambda x: len(graph[x[0]]))\n\t\n\tfor i in range(len(path)):\n\t\tif i<k:\n\t\t\tprint(i+1, end=\" \")\n\t\telse:\n\t\t\tprint(k+1, end=\" \")\n\tprint()\n\nif __name__ == \"__main__\":\n\tmain()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nclass Node:\n    def __init__(self, parent, color):\n        self.parent = parent\n        self.color = color\n        self.children = []\n        self.is_not_good = False\n    def set_not_good(self):\n        self.is_not_good = True\n        if self.parent is not None:\n            self.parent.set_not_good()\n\ndef dfs(node, num_colors):\n    color = 1\n    for child in node.children:\n        if child.color == 0:\n            while color == node.color:\n                color += 1\n            child.color = color\n            color += 1\n        dfs(child, num_colors)\n    num_colors[node.color] += 1\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    nodes = [Node(None, 0) for _ in range(n+1)]\n    for _ in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        nodes[x].children.append(nodes[y])\n        nodes[y].children.append(nodes[x])\n    nodes[1].color = 1\n    num_colors = {}\n    dfs(nodes[1], num_colors)\n    print(len(num_colors))\n    for _ in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        node = nodes[x] if len(nodes[x].children) > len(nodes[y].children) else nodes[y]\n        colors = [c for c in num_colors if c != node.color]\n        colors.sort(key=lambda c: num_colors[c])\n        for child in node.children:\n            if child.color == node.color:\n                child.color = colors[0]\n                colors.append(colors.pop(0))\n        for color in colors:\n            num_colors[color] -= 1\n        num_colors[node.color] += 1\n        print(node.color, end=\" \")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport fileinput\n\nn, k = [int(x) for x in fileinput.input()[0].split()]\nroads = [tuple([int(x) for x in line.split()]) for line in fileinput.input()[1:]]\n\ndef get_parents(n, roads):\n    parents = {}\n    for v in range(1, n+1):\n        parents[v] = v\n    for v1, v2 in roads:\n        parents[v1] = v2\n    return parents\n\ndef get_levels(n, roads):\n    levels = {}\n    for v in range(1, n+1):\n        levels[v] = 0\n    for v1, v2 in roads:\n        levels[v1] = levels[v2]+1\n    return levels\n\ndef get_children(n, roads):\n    children = {}\n    for v in range(1, n+1):\n        children[v] = set()\n    for v1, v2 in roads:\n        children[v2].add(v1)\n    return children\n\ndef get_subtrees(n, roads):\n    parents = get_parents(n, roads)\n    levels = get_levels(n, roads)\n    children = get_children(n, roads)\n    subtrees = {}\n    for v in range(1, n+1):\n        if v == parents[v]:\n            subtrees[v] = [v]\n            for u in children[v]:\n                subtrees[v].extend(subtrees[u])\n    return subtrees\n\ndef get_subtrees_counts(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtrees_counts = {}\n    for v in range(1, n+1):\n        subtrees_counts[v] = len(subtrees[v])\n    return subtrees_counts\n\ndef get_subtree_roots(n, roads):\n    parents = get_parents(n, roads)\n    levels = get_levels(n, roads)\n    children = get_children(n, roads)\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = {}\n    for v in range(1, n+1):\n        if v == parents[v]:\n            subtree_roots[v] = v\n            for u in children[v]:\n                subtree_roots[u] = v\n    return subtree_roots\n\ndef get_subtrees_by_roots(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_by_roots = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_by_roots:\n            subtrees_by_roots[subtree_roots[v]] = []\n        subtrees_by_roots[subtree_roots[v]].append(subtrees[v])\n    return subtrees_by_roots\n\ndef get_subtrees_counts_by_roots(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_counts_by_roots = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_counts_by_roots:\n            subtrees_counts_by_roots[subtree_roots[v]] = []\n        subtrees_counts_by_roots[subtree_roots[v]].append(len(subtrees[v]))\n    return subtrees_counts_by_roots\n\ndef get_subtrees_sizes(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_sizes = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_sizes:\n            subtrees_sizes[subtree_roots[v]] = 0\n        subtrees_sizes[subtree_roots[v]] += len(subtrees[v])\n    return subtrees_sizes\n\ndef get_subtrees_counts_by_sizes(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_counts_by_sizes = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_counts_by_sizes:\n            subtrees_counts_by_sizes[subtree_roots[v]] = []\n        subtrees_counts_by_sizes[subtree_roots[v]].append(len(subtrees[v]))\n    return subtrees_counts_by_sizes\n\ndef get_subtrees_sizes_by_roots(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_sizes_by_roots = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_sizes_by_roots:\n            subtrees_sizes_by_roots[subtree_roots[v]] = 0\n        subtrees_sizes_by_roots[subtree_roots[v]] += len(subtrees[v])\n    return subtrees_sizes_by_roots\n\ndef get_subtrees_sizes_by_sizes(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_sizes_by_sizes = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_sizes_by_sizes:\n            subtrees_sizes_by_sizes[subtree_roots[v]] = []\n        subtrees_sizes_by_sizes[subtree_roots[v]].append(len(subtrees[v]))\n    return subtrees_sizes_by_sizes\n\ndef get_roots(n, roads):\n    parents = get_parents(n, roads)\n    roots = []\n    for v in range(1, n+1):\n        if v == parents[v]:\n            roots.append(v)\n    return roots\n\ndef get_root_subtrees(n, roads):\n    subtrees = get_subtrees(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees = {}\n    for root in roots:\n        root_subtrees[root] = subtrees[root]\n    return root_subtrees\n\ndef get_root_subtrees_counts(n, roads):\n    subtrees_counts = get_subtrees_counts(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts = {}\n    for root in roots:\n        root_subtrees_counts[root] = subtrees_counts[root]\n    return root_subtrees_counts\n\ndef get_root_subtrees_sizes(n, roads):\n    subtrees_sizes = get_subtrees_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_sizes = {}\n    for root in roots:\n        root_subtrees_sizes[root] = subtrees_sizes[root]\n    return root_subtrees_sizes\n\n\ndef get_root_subtrees_sizes_by_roots(n, roads):\n    subtrees_sizes_by_roots = get_subtrees_sizes_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_sizes_by_roots = {}\n    for root in roots:\n        root_subtrees_sizes_by_roots[root] = subtrees_sizes_by_roots[root]\n    return root_subtrees_sizes_by_roots\n\ndef get_root_subtrees_sizes_by_sizes(n, roads):\n    subtrees_sizes_by_sizes = get_subtrees_sizes_by_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_sizes_by_sizes = {}\n    for root in roots:\n        root_subtrees_sizes_by_sizes[root] = subtrees_sizes_by_sizes[root]\n    return root_subtrees_sizes_by_sizes\n\ndef get_root_subtrees_counts_by_roots(n, roads):\n    subtrees_counts_by_roots = get_subtrees_counts_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_roots = {}\n    for root in roots:\n        root_subtrees_counts_by_roots[root] = subtrees_counts_by_roots[root]\n    return root_subtrees_counts_by_roots\n\ndef get_root_subtrees_counts_by_sizes(n, roads):\n    subtrees_counts_by_sizes = get_subtrees_counts_by_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_sizes = {}\n    for root in roots:\n        root_subtrees_counts_by_sizes[root] = subtrees_counts_by_sizes[root]\n    return root_subtrees_counts_by_sizes\n\ndef get_root_subtrees_by_roots(n, roads):\n    subtrees_by_roots = get_subtrees_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_by_roots = {}\n    for root in roots:\n        root_subtrees_by_roots[root] = subtrees_by_roots[root]\n    return root_subtrees_by_roots\n\ndef get_root_subtrees_counts_by_roots(n, roads):\n    subtrees_counts_by_roots = get_subtrees_counts_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_roots = {}\n    for root in roots:\n        root_subtrees_counts_by_roots[root] = subtrees_counts_by_roots[root]\n    return root_subtrees_counts_by_roots\n\ndef get_root_subtrees_counts_by_sizes(n, roads):\n    subtrees_counts_by_sizes = get_subtrees_counts_by_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_sizes = {}\n    for root in roots:\n        root_subtrees_counts_by_sizes[root] = subtrees_counts_by_sizes[root]\n    return root_subtrees_counts_by_sizes\n\n#print(get_root_subtrees_counts_by_sizes(n, roads))\n\ndef get_companies(n, k, roads):\n    root_subtrees_counts_by_sizes = get_root_subtrees_counts_by_sizes(n, roads)\n    root_subtrees_counts_by_roots = get_root_subtrees_counts_by_roots(n, roads)\n    root_subtrees_sizes_by_roots = get_root_subtrees_sizes_by_roots(n, roads)\n    root_subtrees_sizes_by_sizes = get_root_subtrees_sizes_by_sizes(n, roads)\n    root_subtrees_counts_by_sizes = get_root_subtrees_counts_by_sizes(n, roads)\n    root_subtrees_counts_by_roots = get_root_subtrees_counts_by_roots(n, roads)\n    root_subtrees_sizes_by_roots = get_root_subtrees_sizes_by_roots(n, roads)\n    root_subtrees_sizes_by_sizes = get_root_subtrees_sizes_by_sizes(n, roads)\n    r = 0\n    companies = []\n    for root in sorted(root_subtrees_sizes_by_roots, key=lambda x: root_subtrees_sizes_by_roots[x]):\n        for subtree_size in root_subtrees_sizes_by_sizes[root]:\n            if"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def solve(self, n: int, k: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        DFS\n        \"\"\"\n        graph = defaultdict(set)\n        for a,b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n\n        def dfs(v, p=None):\n            ret = []\n            for u in graph[v]:\n                if u == p:\n                    continue\n                ret.append(dfs(u, v))\n            if len(ret) == 0:\n                return 1\n            ret.sort()\n            ret.reverse()\n            return sum(ret[:min(len(ret), k)])\n\n        return dfs(1)\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for _ in range(n-1):\n        edges.append(list(map(int, input().split())))\n    print(Solution().solve(n, k, edges))\n\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650141577,
  "id": "cmpl-4xjUfdnHKBG7PWZ4lEDNJlKZCfawZ",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:41:20.674289 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef dfs(cur, dp):\n    if dp[cur] != -1:\n        return dp[cur]\n    dp[cur] = 1\n    for i in range(len(adj[cur])):\n        dp[cur] = max(dp[cur], 1 + dfs(adj[cur][i], dp))\n    return dp[cur]\n\ndef dfs2(cur, color, dp):\n    if dp[cur] != -1:\n        return dp[cur]\n    dp[cur] = color\n    for i in range(len(adj[cur])):\n        dp[cur] = max(dp[cur], 1 + dfs2(adj[cur][i], color, dp))\n    return dp[cur]\n\nn, k = map(int, sys.stdin.readline().split())\nadj = [[] for _ in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, sys.stdin.readline().split())\n    x -= 1\n    y -= 1\n    adj[x].append(y)\n    adj[y].append(x)\n\ndp = [-1 for _ in range(n)]\n\nfor i in range(n):\n    dfs(i, dp)\n\ndp2 = [-1 for _ in range(n)]\nmax_color = 0\nfor i in range(n):\n    if dp2[i] == -1:\n        max_color = max(dfs2(i, max_color + 1, dp2), max_color)\n\ndp = [0 for _ in range(max_color + 1)]\nfor i in range(n):\n    dp[dp2[i]] += 1\n\nprint(max(1, max(dp) - k))\n\nfor i in range(n - 1):\n    print(dp2[i], end=' ')\nprint()"
}
2022-04-16 20:41:20.674341 REASON stop
2022-04-16 20:41:20.726335 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, k = map(int, input().split())\ngraph = {}\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  if a not in graph:\n    graph[a] = []\n  if b not in graph:\n    graph[b] = []\n  graph[a].append(b)\n  graph[b].append(a)\n\nvisited = [False for i in range(n+1)]\n\ndef dfs(node, parent, num):\n  visited[node] = True\n  for next in graph[node]:\n    if next != parent:\n      dfs(next, node, num)\n\ndef dfs_count(node, parent):\n  visited[node] = True\n  count = 0\n  for next in graph[node]:\n    if next != parent:\n      count += 1 + dfs_count(next, node)\n  return count\n\n# get components\ncomponents = []\nfor i in range(1, n+1):\n  if visited[i] == False:\n    dfs(i, -1, len(components))\n    components.append([])\nfor i in range(1, n+1):\n  components[visited[i]-1].append(i)\n\n# get sizes\nsizes = []\nfor component in components:\n  visited = [False for i in range(n+1)]\n  sizes.append(dfs_count(component[0], -1))\n\n# get answer\nans = min(k+1, len(components))\nprint(ans)\nfor component in components:\n  for node in component:\n    print(ans, end=' ')\n    ans -= 1\n    if ans == 0:\n      ans = min(k+1, len(components))\n  ans = min(k+1, len(components))"
}
2022-04-16 20:41:20.726510 REASON stop
2022-04-16 20:41:20.726971 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:41:20.727033 REASON stop
2022-04-16 20:41:20.743275 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\nn, k = map(int, input().split())\n\n# Get the adjacency list\nadj = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    adj[x-1].append(y-1)\n    adj[y-1].append(x-1)\n\n# Get the degrees of each vertex in the tree\ndeg = [len(adj[i]) for i in range(n)]\n\n# Get the number of subtrees of each vertex in the tree\nnum_subtrees = [1] * n\nfor i in range(n):\n    for j in adj[i]:\n        if j != i:\n            num_subtrees[i] += num_subtrees[j]\n\n# Get the number of edges in the subtree of each vertex in the tree\nnum_edges = [0] * n\nfor i in range(n):\n    for j in adj[i]:\n        if j != i:\n            num_edges[i] += num_edges[j] + num_subtrees[j]\n\n# Recursively assign the vertices to the companies\ndef assign(v, c):\n    # Assign the current vertex to the current company\n    c_assign[v] = c\n    for i in adj[v]:\n        # If the adjacent node is not assigned yet\n        if c_assign[i] == -1:\n            # If the number of edges in the subtree of the adjacent node is at least\n            # k, then assign the adjacent node to the current company\n            # Otherwise, assign the adjacent node to a new company\n            if num_edges[i] >= k:\n                assign(i, c)\n            else:\n                assign(i, c+1)\n\nc_assign = [-1] * n\nassign(0, 0)\n\n# Get the number of companies\nr = max(c_assign) + 1\n\n# Print the solution\nprint(r)\nprint(*c_assign)"
}
2022-04-16 20:41:20.743418 REASON stop
2022-04-16 20:41:20.747339 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef DFS(v):\n\tused[v]=True\n\tfor u in graph[v]:\n\t\tif not used[u]:\n\t\t\tparent[u]=v\n\t\t\tDFS(u)\n\ndef main():\n\tn,k = [int(x) for x in input().split()]\n\tgraph = [[] for x in range(n+1)]\n\tfor i in range(n-1):\n\t\tx,y = [int(x) for x in input().split()]\n\t\tgraph[x].append(y)\n\t\tgraph[y].append(x)\n\tused = [False]*(n+1)\n\tparent = [-1]*(n+1)\n\tDFS(1)\n\tpath = []\n\tfor i in range(1,n+1):\n\t\tpath.append((i,parent[i]))\n\tpath.sort(key=lambda x: len(graph[x[0]]))\n\t\n\tfor i in range(len(path)):\n\t\tif i<k:\n\t\t\tprint(i+1, end=\" \")\n\t\telse:\n\t\t\tprint(k+1, end=\" \")\n\tprint()\n\nif __name__ == \"__main__\":\n\tmain()"
}
2022-04-16 20:41:20.747454 REASON stop
2022-04-16 20:41:20.748288 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nclass Node:\n    def __init__(self, parent, color):\n        self.parent = parent\n        self.color = color\n        self.children = []\n        self.is_not_good = False\n    def set_not_good(self):\n        self.is_not_good = True\n        if self.parent is not None:\n            self.parent.set_not_good()\n\ndef dfs(node, num_colors):\n    color = 1\n    for child in node.children:\n        if child.color == 0:\n            while color == node.color:\n                color += 1\n            child.color = color\n            color += 1\n        dfs(child, num_colors)\n    num_colors[node.color] += 1\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    nodes = [Node(None, 0) for _ in range(n+1)]\n    for _ in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        nodes[x].children.append(nodes[y])\n        nodes[y].children.append(nodes[x])\n    nodes[1].color = 1\n    num_colors = {}\n    dfs(nodes[1], num_colors)\n    print(len(num_colors))\n    for _ in range(n-1):\n        x, y = [int(x) for x in input().split()]\n        node = nodes[x] if len(nodes[x].children) > len(nodes[y].children) else nodes[y]\n        colors = [c for c in num_colors if c != node.color]\n        colors.sort(key=lambda c: num_colors[c])\n        for child in node.children:\n            if child.color == node.color:\n                child.color = colors[0]\n                colors.append(colors.pop(0))\n        for color in colors:\n            num_colors[color] -= 1\n        num_colors[node.color] += 1\n        print(node.color, end=\" \")\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:41:20.748436 REASON stop
2022-04-16 20:41:20.749314 6 {
  "finish_reason": "length",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport fileinput\n\nn, k = [int(x) for x in fileinput.input()[0].split()]\nroads = [tuple([int(x) for x in line.split()]) for line in fileinput.input()[1:]]\n\ndef get_parents(n, roads):\n    parents = {}\n    for v in range(1, n+1):\n        parents[v] = v\n    for v1, v2 in roads:\n        parents[v1] = v2\n    return parents\n\ndef get_levels(n, roads):\n    levels = {}\n    for v in range(1, n+1):\n        levels[v] = 0\n    for v1, v2 in roads:\n        levels[v1] = levels[v2]+1\n    return levels\n\ndef get_children(n, roads):\n    children = {}\n    for v in range(1, n+1):\n        children[v] = set()\n    for v1, v2 in roads:\n        children[v2].add(v1)\n    return children\n\ndef get_subtrees(n, roads):\n    parents = get_parents(n, roads)\n    levels = get_levels(n, roads)\n    children = get_children(n, roads)\n    subtrees = {}\n    for v in range(1, n+1):\n        if v == parents[v]:\n            subtrees[v] = [v]\n            for u in children[v]:\n                subtrees[v].extend(subtrees[u])\n    return subtrees\n\ndef get_subtrees_counts(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtrees_counts = {}\n    for v in range(1, n+1):\n        subtrees_counts[v] = len(subtrees[v])\n    return subtrees_counts\n\ndef get_subtree_roots(n, roads):\n    parents = get_parents(n, roads)\n    levels = get_levels(n, roads)\n    children = get_children(n, roads)\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = {}\n    for v in range(1, n+1):\n        if v == parents[v]:\n            subtree_roots[v] = v\n            for u in children[v]:\n                subtree_roots[u] = v\n    return subtree_roots\n\ndef get_subtrees_by_roots(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_by_roots = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_by_roots:\n            subtrees_by_roots[subtree_roots[v]] = []\n        subtrees_by_roots[subtree_roots[v]].append(subtrees[v])\n    return subtrees_by_roots\n\ndef get_subtrees_counts_by_roots(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_counts_by_roots = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_counts_by_roots:\n            subtrees_counts_by_roots[subtree_roots[v]] = []\n        subtrees_counts_by_roots[subtree_roots[v]].append(len(subtrees[v]))\n    return subtrees_counts_by_roots\n\ndef get_subtrees_sizes(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_sizes = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_sizes:\n            subtrees_sizes[subtree_roots[v]] = 0\n        subtrees_sizes[subtree_roots[v]] += len(subtrees[v])\n    return subtrees_sizes\n\ndef get_subtrees_counts_by_sizes(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_counts_by_sizes = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_counts_by_sizes:\n            subtrees_counts_by_sizes[subtree_roots[v]] = []\n        subtrees_counts_by_sizes[subtree_roots[v]].append(len(subtrees[v]))\n    return subtrees_counts_by_sizes\n\ndef get_subtrees_sizes_by_roots(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_sizes_by_roots = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_sizes_by_roots:\n            subtrees_sizes_by_roots[subtree_roots[v]] = 0\n        subtrees_sizes_by_roots[subtree_roots[v]] += len(subtrees[v])\n    return subtrees_sizes_by_roots\n\ndef get_subtrees_sizes_by_sizes(n, roads):\n    subtrees = get_subtrees(n, roads)\n    subtree_roots = get_subtree_roots(n, roads)\n    subtrees_sizes_by_sizes = {}\n    for v in range(1, n+1):\n        if subtree_roots[v] not in subtrees_sizes_by_sizes:\n            subtrees_sizes_by_sizes[subtree_roots[v]] = []\n        subtrees_sizes_by_sizes[subtree_roots[v]].append(len(subtrees[v]))\n    return subtrees_sizes_by_sizes\n\ndef get_roots(n, roads):\n    parents = get_parents(n, roads)\n    roots = []\n    for v in range(1, n+1):\n        if v == parents[v]:\n            roots.append(v)\n    return roots\n\ndef get_root_subtrees(n, roads):\n    subtrees = get_subtrees(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees = {}\n    for root in roots:\n        root_subtrees[root] = subtrees[root]\n    return root_subtrees\n\ndef get_root_subtrees_counts(n, roads):\n    subtrees_counts = get_subtrees_counts(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts = {}\n    for root in roots:\n        root_subtrees_counts[root] = subtrees_counts[root]\n    return root_subtrees_counts\n\ndef get_root_subtrees_sizes(n, roads):\n    subtrees_sizes = get_subtrees_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_sizes = {}\n    for root in roots:\n        root_subtrees_sizes[root] = subtrees_sizes[root]\n    return root_subtrees_sizes\n\n\ndef get_root_subtrees_sizes_by_roots(n, roads):\n    subtrees_sizes_by_roots = get_subtrees_sizes_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_sizes_by_roots = {}\n    for root in roots:\n        root_subtrees_sizes_by_roots[root] = subtrees_sizes_by_roots[root]\n    return root_subtrees_sizes_by_roots\n\ndef get_root_subtrees_sizes_by_sizes(n, roads):\n    subtrees_sizes_by_sizes = get_subtrees_sizes_by_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_sizes_by_sizes = {}\n    for root in roots:\n        root_subtrees_sizes_by_sizes[root] = subtrees_sizes_by_sizes[root]\n    return root_subtrees_sizes_by_sizes\n\ndef get_root_subtrees_counts_by_roots(n, roads):\n    subtrees_counts_by_roots = get_subtrees_counts_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_roots = {}\n    for root in roots:\n        root_subtrees_counts_by_roots[root] = subtrees_counts_by_roots[root]\n    return root_subtrees_counts_by_roots\n\ndef get_root_subtrees_counts_by_sizes(n, roads):\n    subtrees_counts_by_sizes = get_subtrees_counts_by_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_sizes = {}\n    for root in roots:\n        root_subtrees_counts_by_sizes[root] = subtrees_counts_by_sizes[root]\n    return root_subtrees_counts_by_sizes\n\ndef get_root_subtrees_by_roots(n, roads):\n    subtrees_by_roots = get_subtrees_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_by_roots = {}\n    for root in roots:\n        root_subtrees_by_roots[root] = subtrees_by_roots[root]\n    return root_subtrees_by_roots\n\ndef get_root_subtrees_counts_by_roots(n, roads):\n    subtrees_counts_by_roots = get_subtrees_counts_by_roots(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_roots = {}\n    for root in roots:\n        root_subtrees_counts_by_roots[root] = subtrees_counts_by_roots[root]\n    return root_subtrees_counts_by_roots\n\ndef get_root_subtrees_counts_by_sizes(n, roads):\n    subtrees_counts_by_sizes = get_subtrees_counts_by_sizes(n, roads)\n    roots = get_roots(n, roads)\n    root_subtrees_counts_by_sizes = {}\n    for root in roots:\n        root_subtrees_counts_by_sizes[root] = subtrees_counts_by_sizes[root]\n    return root_subtrees_counts_by_sizes\n\n#print(get_root_subtrees_counts_by_sizes(n, roads))\n\ndef get_companies(n, k, roads):\n    root_subtrees_counts_by_sizes = get_root_subtrees_counts_by_sizes(n, roads)\n    root_subtrees_counts_by_roots = get_root_subtrees_counts_by_roots(n, roads)\n    root_subtrees_sizes_by_roots = get_root_subtrees_sizes_by_roots(n, roads)\n    root_subtrees_sizes_by_sizes = get_root_subtrees_sizes_by_sizes(n, roads)\n    root_subtrees_counts_by_sizes = get_root_subtrees_counts_by_sizes(n, roads)\n    root_subtrees_counts_by_roots = get_root_subtrees_counts_by_roots(n, roads)\n    root_subtrees_sizes_by_roots = get_root_subtrees_sizes_by_roots(n, roads)\n    root_subtrees_sizes_by_sizes = get_root_subtrees_sizes_by_sizes(n, roads)\n    r = 0\n    companies = []\n    for root in sorted(root_subtrees_sizes_by_roots, key=lambda x: root_subtrees_sizes_by_roots[x]):\n        for subtree_size in root_subtrees_sizes_by_sizes[root]:\n            if"
}
2022-04-16 20:41:20.749466 REASON length
2022-04-16 20:41:20.749475 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\nimport sys\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def solve(self, n: int, k: int, edges: List[List[int]]) -> List[int]:\n        \"\"\"\n        DFS\n        \"\"\"\n        graph = defaultdict(set)\n        for a,b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n\n        def dfs(v, p=None):\n            ret = []\n            for u in graph[v]:\n                if u == p:\n                    continue\n                ret.append(dfs(u, v))\n            if len(ret) == 0:\n                return 1\n            ret.sort()\n            ret.reverse()\n            return sum(ret[:min(len(ret), k)])\n\n        return dfs(1)\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for _ in range(n-1):\n        edges.append(list(map(int, input().split())))\n    print(Solution().solve(n, k, edges))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:41:20.749519 REASON stop
