["\n\n\ndef dp_solver(s, t):\n    len_s = len(s)\n    len_t = len(t)\n    dp = [[0] * (len_s + 1) for _ in range(len_t + 1)]\n    for i in range(1, len_t + 1):\n        for j in range(1, len_s + 1):\n            if t[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    return len_s - dp[-1][-1]\n\n\ndef main():\n    s = input()\n    t = input()\n    print(dp_solver(s, t))\n\n\nif __name__ == '__main__':\n    main()", "\n\nfrom collections import Counter\n\ndef solve(s, t):\n    unique = [k for k, v in Counter(s).items() if v == 1]\n    l = len(s)\n    for x in unique:\n        if x in t:\n            l = min(l, s.count(x))\n    return l\n\nif __name__ == \"__main__\":\n    s = input()\n    t = input()\n    print(solve(s, t))", "\n\nimport sys\nsys.setrecursionlimit(10000)\n\ndef subsequence(s, t, i, j):\n    if i >= len(s) or j >= len(t):\n        return 0\n    if s[i] == t[j]:\n        return 1 + subsequence(s, t, i+1, j+1)\n    return subsequence(s, t, i+1, j)\n\ndef main():\n    S = input()\n    T = input()\n    print(len(S)-subsequence(S, T, 0, 0))\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef solve(s, t):\n    n, m = len(s), len(t)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            if s[i] == t[j]:\n                dp[i + 1][j + 1] = 1 + dp[i][j]\n            else:\n                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])\n    return n - dp[-1][-1]\n\n\nif __name__ == '__main__':\n    s = input()\n    t = input()\n    print(solve(s, t))", "\n\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    t_index = 0\n    for i in range(len(s)):\n        if t_index == len(t):\n            break\n\n        if s[i] == t[t_index]:\n            t_index += 1\n\n    print(len(s)-t_index)\n\n\nif __name__ == '__main__':\n    main()", "\n\ns = input()\nt = input()\n\ni, j, count = 0, 0, 0\nwhile i < len(s):\n    if s[i] == t[j]:\n        j += 1\n    else:\n        count += 1\n    i += 1\n\nprint(count)", "\n#SOLUTION\ns = input()\nt = input()\n\ndef maxSubstring(s, t):\n    if t:\n        s_index = s.index(t[0])\n        t_index = 0\n        max_substring_length = 0\n        while t_index < len(t):\n            max_substring_length = s_index - t_index\n            s_index += 1\n            t_index += 1\n            if s_index < len(s) and t_index < len(t):\n                while s_index < len(s) and s[s_index] != t[t_index]:\n                    s_index += 1\n    else:\n        max_substring_length = len(s)\n    return max_substring_length\n\nprint(maxSubstring(s, t))", "\n\ndef solve(s, t):\n    \"\"\"\n    >>> solve(\"bbaba\", \"bb\")\n    3\n    >>> solve(\"baaba\", \"ab\")\n    2\n    >>> solve(\"abcde\", \"abcde\")\n    0\n    >>> solve(\"asdfasdf\", \"fasd\")\n    3\n    \"\"\"\n    s = list(s)\n    t = list(t)\n    s_len = len(s)\n    t_len = len(t)\n\n    dp = [[0 for _ in range(s_len + 1)] for _ in range(t_len + 1)]\n    for i in range(1, t_len + 1):\n        for j in range(1, s_len + 1):\n            if t[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n    return s_len - dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    t = input().strip()\n    print(solve(s, t))"]