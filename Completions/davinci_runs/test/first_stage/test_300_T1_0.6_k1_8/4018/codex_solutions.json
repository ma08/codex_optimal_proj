["\n\ndef main():\n    n, k = map(int, raw_input().split())\n    s = raw_input()\n\n    if k > (n * (n + 1)) / 2:\n        print -1\n        return\n\n    cost = 0\n    for i in xrange(n, 0, -1):\n        if k >= i:\n            cost += (n - i) * i\n            k -= i\n        else:\n            cost += (n - i) * k\n            break\n\n    print cost\n\nif __name__ == '__main__':\n    main()", "\n\n#SOLUTION\n\nn, k = map(int, input().split())\ns = input()\n\nif k > n*(n+1)/2:\n    print(-1)\n    exit()\n\nif k == 1:\n    print(n*(n+1)//2)\n    exit()\n\n#print(s[:k-1])\n\nprint(n*(n+1)//2 - (n-k+1)*k//2)", "\n\nfrom collections import defaultdict\n\ndef is_subsequence(s, t):\n    i = 0\n    j = 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n    return i == len(s)\n\ndef solve_easy(s, k):\n    if len(s) == 1:\n        return 0\n    if len(s) == k:\n        return len(s) * (len(s) - 1) // 2\n\n    n = len(s)\n    dp = defaultdict(lambda: float('inf'))\n    dp[''] = 0\n    for j in range(n):\n        for i in range(j + 1, n + 1):\n            for t in dp.keys():\n                if is_subsequence(t, s[j:i]):\n                    dp[s[j:i]] = min(dp[s[j:i]], dp[t] + n - len(s[j:i]))\n    return dp[s] if dp[s] != float('inf') else -1\n\ndef solve_hard(s, k):\n    n = len(s)\n    dp = defaultdict(lambda: float('inf'))\n    dp[''] = 0\n    for j in range(n):\n        for i in range(j + 1, n + 1):\n            for t in dp.keys():\n                if is_subsequence(t, s[j:i]):\n                    dp[s[j:i]] = min(dp[s[j:i]], dp[t] + n - len(s[j:i]))\n    dp_sum = [0] * (n + 1)\n    for t in dp:\n        dp_sum[len(t)] = min(dp_sum[len(t)], dp[t])\n    for i in range(2, n + 1):\n        dp_sum[i] = min(dp_sum[i], dp_sum[i - 1])\n    ans = float('inf')\n    for i in range(1, n + 1):\n        if k % i == 0:\n            tot = dp_sum[i] * (k // i)\n            if tot < ans:\n                ans = tot\n    return ans if ans != float('inf') else -1\n\ndef solve(s, k):\n    return solve_hard(s, k)\n\ndef stress_test():\n    import random\n    import string\n    while True:\n        n = random.randint(1, 10)\n        k = random.randint(1, 10 ** 12)\n        s = ''.join(random.choice(string.ascii_lowercase) for _ in range(n))\n        ans1 = solve_easy(s, k)\n        ans2 = solve_hard(s, k)\n        assert ans1 == ans2\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    s = input()\n    ans = solve(s, k)\n    print(ans)", "\nn, k = map(int, input().split())\ns = input()\n\nif k > n*(n+1)//2:\n    print(-1)\nelse:\n    ans = 0\n    for i in range(1, n+1):\n        if k > i:\n            k -= i\n            ans += n-i\n        else:\n            ans += n-k\n            break\n    print(ans)", "\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    ans = 0\n    if k > 2**n:\n        ans = -1\n    else:\n        ans = n-1\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport math\n\ndef process(s):\n\tout = [0]\n\tfor i in range(1, len(s)+1):\n\t\tout.append(out[i-1] + len(s) - i)\n\treturn out\n\n\ndef main():\n\tn, k = map(int, input().split())\n\ts = input()\n\tif n > k:\n\t\tprint(-1)\n\telse:\n\t\tout = process(s)\n\t\tprint(out[n] - out[n - k])\n\n\nif __name__ == \"__main__\":\n\tmain()", "\n\nimport sys\n\ndef min_cost(s, k):\n    n = len(s)\n    costs = [0] * n\n    costs[0] = n - 1\n    for i in range(1, n):\n        costs[i] = costs[i - 1] + n - i\n        if costs[i] > k:\n            return -1\n    return costs[-1]\n\ndef main():\n    n, k = [int(i) for i in sys.stdin.readline().strip().split()]\n    s = sys.stdin.readline().strip()\n    print(min_cost(s, k))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = map(int, line.split())\n    \n    line = sys.stdin.readline()\n    s = [ord(c) - ord('a') for c in line.strip()]\n    \n    if n < k:\n        print(-1)\n    else:\n        # f[i][j] - min cost to generate set with size i\n        f = [[0] * (n + 1) for _ in range(n + 1)]\n        for j in range(n + 1):\n            f[0][j] = 0\n        for i in range(1, n + 1):\n            f[i][0] = 0\n            for j in range(1, n + 1):\n                f[i][j] = f[i][j - 1]\n                for l in range(1, j + 1):\n                    subs = s[j - l : j]\n                    cost = sum(1 for c in subs if subs[0] != c)\n                    f[i][j] = min(f[i][j], f[i - 1][j - l] + cost)\n        print(f[k][n] if f[k][n] < 10 ** 12 else -1)\n\nif __name__ == '__main__':\n    main()"]