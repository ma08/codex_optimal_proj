2022-04-16 19:48:49.013796 """
You have N bamboos. The lengths (in centimeters) of these are l_1, l_2, ..., l_N, respectively.
Your objective is to use some of these bamboos (possibly all) to obtain three bamboos of length A, B, C. For that, you can use the following three kinds of magics any number:
 - Extension Magic: Consumes 1 MP (magic point). Choose one bamboo and increase its length by 1.
 - Shortening Magic: Consumes 1 MP. Choose one bamboo of length at least 2 and decrease its length by 1.
 - Composition Magic: Consumes 10 MP. Choose two bamboos and combine them into one bamboo. The length of this new bamboo is equal to the sum of the lengths of the two bamboos combined. (Afterwards, further magics can be used on this bamboo.)
At least how much MP is needed to achieve the objective?

-----Constraints-----
 - 3 \leq N \leq 8
 - 1 \leq C < B < A \leq 1000
 - 1 \leq l_i \leq 1000
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N A B C
l_1
l_2
:
l_N

-----Output-----
Print the minimum amount of MP needed to achieve the objective.

-----Sample Input-----
5 100 90 80
98
40
30
21
80

-----Sample Output-----
23

We are obtaining three bamboos of lengths 100, 90, 80 from five bamboos 98, 40, 30, 21, 80. We already have a bamboo of length 80, and we can obtain bamboos of lengths 100, 90 by using the magics as follows at the total cost of 23 MP, which is optimal.
 - Use Extension Magic twice on the bamboo of length 98 to obtain a bamboo of length 100. (MP consumed: 2)
 - Use Composition Magic on the bamboos of lengths 40, 30 to obtain a bamboo of length 70. (MP consumed: 10)
 - Use Shortening Magic once on the bamboo of length 21 to obtain a bamboo of length 20. (MP consumed: 1)
 - Use Composition Magic on the bamboo of length 70 obtained in step 2 and the bamboo of length 20 obtained in step 3 to obtain a bamboo of length 90. (MP consumed: 10)
"""
2022-04-16 19:48:49.013827 --------------------------
2022-04-16 19:50:24.064276 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    l = [int(input()) for _ in range(N)]\n    dp = [[[float('inf')] * (C + 1) for _ in range(B + 1)] for _ in range(A + 1)]\n    dp[0][0][0] = 0\n    for i in range(N):\n        for a in range(A + 1):\n            for b in range(B + 1):\n                for c in range(C + 1):\n                    if dp[a][b][c] == float('inf'):\n                        continue\n                    # Extension Magic\n                    dp[min(a + l[i], A)][b][c] = min(dp[min(a + l[i], A)][b][c], dp[a][b][c] + max(0, a + l[i] - A))\n                    # Shortening Magic\n                    dp[max(a - l[i], 0)][b][c] = min(dp[max(a - l[i], 0)][b][c], dp[a][b][c] + max(0, l[i] - a))\n                    # Composition Magic\n                    dp[a][min(b + l[i], B)][c] = min(dp[a][min(b + l[i], B)][c], dp[a][b][c] + max(0, b + l[i] - B) + 10)\n                    dp[a][b][min(c + l[i], C)] = min(dp[a][b][min(c + l[i], C)], dp[a][b][c] + max(0, c + l[i] - C) + 10)\n    print(dp[A][B][C])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn, a, b, c = map(int, input().split())\nls = list(map(int, [input() for _ in range(n)]))\n\ndef dfs(target, ls):\n    if len(ls) == 0:\n        return 10**9\n    x = ls[0]\n    ls = ls[1:]\n    res = 10**9\n    if x == target:\n        res = 0\n    res = min(res, dfs(target, ls) + 1)\n    if x > target:\n        res = min(res, dfs(target, ls) + 10)\n    res = min(res, dfs(target-x, ls) + 10)\n    return res\n\nprint(dfs(a, ls) + dfs(b, ls) + dfs(c, ls))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\nN, A, B, C = map(int, input().split())\nL = []\nfor i in range(N):\n    L.append(int(input()))\n\nINF = 1000000\ndp = [[[INF for i in range(3000)] for j in range(3000)] for k in range(10)]\ndp[0][0][0] = 0\n\nfor i in range(N):\n    for j in range(3000):\n        for k in range(3000):\n            if dp[i][j][k] != INF:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]) # \u4f7f\u308f\u306a\u3044\n                dp[i+1][j+L[i]][k] = min(dp[i+1][j+L[i]][k], dp[i][j][k]) # \u4f7f\u3046\n                if j >= 2:\n                    dp[i+1][j-1][k] = min(dp[i+1][j-1][k], dp[i][j][k] + 1)\n                if j >= 1 and k >= 1:\n                    dp[i+1][j][k-1] = min(dp[i+1][j][k-1], dp[i][j][k] + 1)\n                if j >= 1 and k >= 9:\n                    dp[i+1][j+k-9][9] = min(dp[i+1][j+k-9][9], dp[i][j][k] + 10)\n\nprint(dp[N][A][B])"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for i in range(n)]\n\ndef dfs(n, a, b, c, l):\n    if n == 0:\n        return 10 ** 9\n    if max([a, b, c]) == 0:\n        return 0\n\n    ret = 10 ** 9\n    for i in range(n):\n        if l[i] == a:\n            ret = min(ret, dfs(n-1, a-1, b, c, l[:i] + l[i+1:]))\n        if l[i] == b:\n            ret = min(ret, dfs(n-1, a, b-1, c, l[:i] + l[i+1:]))\n        if l[i] == c:\n            ret = min(ret, dfs(n-1, a, b, c-1, l[:i] + l[i+1:]))\n        if l[i] > a:\n            ret = min(ret, dfs(n-1, a+1, b, c, l[:i] + l[i+1:]) + 1)\n        if l[i] > b:\n            ret = min(ret, dfs(n-1, a, b+1, c, l[:i] + l[i+1:]) + 1)\n        if l[i] > c:\n            ret = min(ret, dfs(n-1, a, b, c+1, l[:i] + l[i+1:]) + 1)\n        if l[i] > 1:\n            ret = min(ret, dfs(n-1, a, b, c, l[:i] + l[i+1:]) + 1)\n        for j in range(i+1, n):\n            if l[i] + l[j] == a:\n                ret = min(ret, dfs(n-2, a-1, b, c, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] == b:\n                ret = min(ret, dfs(n-2, a, b-1, c, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] == c:\n                ret = min(ret, dfs(n-2, a, b, c-1, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] > a:\n                ret = min(ret, dfs(n-2, a+1, b, c, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n            if l[i] + l[j] > b:\n                ret = min(ret, dfs(n-2, a, b+1, c, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n            if l[i] + l[j] > c:\n                ret = min(ret, dfs(n-2, a, b, c+1, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n    return ret\n\nprint(dfs(n, a, b, c, l))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\nn, a, b, c = map(int, sys.stdin.readline().rstrip().split())\nbamboos = list(map(int, sys.stdin.readline().rstrip().split()))\n\nbamboos.sort(reverse=True)\n\ncost = 0\nfor i in range(n):\n    if bamboos[i] >= a:\n        cost += (bamboos[i]-a)\n    elif a-bamboos[i] <= 10:\n        cost += (a-bamboos[i])*2\n    else:\n        bamboos[i] = a\n\nbamboos.sort(reverse=True)\n\nfor i in range(n):\n    if bamboos[i] >= b:\n        cost += (bamboos[i]-b)\n    elif b-bamboos[i] <= 10:\n        cost += (b-bamboos[i])*2\n    else:\n        bamboos[i] = b\n\nbamboos.sort(reverse=True)\n\nfor i in range(n):\n    if bamboos[i] >= c:\n        cost += (bamboos[i]-c)\n    elif c-bamboos[i] <= 10:\n        cost += (c-bamboos[i])*2\n    else:\n        bamboos[i] = c\n\nprint(cost)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\nfrom typing import Any, DefaultDict, Tuple\n\n\ndef get_min_cost(N: int, A: int, B: int, C: int, l_list: list) -> int:\n    \"\"\"\n    Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n    from N bamboos of lengths l_list.\n    \"\"\"\n    if A < B < C:\n        A, B, C = B, C, A\n\n    @lru_cache(maxsize=None)\n    def get_min_cost_inner(\n        A: int, B: int, C: int, length_dict: DefaultDict[int, int]\n    ) -> int:\n        \"\"\"\n        Inner function of get_min_cost.\n        Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n        from the bamboos of lengths in length_dict.\n        \"\"\"\n        if A < B < C:\n            return get_min_cost_inner(B, C, A, length_dict)\n        if len(length_dict) == 0:\n            return float(\"inf\")\n        if A < 0 or B < 0 or C < 0:\n            return float(\"inf\")\n        if A == 0 and B == 0 and C == 0:\n            return 0\n\n        # Get the maximum length of bamboo in length_dict\n        length_list = list(length_dict.keys())\n        max_length = max(length_list)\n\n        # Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n        # from the bamboos of lengths in length_dict\n        min_cost = float(\"inf\")\n        # Subtract the length of the bamboo with the maximum length from each of\n        # A, B, C and get the minimum cost of magic to get three bamboos of lengths\n        # (A - {max_length}, B - {max_length}, C - {max_length}) from the bamboos\n        # of lengths in length_dict\n        min_cost = min(\n            min_cost,\n            get_min_cost_inner(\n                A - max_length, B - max_length, C - max_length, length_dict\n            ),\n        )\n        # Subtract 1 from the length of the bamboo with the maximum length and get\n        # the minimum cost of magic to get three bamboos of lengths (A, B, C) from\n        # the bamboos of lengths in length_dict\n        if max_length > 1:\n            length_dict[max_length - 1] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 1,\n            )\n            length_dict[max_length - 1] -= 1\n        # Add 1 to the length of the bamboo with the maximum length and get\n        # the minimum cost of magic to get three bamboos of lengths (A, B, C) from\n        # the bamboos of lengths in length_dict\n        length_dict[max_length + 1] += 1\n        min_cost = min(\n            min_cost,\n            get_min_cost_inner(A, B, C, length_dict) + 1,\n        )\n        length_dict[max_length + 1] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 1 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 1:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 1] -= 1\n            length_dict[max_length * 2 - 1] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 1] += 1\n            length_dict[max_length * 2 - 1] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 2 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 2:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 2] -= 1\n            length_dict[max_length * 2 - 2] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 2] += 1\n            length_dict[max_length * 2 - 2] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 3 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 3:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 3] -= 1\n            length_dict[max_length * 2 - 3] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 3] += 1\n            length_dict[max_length * 2 - 3] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 4 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 4:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 4] -= 1\n            length_dict[max_length * 2 - 4] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 4] += 1\n            length_dict[max_length * 2 - 4] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 5 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 5:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 5] -= 1\n            length_dict[max_length * 2 - 5] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 5] += 1\n            length_dict[max_length * 2 - 5] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 6 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 6:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 6] -= 1\n            length_dict[max_length * 2 - 6] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 6] += 1\n            length_dict[max_length * 2 - 6] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 7 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 7:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 7] -= 1\n            length_dict[max_length * 2 - 7] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 7] += 1\n            length_dict[max_length * 2 - 7] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 8 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 8:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 8] -= 1\n            length_dict[max_length * 2 - 8] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 8] += 1\n            length_dict[max_length * 2 - 8] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 9 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 9:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 9] -= 1\n            length_dict[max_length * 2 - 9] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 9] += 1\n            length_dict[max_length * 2 - 9] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 10 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 10:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 10] -= 1\n            length_dict[max_length * 2 - 10] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 10] += 1\n            length_dict[max_length * 2 - 10] -= 1\n\n        return min_cost\n\n    # Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n    # from N bamboos of lengths l_list\n    length_dict: DefaultDict[int, int] = defaultdict(lambda: 0)\n    for l in l_list:\n        length_dict[l] += 1\n    min_cost = get_min_cost_inner(A, B, C, length_dict)\n\n    return min_cost\n\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    l_list = []\n    for _ in range(N):\n        l_list.append(int(input()))\n    min_cost = get_min_cost(N, A, B, C, l_list)\n    print(min_cost)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    lengths = [int(input()) for _ in range(N)]\n    \n    lengths.sort(reverse=True)\n    \n    ans = math.inf\n\n    # the first bamboo is of length A\n    for i in range(N):\n        if lengths[i] < A:\n            break\n        \n        a = lengths[i]\n        b = B - a\n        c = C - a\n        if b < 1 or c < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build b\n        b_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] == b:\n                b_cost = 0\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1 + 10)\n        \n        # build c\n        c_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] == c:\n                c_cost = 0\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1 + 10)\n        \n        ans = min(ans, a - lengths[i], b_cost, c_cost)\n\n    # the first bamboo is of length B\n    for i in range(N):\n        if lengths[i] < B:\n            break\n        \n        a = A - lengths[i]\n        b = lengths[i]\n        c = C - b\n        if a < 1 or c < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build a\n        a_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] == a:\n                a_cost = 0\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1 + 10)\n        \n        # build c\n        c_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] == c:\n                c_cost = 0\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1 + 10)\n        \n        ans = min(ans, b - lengths[i], a_cost, c_cost)\n\n    # the first bamboo is of length C\n    for i in range(N):\n        if lengths[i] < C:\n            break\n        \n        a = A - lengths[i]\n        b = B - lengths[i]\n        c = lengths[i]\n        if a < 1 or b < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build a\n        a_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] == a:\n                a_cost = 0\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1 + 10)\n        \n        # build b\n        b_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] == b:\n                b_cost = 0\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1 + 10)\n        \n        ans = min(ans, c - lengths[i], a_cost, b_cost)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650138529,
  "id": "cmpl-4xihVFd5C8Oe5b6DCy10IRuKwzDAc",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:50:24.064746 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    l = [int(input()) for _ in range(N)]\n    dp = [[[float('inf')] * (C + 1) for _ in range(B + 1)] for _ in range(A + 1)]\n    dp[0][0][0] = 0\n    for i in range(N):\n        for a in range(A + 1):\n            for b in range(B + 1):\n                for c in range(C + 1):\n                    if dp[a][b][c] == float('inf'):\n                        continue\n                    # Extension Magic\n                    dp[min(a + l[i], A)][b][c] = min(dp[min(a + l[i], A)][b][c], dp[a][b][c] + max(0, a + l[i] - A))\n                    # Shortening Magic\n                    dp[max(a - l[i], 0)][b][c] = min(dp[max(a - l[i], 0)][b][c], dp[a][b][c] + max(0, l[i] - a))\n                    # Composition Magic\n                    dp[a][min(b + l[i], B)][c] = min(dp[a][min(b + l[i], B)][c], dp[a][b][c] + max(0, b + l[i] - B) + 10)\n                    dp[a][b][min(c + l[i], C)] = min(dp[a][b][min(c + l[i], C)], dp[a][b][c] + max(0, c + l[i] - C) + 10)\n    print(dp[A][B][C])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:50:24.064794 REASON stop
2022-04-16 19:50:24.087423 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": ""
}
2022-04-16 19:50:24.087616 REASON stop
2022-04-16 19:50:24.088186 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn, a, b, c = map(int, input().split())\nls = list(map(int, [input() for _ in range(n)]))\n\ndef dfs(target, ls):\n    if len(ls) == 0:\n        return 10**9\n    x = ls[0]\n    ls = ls[1:]\n    res = 10**9\n    if x == target:\n        res = 0\n    res = min(res, dfs(target, ls) + 1)\n    if x > target:\n        res = min(res, dfs(target, ls) + 10)\n    res = min(res, dfs(target-x, ls) + 10)\n    return res\n\nprint(dfs(a, ls) + dfs(b, ls) + dfs(c, ls))"
}
2022-04-16 19:50:24.088255 REASON stop
2022-04-16 19:50:24.112663 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\nN, A, B, C = map(int, input().split())\nL = []\nfor i in range(N):\n    L.append(int(input()))\n\nINF = 1000000\ndp = [[[INF for i in range(3000)] for j in range(3000)] for k in range(10)]\ndp[0][0][0] = 0\n\nfor i in range(N):\n    for j in range(3000):\n        for k in range(3000):\n            if dp[i][j][k] != INF:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]) # \u4f7f\u308f\u306a\u3044\n                dp[i+1][j+L[i]][k] = min(dp[i+1][j+L[i]][k], dp[i][j][k]) # \u4f7f\u3046\n                if j >= 2:\n                    dp[i+1][j-1][k] = min(dp[i+1][j-1][k], dp[i][j][k] + 1)\n                if j >= 1 and k >= 1:\n                    dp[i+1][j][k-1] = min(dp[i+1][j][k-1], dp[i][j][k] + 1)\n                if j >= 1 and k >= 9:\n                    dp[i+1][j+k-9][9] = min(dp[i+1][j+k-9][9], dp[i][j][k] + 10)\n\nprint(dp[N][A][B])"
}
2022-04-16 19:50:24.112786 REASON stop
2022-04-16 19:50:24.114969 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for i in range(n)]\n\ndef dfs(n, a, b, c, l):\n    if n == 0:\n        return 10 ** 9\n    if max([a, b, c]) == 0:\n        return 0\n\n    ret = 10 ** 9\n    for i in range(n):\n        if l[i] == a:\n            ret = min(ret, dfs(n-1, a-1, b, c, l[:i] + l[i+1:]))\n        if l[i] == b:\n            ret = min(ret, dfs(n-1, a, b-1, c, l[:i] + l[i+1:]))\n        if l[i] == c:\n            ret = min(ret, dfs(n-1, a, b, c-1, l[:i] + l[i+1:]))\n        if l[i] > a:\n            ret = min(ret, dfs(n-1, a+1, b, c, l[:i] + l[i+1:]) + 1)\n        if l[i] > b:\n            ret = min(ret, dfs(n-1, a, b+1, c, l[:i] + l[i+1:]) + 1)\n        if l[i] > c:\n            ret = min(ret, dfs(n-1, a, b, c+1, l[:i] + l[i+1:]) + 1)\n        if l[i] > 1:\n            ret = min(ret, dfs(n-1, a, b, c, l[:i] + l[i+1:]) + 1)\n        for j in range(i+1, n):\n            if l[i] + l[j] == a:\n                ret = min(ret, dfs(n-2, a-1, b, c, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] == b:\n                ret = min(ret, dfs(n-2, a, b-1, c, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] == c:\n                ret = min(ret, dfs(n-2, a, b, c-1, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] > a:\n                ret = min(ret, dfs(n-2, a+1, b, c, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n            if l[i] + l[j] > b:\n                ret = min(ret, dfs(n-2, a, b+1, c, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n            if l[i] + l[j] > c:\n                ret = min(ret, dfs(n-2, a, b, c+1, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n    return ret\n\nprint(dfs(n, a, b, c, l))"
}
2022-04-16 19:50:24.115074 REASON stop
2022-04-16 19:50:24.116710 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\nn, a, b, c = map(int, sys.stdin.readline().rstrip().split())\nbamboos = list(map(int, sys.stdin.readline().rstrip().split()))\n\nbamboos.sort(reverse=True)\n\ncost = 0\nfor i in range(n):\n    if bamboos[i] >= a:\n        cost += (bamboos[i]-a)\n    elif a-bamboos[i] <= 10:\n        cost += (a-bamboos[i])*2\n    else:\n        bamboos[i] = a\n\nbamboos.sort(reverse=True)\n\nfor i in range(n):\n    if bamboos[i] >= b:\n        cost += (bamboos[i]-b)\n    elif b-bamboos[i] <= 10:\n        cost += (b-bamboos[i])*2\n    else:\n        bamboos[i] = b\n\nbamboos.sort(reverse=True)\n\nfor i in range(n):\n    if bamboos[i] >= c:\n        cost += (bamboos[i]-c)\n    elif c-bamboos[i] <= 10:\n        cost += (c-bamboos[i])*2\n    else:\n        bamboos[i] = c\n\nprint(cost)"
}
2022-04-16 19:50:24.116852 REASON stop
2022-04-16 19:50:24.118195 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\nfrom typing import Any, DefaultDict, Tuple\n\n\ndef get_min_cost(N: int, A: int, B: int, C: int, l_list: list) -> int:\n    \"\"\"\n    Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n    from N bamboos of lengths l_list.\n    \"\"\"\n    if A < B < C:\n        A, B, C = B, C, A\n\n    @lru_cache(maxsize=None)\n    def get_min_cost_inner(\n        A: int, B: int, C: int, length_dict: DefaultDict[int, int]\n    ) -> int:\n        \"\"\"\n        Inner function of get_min_cost.\n        Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n        from the bamboos of lengths in length_dict.\n        \"\"\"\n        if A < B < C:\n            return get_min_cost_inner(B, C, A, length_dict)\n        if len(length_dict) == 0:\n            return float(\"inf\")\n        if A < 0 or B < 0 or C < 0:\n            return float(\"inf\")\n        if A == 0 and B == 0 and C == 0:\n            return 0\n\n        # Get the maximum length of bamboo in length_dict\n        length_list = list(length_dict.keys())\n        max_length = max(length_list)\n\n        # Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n        # from the bamboos of lengths in length_dict\n        min_cost = float(\"inf\")\n        # Subtract the length of the bamboo with the maximum length from each of\n        # A, B, C and get the minimum cost of magic to get three bamboos of lengths\n        # (A - {max_length}, B - {max_length}, C - {max_length}) from the bamboos\n        # of lengths in length_dict\n        min_cost = min(\n            min_cost,\n            get_min_cost_inner(\n                A - max_length, B - max_length, C - max_length, length_dict\n            ),\n        )\n        # Subtract 1 from the length of the bamboo with the maximum length and get\n        # the minimum cost of magic to get three bamboos of lengths (A, B, C) from\n        # the bamboos of lengths in length_dict\n        if max_length > 1:\n            length_dict[max_length - 1] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 1,\n            )\n            length_dict[max_length - 1] -= 1\n        # Add 1 to the length of the bamboo with the maximum length and get\n        # the minimum cost of magic to get three bamboos of lengths (A, B, C) from\n        # the bamboos of lengths in length_dict\n        length_dict[max_length + 1] += 1\n        min_cost = min(\n            min_cost,\n            get_min_cost_inner(A, B, C, length_dict) + 1,\n        )\n        length_dict[max_length + 1] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 1 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 1:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 1] -= 1\n            length_dict[max_length * 2 - 1] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 1] += 1\n            length_dict[max_length * 2 - 1] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 2 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 2:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 2] -= 1\n            length_dict[max_length * 2 - 2] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 2] += 1\n            length_dict[max_length * 2 - 2] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 3 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 3:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 3] -= 1\n            length_dict[max_length * 2 - 3] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 3] += 1\n            length_dict[max_length * 2 - 3] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 4 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 4:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 4] -= 1\n            length_dict[max_length * 2 - 4] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 4] += 1\n            length_dict[max_length * 2 - 4] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 5 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 5:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 5] -= 1\n            length_dict[max_length * 2 - 5] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 5] += 1\n            length_dict[max_length * 2 - 5] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 6 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 6:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 6] -= 1\n            length_dict[max_length * 2 - 6] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 6] += 1\n            length_dict[max_length * 2 - 6] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 7 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 7:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 7] -= 1\n            length_dict[max_length * 2 - 7] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 7] += 1\n            length_dict[max_length * 2 - 7] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 8 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 8:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 8] -= 1\n            length_dict[max_length * 2 - 8] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 8] += 1\n            length_dict[max_length * 2 - 8] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 9 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 9:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 9] -= 1\n            length_dict[max_length * 2 - 9] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 9] += 1\n            length_dict[max_length * 2 - 9] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 10 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 10:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 10] -= 1\n            length_dict[max_length * 2 - 10] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 10] += 1\n            length_dict[max_length * 2 - 10] -= 1\n\n        return min_cost\n\n    # Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n    # from N bamboos of lengths l_list\n    length_dict: DefaultDict[int, int] = defaultdict(lambda: 0)\n    for l in l_list:\n        length_dict[l] += 1\n    min_cost = get_min_cost_inner(A, B, C, length_dict)\n\n    return min_cost\n\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    l_list = []\n    for _ in range(N):\n        l_list.append(int(input()))\n    min_cost = get_min_cost(N, A, B, C, l_list)\n    print(min_cost)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:50:24.118397 REASON stop
2022-04-16 19:50:24.119612 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    lengths = [int(input()) for _ in range(N)]\n    \n    lengths.sort(reverse=True)\n    \n    ans = math.inf\n\n    # the first bamboo is of length A\n    for i in range(N):\n        if lengths[i] < A:\n            break\n        \n        a = lengths[i]\n        b = B - a\n        c = C - a\n        if b < 1 or c < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build b\n        b_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] == b:\n                b_cost = 0\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1 + 10)\n        \n        # build c\n        c_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] == c:\n                c_cost = 0\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1 + 10)\n        \n        ans = min(ans, a - lengths[i], b_cost, c_cost)\n\n    # the first bamboo is of length B\n    for i in range(N):\n        if lengths[i] < B:\n            break\n        \n        a = A - lengths[i]\n        b = lengths[i]\n        c = C - b\n        if a < 1 or c < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build a\n        a_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] == a:\n                a_cost = 0\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1 + 10)\n        \n        # build c\n        c_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] == c:\n                c_cost = 0\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1 + 10)\n        \n        ans = min(ans, b - lengths[i], a_cost, c_cost)\n\n    # the first bamboo is of length C\n    for i in range(N):\n        if lengths[i] < C:\n            break\n        \n        a = A - lengths[i]\n        b = B - lengths[i]\n        c = lengths[i]\n        if a < 1 or b < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build a\n        a_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] == a:\n                a_cost = 0\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1 + 10)\n        \n        # build b\n        b_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] == b:\n                b_cost = 0\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1 + 10)\n        \n        ans = min(ans, c - lengths[i], a_cost, b_cost)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:50:24.119719 REASON stop
