["", "\nfrom collections import defaultdict\nfrom functools import lru_cache\nimport sys\nfrom typing import Any, DefaultDict, Tuple\n\n\ndef get_min_cost(N: int, A: int, B: int, C: int, l_list: list) -> int:\n    \"\"\"\n    Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n    from N bamboos of lengths l_list.\n    \"\"\"\n    if A < B < C:\n        A, B, C = B, C, A\n\n    @lru_cache(maxsize=None)\n    def get_min_cost_inner(\n        A: int, B: int, C: int, length_dict: DefaultDict[int, int]\n    ) -> int:\n        \"\"\"\n        Inner function of get_min_cost.\n        Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n        from the bamboos of lengths in length_dict.\n        \"\"\"\n        if A < B < C:\n            return get_min_cost_inner(B, C, A, length_dict)\n        if len(length_dict) == 0:\n            return float(\"inf\")\n        if A < 0 or B < 0 or C < 0:\n            return float(\"inf\")\n        if A == 0 and B == 0 and C == 0:\n            return 0\n\n        # Get the maximum length of bamboo in length_dict\n        length_list = list(length_dict.keys())\n        max_length = max(length_list)\n\n        # Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n        # from the bamboos of lengths in length_dict\n        min_cost = float(\"inf\")\n        # Subtract the length of the bamboo with the maximum length from each of\n        # A, B, C and get the minimum cost of magic to get three bamboos of lengths\n        # (A - {max_length}, B - {max_length}, C - {max_length}) from the bamboos\n        # of lengths in length_dict\n        min_cost = min(\n            min_cost,\n            get_min_cost_inner(\n                A - max_length, B - max_length, C - max_length, length_dict\n            ),\n        )\n        # Subtract 1 from the length of the bamboo with the maximum length and get\n        # the minimum cost of magic to get three bamboos of lengths (A, B, C) from\n        # the bamboos of lengths in length_dict\n        if max_length > 1:\n            length_dict[max_length - 1] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 1,\n            )\n            length_dict[max_length - 1] -= 1\n        # Add 1 to the length of the bamboo with the maximum length and get\n        # the minimum cost of magic to get three bamboos of lengths (A, B, C) from\n        # the bamboos of lengths in length_dict\n        length_dict[max_length + 1] += 1\n        min_cost = min(\n            min_cost,\n            get_min_cost_inner(A, B, C, length_dict) + 1,\n        )\n        length_dict[max_length + 1] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 1 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 1:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 1] -= 1\n            length_dict[max_length * 2 - 1] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 1] += 1\n            length_dict[max_length * 2 - 1] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 2 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 2:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 2] -= 1\n            length_dict[max_length * 2 - 2] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 2] += 1\n            length_dict[max_length * 2 - 2] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 3 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 3:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 3] -= 1\n            length_dict[max_length * 2 - 3] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 3] += 1\n            length_dict[max_length * 2 - 3] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 4 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 4:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 4] -= 1\n            length_dict[max_length * 2 - 4] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 4] += 1\n            length_dict[max_length * 2 - 4] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 5 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 5:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 5] -= 1\n            length_dict[max_length * 2 - 5] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 5] += 1\n            length_dict[max_length * 2 - 5] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 6 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 6:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 6] -= 1\n            length_dict[max_length * 2 - 6] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 6] += 1\n            length_dict[max_length * 2 - 6] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 7 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 7:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 7] -= 1\n            length_dict[max_length * 2 - 7] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 7] += 1\n            length_dict[max_length * 2 - 7] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 8 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 8:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 8] -= 1\n            length_dict[max_length * 2 - 8] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 8] += 1\n            length_dict[max_length * 2 - 8] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 9 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 9:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 9] -= 1\n            length_dict[max_length * 2 - 9] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 9] += 1\n            length_dict[max_length * 2 - 9] -= 1\n        # Combine the bamboos with the maximum length and the length of the bamboo\n        # with the maximum length - 10 and get the minimum cost of magic to get three\n        # bamboos of lengths (A, B, C) from the bamboos of lengths in length_dict\n        if max_length > 10:\n            length_dict[max_length] -= 1\n            length_dict[max_length - 10] -= 1\n            length_dict[max_length * 2 - 10] += 1\n            min_cost = min(\n                min_cost,\n                get_min_cost_inner(A, B, C, length_dict) + 10,\n            )\n            length_dict[max_length] += 1\n            length_dict[max_length - 10] += 1\n            length_dict[max_length * 2 - 10] -= 1\n\n        return min_cost\n\n    # Get the minimum cost of magic to get three bamboos of lengths (A, B, C)\n    # from N bamboos of lengths l_list\n    length_dict: DefaultDict[int, int] = defaultdict(lambda: 0)\n    for l in l_list:\n        length_dict[l] += 1\n    min_cost = get_min_cost_inner(A, B, C, length_dict)\n\n    return min_cost\n\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    l_list = []\n    for _ in range(N):\n        l_list.append(int(input()))\n    min_cost = get_min_cost(N, A, B, C, l_list)\n    print(min_cost)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for i in range(n)]\n\ndef dfs(n, a, b, c, l):\n    if n == 0:\n        return 10 ** 9\n    if max([a, b, c]) == 0:\n        return 0\n\n    ret = 10 ** 9\n    for i in range(n):\n        if l[i] == a:\n            ret = min(ret, dfs(n-1, a-1, b, c, l[:i] + l[i+1:]))\n        if l[i] == b:\n            ret = min(ret, dfs(n-1, a, b-1, c, l[:i] + l[i+1:]))\n        if l[i] == c:\n            ret = min(ret, dfs(n-1, a, b, c-1, l[:i] + l[i+1:]))\n        if l[i] > a:\n            ret = min(ret, dfs(n-1, a+1, b, c, l[:i] + l[i+1:]) + 1)\n        if l[i] > b:\n            ret = min(ret, dfs(n-1, a, b+1, c, l[:i] + l[i+1:]) + 1)\n        if l[i] > c:\n            ret = min(ret, dfs(n-1, a, b, c+1, l[:i] + l[i+1:]) + 1)\n        if l[i] > 1:\n            ret = min(ret, dfs(n-1, a, b, c, l[:i] + l[i+1:]) + 1)\n        for j in range(i+1, n):\n            if l[i] + l[j] == a:\n                ret = min(ret, dfs(n-2, a-1, b, c, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] == b:\n                ret = min(ret, dfs(n-2, a, b-1, c, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] == c:\n                ret = min(ret, dfs(n-2, a, b, c-1, l[:i] + l[i+1:j] + l[j+1:]) + 10)\n            if l[i] + l[j] > a:\n                ret = min(ret, dfs(n-2, a+1, b, c, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n            if l[i] + l[j] > b:\n                ret = min(ret, dfs(n-2, a, b+1, c, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n            if l[i] + l[j] > c:\n                ret = min(ret, dfs(n-2, a, b, c+1, l[:i] + l[i+1:j] + l[j+1:]) + 11)\n    return ret\n\nprint(dfs(n, a, b, c, l))", "\n\nimport sys\n\nn, a, b, c = map(int, sys.stdin.readline().rstrip().split())\nbamboos = list(map(int, sys.stdin.readline().rstrip().split()))\n\nbamboos.sort(reverse=True)\n\ncost = 0\nfor i in range(n):\n    if bamboos[i] >= a:\n        cost += (bamboos[i]-a)\n    elif a-bamboos[i] <= 10:\n        cost += (a-bamboos[i])*2\n    else:\n        bamboos[i] = a\n\nbamboos.sort(reverse=True)\n\nfor i in range(n):\n    if bamboos[i] >= b:\n        cost += (bamboos[i]-b)\n    elif b-bamboos[i] <= 10:\n        cost += (b-bamboos[i])*2\n    else:\n        bamboos[i] = b\n\nbamboos.sort(reverse=True)\n\nfor i in range(n):\n    if bamboos[i] >= c:\n        cost += (bamboos[i]-c)\n    elif c-bamboos[i] <= 10:\n        cost += (c-bamboos[i])*2\n    else:\n        bamboos[i] = c\n\nprint(cost)", "\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    l = [int(input()) for _ in range(N)]\n    dp = [[[float('inf')] * (C + 1) for _ in range(B + 1)] for _ in range(A + 1)]\n    dp[0][0][0] = 0\n    for i in range(N):\n        for a in range(A + 1):\n            for b in range(B + 1):\n                for c in range(C + 1):\n                    if dp[a][b][c] == float('inf'):\n                        continue\n                    # Extension Magic\n                    dp[min(a + l[i], A)][b][c] = min(dp[min(a + l[i], A)][b][c], dp[a][b][c] + max(0, a + l[i] - A))\n                    # Shortening Magic\n                    dp[max(a - l[i], 0)][b][c] = min(dp[max(a - l[i], 0)][b][c], dp[a][b][c] + max(0, l[i] - a))\n                    # Composition Magic\n                    dp[a][min(b + l[i], B)][c] = min(dp[a][min(b + l[i], B)][c], dp[a][b][c] + max(0, b + l[i] - B) + 10)\n                    dp[a][b][min(c + l[i], C)] = min(dp[a][b][min(c + l[i], C)], dp[a][b][c] + max(0, c + l[i] - C) + 10)\n    print(dp[A][B][C])\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport math\n\ndef main():\n    N, A, B, C = map(int, input().split())\n    lengths = [int(input()) for _ in range(N)]\n    \n    lengths.sort(reverse=True)\n    \n    ans = math.inf\n\n    # the first bamboo is of length A\n    for i in range(N):\n        if lengths[i] < A:\n            break\n        \n        a = lengths[i]\n        b = B - a\n        c = C - a\n        if b < 1 or c < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build b\n        b_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] == b:\n                b_cost = 0\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1 + 10)\n        \n        # build c\n        c_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] == c:\n                c_cost = 0\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1 + 10)\n        \n        ans = min(ans, a - lengths[i], b_cost, c_cost)\n\n    # the first bamboo is of length B\n    for i in range(N):\n        if lengths[i] < B:\n            break\n        \n        a = A - lengths[i]\n        b = lengths[i]\n        c = C - b\n        if a < 1 or c < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build a\n        a_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] == a:\n                a_cost = 0\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1 + 10)\n        \n        # build c\n        c_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] == c:\n                c_cost = 0\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < c:\n                break\n            if lengths[j] > c:\n                c_cost = min(c_cost, abs(lengths[j] - c) * 1 + 10)\n        \n        ans = min(ans, b - lengths[i], a_cost, c_cost)\n\n    # the first bamboo is of length C\n    for i in range(N):\n        if lengths[i] < C:\n            break\n        \n        a = A - lengths[i]\n        b = B - lengths[i]\n        c = lengths[i]\n        if a < 1 or b < 1:\n            continue\n        # we have bamboos of lengths a, b, c\n        \n        # build a\n        a_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] == a:\n                a_cost = 0\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < a:\n                break\n            if lengths[j] > a:\n                a_cost = min(a_cost, abs(lengths[j] - a) * 1 + 10)\n        \n        # build b\n        b_cost = 0\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] == b:\n                b_cost = 0\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1)\n        for j in range(i+1, N):\n            if lengths[j] < b:\n                break\n            if lengths[j] > b:\n                b_cost = min(b_cost, abs(lengths[j] - b) * 1 + 10)\n        \n        ans = min(ans, c - lengths[i], a_cost, b_cost)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nn, a, b, c = map(int, input().split())\nls = list(map(int, [input() for _ in range(n)]))\n\ndef dfs(target, ls):\n    if len(ls) == 0:\n        return 10**9\n    x = ls[0]\n    ls = ls[1:]\n    res = 10**9\n    if x == target:\n        res = 0\n    res = min(res, dfs(target, ls) + 1)\n    if x > target:\n        res = min(res, dfs(target, ls) + 10)\n    res = min(res, dfs(target-x, ls) + 10)\n    return res\n\nprint(dfs(a, ls) + dfs(b, ls) + dfs(c, ls))", "\nN, A, B, C = map(int, input().split())\nL = []\nfor i in range(N):\n    L.append(int(input()))\n\nINF = 1000000\ndp = [[[INF for i in range(3000)] for j in range(3000)] for k in range(10)]\ndp[0][0][0] = 0\n\nfor i in range(N):\n    for j in range(3000):\n        for k in range(3000):\n            if dp[i][j][k] != INF:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]) # \u4f7f\u308f\u306a\u3044\n                dp[i+1][j+L[i]][k] = min(dp[i+1][j+L[i]][k], dp[i][j][k]) # \u4f7f\u3046\n                if j >= 2:\n                    dp[i+1][j-1][k] = min(dp[i+1][j-1][k], dp[i][j][k] + 1)\n                if j >= 1 and k >= 1:\n                    dp[i+1][j][k-1] = min(dp[i+1][j][k-1], dp[i][j][k] + 1)\n                if j >= 1 and k >= 9:\n                    dp[i+1][j+k-9][9] = min(dp[i+1][j+k-9][9], dp[i][j][k] + 10)\n\nprint(dp[N][A][B])"]