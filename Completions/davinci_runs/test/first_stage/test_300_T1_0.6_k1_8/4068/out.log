2022-04-16 19:13:26.656999 """
There is a staircase with N steps. Takahashi is now standing at the foot of the stairs, that is, on the 0-th step.
He can climb up one or two steps at a time.
However, the treads of the a_1-th, a_2-th, a_3-th, \ldots, a_M-th steps are broken, so it is dangerous to set foot on those steps.
How many are there to climb up to the top step, that is, the N-th step, without setting foot on the broken steps?
Find the count modulo 1\ 000\ 000\ 007.

-----Constraints-----
 - 1 \leq N \leq 10^5
 - 0 \leq M \leq N-1
 - 1 \leq a_1 < a_2 <  ...  < a_M \leq N-1

-----Input-----
Input is given from Standard Input in the following format:
N M
a_1
a_2
 .
 .
 .
a_M

-----Output-----
Print the number of ways to climb up the stairs under the condition, modulo 1\ 000\ 000\ 007.

-----Sample Input-----
6 1
3

-----Sample Output-----
4

There are four ways to climb up the stairs, as follows:
 - 0 \to 1 \to 2 \to 4 \to 5 \to 6
 - 0 \to 1 \to 2 \to 4 \to 6
 - 0 \to 2 \to 4 \to 5 \to 6
 - 0 \to 2 \to 4 \to 6
"""
2022-04-16 19:13:26.657007 --------------------------
2022-04-16 19:13:48.773414 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\nm = int(sys.stdin.readline())\na = []\nfor _ in range(m):\n    a.append(int(sys.stdin.readline()))\na.sort()\n\narr = [0] * (n + 1)\narr[0] = 1\narr[1] = 1\n\nfor i in range(2, n + 1):\n    if i == a[0]:\n        arr[i] = arr[i - 1]\n        a.pop(0)\n    else:\n        arr[i] = arr[i - 1] + arr[i - 2]\n\nprint(arr[n] % 1000000007)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nN, M = map(int, input().split())\n# N = number of steps\n# M = number of broken steps\nbroken = [int(input()) for i in range(M)]\n\n# dp[i][j] = ways to reach the i-th step, using j steps\ndp = [[0 for i in range(2)] for j in range(N+1)]\ndp[0][0] = 1\n\nfor i in range(N):\n    if i+1 not in broken:\n        dp[i+1][0] = (dp[i][0] + dp[i][1]) % 1000000007\n    if i+2 not in broken:\n        dp[i+2][1] = (dp[i][0] + dp[i][1]) % 1000000007\n\nprint(sum(dp[N]) % 1000000007)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\n# read input values\nN, M = map(int, sys.stdin.readline().split())\n#print(\"N:\", N)\n#print(\"M:\", M)\n\nA = []\nfor i in range(M):\n    A.append(int(sys.stdin.readline()))\n#print(\"A:\", A)\n\n# set up a list of 1s\nP = [1] * N\n#print(\"P:\", P)\n\nfor a in A:\n    P[a] = 0\n#print(\"P:\", P)\n\n# calculate the number of possible paths from the bottom to the top step\nfor i in range(1, N):\n    if i != A and P[i] != 0:\n        P[i] = P[i-1] + P[i-2]\n#print(\"P:\", P)\n\nprint(P[N-1] % 1000000007)\n\n\"\"\"\n-----Test Case 1-----\nInput:\n6 1\n3\nOutput:\n4\n\n-----Test Case 2-----\nInput:\n6 2\n2\n4\nOutput:\n0\n\n-----Test Case 3-----\nInput:\n5000 3\n300\n400\n500\nOutput:\n223517996\n\n-----Test Case 4-----\nInput:\n5000 3\n300\n4000\n4999\nOutput:\n203172800\n\n-----Test Case 5-----\nInput:\n5000 3\n3\n4\n5\nOutput:\n7560\n\n-----Test Case 6-----\nInput:\n5000 4\n300\n400\n500\n1000\nOutput:\n812258208\n\"\"\""
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef count_ways_to_climb_stairs(N, M, broken_steps):\n    # dp[i] = number of ways to climb up to i-th step\n    dp = [0] * (N+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, N+1):\n        if i not in broken_steps:\n            dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[N] % 1000000007\n\ndef main():\n    N, M = map(int, input().split())\n    a = [int(input()) for _ in range(M)]\n    print(count_ways_to_climb_stairs(N, M, a))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport copy\nimport sys\n\n\ndef input_data():\n    \"\"\"\n    1\u884c\u76ee\u306b\u3001\u968e\u6bb5\u306e\u9577\u3055\u3092\u8868\u3059\u6574\u6570N\u3001\u7834\u640d\u3057\u305f\u624b\u3059\u308a\u306e\u6570\u3092\u8868\u3059\u6574\u6570M\u304c\u7a7a\u767d\u533a\u5207\u308a\u3067\u4e0e\u3048\u3089\u308c\u308b\u3002\n    \u7d9a\u304fM\u884c\u306b\u3001\u7834\u640d\u3057\u305f\u624b\u3059\u308a\u306e\u756a\u53f7\u3092\u8868\u3059\u6574\u6570a_1,a_2,\u2026,a_M\u304c\u9806\u306b\u4e0e\u3048\u3089\u308c\u308b\u3002\n    :return:\n    \"\"\"\n    n, m = list(map(int, sys.stdin.readline().split()))\n    broken_list = []\n    for _ in range(m):\n        broken_list.append(int(sys.stdin.readline()))\n    return n, broken_list\n\n\ndef main():\n    n, broken_list = input_data()\n    dp = [0 for _ in range(n+1)]\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        if i in broken_list:\n            continue\n        dp[i] = dp[i - 1] + dp[i - 2]\n    print(dp[n] % 1000000007)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN, M = map(int, input().split())\na = list(map(int, [input() for _ in range(M)]))\n\ndp = [0 for _ in range(N+1)]\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, N+1):\n    if i in a:\n        dp[i] = 0\n    else:\n        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n\nprint(dp[N])"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    broken = set(int(input()) for _ in range(m))\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        if i in broken:\n            dp[i] = 0\n        else:\n            dp[i] = dp[i - 1] + dp[i - 2]\n    print(dp[n] % 1000000007)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\n\ndef solve(n, m, a):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(2)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        dp[0][i] = dp[0][i - 1] + dp[1][i - 1]\n        dp[0][i] %= MOD\n    for i in range(1, n + 1):\n        dp[1][i] = dp[0][i - 1]\n        if i - 2 >= 0:\n            dp[1][i] += dp[0][i - 2]\n        dp[1][i] %= MOD\n    for i in range(m):\n        dp[1][a[i]] = 0\n    return dp[0][n] + dp[1][n]\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = []\n    for _ in range(m):\n        a.append(int(input()))\n    print(solve(n, m, a))\n\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650136406,
  "id": "cmpl-4xi9GVvXCi56KI1G8Z5D6msm14Cbn",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:13:48.773715 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\nm = int(sys.stdin.readline())\na = []\nfor _ in range(m):\n    a.append(int(sys.stdin.readline()))\na.sort()\n\narr = [0] * (n + 1)\narr[0] = 1\narr[1] = 1\n\nfor i in range(2, n + 1):\n    if i == a[0]:\n        arr[i] = arr[i - 1]\n        a.pop(0)\n    else:\n        arr[i] = arr[i - 1] + arr[i - 2]\n\nprint(arr[n] % 1000000007)"
}
2022-04-16 19:13:48.773748 REASON stop
2022-04-16 19:13:48.854075 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nN, M = map(int, input().split())\n# N = number of steps\n# M = number of broken steps\nbroken = [int(input()) for i in range(M)]\n\n# dp[i][j] = ways to reach the i-th step, using j steps\ndp = [[0 for i in range(2)] for j in range(N+1)]\ndp[0][0] = 1\n\nfor i in range(N):\n    if i+1 not in broken:\n        dp[i+1][0] = (dp[i][0] + dp[i][1]) % 1000000007\n    if i+2 not in broken:\n        dp[i+2][1] = (dp[i][0] + dp[i][1]) % 1000000007\n\nprint(sum(dp[N]) % 1000000007)"
}
2022-04-16 19:13:48.854451 REASON stop
2022-04-16 19:13:48.895441 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\n# read input values\nN, M = map(int, sys.stdin.readline().split())\n#print(\"N:\", N)\n#print(\"M:\", M)\n\nA = []\nfor i in range(M):\n    A.append(int(sys.stdin.readline()))\n#print(\"A:\", A)\n\n# set up a list of 1s\nP = [1] * N\n#print(\"P:\", P)\n\nfor a in A:\n    P[a] = 0\n#print(\"P:\", P)\n\n# calculate the number of possible paths from the bottom to the top step\nfor i in range(1, N):\n    if i != A and P[i] != 0:\n        P[i] = P[i-1] + P[i-2]\n#print(\"P:\", P)\n\nprint(P[N-1] % 1000000007)\n\n\"\"\"\n-----Test Case 1-----\nInput:\n6 1\n3\nOutput:\n4\n\n-----Test Case 2-----\nInput:\n6 2\n2\n4\nOutput:\n0\n\n-----Test Case 3-----\nInput:\n5000 3\n300\n400\n500\nOutput:\n223517996\n\n-----Test Case 4-----\nInput:\n5000 3\n300\n4000\n4999\nOutput:\n203172800\n\n-----Test Case 5-----\nInput:\n5000 3\n3\n4\n5\nOutput:\n7560\n\n-----Test Case 6-----\nInput:\n5000 4\n300\n400\n500\n1000\nOutput:\n812258208\n\"\"\""
}
2022-04-16 19:13:48.895646 REASON stop
2022-04-16 19:13:48.915168 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef count_ways_to_climb_stairs(N, M, broken_steps):\n    # dp[i] = number of ways to climb up to i-th step\n    dp = [0] * (N+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, N+1):\n        if i not in broken_steps:\n            dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[N] % 1000000007\n\ndef main():\n    N, M = map(int, input().split())\n    a = [int(input()) for _ in range(M)]\n    print(count_ways_to_climb_stairs(N, M, a))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:13:48.915405 REASON stop
2022-04-16 19:13:48.937999 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport copy\nimport sys\n\n\ndef input_data():\n    \"\"\"\n    1\u884c\u76ee\u306b\u3001\u968e\u6bb5\u306e\u9577\u3055\u3092\u8868\u3059\u6574\u6570N\u3001\u7834\u640d\u3057\u305f\u624b\u3059\u308a\u306e\u6570\u3092\u8868\u3059\u6574\u6570M\u304c\u7a7a\u767d\u533a\u5207\u308a\u3067\u4e0e\u3048\u3089\u308c\u308b\u3002\n    \u7d9a\u304fM\u884c\u306b\u3001\u7834\u640d\u3057\u305f\u624b\u3059\u308a\u306e\u756a\u53f7\u3092\u8868\u3059\u6574\u6570a_1,a_2,\u2026,a_M\u304c\u9806\u306b\u4e0e\u3048\u3089\u308c\u308b\u3002\n    :return:\n    \"\"\"\n    n, m = list(map(int, sys.stdin.readline().split()))\n    broken_list = []\n    for _ in range(m):\n        broken_list.append(int(sys.stdin.readline()))\n    return n, broken_list\n\n\ndef main():\n    n, broken_list = input_data()\n    dp = [0 for _ in range(n+1)]\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        if i in broken_list:\n            continue\n        dp[i] = dp[i - 1] + dp[i - 2]\n    print(dp[n] % 1000000007)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:13:48.938182 REASON stop
2022-04-16 19:13:48.955670 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN, M = map(int, input().split())\na = list(map(int, [input() for _ in range(M)]))\n\ndp = [0 for _ in range(N+1)]\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, N+1):\n    if i in a:\n        dp[i] = 0\n    else:\n        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n\nprint(dp[N])"
}
2022-04-16 19:13:48.955815 REASON stop
2022-04-16 19:13:48.988193 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    broken = set(int(input()) for _ in range(m))\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        if i in broken:\n            dp[i] = 0\n        else:\n            dp[i] = dp[i - 1] + dp[i - 2]\n    print(dp[n] % 1000000007)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:13:48.988312 REASON stop
2022-04-16 19:13:49.003666 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\n\ndef solve(n, m, a):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(2)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        dp[0][i] = dp[0][i - 1] + dp[1][i - 1]\n        dp[0][i] %= MOD\n    for i in range(1, n + 1):\n        dp[1][i] = dp[0][i - 1]\n        if i - 2 >= 0:\n            dp[1][i] += dp[0][i - 2]\n        dp[1][i] %= MOD\n    for i in range(m):\n        dp[1][a[i]] = 0\n    return dp[0][n] + dp[1][n]\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = []\n    for _ in range(m):\n        a.append(int(input()))\n    print(solve(n, m, a))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:13:49.003795 REASON stop
