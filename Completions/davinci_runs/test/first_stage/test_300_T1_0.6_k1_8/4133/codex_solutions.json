["\n\nimport sys\nimport math\n\ndef preprocess(s):\n    \"\"\" \n    replace ? with 0, replace * with +, replace _ with 0, replace :- with =\n    \"\"\"\n    new_s = ''\n    for c in s:\n        if c == '?':\n            c = '0'\n        elif c == '*':\n            c = '+'\n        elif c == '_':\n            c = '0'\n        elif c == ':':\n            c = '='\n            new_s += c\n            continue\n        elif c == '-':\n            c = '='\n        new_s += c\n    return new_s\n\ndef parse_golorps(s):\n    \"\"\"\n    parse golorps\n    \"\"\"\n    golorps = []\n    p = 0\n    while p < len(s):\n        if s[p] == '?':\n            new_golorp = s[p]\n            p += 1\n            while s[p] != '?':\n                new_golorp += s[p]\n                p += 1\n            new_golorp += s[p]\n            golorps.append(new_golorp)\n        p += 1\n    return golorps\n\ndef generate_equations(s):\n    \"\"\"\n    generate equations from golorps\n    \"\"\"\n    equations = []\n    p = 0\n    while p < len(s):\n        if s[p] == '?':\n            new_equation = ''\n            p += 1\n            while s[p] != '?':\n                new_equation += s[p]\n                p += 1\n            equations.append(new_equation)\n        p += 1\n    return equations\n\ndef solve_equation(equation):\n    \"\"\"\n    solve equation\n    \"\"\"\n    #print equation\n    # get the variables\n    variables = []\n    stack = []\n    p = 0\n    while p < len(equation):\n        if equation[p] == ')':\n            variable = ''\n            while stack[-1] != '(':\n                variable = stack.pop() + variable\n            stack.pop()\n            variables.append(variable)\n            p += 1\n        else:\n            stack.append(equation[p])\n            p += 1\n    #print variables\n\n    # get the operators\n    operators = []\n    p = 0\n    while p < len(equation):\n        if equation[p] == ')':\n            p += 1\n        elif equation[p] == '(':\n            operators.append(equation[p])\n            p += 1\n        elif equation[p].isdigit() and equation[p+1] == '(':\n            operators.append(equation[p])\n            p += 1\n        elif equation[p].isdigit() and equation[p+1].isdigit():\n            operators.append(equation[p] + equation[p+1])\n            p += 2\n        else:\n            operators.append(equation[p])\n            p += 1\n    #print operators\n\n    # check if valid equation\n    if len(operators) != len(variables) + 1:\n        return False\n\n    # get the possible values of variables\n    possible_values = []\n    for var in variables:\n        if var[0] == '+' or var[0] == '-':\n            possible_values.append([0, 1])\n        elif var[0] == '*':\n            possible_values.append([1])\n        else:\n            possible_values.append([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    #print possible_values\n\n    # get the possible values of operators\n    possible_operators = []\n    for op in operators:\n        if op == '+':\n            possible_operators.append([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n        elif op == '-':\n            possible_operators.append([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n        elif op == '*':\n            possible_operators.append([1, 2, 3, 4, 5, 6, 7, 8, 9])\n        else:\n            possible_operators.append([int(op)])\n    #print possible_operators\n\n    # get all possible solutions\n    possible_solutions = []\n    if len(variables) == 1:\n        for op in possible_operators[0]:\n            for val in possible_values[0]:\n                if op == val:\n                    possible_solutions.append([val])\n    else:\n        for op in possible_operators[0]:\n            for val in possible_values[0]:\n                if op == val:\n                    possible_solutions.append([val])\n        for i in range(1, len(variables)):\n            new_solutions = []\n            for sol in possible_solutions:\n                for op in possible_operators[i]:\n                    for val in possible_values[i]:\n                        if op == val:\n                            new_solutions.append(sol + [val])\n            possible_solutions = new_solutions\n    #print possible_solutions\n\n    if len(possible_solutions) == 0:\n        return False\n\n    # get the best solution\n    best_sol = possible_solutions[0]\n    for sol in possible_solutions:\n        if sol < best_sol:\n            best_sol = sol\n    #print best_sol\n    return best_sol\n\ndef solve_golorps(golorps):\n    \"\"\"\n    solve golorps\n    \"\"\"\n    # get the equations\n    equations = generate_equations(golorps)\n    #print equations\n\n    # solve equations\n    solutions = []\n    for equation in equations:\n        sol = solve_equation(equation)\n        if sol == False:\n            return False\n        solutions.append(sol)\n    #print solutions\n\n    # get the best solution\n    best_sol = solutions[0]\n    for sol in solutions:\n        if sol < best_sol:\n            best_sol = sol\n    #print best_sol\n    return best_sol\n\ndef main():\n    # read input\n    s = sys.stdin.readline()\n    s = preprocess(s)\n    #print s\n    #print\n\n    # parse golorps\n    golorps = parse_golorps(s)\n    #print golorps\n    #print\n\n    # solve golorps\n    sol = solve_golorps(golorps)\n\n    # output\n    if sol == False:\n        print 'false'\n    else:\n        for i in sol:\n            print i,\n\n    #print\n    #print 'done'\n\nif __name__ == '__main__':\n    main()", "\n\ndef get_golorp(golorp):\n    \"\"\"\n    This function gets the golorp and returns the smallest possible values to feed it.\n    :param golorp: a string of the golorp to be fed.\n    :return: a string of the smallest values to feed the golorp.\n    \"\"\"\n    #0. initialize the result.\n    result = \"\"\n\n    #1. first we will get the jaw.\n    jaw = golorp[0:golorp.find(\"-\")]\n    jaw_list = []\n    for item in jaw:\n        if item.isalpha() and item not in jaw_list:\n            jaw_list.append(item)\n\n    #2. now we will get the stomach.\n    stomach = golorp[golorp.find(\"-\")+1:golorp.find(\")\")]\n    stomach_list = []\n    for item in stomach:\n        if item.isalpha() and item not in stomach_list:\n            stomach_list.append(item)\n\n    #3. now we will get the rules.\n    rules = golorp[golorp.find(\")\")+1:]\n    rules = rules[1:]\n    rules_list = rules.split(\",\")\n    rules_dict = {\"jaw\": jaw_list, \"stomach\": stomach_list, \"rules\": rules_list}\n\n    #4. now we will check if the golorp can be fed.\n    if not can_be_fed(rules_dict):\n        return \"false\"\n\n    #5. now we will get the smallest possible values for the golorp.\n    for item in jaw_list:\n        result += get_smallest_variable(rules_dict, item)\n    return result\n\n\ndef can_be_fed(rules_dict):\n    \"\"\"\n    This function checks if the golorp can be fed.\n    :param rules_dict: a dictionary of the rules.\n    :return: a boolean.\n    \"\"\"\n    #0. initialize the variables.\n    jaw_list = rules_dict[\"jaw\"]\n    stomach_list = rules_dict[\"stomach\"]\n    rules_list = rules_dict[\"rules\"]\n    rules_dict = get_rules_dict(rules_list)\n    result = []\n    variables_list = []\n    for item in jaw_list:\n        variables_list.append(item)\n    for item in stomach_list:\n        variables_list.append(item)\n    variables_list = list(set(variables_list))\n\n    #1. now we will get the first possible values.\n    for item in variables_list:\n        result.append(get_first_variable_value(item, rules_dict))\n\n    #2. now we will check if the golorp can be fed.\n    for item in jaw_list:\n        if item not in rules_dict:\n            return False\n    for item in stomach_list:\n        if item not in rules_dict:\n            return False\n    if len(result) == len(variables_list):\n        for item in result:\n            if item == -1:\n                return False\n    return True\n\n\ndef get_first_variable_value(item, rules_dict):\n    \"\"\"\n    This function gets the first possible value of a variable.\n    :param item: a string of the variable.\n    :param rules_dict: a dictionary of the rules.\n    :return: an int of the number.\n    \"\"\"\n    if item in rules_dict:\n        if rules_dict[item][\"op\"] == \"<\":\n            return rules_dict[item][\"value\"] - 1\n        elif rules_dict[item][\"op\"] == \">\":\n            return rules_dict[item][\"value\"] + 1\n    return 0\n\n\ndef get_rules_dict(rules_list):\n    \"\"\"\n    This function gets the rules and returns them as a dictionary.\n    :param rules_list: a list of the rules.\n    :return: a dictionary of the rules.\n    \"\"\"\n    #0. initialize the result.\n    result = {}\n\n    #1. we will go over the list and create the dictionary.\n    for item in rules_list:\n        key = item[0:item.find(\":\")]\n        value = item[item.find(\":\")+1:]\n        if \">\" in value:\n            op = \">\"\n            value = int(value[0])\n        elif \"<\" in value:\n            op = \"<\"\n            value = int(value[0])\n        result[key] = {\"op\": op, \"value\": value}\n    return result\n\n\ndef get_smallest_variable(rules_dict, item):\n    \"\"\"\n    This function gets the smallest variable.\n    :param rules_dict: a dictionary of the rules.\n    :param item: a string of the variable.\n    :return: a string of the smallest variable.\n    \"\"\"\n    #0. initialize the variables.\n    result = \"\"\n    rules_list = rules_dict[\"rules\"]\n    rules_dict = get_rules_dict(rules_list)\n    value = get_first_variable_value(item, rules_dict)\n\n    #1. now we will check if the golorp can be fed.\n    if value == -1:\n        return \"false\"\n\n    #2. now we will get the smallest possible value.\n    while value >= 0 and value <= 9:\n        if check_value(rules_dict, item, value):\n            result += str(value)\n            return result\n        value += 1\n\n\ndef check_value(rules_dict, item, value):\n    \"\"\"\n    This function checks if the value is good for the variable.\n    :param rules_dict: a dictionary of the rules.\n    :param item: a string of the variable.\n    :param value: an int of the value.\n    :return: a boolean.\n    \"\"\"\n    #1. now we will check if this value is good.\n    if item in rules_dict:\n        if rules_dict[item][\"op\"] == \"<\":\n            if value > rules_dict[item][\"value\"]:\n                return False\n        elif rules_dict[item][\"op\"] == \">\":\n            if value < rules_dict[item][\"value\"]:\n                return False\n    return True\n\n\ndef main():\n    #1. get the input.\n    golorp = input()\n\n    #2. print the result.\n    print(get_golorp(golorp))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1], 'r')\n        lines = f.readlines()\n        f.close()\n    else:\n        lines = [\"?(_-_/___*__):-___>__.\"]\n\n    for line in lines:\n        print(golorp(line.replace(\"\\n\", \"\")))\n\n\ndef golorp(line):\n    stack = []\n    for c in line:\n        if c == \"?\":\n            stack.append(c)\n        elif c == \":\":\n            stack.append(c)\n        elif c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if stack[-1] == \"(\":\n                stack.pop()\n        elif c == \"_\":\n            if stack[-1] == \"?\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \">\":\n            if stack[-1] == \":\":\n                stack.pop()\n            elif stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \".\":\n            if stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \"-\":\n            if stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \"+\":\n            if stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \"*\":\n            if stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \"/\":\n            if stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \"<\":\n            if stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n        elif c == \",\":\n            if stack[-1] == \".\":\n                stack.pop()\n            elif stack[-1] == \":\":\n                stack.append(c)\n            elif stack[-1] == \"(\":\n                stack.append(c)\n\n    if stack == [\"?\", \":\"]:\n        return \"0123456789\"\n    else:\n        return \"false\"\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef solve():\n    name = sys.stdin.readline().strip()\n    stack = []\n    curr_index = 0\n    while curr_index < len(name):\n        curr_char = name[curr_index]\n        if curr_char == '?':\n            curr_index += 1\n            continue\n        elif curr_char == '-':\n            var = stack.pop()\n            stack.append(var - 1)\n            curr_index += 1\n            continue\n        elif curr_char == '+':\n            var = stack.pop()\n            stack.append(var + 1)\n            curr_index += 1\n            continue\n        elif curr_char == '*':\n            var1 = stack.pop()\n            var2 = stack.pop()\n            stack.append(var1 * var2)\n            curr_index += 1\n            continue\n        elif curr_char == '/':\n            var1 = stack.pop()\n            var2 = stack.pop()\n            stack.append(var1 // var2)\n            curr_index += 1\n            continue\n        elif curr_char == '>':\n            var = stack.pop()\n            if var < 0:\n                print(\"false\")\n                return\n            curr_index += 1\n            continue\n        elif curr_char == '<':\n            var = stack.pop()\n            if var > 9:\n                print(\"false\")\n                return\n            curr_index += 1\n            continue\n        elif curr_char == ':':\n            curr_index += 1\n            continue\n        elif curr_char == '.':\n            break\n        elif curr_char == '(':\n            curr_index += 1\n            continue\n        elif curr_char == ')':\n            curr_index += 1\n            continue\n        else:\n            stack.append(int(curr_char))\n            curr_index += 1\n            continue\n    if len(stack) == 0:\n        print(\"false\")\n        return\n    stack.sort()\n    print(\"\".join([str(x) for x in stack]))\n\nif __name__ == \"__main__\":\n    solve()", "\n\n\ndef test_solution():\n    assert solution(\"?(_-_/___*__):-___>__.\") == \"0010\"\n    assert solution(\"?(__-_+_/_____):-__>__,_____<__.\") == \"false\"\n    assert solution(\"?(______________________/____+_______*__-_____*______-___):-__<___,___<____,____<_____,_____<______,______<_______.\") == \"0250341\"\n    assert solution(\"?(__+___+__-___):-___>__.\") == \"0101\"", "\n\n#Variables will be stored in a list\n#The list will be built from left to right\n#If the list is empty, we start with 0\n#The list is a stack: each new variable will be added to the top\n#If a variable is removed, the top variable will be removed\n\n#When the variable is added and removed, the following rules apply:\n# - If the variable is added 0, it will be added to the top of the stack\n# - If the variable is added 1, it will be added to the top of the stack\n# - If the variable is added 2, it will be added to the top of the stack\n# - If the variable is added 3, it will be added to the top of the stack\n# - If the variable is added 4, it will be added to the top of the stack\n# - If the variable is added 5, it will be added to the top of the stack\n# - If the variable is added 6, it will be added to the top of the stack\n# - If the variable is added 7, it will be added to the top of the stack\n# - If the variable is added 8, it will be added to the top of the stack\n# - If the variable is added 9, it will be added to the top of the stack\n# - If a variable is removed and the stack is empty, the golorp is impossible to feed\n# - If a variable is removed and the stack is not empty, the top variable will be removed\n\n#The stack is built from left to right, the values are added to the top of the stack\n\n# - If the stack is empty, we start with 0\n# - If the stack is not empty, we start with the top of the stack\n# - If the stack is full, we pop the top of the stack\n\n#The goal is to make the stack empty at the end of the line\n\n#First we need to split the line in its components:\n# - The first component is the name of the golorp. We don't need that\n# - The second component is the diet of the golorp. We need that\n\ndef FeedGolorp(golorp):\n    diet = golorp.split(\":\")[1]\n    stack = []\n    stack.append(0)\n    #print(diet)\n    #print(stack)\n    for i in diet:\n        #print(i)\n        #print(stack)\n        if i == \"?\":\n            #print(\"?\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                stack.append(0)\n            else:\n                #print(\"The stack is not empty\")\n                stack.append(stack[-1])\n        elif i == \"(\":\n            #print(\"(\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                stack.append(0)\n            else:\n                #print(\"The stack is not empty\")\n                stack.append(stack[-1])\n        elif i == \")\":\n            #print(\")\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack.pop()\n        elif i == \"_\":\n            #print(\"_\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                stack.append(0)\n            else:\n                #print(\"The stack is not empty\")\n                stack.append(stack[-1])\n        elif i == \"-\":\n            #print(\"-\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack.pop()\n        elif i == \"+\":\n            #print(\"+\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack[-1] += 1\n                if stack[-1] == 10:\n                    stack[-1] = 0\n        elif i == \"*\":\n            #print(\"*\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack[-1] *= 2\n                if stack[-1] == 10:\n                    stack[-1] = 0\n        elif i == \"/\":\n            #print(\"/\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack[-1] //= 2\n        elif i == \">\":\n            #print(\">\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                stack.append(0)\n            else:\n                #print(\"The stack is not empty\")\n                stack.append(stack[-1])\n        elif i == \"<\":\n            #print(\"<\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                stack.append(0)\n            else:\n                #print(\"The stack is not empty\")\n                stack.append(stack[-1])\n        elif i == \",\":\n            #print(\",\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack.pop()\n        elif i == \".\":\n            #print(\".\")\n            if len(stack) == 0:\n                #print(\"The stack is empty\")\n                return \"false\"\n            else:\n                #print(\"The stack is not empty\")\n                stack.pop()\n    return \"\".join(map(str, stack))\n\nif __name__ == \"__main__\":\n    #print(FeedGolorp(\"?(_-_/___*__):-___>__.\"))\n    #print(FeedGolorp(\"?(__-_+_/_____):-__>__,_____<__.\"))\n    #print(FeedGolorp(\"?(______________________/____+_______*__-_____*______-___):-__<___,___<____,____<_____,_____<______,______<_______.\"))\n    #print(FeedGolorp(\"?(__+___+__-___):-___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    #print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))\n    print(FeedGolorp(\"?(__+___-__/___):-___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__,___>__.\"))"]