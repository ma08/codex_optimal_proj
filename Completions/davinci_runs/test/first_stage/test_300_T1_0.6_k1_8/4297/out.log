2022-04-16 20:46:27.397607 """
You are given a positive integer N.
Find the minimum positive integer divisible by both 2 and N.

-----Constraints-----
 - 1 \leq N \leq 10^9
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N

-----Output-----
Print the minimum positive integer divisible by both 2 and N.

-----Sample Input-----
3

-----Sample Output-----
6

6 is divisible by both 2 and 3.
Also, there is no positive integer less than 6 that is divisible by both 2 and 3.
Thus, the answer is 6.
"""
2022-04-16 20:46:27.397642 --------------------------
2022-04-16 20:46:41.951402 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nN = int(input())\nprint(2*N)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nN = int(input())\n\n# print(math.gcd(2, N))\n# print(math.gcd(N, 2))\n\nprint(lcm(2, N))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\nprint((lambda n: 4 if n%2==0 else 2*n)(int(input())))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport unittest\n\n\nclass TestMinPosInt(unittest.TestCase):\n\n    def test_1(self):\n        n = 3\n        expected = 6\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n    def test_2(self):\n        n = 2\n        expected = 2\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n    def test_3(self):\n        n = 4\n        expected = 4\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n    def test_4(self):\n        n = 6\n        expected = 6\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n\ndef min_pos_int(n):\n    return n * 2\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nprint(int(input()) * 2)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nprint(2*int(input()))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n\n    if n % 2 == 0:\n        print(n)\n    else:\n        print(2*n)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\nN = int(input())\n\nif N % 2 == 0:\n    print(N)\nelse:\n    print(2 * N)"
    }
  ],
  "created": 1650141987,
  "id": "cmpl-4xjbHPxNvFR4gf3FVtG9sEhFRTZcf",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:46:41.951704 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nN = int(input())\nprint(2*N)"
}
2022-04-16 20:46:41.951748 REASON stop
2022-04-16 20:46:41.993341 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nN = int(input())\n\n# print(math.gcd(2, N))\n# print(math.gcd(N, 2))\n\nprint(lcm(2, N))"
}
2022-04-16 20:46:41.993529 REASON stop
2022-04-16 20:46:41.993986 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\nprint((lambda n: 4 if n%2==0 else 2*n)(int(input())))"
}
2022-04-16 20:46:41.994044 REASON stop
2022-04-16 20:46:42.017999 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport unittest\n\n\nclass TestMinPosInt(unittest.TestCase):\n\n    def test_1(self):\n        n = 3\n        expected = 6\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n    def test_2(self):\n        n = 2\n        expected = 2\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n    def test_3(self):\n        n = 4\n        expected = 4\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n    def test_4(self):\n        n = 6\n        expected = 6\n        actual = min_pos_int(n)\n        self.assertEqual(expected, actual)\n\n\ndef min_pos_int(n):\n    return n * 2\n\n\nif __name__ == '__main__':\n    unittest.main()"
}
2022-04-16 20:46:42.018144 REASON stop
2022-04-16 20:46:42.028201 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nprint(int(input()) * 2)"
}
2022-04-16 20:46:42.028317 REASON stop
2022-04-16 20:46:42.029365 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nprint(2*int(input()))"
}
2022-04-16 20:46:42.029461 REASON stop
2022-04-16 20:46:42.030409 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n\n    if n % 2 == 0:\n        print(n)\n    else:\n        print(2*n)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:46:42.030500 REASON stop
2022-04-16 20:46:42.031463 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\nN = int(input())\n\nif N % 2 == 0:\n    print(N)\nelse:\n    print(2 * N)"
}
2022-04-16 20:46:42.031525 REASON stop
