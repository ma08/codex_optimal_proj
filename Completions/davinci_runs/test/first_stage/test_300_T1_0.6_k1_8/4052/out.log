2022-04-16 19:09:06.720338 """
You are given two strings $s$ and $t$. Both strings have length $n$ and consist of lowercase Latin letters. The characters in the strings are numbered from $1$ to $n$.

You can successively perform the following move any number of times (possibly, zero):  swap any two adjacent (neighboring) characters of $s$ (i.e. for any $i = \{1, 2, \dots, n - 1\}$ you can swap $s_i$ and $s_{i + 1})$. 

You can't apply a move to the string $t$. The moves are applied to the string $s$ one after another.

Your task is to obtain the string $t$ from the string $s$. Find any way to do it with at most $10^4$ such moves.

You do not have to minimize the number of moves, just find any sequence of moves of length $10^4$ or less to transform $s$ into $t$.


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 50$) — the length of strings $s$ and $t$.

The second line of the input contains the string $s$ consisting of $n$ lowercase Latin letters.

The third line of the input contains the string $t$ consisting of $n$ lowercase Latin letters.


-----Output-----

If it is impossible to obtain the string $t$ using moves, print "-1".

Otherwise in the first line print one integer $k$ — the number of moves to transform $s$ to $t$. Note that $k$ must be an integer number between $0$ and $10^4$ inclusive.

In the second line print $k$ integers $c_j$ ($1 \le c_j < n$), where $c_j$ means that on the $j$-th move you swap characters $s_{c_j}$ and $s_{c_j + 1}$.

If you do not need to apply any moves, print a single integer $0$ in the first line and either leave the second line empty or do not print it at all.


-----Examples-----
Input
6
abcdef
abdfec

Output
4
3 5 4 5 

Input
4
abcd
accd

Output
-1



-----Note-----

In the first example the string $s$ changes as follows: "abcdef" $\rightarrow$ "abdcef" $\rightarrow$ "abdcfe" $\rightarrow$ "abdfce" $\rightarrow$ "abdfec".

In the second example there is no way to transform the string $s$ into the string $t$ through any allowed moves.
"""
2022-04-16 19:09:06.720360 --------------------------
2022-04-16 19:09:32.351662 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\nt = input()\n\ndef is_possible(sequence, s, t):\n    curr = list(s)\n    for i in range(len(sequence)):\n        curr[sequence[i]-1], curr[sequence[i]] = curr[sequence[i]], curr[sequence[i]-1]\n    return \"\".join(curr) == t\n\ndef get_sequences(n):\n    for i in range(1, n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    yield [i, j, k, l]\n\nfor seq in get_sequences(n):\n    if is_possible(seq, s, t):\n        print(len(seq))\n        print(\" \".join([str(x) for x in seq]))\n        break\nelse:\n    print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\nfrom collections import deque\n\n\ndef get_swap_moves(s, t):\n    if s == t:\n        return 0\n    if len(s) != len(t):\n        return -1\n    if sorted(s) != sorted(t):\n        return -1\n\n    def get_neighbors(index):\n        if index > 0:\n            yield index - 1\n        if index < len(s) - 1:\n            yield index + 1\n\n    def swap(index):\n        s[index], s[index + 1] = s[index + 1], s[index]\n\n    Q = deque([(s, 0, [])])\n    seen = set()\n    while Q:\n        s, moves, swap_moves = Q.popleft()\n        if s == t:\n            return moves, swap_moves\n\n        for index, (c1, c2) in enumerate(zip(s, t)):\n            if c1 != c2:\n                for neighbor in get_neighbors(index):\n                    swap(neighbor)\n                    new_s = tuple(s)\n                    swap(neighbor)\n                    if new_s in seen:\n                        continue\n                    seen.add(new_s)\n                    Q.append((list(new_s), moves + 1, swap_moves + [neighbor + 1]))\n\n    return -1\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = list(input())\n    t = list(input())\n    swap_moves = get_swap_moves(s, t)\n    if swap_moves == -1:\n        print(swap_moves)\n    else:\n        moves, swap_moves = swap_moves\n        print(moves)\n        print(*swap_moves)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n#------------------------------------------------------------------------------#\n\ndef solve(n, s, t):\n    \"\"\"\n    Solves the problem.\n    \n    Parameters:\n        n: \n        s: \n        t: \n        \n    Returns:\n        The solution as a string.\n    \"\"\"\n    # Check if the input is valid\n    if not n in range(1, 51):\n        return '-1'\n    for i in range(n):\n        if not s[i] in ascii_lowercase or not t[i] in ascii_lowercase:\n            return '-1'\n    \n    # If the two strings are equal, no moves are needed\n    if s == t:\n        return '0\\n'\n    \n    # Solve the problem\n    return '\\n'.join(str(i) for i in range(1, n))\n\n#------------------------------------------------------------------------------#\n\ndef read_input():\n    \"\"\"\n    Reads the input and returns it.\n    \n    Returns:\n        The input as a list of strings.\n    \"\"\"\n    n = int(input())\n    s = input()\n    t = input()\n    \n    return [n, s, t]\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    \"\"\"\n    Solves the problem.\n    \n    Returns:\n        None.\n    \"\"\"\n    print(solve(*read_input()))\n\n#------------------------------------------------------------------------------#\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\nt = input()\n\nif s == t:\n    print(\"0\")\nelse:\n    print(\"-1\")"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n\nn = int(input())\ns = list(input())\nt = list(input())\n\nif s == t:\n    print(0)\n    exit()\n\n\ndef swap(lst, i, j):\n    lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\n\ndef find_swap_points(s, t):\n    swap_points = []\n    i = 0\n    while i < n:\n        if s[i] != t[i]:\n            for j in range(i + 1, n):\n                if s[j] == t[i]:\n                    swap_points.append(j)\n                    s = swap(s, i, j)\n                    break\n        i += 1\n    return swap_points\n\n\ndef find_swap_points2(s, t):\n    swap_points = []\n    i = 0\n    while i < n:\n        if s[i] != t[i]:\n            j = i + 1\n            while j < n:\n                if s[j] == t[i]:\n                    swap_points.append(j)\n                    s = swap(s, i, j)\n                    break\n                j += 1\n        i += 1\n    return swap_points\n\n\nswap_points = find_swap_points(s, t)\n\nif s != t:\n    swap_points = find_swap_points2(s, t)\n\nif s != t:\n    print(-1)\nelse:\n    print(len(swap_points))\n    print(*swap_points)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\ns = input()\nt = input()\n\n# If s and t are the same, we don't need to do any swaps\nif s == t:\n    print(0)\n    exit()\n\n# Otherwise, we need to find the first index that differs between s and t\ni = 0\nwhile s[i] == t[i]:\n    i += 1\n\n# If all of the characters from index i to n are the same, then we can't swap\n# to get to t, so print -1\nif s[i:] == t[i:]:\n    print(-1)\n    exit()\n\n# Otherwise, we can swap s[i] and s[i+1] to get to t\nprint(1)\nprint(i + 1)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\ndef get_neighbors(i, n):\n    if i == 0:\n        return [1]\n    elif i == n-1:\n        return [i-1]\n    else:\n        return [i-1, i+1]\n\ndef dfs_path(i, j, n, m, graph, visited, path):\n    visited[i] = True\n    path.append(i)\n\n    if i == j:\n        return path\n\n    for neighbor in get_neighbors(i, n):\n        if not visited[neighbor] and neighbor in graph:\n            new_path = dfs_path(neighbor, j, n, m, graph, visited, path)\n            if new_path:\n                return new_path\n\n    path.pop(-1)\n    return None\n\ndef find_path(i, j, n, m, graph):\n    return dfs_path(i, j, n, m, graph, visited=[False]*n, path=[])\n\ndef find_paths(n, m, graph):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            path = find_path(i, j, n, m, graph)\n            if path:\n                paths.append(path)\n    return paths\n\ndef get_paths(n, s, t):\n    graph = defaultdict(list)\n    for i in range(n):\n        if s[i] != t[i]:\n            graph[s[i]].append(t[i])\n    return find_paths(n, m=len(graph), graph=graph)\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    paths = get_paths(n, s, t)\n    if paths:\n        print(len(paths))\n        for path in paths:\n            for i in range(1, len(path)):\n                print(path[i]-1, end=\" \")\n            print()\n    else:\n        print(-1)\n\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650136146,
  "id": "cmpl-4xi54HVfKA92DgVVKf3jomyWZtG7o",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:09:32.352082 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:09:32.352126 REASON stop
2022-04-16 19:09:32.383593 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\nt = input()\n\ndef is_possible(sequence, s, t):\n    curr = list(s)\n    for i in range(len(sequence)):\n        curr[sequence[i]-1], curr[sequence[i]] = curr[sequence[i]], curr[sequence[i]-1]\n    return \"\".join(curr) == t\n\ndef get_sequences(n):\n    for i in range(1, n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    yield [i, j, k, l]\n\nfor seq in get_sequences(n):\n    if is_possible(seq, s, t):\n        print(len(seq))\n        print(\" \".join([str(x) for x in seq]))\n        break\nelse:\n    print(-1)"
}
2022-04-16 19:09:32.383769 REASON stop
2022-04-16 19:09:32.384239 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\nfrom collections import deque\n\n\ndef get_swap_moves(s, t):\n    if s == t:\n        return 0\n    if len(s) != len(t):\n        return -1\n    if sorted(s) != sorted(t):\n        return -1\n\n    def get_neighbors(index):\n        if index > 0:\n            yield index - 1\n        if index < len(s) - 1:\n            yield index + 1\n\n    def swap(index):\n        s[index], s[index + 1] = s[index + 1], s[index]\n\n    Q = deque([(s, 0, [])])\n    seen = set()\n    while Q:\n        s, moves, swap_moves = Q.popleft()\n        if s == t:\n            return moves, swap_moves\n\n        for index, (c1, c2) in enumerate(zip(s, t)):\n            if c1 != c2:\n                for neighbor in get_neighbors(index):\n                    swap(neighbor)\n                    new_s = tuple(s)\n                    swap(neighbor)\n                    if new_s in seen:\n                        continue\n                    seen.add(new_s)\n                    Q.append((list(new_s), moves + 1, swap_moves + [neighbor + 1]))\n\n    return -1\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = list(input())\n    t = list(input())\n    swap_moves = get_swap_moves(s, t)\n    if swap_moves == -1:\n        print(swap_moves)\n    else:\n        moves, swap_moves = swap_moves\n        print(moves)\n        print(*swap_moves)"
}
2022-04-16 19:09:32.384306 REASON stop
2022-04-16 19:09:32.407591 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n#------------------------------------------------------------------------------#\n\ndef solve(n, s, t):\n    \"\"\"\n    Solves the problem.\n    \n    Parameters:\n        n: \n        s: \n        t: \n        \n    Returns:\n        The solution as a string.\n    \"\"\"\n    # Check if the input is valid\n    if not n in range(1, 51):\n        return '-1'\n    for i in range(n):\n        if not s[i] in ascii_lowercase or not t[i] in ascii_lowercase:\n            return '-1'\n    \n    # If the two strings are equal, no moves are needed\n    if s == t:\n        return '0\\n'\n    \n    # Solve the problem\n    return '\\n'.join(str(i) for i in range(1, n))\n\n#------------------------------------------------------------------------------#\n\ndef read_input():\n    \"\"\"\n    Reads the input and returns it.\n    \n    Returns:\n        The input as a list of strings.\n    \"\"\"\n    n = int(input())\n    s = input()\n    t = input()\n    \n    return [n, s, t]\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    \"\"\"\n    Solves the problem.\n    \n    Returns:\n        None.\n    \"\"\"\n    print(solve(*read_input()))\n\n#------------------------------------------------------------------------------#\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:09:32.407698 REASON stop
2022-04-16 19:09:32.408600 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\nt = input()\n\nif s == t:\n    print(\"0\")\nelse:\n    print(\"-1\")"
}
2022-04-16 19:09:32.408684 REASON stop
2022-04-16 19:09:32.416889 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n\nn = int(input())\ns = list(input())\nt = list(input())\n\nif s == t:\n    print(0)\n    exit()\n\n\ndef swap(lst, i, j):\n    lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\n\ndef find_swap_points(s, t):\n    swap_points = []\n    i = 0\n    while i < n:\n        if s[i] != t[i]:\n            for j in range(i + 1, n):\n                if s[j] == t[i]:\n                    swap_points.append(j)\n                    s = swap(s, i, j)\n                    break\n        i += 1\n    return swap_points\n\n\ndef find_swap_points2(s, t):\n    swap_points = []\n    i = 0\n    while i < n:\n        if s[i] != t[i]:\n            j = i + 1\n            while j < n:\n                if s[j] == t[i]:\n                    swap_points.append(j)\n                    s = swap(s, i, j)\n                    break\n                j += 1\n        i += 1\n    return swap_points\n\n\nswap_points = find_swap_points(s, t)\n\nif s != t:\n    swap_points = find_swap_points2(s, t)\n\nif s != t:\n    print(-1)\nelse:\n    print(len(swap_points))\n    print(*swap_points)"
}
2022-04-16 19:09:32.416991 REASON stop
2022-04-16 19:09:32.417841 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\ns = input()\nt = input()\n\n# If s and t are the same, we don't need to do any swaps\nif s == t:\n    print(0)\n    exit()\n\n# Otherwise, we need to find the first index that differs between s and t\ni = 0\nwhile s[i] == t[i]:\n    i += 1\n\n# If all of the characters from index i to n are the same, then we can't swap\n# to get to t, so print -1\nif s[i:] == t[i:]:\n    print(-1)\n    exit()\n\n# Otherwise, we can swap s[i] and s[i+1] to get to t\nprint(1)\nprint(i + 1)"
}
2022-04-16 19:09:32.417934 REASON stop
2022-04-16 19:09:32.418697 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\ndef get_neighbors(i, n):\n    if i == 0:\n        return [1]\n    elif i == n-1:\n        return [i-1]\n    else:\n        return [i-1, i+1]\n\ndef dfs_path(i, j, n, m, graph, visited, path):\n    visited[i] = True\n    path.append(i)\n\n    if i == j:\n        return path\n\n    for neighbor in get_neighbors(i, n):\n        if not visited[neighbor] and neighbor in graph:\n            new_path = dfs_path(neighbor, j, n, m, graph, visited, path)\n            if new_path:\n                return new_path\n\n    path.pop(-1)\n    return None\n\ndef find_path(i, j, n, m, graph):\n    return dfs_path(i, j, n, m, graph, visited=[False]*n, path=[])\n\ndef find_paths(n, m, graph):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            path = find_path(i, j, n, m, graph)\n            if path:\n                paths.append(path)\n    return paths\n\ndef get_paths(n, s, t):\n    graph = defaultdict(list)\n    for i in range(n):\n        if s[i] != t[i]:\n            graph[s[i]].append(t[i])\n    return find_paths(n, m=len(graph), graph=graph)\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    paths = get_paths(n, s, t)\n    if paths:\n        print(len(paths))\n        for path in paths:\n            for i in range(1, len(path)):\n                print(path[i]-1, end=\" \")\n            print()\n    else:\n        print(-1)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:09:32.418780 REASON stop
