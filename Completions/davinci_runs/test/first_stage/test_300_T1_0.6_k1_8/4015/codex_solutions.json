["", "\n\n\ndef main(n, m):\n    if n == m:\n        print 0\n    else:\n        if n > m:\n            print -1\n        else:\n            if m % n != 0:\n                print -1\n            else:\n                res = 0\n                while n != m:\n                    if m % 2 == 0:\n                        m /= 2\n                        res += 1\n                    elif m % 3 == 0:\n                        m /= 3\n                        res += 1\n                    else:\n                        print -1\n                        break\n                print res\n\nif __name__ == '__main__':\n    n, m = map(int, raw_input().split())\n    main(n, m)", "\n\nn,m = [int(x) for x in input().split()]\n\ndef find_moves(n,m):\n    if n == m:\n        return 0\n    if n > m or n == 0 or m == 0:\n        return -1\n    if n%2 == 0:\n        return find_moves(n//2,m)\n    if n%3 == 0:\n        return find_moves(n//3,m)\n    return -1\n\nprint(find_moves(n,m))", "\n\nn,m = map(int,input().split())\nif n==m:\n    print(0)\nelif n%2==0 and n%3==0:\n    print(-1)\nelif n%2==0 and m%2==0:\n    print(n.bit_length()-m.bit_length())\nelif n%3==0 and m%3==0:\n    print(n.bit_length()-m.bit_length())\nelse:\n    print(-1)", "\n\nn, m = list(map(int, input().split()))\n\n# Observation: all solutions contain the same number of moves\n# Observation: we can only multiply by 2 or 3 --> if both are valid, we'll always choose 3\n# Observation: $m = 3^{a}2^{b}$ --> $n = 3^{c}2^{d}$ --> $m = n*3^{a-c}2^{b-d}$\n# Observation: $m$ can be written as a product of powers of 2 and 3 --> we can reduce the problem of finding the number of moves to finding the number of 2's and 3's\n\n# The solution is to count the number of 2's and 3's in $m$ and $n$\n# to find the number of 2's and 3's in $m$, we can keep dividing $m$ by 2 or 3 until it is 1\n# to find the number of 2's and 3's in $n$, we can keep dividing $n$ by 2 or 3 until it is 1\n# the number of moves is the sum of the number of 2's and 3's in $m$ and $n$\n# we can't solve the problem if the number of 3's in $m$ is bigger than the number of 3's in $n$\n\nnumber_of_twos = 0\nnumber_of_threes = 0\n\nwhile m > 1:\n    if m % 2 == 0:\n        number_of_twos += 1\n        m //= 2\n    elif m % 3 == 0:\n        number_of_threes += 1\n        m //= 3\n    else:\n        print(\"-1\")\n        exit()\n\nwhile n > 1:\n    if n % 2 == 0:\n        number_of_twos -= 1\n        n //= 2\n    elif n % 3 == 0:\n        number_of_threes -= 1\n        n //= 3\n\nif number_of_threes < 0:\n    print(\"-1\")\n    exit()\n\nprint(number_of_twos + number_of_threes)", "\n\ndef main():\n    n, m = map(int, raw_input().split())\n    ans = 0\n    while n != m:\n        if n > m:\n            n /= 2\n            ans += 1\n        else:\n            if n * 3 != m:\n                n *= 3\n                ans += 1\n            else:\n                ans += 1\n                break\n    if n == m:\n        print ans\n    else:\n        print -1\n\n\nif __name__ == '__main__':\n    main()", "\n\nn,m = map(int,input().split())\n\nif m % n != 0:\n    print(\"-1\")\nelse:\n    count = 0\n    while m != n:\n        if m % 2 == 0:\n            m = m // 2\n            count += 1\n        elif m % 3 == 0:\n            m = m // 3\n            count += 1\n        else:\n            print(\"-1\")\n            break\n    else:\n        print(count)", "\n\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    if n == m:\n        print(0)\n        return\n    stack = [n]\n    visited = set()\n    while stack:\n        v = stack.pop()\n        if v not in visited:\n            visited.add(v)\n            if v == m:\n                print(len(visited) - 1)\n                return\n            if v * 2 <= m:\n                stack.append(v * 2)\n            if v * 3 <= m:\n                stack.append(v * 3)\n    print(-1)\n\n\nif __name__ == '__main__':\n    main()"]