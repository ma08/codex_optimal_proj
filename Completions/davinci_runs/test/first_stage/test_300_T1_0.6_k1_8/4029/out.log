2022-04-16 18:57:30.958220 """
You are given an integer $n$ from $1$ to $10^{18}$ without leading zeroes.

In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words, after each move the number you have cannot contain any leading zeroes.

What is the minimum number of moves you have to make to obtain a number that is divisible by $25$? Print -1 if it is impossible to obtain a number that is divisible by $25$.


-----Input-----

The first line contains an integer $n$ ($1 \le n \le 10^{18}$). It is guaranteed that the first (left) digit of the number $n$ is not a zero.


-----Output-----

If it is impossible to obtain a number that is divisible by $25$, print -1. Otherwise print the minimum number of moves required to obtain such number.

Note that you can swap only adjacent digits in the given number.


-----Examples-----
Input
5071

Output
4

Input
705

Output
1

Input
1241367

Output
-1



-----Note-----

In the first example one of the possible sequences of moves is 5071 $\rightarrow$ 5701 $\rightarrow$ 7501 $\rightarrow$ 7510 $\rightarrow$ 7150.
"""
2022-04-16 18:57:30.958228 --------------------------
2022-04-16 18:58:00.587881 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\n\nif len(str(n)) == 1:\n    print(-1)\nelse:\n    count = 0\n    while n % 25 != 0:\n        if n < 25:\n            print(-1)\n            break\n        else:\n            n = list(str(n))\n            for i in range(len(n) - 1):\n                if n[i] > n[i+1]:\n                    n[i], n[i+1] = n[i+1], n[i]\n                    count += 1\n                    break\n            n = int(''.join(n))\n    print(count)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef minimum_moves(number):\n    minimum = 100\n    number = str(number)\n    for i in range(0, len(number)-1):\n        if number[i] == '0':\n            temp = list(number)\n            temp[i], temp[i+1] = temp[i+1], temp[i]\n            temp = ''.join(temp)\n            temp = int(temp)\n            temp2 = temp\n            count = 0\n            while(temp2 % 25 != 0):\n                count += 1\n                temp2 += 1\n            if count < minimum:\n                minimum = count\n    if minimum == 100:\n        return -1\n    else:\n        return minimum\n\nif __name__ == '__main__':\n    number = int(input())\n    print(minimum_moves(number))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef swaps(n):\n    if n % 25 == 0:\n        return 0\n    if len(n) <= 1:\n        return -1\n    if n[-2] == '0':\n        return swaps(n[:-1])\n    return min(swaps(n[:-1]), swaps(n[:-2] + n[-1] + n[-2])) + 1\n\ndef main():\n    n = sys.stdin.readline()\n    print swaps(n)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\n\ncnt = 0\nwhile n % 25 != 0:\n    if n % 10 == 0:\n        cnt = -1\n        break\n    if n % 5 != 0:\n        n = n * 10 + 3\n    else:\n        n = n * 10 + 2\n    cnt += 1\n\nprint(cnt)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\nn = int(stdin.readline())\n\ndef find_divisible(n):\n    if n == 0:\n        return -1\n    elif n % 25 == 0:\n        return 0\n    else:\n        return find_divisible(n // 10) + 1\n\nprint(find_divisible(n))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn = input()\nn = list(n)\n\ndef is_divisible_by_25(n):\n    \"\"\"Returns True if n is divisible by 25, else False\"\"\"\n    if len(n) == 1:\n        return False\n    else:\n        if n[-1] == '0' and n[-2] in ['0', '5']:\n            return True\n        else:\n            return False\n\ndef get_swap_indices(n):\n    \"\"\"Returns indices of n, which if swapped, would make n divisible by 25\"\"\"\n    if is_divisible_by_25(n) == True:\n        return []\n    else:\n        for i in range(len(n)-1):\n            if (n[i] == '5' and n[i+1] == '0') or (n[i] == '0' and n[i+1] == '5'):\n                return [i, i+1]\n        return [-1, -1]\n\ndef swap_indices(n, i, j):\n    \"\"\"Returns a list where n[i] and n[j] are swapped\"\"\"\n    n[i], n[j] = n[j], n[i]\n    return n\n\ndef get_swap_count(n):\n    \"\"\"Returns the minimum number of swaps required to make n divisible by 25\"\"\"\n    swap_count = 0\n    while True:\n        if is_divisible_by_25(n) == True:\n            break\n        else:\n            swap_indices_list = get_swap_indices(n)\n            if swap_indices_list == [-1, -1]:\n                return -1\n            else:\n                i, j = swap_indices_list[0], swap_indices_list[1]\n                n = swap_indices(n, i, j)\n                swap_count += 1\n    return swap_count\n\nprint(get_swap_count(n))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n = int(input())\n    if n % 25 == 0:\n        print(0)\n    else:\n        n = list(map(int, str(n)))\n        count = 0\n        while True:\n            if n[0] == 0:\n                print(-1)\n                break\n            if n[len(n) - 1] == 0:\n                n.append(n[0])\n                n.pop(0)\n                count += 1\n            else:\n                n[len(n) - 1] = 0\n                count += 1\n            if len(n) > 1 and n[len(n) - 1] == 0 and n[len(n) - 2] == 0:\n                print(count)\n                break\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport pprint\nimport sys\n\ndef find_min_moves(num):\n    # base case\n    if num % 25 == 0:\n        return 0\n\n    # check if the num is a multiple of 5\n    if num % 5 != 0:\n        return -1\n\n    # get the last 2 digits\n    last_2 = num % 100\n    if last_2 % 25 == 0:\n        return 1\n    else:\n        return -1\n\n    # if the last two digits are non-zero, then we can swap them\n    # and get the num to be divisible by 25\n    # if (last_2[0] != '0' and last_2[1] != '0'):\n        # swap the last two digits\n        # last_2 = last_2[1] + last_2[0]\n\n        # get the remaining digits\n        # rem_digits = num // 100\n\n        # concatenate the num\n        # concat_num = rem_digits + last_2\n        # return 1 + find_min_moves(concat_num)\n\ndef main():\n    num = int(sys.stdin.readline().strip())\n    print(find_min_moves(num))\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650135451,
  "id": "cmpl-4xhtrQ9BknhEANbHNof07Sh0xKUcO",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 18:58:00.588233 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\n\nif len(str(n)) == 1:\n    print(-1)\nelse:\n    count = 0\n    while n % 25 != 0:\n        if n < 25:\n            print(-1)\n            break\n        else:\n            n = list(str(n))\n            for i in range(len(n) - 1):\n                if n[i] > n[i+1]:\n                    n[i], n[i+1] = n[i+1], n[i]\n                    count += 1\n                    break\n            n = int(''.join(n))\n    print(count)"
}
2022-04-16 18:58:00.588270 REASON stop
2022-04-16 18:58:00.631044 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef minimum_moves(number):\n    minimum = 100\n    number = str(number)\n    for i in range(0, len(number)-1):\n        if number[i] == '0':\n            temp = list(number)\n            temp[i], temp[i+1] = temp[i+1], temp[i]\n            temp = ''.join(temp)\n            temp = int(temp)\n            temp2 = temp\n            count = 0\n            while(temp2 % 25 != 0):\n                count += 1\n                temp2 += 1\n            if count < minimum:\n                minimum = count\n    if minimum == 100:\n        return -1\n    else:\n        return minimum\n\nif __name__ == '__main__':\n    number = int(input())\n    print(minimum_moves(number))"
}
2022-04-16 18:58:00.631262 REASON stop
2022-04-16 18:58:00.631800 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef swaps(n):\n    if n % 25 == 0:\n        return 0\n    if len(n) <= 1:\n        return -1\n    if n[-2] == '0':\n        return swaps(n[:-1])\n    return min(swaps(n[:-1]), swaps(n[:-2] + n[-1] + n[-2])) + 1\n\ndef main():\n    n = sys.stdin.readline()\n    print swaps(n)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 18:58:00.631867 REASON stop
2022-04-16 18:58:00.645152 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\n\ncnt = 0\nwhile n % 25 != 0:\n    if n % 10 == 0:\n        cnt = -1\n        break\n    if n % 5 != 0:\n        n = n * 10 + 3\n    else:\n        n = n * 10 + 2\n    cnt += 1\n\nprint(cnt)"
}
2022-04-16 18:58:00.645264 REASON stop
2022-04-16 18:58:00.667531 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\nn = int(stdin.readline())\n\ndef find_divisible(n):\n    if n == 0:\n        return -1\n    elif n % 25 == 0:\n        return 0\n    else:\n        return find_divisible(n // 10) + 1\n\nprint(find_divisible(n))"
}
2022-04-16 18:58:00.667657 REASON stop
2022-04-16 18:58:00.668662 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn = input()\nn = list(n)\n\ndef is_divisible_by_25(n):\n    \"\"\"Returns True if n is divisible by 25, else False\"\"\"\n    if len(n) == 1:\n        return False\n    else:\n        if n[-1] == '0' and n[-2] in ['0', '5']:\n            return True\n        else:\n            return False\n\ndef get_swap_indices(n):\n    \"\"\"Returns indices of n, which if swapped, would make n divisible by 25\"\"\"\n    if is_divisible_by_25(n) == True:\n        return []\n    else:\n        for i in range(len(n)-1):\n            if (n[i] == '5' and n[i+1] == '0') or (n[i] == '0' and n[i+1] == '5'):\n                return [i, i+1]\n        return [-1, -1]\n\ndef swap_indices(n, i, j):\n    \"\"\"Returns a list where n[i] and n[j] are swapped\"\"\"\n    n[i], n[j] = n[j], n[i]\n    return n\n\ndef get_swap_count(n):\n    \"\"\"Returns the minimum number of swaps required to make n divisible by 25\"\"\"\n    swap_count = 0\n    while True:\n        if is_divisible_by_25(n) == True:\n            break\n        else:\n            swap_indices_list = get_swap_indices(n)\n            if swap_indices_list == [-1, -1]:\n                return -1\n            else:\n                i, j = swap_indices_list[0], swap_indices_list[1]\n                n = swap_indices(n, i, j)\n                swap_count += 1\n    return swap_count\n\nprint(get_swap_count(n))"
}
2022-04-16 18:58:00.668745 REASON stop
2022-04-16 18:58:00.670384 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n = int(input())\n    if n % 25 == 0:\n        print(0)\n    else:\n        n = list(map(int, str(n)))\n        count = 0\n        while True:\n            if n[0] == 0:\n                print(-1)\n                break\n            if n[len(n) - 1] == 0:\n                n.append(n[0])\n                n.pop(0)\n                count += 1\n            else:\n                n[len(n) - 1] = 0\n                count += 1\n            if len(n) > 1 and n[len(n) - 1] == 0 and n[len(n) - 2] == 0:\n                print(count)\n                break\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 18:58:00.670510 REASON stop
2022-04-16 18:58:00.671497 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport pprint\nimport sys\n\ndef find_min_moves(num):\n    # base case\n    if num % 25 == 0:\n        return 0\n\n    # check if the num is a multiple of 5\n    if num % 5 != 0:\n        return -1\n\n    # get the last 2 digits\n    last_2 = num % 100\n    if last_2 % 25 == 0:\n        return 1\n    else:\n        return -1\n\n    # if the last two digits are non-zero, then we can swap them\n    # and get the num to be divisible by 25\n    # if (last_2[0] != '0' and last_2[1] != '0'):\n        # swap the last two digits\n        # last_2 = last_2[1] + last_2[0]\n\n        # get the remaining digits\n        # rem_digits = num // 100\n\n        # concatenate the num\n        # concat_num = rem_digits + last_2\n        # return 1 + find_min_moves(concat_num)\n\ndef main():\n    num = int(sys.stdin.readline().strip())\n    print(find_min_moves(num))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 18:58:00.671606 REASON stop
