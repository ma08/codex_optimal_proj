["\n\nclass Graph:\n    def __init__(self, vertices): \n        self.V = vertices \n        self.adj = [[] for i in range(vertices)] \n  \n    def addEdge(self, u, v): \n        self.adj[u].append(v) \n  \n    def DFSUtil(self, v, visited): \n        visited[v] = True\n        for i in self.adj[v]: \n            if visited[i] == False: \n                self.DFSUtil(i, visited) \n  \n    def DFS(self, v): \n        visited = [False]*(self.V) \n        self.DFSUtil(v, visited) \n        return visited.count(True) \n\ndef find_min_roads(n, m, s, paths):\n    g = Graph(n+1)\n    for p in paths:\n        g.addEdge(p[0], p[1])\n    return n - g.DFS(s)\n\nif __name__ == \"__main__\":\n    n, m, s = map(int, input().split())\n    paths = [list(map(int, input().split())) for _ in range(m)]\n    print(find_min_roads(n, m, s, paths))", "\n\nimport sys\nfrom collections import defaultdict\n\ndef get_input(infile):\n    n, m, s = [int(x) for x in infile.readline().strip().split()]\n    road_map = defaultdict(set)\n    for _ in range(m):\n        u, v = [int(x) for x in infile.readline().strip().split()]\n        road_map[u].add(v)\n    return n, m, s, road_map\n\ndef dfs(s, road_map, visited):\n    visited.add(s)\n    for v in road_map[s]:\n        if v not in visited:\n            visited.add(v)\n            dfs(v, road_map, visited)\n\ndef main():\n    n, m, s, road_map = get_input(sys.stdin)\n    visited = set()\n    dfs(s, road_map, visited)\n    print(n - len(visited))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, m, s = map(int, input().split())\n    graph = [[] for i in range(n)]\n\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n\n    # run DFS from the source and mark all reachable nodes as visited\n    visited = [False]*n\n    dfs(s-1, graph, visited)\n\n    # run DFS again, but this time from all the nodes that were not visited\n    # and count the number of nodes that are not visited in the end\n    # the number of nodes that are not visited is the number of new roads\n    # that need to be built\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, graph, visited)\n            count += 1\n\n    print(count)\n\n\ndef dfs(node, graph, visited):\n    visited[node] = True\n\n    for i in graph[node]:\n        if not visited[i]:\n            dfs(i, graph, visited)\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport math\n\n# TODO: This is a minimum spanning tree problem.\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef readline():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n,m,s = map(int, readline().split())\n    adj = [[] for i in range(n+1)]\n    for i in range(m):\n        u,v = map(int, readline().split())\n        adj[u].append(v)\n    for i in range(n):\n        adj[i].append(i+1)\n    ans = 0\n    vis = [False]*(n+1)\n    vis[s] = True\n    queue = []\n    queue.append(s)\n    while len(queue) > 0:\n        u = queue.pop()\n        for v in adj[u]:\n            if not vis[v]:\n                vis[v] = True\n                ans += 1\n                queue.append(v)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    # read input\n    n, m, s = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        roads.append((u, v))\n\n    # get connected components\n    components = get_connected_components(roads, n)\n\n    # initialise counts\n    counts = collections.defaultdict(int)\n\n    # count the number of vertices in each component\n    for component in components:\n        if len(component) > 1:\n            for vertex in component:\n                counts[vertex] += 1\n\n    # initialise the number of extra roads\n    extra_roads = 0\n\n    # check if capital is in a component\n    if counts[s] > 0:\n        extra_roads += counts[s] - 1\n\n    # check if other vertices are in components\n    for vertex, count in counts.items():\n        if vertex == s:\n            continue\n        if count > 0:\n            extra_roads += count\n\n    # print result\n    print(extra_roads)\n\n\ndef get_connected_components(roads, n):\n    # initialise adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n\n    # populate adjacency list\n    for u, v in roads:\n        adj_list[u].append(v)\n\n    # initialise visited vertices\n    visited = set()\n\n    # initialise connected components\n    components = []\n\n    # find connected components\n    for vertex in range(1, n + 1):\n        if vertex in visited:\n            continue\n        component = []\n        stack = [vertex]\n        while stack:\n            u = stack.pop()\n            if u not in visited:\n                visited.add(u)\n                component.append(u)\n                stack.extend(adj_list[u])\n        components.append(component)\n\n    return components\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom sys import stdin\n\ndef main():\n\tn, m, start = [int(x) for x in stdin.readline().split()]\n\troads = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\tu, v = [int(x) for x in stdin.readline().split()]\n\t\troads[u-1].append(v-1)\n\t\n\tvisited = [False for _ in range(n)]\n\tstack = [start-1]\n\twhile stack:\n\t\tcurr = stack.pop()\n\t\tvisited[curr] = True\n\t\tfor to in roads[curr]:\n\t\t\tif not visited[to]:\n\t\t\t\tstack.append(to)\n\t\n\tprint(sum(visited))\n\nif __name__ == \"__main__\":\n\tmain()", "\n\nfrom sys import stdin, stdout\nfrom collections import defaultdict, deque\n\n# from collections import defaultdict, deque\n\ndef main():\n    n, m, s = map(int, stdin.readline().split())\n    adj_list = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        adj_list[u].append(v)\n    reachable_from_s = set()\n    queue = deque()\n    queue.append(s)\n    reachable_from_s.add(s)\n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            if v not in reachable_from_s:\n                queue.append(v)\n                reachable_from_s.add(v)\n    stdout.write(str(n - len(reachable_from_s)) + \"\\n\")\n\nmain()"]