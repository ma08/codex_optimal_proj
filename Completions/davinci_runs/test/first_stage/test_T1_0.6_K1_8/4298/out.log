2022-04-16 20:46:42.460462 """
There are N apple trees in a row. People say that one of them will bear golden apples.
We want to deploy some number of inspectors so that each of these trees will be inspected.
Each inspector will be deployed under one of the trees. For convenience, we will assign numbers from 1 through N to the trees. An inspector deployed under the i-th tree (1 \leq i \leq N) will inspect the trees with numbers between i-D and i+D (inclusive).
Find the minimum number of inspectors that we need to deploy to achieve the objective.

-----Constraints-----
 - All values in input are integers.
 - 1 \leq N \leq 20
 - 1 \leq D \leq 20

-----Input-----
Input is given from Standard Input in the following format:
N D

-----Output-----
Print the minimum number of inspectors that we need to deploy to achieve the objective.

-----Sample Input-----
6 2

-----Sample Output-----
2

We can achieve the objective by, for example, placing an inspector under Tree 3 and Tree 4.
"""
2022-04-16 20:46:42.460482 --------------------------
2022-04-16 20:47:06.060539 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN, D = map(int, input().split())\n\ngolden = 0\nfor i in range(1, N+1):\n    if i % 7 == 0:\n        golden = i\n        break\n\nif golden == 0:\n    print(N)\nelse:\n    if golden-D >= 1 and golden+D <= N:\n        print(2)\n    else:\n        print(1)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, d = map(int, input().split())\n\n# In this problem, we need to find the minimum number of inspectors required.\n# This can be achieved by using the greedy algorithm.\n# The idea is to start from 1 and add an inspector to the next tree which is not covered by the previous inspector.\n# Since we have to cover all the trees, the last inspector should cover the last tree.\n# This can be achieved by adding the last inspector at the tree which is not covered by the previous inspector.\n\n# Initially, we need to cover tree 1.\ncount = 1\n# The tree which is covered by the last inspector.\nlast = 1\n\n# For the ith tree, the range of trees covered by the inspector is [i-d, i+d].\n# We will start from 1 and add an inspector to the next tree which is not covered by the previous inspector.\nfor i in range(2, n+1):\n    # If the tree is not covered by the previous inspector, we will add an inspector.\n    # There are four cases to check:\n    # 1. The tree is not covered by the previous inspector and the next tree is not covered by the last inspector.\n    # 2. The tree is covered by the previous inspector and the next tree is not covered by the last inspector.\n    # 3. The tree is not covered by the previous inspector and the next tree is covered by the last inspector.\n    # 4. The tree is covered by the previous inspector and the next tree is covered by the last inspector.\n    if i-d > last or last < i+d:\n        count += 1\n        last = i+d\n\nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN, D = map(int, sys.stdin.readline().split())\n\nif N <= D:\n    print(1)\nelse:\n    print(numpy.ceil(N / (D * 2 + 1)))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nN, D = map(int, input().split())\n\nprint(N // (2*D + 1) + (1 if N % (2 * D + 1) else 0))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nN, D = map(int, inp"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nn, d = map(int, input().split())\n\ninspectors = 0\nfor i in range(1, n+1):\n    if i + d > n:\n        inspectors += 1\n        break\n    else:\n        i += (2 * d)\n        inspectors += 1\n\nprint(inspectors)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn, d = map(int, input().split())\n\nprint((n + d) // (2 * d + 1))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\nN, D = map(int, input().split())\n\nif N <= 1:\n    print(N)\nelif D == 0:\n    print(1)\nelse:\n    print((N + 2 * D - 1) // (2 * D))"
    }
  ],
  "created": 1650142002,
  "id": "cmpl-4xjbWKUDE2wwd5ANRXZbAcxiqFQmL",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:47:06.060816 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN, D = map(int, input().split())\n\ngolden = 0\nfor i in range(1, N+1):\n    if i % 7 == 0:\n        golden = i\n        break\n\nif golden == 0:\n    print(N)\nelse:\n    if golden-D >= 1 and golden+D <= N:\n        print(2)\n    else:\n        print(1)"
}
2022-04-16 20:47:06.060853 REASON stop
2022-04-16 20:47:06.078990 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, d = map(int, input().split())\n\n# In this problem, we need to find the minimum number of inspectors required.\n# This can be achieved by using the greedy algorithm.\n# The idea is to start from 1 and add an inspector to the next tree which is not covered by the previous inspector.\n# Since we have to cover all the trees, the last inspector should cover the last tree.\n# This can be achieved by adding the last inspector at the tree which is not covered by the previous inspector.\n\n# Initially, we need to cover tree 1.\ncount = 1\n# The tree which is covered by the last inspector.\nlast = 1\n\n# For the ith tree, the range of trees covered by the inspector is [i-d, i+d].\n# We will start from 1 and add an inspector to the next tree which is not covered by the previous inspector.\nfor i in range(2, n+1):\n    # If the tree is not covered by the previous inspector, we will add an inspector.\n    # There are four cases to check:\n    # 1. The tree is not covered by the previous inspector and the next tree is not covered by the last inspector.\n    # 2. The tree is covered by the previous inspector and the next tree is not covered by the last inspector.\n    # 3. The tree is not covered by the previous inspector and the next tree is covered by the last inspector.\n    # 4. The tree is covered by the previous inspector and the next tree is covered by the last inspector.\n    if i-d > last or last < i+d:\n        count += 1\n        last = i+d\n\nprint(count)"
}
2022-04-16 20:47:06.079221 REASON stop
2022-04-16 20:47:06.079906 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN, D = map(int, sys.stdin.readline().split())\n\nif N <= D:\n    print(1)\nelse:\n    print(numpy.ceil(N / (D * 2 + 1)))"
}
2022-04-16 20:47:06.079997 REASON stop
2022-04-16 20:47:06.091766 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nN, D = map(int, input().split())\n\nprint(N // (2*D + 1) + (1 if N % (2 * D + 1) else 0))"
}
2022-04-16 20:47:06.091934 REASON stop
2022-04-16 20:47:06.118332 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nN, D = map(int, inp"
}
2022-04-16 20:47:06.118452 REASON stop
2022-04-16 20:47:06.119393 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nn, d = map(int, input().split())\n\ninspectors = 0\nfor i in range(1, n+1):\n    if i + d > n:\n        inspectors += 1\n        break\n    else:\n        i += (2 * d)\n        inspectors += 1\n\nprint(inspectors)"
}
2022-04-16 20:47:06.119477 REASON stop
2022-04-16 20:47:06.120244 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn, d = map(int, input().split())\n\nprint((n + d) // (2 * d + 1))"
}
2022-04-16 20:47:06.120314 REASON stop
2022-04-16 20:47:06.120900 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\nN, D = map(int, input().split())\n\nif N <= 1:\n    print(N)\nelif D == 0:\n    print(1)\nelse:\n    print((N + 2 * D - 1) // (2 * D))"
}
2022-04-16 20:47:06.120964 REASON stop
