2022-04-16 19:01:45.734625 """
The only difference between easy and hard versions is that you should complete all the projects in easy version but this is not necessary in hard version.

Polycarp is a very famous freelancer. His current rating is $r$ units.

Some very rich customers asked him to complete some projects for their companies. To complete the $i$-th project, Polycarp needs to have at least $a_i$ units of rating; after he completes this project, his rating will change by $b_i$ (his rating will increase or decrease by $b_i$) ($b_i$ can be positive or negative). Polycarp's rating should not fall below zero because then people won't trust such a low rated freelancer.

Polycarp can choose the order in which he completes projects. Furthermore, he can even skip some projects altogether.

To gain more experience (and money, of course) Polycarp wants to choose the subset of projects having maximum possible size and the order in which he will complete them, so he has enough rating before starting each project, and has non-negative rating after completing each project.

Your task is to calculate the maximum possible size of such subset of projects.


-----Input-----

The first line of the input contains two integers $n$ and $r$ ($1 \le n \le 100, 1 \le r \le 30000$) — the number of projects and the initial rating of Polycarp, respectively.

The next $n$ lines contain projects, one per line. The $i$-th project is represented as a pair of integers $a_i$ and $b_i$ ($1 \le a_i \le 30000$, $-300 \le b_i \le 300$) — the rating required to complete the $i$-th project and the rating change after the project completion.


-----Output-----

Print one integer — the size of the maximum possible subset (possibly, empty) of projects Polycarp can choose.


-----Examples-----
Input
3 4
4 6
10 -2
8 -1

Output
3

Input
5 20
45 -6
34 -15
10 34
1 27
40 -45

Output
5

Input
3 2
300 -300
1 299
1 123

Output
3
"""
2022-04-16 19:01:45.734641 --------------------------
2022-04-16 19:02:37.547182 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn, r = map(int, input().split())\n\nprojects = []\n\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\nprojects.sort(key=lambda x: x[0])\n\nfor i in range(1, n):\n    projects[i][0] += projects[i-1][0]\n\ncount = 0\n\nfor i in range(n):\n    if projects[i][0] > r:\n        break\n        \n    count += 1\n    r += projects[i][1]\n    \n    if r < 0:\n        break\n        \nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n#------------------------------------------------------------------------------#\n\ndef polycarp(n, r, projects):\n    # sort the projects by the rating required to complete them\n    projects = sorted(projects, key = lambda x: x[0])\n    \n    # initialize count of projects\n    count = 0\n    \n    # iterate through the projects\n    for project in projects:\n        # if a project cannot be completed, break\n        if project[0] > r: break\n        \n        # add to the count of projects\n        count += 1\n        \n        # update the rating\n        r += project[1]\n        \n    return count\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    n, r = map(int, input().split())\n    projects = [list(map(int, input().split())) for _ in range(n)]\n    print(polycarp(n, r, projects))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nraw_input()\nr = int(raw_input())\nlst = [map(int, raw_input().split()) for x in range(r)]\nlst.sort(key=lambda x: x[0] - x[1])\ncnt = 0\nfor a, b in lst:\n    if r < a:\n        break\n    r += b\n    cnt += 1\nprint cnt"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn, r = [int(x) for x in input().split(' ')]\n\n# this is a classic knapsack problem\n# we can use the same DP table\n# but the only difference is that we will have a new column for each $i$\n# and the new row for each $j$\n# and the last column will be the one we are looking for\n\n\n# a = [int(x) for x in input().split(' ')]\n# b = [int(x) for x in input().split(' ')]\n\n# # create the DP table\n# DP = [[0 for x in range(r+1)] for x in range(n+1)]\n\n# # DP[i][j] means the maximum value we can get with $j$ dollars\n# # and the first $i$ items\n\n# # we will fill the table row by row\n# for i in range(1, n+1):\n#     for j in range(1, r+1):\n#         # if the item is too expensive, then we cannot buy it\n#         if a[i-1] > j:\n#             DP[i][j] = DP[i-1][j]\n#         else:\n#             # else we can either buy it or not\n#             # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n#             # if we don't buy it, then the value will be DP[i-1][j]\n#             # we will choose the maximum value of them\n#             DP[i][j] = max(b[i-1] + DP[i-1][j-a[i-1]], DP[i-1][j])\n\n# print(DP[n][r])\n\n# but the problem with this is that we need to find the maximum value in the last column\n# but this will not be a problem if we only keep the last two rows\n\n# a = [int(x) for x in input().split(' ')]\n# b = [int(x) for x in input().split(' ')]\n\n# # create the DP table\n# DP = [[0 for x in range(r+1)] for x in range(2)]\n\n# # DP[i][j] means the maximum value we can get with $j$ dollars\n# # and the first $i$ items\n\n# # we will fill the table row by row\n# for i in range(1, n+1):\n#     # fill the new row\n#     for j in range(1, r+1):\n#         # if the item is too expensive, then we cannot buy it\n#         if a[i-1] > j:\n#             DP[1][j] = DP[0][j]\n#         else:\n#             # else we can either buy it or not\n#             # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n#             # if we don't buy it, then the value will be DP[i-1][j]\n#             # we will choose the maximum value of them\n#             DP[1][j] = max(b[i-1] + DP[0][j-a[i-1]], DP[0][j])\n#     # copy the new row to the old row\n#     DP[0] = DP[1]\n\n# print(DP[1][r])\n\n# but the problem with this is that we need to find the maximum value in the last column\n# but this will not be a problem if we only keep the last two rows\n# and since we only need the last column to find the answer, we don't even need to keep the last two rows\n# we only need to keep the last column and the current column\n\na = [int(x) for x in input().split(' ')]\nb = [int(x) for x in input().split(' ')]\n\n# create the DP table\nDP = [[0 for x in range(r+1)] for x in range(2)]\n\n# DP[i][j] means the maximum value we can get with $j$ dollars\n# and the first $i$ items\n\n# we will fill the table row by row\nfor i in range(1, n+1):\n    # if the item is too expensive, then we cannot buy it\n    # else we can either buy it or not\n    # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n    # if we don't buy it, then the value will be DP[i-1][j]\n    # we will choose the maximum value of them\n    for j in range(1, r+1):\n        if a[i-1] > j:\n            DP[1][j] = DP[0][j]\n        else:\n            DP[1][j] = max(b[i-1] + DP[0][j-a[i-1]], DP[0][j])\n    # copy the new column to the old column\n    for j in range(1, r+1):\n        DP[0][j] = DP[1][j]\n\nmax_value = 0\nfor j in range(1, r+1):\n    if DP[1][j] > max_value:\n        max_value = DP[1][j]\n\n# print(DP[1][r])\nprint(max_value)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nn, r = list(map(int, input().split()))\nprojects = []\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\ndef get_max_projects(n, r, projects):\n    projects = sorted(projects, key=lambda x: x[0])\n    result = 0\n    for project in projects:\n        if project[0] > r:\n            break\n        r += project[1]\n        result += 1\n    return result\n\nprint(get_max_projects(n, r, projects))"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\n\ndef main():\n    data = sys.stdin.readlines()\n\n    _, r = map(int, data[0].split())\n\n    projects = []\n    for line in data[1:]:\n        ai, bi = map(int, line.split())\n        projects.append((ai, bi))\n\n    projects.sort(key=lambda x: x[0])\n\n    print(len(projects) - len(filter(lambda x: x[0] > r, projects)))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef compute():\n\tn, r = map(int, input().split())\n\ta = [0] * n\n\tb = [0] * n\n\tfor i in range(n):\n\t\ta[i], b[i] = map(int, input().split())\n\t\n\tdp = [None] * (r + 1)\n\tdp[r] = 0\n\tfor i in range(r - 1, -1, -1):\n\t\tdp[i] = dp[i + 1]\n\t\tfor j in range(n):\n\t\t\tif i + a[j] <= r and (dp[i] is None or dp[i + a[j]] + b[j] > dp[i]):\n\t\t\t\tdp[i] = dp[i + a[j]] + b[j]\n\t\n\tans = 0\n\tfor i in range(n):\n\t\tif dp[a[i]] + b[i] > 0:\n\t\t\tans += 1\n\treturn str(ans)\n\n\nif __name__ == \"__main__\":\n\tprint(compute())"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    This problem is solved by a greedy algorithm.\n    It is solved by a greedy algorithm because the optimal solution\n    to a subproblem is always part of the optimal solution to the\n    original problem.\n    \"\"\"\n    n, r = [int(x) for x in input().strip().split()]\n    projects = []\n    for i in range(n):\n        projects.append([int(x) for x in input().strip().split()])\n    projects.sort(key=lambda x: x[0])\n    # print(projects)\n    count = 0\n    for project in projects:\n        if project[1] + r >= project[0]:\n            r += project[1]\n            count += 1\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650135705,
  "id": "cmpl-4xhxxBMvXYzKnPjoBiY8M4qvwLjhK",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 19:02:37.547599 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn, r = map(int, input().split())\n\nprojects = []\n\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\nprojects.sort(key=lambda x: x[0])\n\nfor i in range(1, n):\n    projects[i][0] += projects[i-1][0]\n\ncount = 0\n\nfor i in range(n):\n    if projects[i][0] > r:\n        break\n        \n    count += 1\n    r += projects[i][1]\n    \n    if r < 0:\n        break\n        \nprint(count)"
}
2022-04-16 19:02:37.547663 REASON stop
2022-04-16 19:02:37.570754 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n#------------------------------------------------------------------------------#\n\ndef polycarp(n, r, projects):\n    # sort the projects by the rating required to complete them\n    projects = sorted(projects, key = lambda x: x[0])\n    \n    # initialize count of projects\n    count = 0\n    \n    # iterate through the projects\n    for project in projects:\n        # if a project cannot be completed, break\n        if project[0] > r: break\n        \n        # add to the count of projects\n        count += 1\n        \n        # update the rating\n        r += project[1]\n        \n    return count\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    n, r = map(int, input().split())\n    projects = [list(map(int, input().split())) for _ in range(n)]\n    print(polycarp(n, r, projects))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:02:37.570943 REASON stop
2022-04-16 19:02:37.571533 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nraw_input()\nr = int(raw_input())\nlst = [map(int, raw_input().split()) for x in range(r)]\nlst.sort(key=lambda x: x[0] - x[1])\ncnt = 0\nfor a, b in lst:\n    if r < a:\n        break\n    r += b\n    cnt += 1\nprint cnt"
}
2022-04-16 19:02:37.571611 REASON stop
2022-04-16 19:02:37.590719 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn, r = [int(x) for x in input().split(' ')]\n\n# this is a classic knapsack problem\n# we can use the same DP table\n# but the only difference is that we will have a new column for each $i$\n# and the new row for each $j$\n# and the last column will be the one we are looking for\n\n\n# a = [int(x) for x in input().split(' ')]\n# b = [int(x) for x in input().split(' ')]\n\n# # create the DP table\n# DP = [[0 for x in range(r+1)] for x in range(n+1)]\n\n# # DP[i][j] means the maximum value we can get with $j$ dollars\n# # and the first $i$ items\n\n# # we will fill the table row by row\n# for i in range(1, n+1):\n#     for j in range(1, r+1):\n#         # if the item is too expensive, then we cannot buy it\n#         if a[i-1] > j:\n#             DP[i][j] = DP[i-1][j]\n#         else:\n#             # else we can either buy it or not\n#             # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n#             # if we don't buy it, then the value will be DP[i-1][j]\n#             # we will choose the maximum value of them\n#             DP[i][j] = max(b[i-1] + DP[i-1][j-a[i-1]], DP[i-1][j])\n\n# print(DP[n][r])\n\n# but the problem with this is that we need to find the maximum value in the last column\n# but this will not be a problem if we only keep the last two rows\n\n# a = [int(x) for x in input().split(' ')]\n# b = [int(x) for x in input().split(' ')]\n\n# # create the DP table\n# DP = [[0 for x in range(r+1)] for x in range(2)]\n\n# # DP[i][j] means the maximum value we can get with $j$ dollars\n# # and the first $i$ items\n\n# # we will fill the table row by row\n# for i in range(1, n+1):\n#     # fill the new row\n#     for j in range(1, r+1):\n#         # if the item is too expensive, then we cannot buy it\n#         if a[i-1] > j:\n#             DP[1][j] = DP[0][j]\n#         else:\n#             # else we can either buy it or not\n#             # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n#             # if we don't buy it, then the value will be DP[i-1][j]\n#             # we will choose the maximum value of them\n#             DP[1][j] = max(b[i-1] + DP[0][j-a[i-1]], DP[0][j])\n#     # copy the new row to the old row\n#     DP[0] = DP[1]\n\n# print(DP[1][r])\n\n# but the problem with this is that we need to find the maximum value in the last column\n# but this will not be a problem if we only keep the last two rows\n# and since we only need the last column to find the answer, we don't even need to keep the last two rows\n# we only need to keep the last column and the current column\n\na = [int(x) for x in input().split(' ')]\nb = [int(x) for x in input().split(' ')]\n\n# create the DP table\nDP = [[0 for x in range(r+1)] for x in range(2)]\n\n# DP[i][j] means the maximum value we can get with $j$ dollars\n# and the first $i$ items\n\n# we will fill the table row by row\nfor i in range(1, n+1):\n    # if the item is too expensive, then we cannot buy it\n    # else we can either buy it or not\n    # if we buy it, then the value will be b[i-1] + DP[i-1][j-a[i-1]]\n    # if we don't buy it, then the value will be DP[i-1][j]\n    # we will choose the maximum value of them\n    for j in range(1, r+1):\n        if a[i-1] > j:\n            DP[1][j] = DP[0][j]\n        else:\n            DP[1][j] = max(b[i-1] + DP[0][j-a[i-1]], DP[0][j])\n    # copy the new column to the old column\n    for j in range(1, r+1):\n        DP[0][j] = DP[1][j]\n\nmax_value = 0\nfor j in range(1, r+1):\n    if DP[1][j] > max_value:\n        max_value = DP[1][j]\n\n# print(DP[1][r])\nprint(max_value)"
}
2022-04-16 19:02:37.591006 REASON stop
2022-04-16 19:02:37.600893 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nn, r = list(map(int, input().split()))\nprojects = []\nfor i in range(n):\n    projects.append(list(map(int, input().split())))\n\ndef get_max_projects(n, r, projects):\n    projects = sorted(projects, key=lambda x: x[0])\n    result = 0\n    for project in projects:\n        if project[0] > r:\n            break\n        r += project[1]\n        result += 1\n    return result\n\nprint(get_max_projects(n, r, projects))"
}
2022-04-16 19:02:37.601002 REASON stop
2022-04-16 19:02:37.621334 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\n\ndef main():\n    data = sys.stdin.readlines()\n\n    _, r = map(int, data[0].split())\n\n    projects = []\n    for line in data[1:]:\n        ai, bi = map(int, line.split())\n        projects.append((ai, bi))\n\n    projects.sort(key=lambda x: x[0])\n\n    print(len(projects) - len(filter(lambda x: x[0] > r, projects)))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 19:02:37.621435 REASON stop
2022-04-16 19:02:37.622593 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef compute():\n\tn, r = map(int, input().split())\n\ta = [0] * n\n\tb = [0] * n\n\tfor i in range(n):\n\t\ta[i], b[i] = map(int, input().split())\n\t\n\tdp = [None] * (r + 1)\n\tdp[r] = 0\n\tfor i in range(r - 1, -1, -1):\n\t\tdp[i] = dp[i + 1]\n\t\tfor j in range(n):\n\t\t\tif i + a[j] <= r and (dp[i] is None or dp[i + a[j]] + b[j] > dp[i]):\n\t\t\t\tdp[i] = dp[i + a[j]] + b[j]\n\t\n\tans = 0\n\tfor i in range(n):\n\t\tif dp[a[i]] + b[i] > 0:\n\t\t\tans += 1\n\treturn str(ans)\n\n\nif __name__ == \"__main__\":\n\tprint(compute())"
}
2022-04-16 19:02:37.622691 REASON stop
2022-04-16 19:02:37.625002 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    This problem is solved by a greedy algorithm.\n    It is solved by a greedy algorithm because the optimal solution\n    to a subproblem is always part of the optimal solution to the\n    original problem.\n    \"\"\"\n    n, r = [int(x) for x in input().strip().split()]\n    projects = []\n    for i in range(n):\n        projects.append([int(x) for x in input().strip().split()])\n    projects.sort(key=lambda x: x[0])\n    # print(projects)\n    count = 0\n    for project in projects:\n        if project[1] + r >= project[0]:\n            r += project[1]\n            count += 1\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 19:02:37.625168 REASON stop
