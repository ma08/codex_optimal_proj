2022-04-16 20:34:30.161889 """
We have two permutations P and Q of size N (that is, P and Q are both rearrangements of (1,~2,~...,~N)).
There are N! possible permutations of size N. Among them, let P and Q be the a-th and b-th lexicographically smallest permutations, respectively. Find |a - b|.

-----Notes-----
For two sequences X and Y, X is said to be lexicographically smaller than Y if and only if there exists an integer k such that X_i = Y_i~(1 \leq i < k) and X_k < Y_k.

-----Constraints-----
 - 2 \leq N \leq 8
 - P and Q are permutations of size N.

-----Input-----
Input is given from Standard Input in the following format:
N
P_1 P_2 ... P_N
Q_1 Q_2 ... Q_N

-----Output-----
Print |a - b|.

-----Sample Input-----
3
1 3 2
3 1 2

-----Sample Output-----
3

There are 6 permutations of size 3: (1,~2,~3), (1,~3,~2), (2,~1,~3), (2,~3,~1), (3,~1,~2), and (3,~2,~1). Among them, (1,~3,~2) and (3,~1,~2) come 2-nd and 5-th in lexicographical order, so the answer is |2 - 5| = 3.
"""
2022-04-16 20:34:30.161917 --------------------------
2022-04-16 20:34:51.540262 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    import sys\n    N = int(sys.stdin.readline())\n    P = list(map(int, sys.stdin.readline().split()))\n    Q = list(map(int, sys.stdin.readline().split()))\n\n    permutations = []\n    for i in range(N):\n        permutations.append(i+1)\n    permutations = list(set(permutations))\n\n    # find a\n    a = 0\n    for i in range(N):\n        a += permutations.index(P[i]) * factorial(N-1-i)\n        permutations.remove(P[i])\n    a += 1\n\n    # find b\n    permutations = []\n    for i in range(N):\n        permutations.append(i+1)\n    permutations = list(set(permutations))\n    b = 0\n    for i in range(N):\n        b += permutations.index(Q[i]) * factorial(N-1-i)\n        permutations.remove(Q[i])\n    b += 1\n\n    print(abs(a-b))\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef factorial(n):\n    return factorial(n-1)*n if n > 1 else 1\n\ndef permutation_to_n(p,n):\n    if n <= 1:\n        return 0\n    i = 0\n    while p[i] != 1:\n        i += 1\n    b = factorial(n-1) * i\n    return b + permutation_to_n(p[:i]+p[i+1:],n-1)\n\ndef main():\n    n = int(input())\n    p = list(map(int,input().split()))\n    q = list(map(int,input().split()))\n    print(abs(permutation_to_n(p,n)-permutation_to_n(q,n)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# permutations of size N\nperm_size_N = factorial(N)\n\n# Find the index of P in the permutations of size N\np_index = 0\nfor i in range(N):\n    perm_size_N_i = perm_size_N // (N - i)\n    p_index += perm_size_N_i * P[i]\n    perm_size_N = perm_size_N_i\n    p_index -= 1\n\n# Find the index of Q in the permutations of size N\nq_index = 0\nfor i in range(N):\n    perm_size_N_i = perm_size_N // (N - i)\n    q_index += perm_size_N_i * Q[i]\n    perm_size_N = perm_size_N_i\n    q_index -= 1\n\nprint(abs(p_index - q_index))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n# \u914d\u5217\u3092\u4f5c\u6210\narr = []\nfor i in range(n):\n    arr.append(i+1)\n\n# \u914d\u5217\u3092\u5909\u63db\ndef trans(arr):\n    res = []\n    for i in range(n):\n        res.append(arr[i] - 1)\n    return res\n\n# p = [0, 1, 2]\n# q = [1, 0, 2]\n\n# \u9806\u5217\u3092\u30ab\u30a6\u30f3\u30c8\ncount = 0\nwhile(True):\n    # print(arr)\n    count += 1\n    if arr == p:\n        a = count\n    elif arr == q:\n        b = count\n    if count == n:\n        break\n    # \u9806\u5217\u3092\u6c42\u3081\u308b\n    i = n - 1\n    while(arr[i-1] >= arr[i]):\n        i -= 1\n    j = n - 1\n    while(arr[i-1] >= arr[j]):\n        j -= 1\n    # print(i, j)\n    arr[i-1], arr[j] = arr[j], arr[i-1]\n    # print(arr)\n    arr[i:] = arr[i:][::-1]\n\nprint(abs(a-b))"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport itertools\n\ndef main():\n    N = int(input())\n    P = tuple(map(int, input().split()))\n    Q = tuple(map(int, input().split()))\n\n    # N! possible permutations\n    permutations = list(itertools.permutations(range(1, N+1)))\n\n    # find a and b\n    a = permutations.index(P)\n    b = permutations.index(Q)\n\n    print(abs(a - b))\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# My answer:\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\ndef fact_perm(n):\n    if n == 0 or n == 1:\n        return 0\n    else:\n        return n*fact_perm(n-1)\n\ndef find_perm_pos(n, p):\n    perm_pos = 0\n    for i in range(n):\n        smaller = 0\n        for j in range(i+1, n):\n            if p[i] > p[j]:\n                smaller += 1\n        perm_pos += (fact_perm(n-i-1) * smaller)\n    return perm_pos\n\ndef main(n, p, q):\n    p_pos = find_perm_pos(n, p)\n    q_pos = find_perm_pos(n, q)\n    return abs(p_pos-q_pos)\n\nprint(main(n, p, q))\n\n# Reference answer:\nimport itertools\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\nperm = list(itertools.permutations(range(1, N+1)))\nprint(abs(perm.index(P) - perm.index(Q)))"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport itertools\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\npermutations = list(itertools.permutations([i for i in range(1, n+1)]))\n\np_index = permutations.index(tuple(p))\nq_index = permutations.index(tuple(q))\n\nprint(abs(p_index - q_index))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    p = list(map(int,input().split()))\n    q = list(map(int,input().split()))\n    cnt = 0\n    ptup = ()\n    qtup = ()\n    for i in p:\n        ptup += (i,)\n    for j in q:\n        qtup += (j,)\n    perms = list(itertools.permutations(range(1,n+1)))\n    for perm in perms:\n        cnt += 1\n        if perm == ptup:\n            a = cnt\n        if perm == qtup:\n            b = cnt\n    print(abs(a-b))\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650141270,
  "id": "cmpl-4xjPiEm54fpsPuv5ipzJqRkUBfX9h",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:34:51.540583 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    import sys\n    N = int(sys.stdin.readline())\n    P = list(map(int, sys.stdin.readline().split()))\n    Q = list(map(int, sys.stdin.readline().split()))\n\n    permutations = []\n    for i in range(N):\n        permutations.append(i+1)\n    permutations = list(set(permutations))\n\n    # find a\n    a = 0\n    for i in range(N):\n        a += permutations.index(P[i]) * factorial(N-1-i)\n        permutations.remove(P[i])\n    a += 1\n\n    # find b\n    permutations = []\n    for i in range(N):\n        permutations.append(i+1)\n    permutations = list(set(permutations))\n    b = 0\n    for i in range(N):\n        b += permutations.index(Q[i]) * factorial(N-1-i)\n        permutations.remove(Q[i])\n    b += 1\n\n    print(abs(a-b))\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:34:51.540623 REASON stop
2022-04-16 20:34:51.565783 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef factorial(n):\n    return factorial(n-1)*n if n > 1 else 1\n\ndef permutation_to_n(p,n):\n    if n <= 1:\n        return 0\n    i = 0\n    while p[i] != 1:\n        i += 1\n    b = factorial(n-1) * i\n    return b + permutation_to_n(p[:i]+p[i+1:],n-1)\n\ndef main():\n    n = int(input())\n    p = list(map(int,input().split()))\n    q = list(map(int,input().split()))\n    print(abs(permutation_to_n(p,n)-permutation_to_n(q,n)))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:34:51.565994 REASON stop
2022-04-16 20:34:51.566470 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# permutations of size N\nperm_size_N = factorial(N)\n\n# Find the index of P in the permutations of size N\np_index = 0\nfor i in range(N):\n    perm_size_N_i = perm_size_N // (N - i)\n    p_index += perm_size_N_i * P[i]\n    perm_size_N = perm_size_N_i\n    p_index -= 1\n\n# Find the index of Q in the permutations of size N\nq_index = 0\nfor i in range(N):\n    perm_size_N_i = perm_size_N // (N - i)\n    q_index += perm_size_N_i * Q[i]\n    perm_size_N = perm_size_N_i\n    q_index -= 1\n\nprint(abs(p_index - q_index))"
}
2022-04-16 20:34:51.566535 REASON stop
2022-04-16 20:34:51.586659 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n# \u914d\u5217\u3092\u4f5c\u6210\narr = []\nfor i in range(n):\n    arr.append(i+1)\n\n# \u914d\u5217\u3092\u5909\u63db\ndef trans(arr):\n    res = []\n    for i in range(n):\n        res.append(arr[i] - 1)\n    return res\n\n# p = [0, 1, 2]\n# q = [1, 0, 2]\n\n# \u9806\u5217\u3092\u30ab\u30a6\u30f3\u30c8\ncount = 0\nwhile(True):\n    # print(arr)\n    count += 1\n    if arr == p:\n        a = count\n    elif arr == q:\n        b = count\n    if count == n:\n        break\n    # \u9806\u5217\u3092\u6c42\u3081\u308b\n    i = n - 1\n    while(arr[i-1] >= arr[i]):\n        i -= 1\n    j = n - 1\n    while(arr[i-1] >= arr[j]):\n        j -= 1\n    # print(i, j)\n    arr[i-1], arr[j] = arr[j], arr[i-1]\n    # print(arr)\n    arr[i:] = arr[i:][::-1]\n\nprint(abs(a-b))"
}
2022-04-16 20:34:51.586774 REASON stop
2022-04-16 20:34:51.599483 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport itertools\n\ndef main():\n    N = int(input())\n    P = tuple(map(int, input().split()))\n    Q = tuple(map(int, input().split()))\n\n    # N! possible permutations\n    permutations = list(itertools.permutations(range(1, N+1)))\n\n    # find a and b\n    a = permutations.index(P)\n    b = permutations.index(Q)\n\n    print(abs(a - b))\n\nmain()"
}
2022-04-16 20:34:51.599599 REASON stop
2022-04-16 20:34:51.600546 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# My answer:\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\ndef fact_perm(n):\n    if n == 0 or n == 1:\n        return 0\n    else:\n        return n*fact_perm(n-1)\n\ndef find_perm_pos(n, p):\n    perm_pos = 0\n    for i in range(n):\n        smaller = 0\n        for j in range(i+1, n):\n            if p[i] > p[j]:\n                smaller += 1\n        perm_pos += (fact_perm(n-i-1) * smaller)\n    return perm_pos\n\ndef main(n, p, q):\n    p_pos = find_perm_pos(n, p)\n    q_pos = find_perm_pos(n, q)\n    return abs(p_pos-q_pos)\n\nprint(main(n, p, q))\n\n# Reference answer:\nimport itertools\n\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\nperm = list(itertools.permutations(range(1, N+1)))\nprint(abs(perm.index(P) - perm.index(Q)))"
}
2022-04-16 20:34:51.600648 REASON stop
2022-04-16 20:34:51.601390 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport itertools\n\nn = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\npermutations = list(itertools.permutations([i for i in range(1, n+1)]))\n\np_index = permutations.index(tuple(p))\nq_index = permutations.index(tuple(q))\n\nprint(abs(p_index - q_index))"
}
2022-04-16 20:34:51.601484 REASON stop
2022-04-16 20:34:51.602644 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    p = list(map(int,input().split()))\n    q = list(map(int,input().split()))\n    cnt = 0\n    ptup = ()\n    qtup = ()\n    for i in p:\n        ptup += (i,)\n    for j in q:\n        qtup += (j,)\n    perms = list(itertools.permutations(range(1,n+1)))\n    for perm in perms:\n        cnt += 1\n        if perm == ptup:\n            a = cnt\n        if perm == qtup:\n            b = cnt\n    print(abs(a-b))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:34:51.602725 REASON stop
