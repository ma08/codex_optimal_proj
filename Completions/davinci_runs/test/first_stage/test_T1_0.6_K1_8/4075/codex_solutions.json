["\n\nimport numpy as np\n\n# Input\nN, M = map(int, input().split())\nS = np.zeros((M, N), dtype=int)\nP = np.zeros(M, dtype=int)\n\nfor i in range(M):\n    K = list(map(int, input().split()))\n    S[i, K[1:]-1] = 1\nP = list(map(int, input().split()))\n\n# Calculate\nans = 0\nfor i in range(2**N):\n    state = np.array([int(j) for j in format(i, '0{}b'.format(N))])\n    c = np.count_nonzero(np.dot(S, state) % 2 == P)\n    if c == M:\n        ans += 1\n\n# Output\nprint(ans)", "\n\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef main():\n\tN, M = map(int, input().split())\n\tS = [0] * N\n\tB = [0] * M\n\tfor i in range(M):\n\t\tS[i] = list(map(int, input().split()))\n\t\tS[i] = S[i][1:]\n\tP = list(map(int, input().split()))\n\n\tcount = 0\n\tfor v in combinations(range(N), M):\n\t\tfor i in range(M):\n\t\t\tB[i] = 0\n\t\t\tfor j in S[i]:\n\t\t\t\tif j in v:\n\t\t\t\t\tB[i] += 1\n\t\t\tB[i] = B[i] % 2\n\t\t\tif B[i] != P[i]:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcount += 1\n\n\tprint(count)\n\nif __name__ == '__main__':\n\tmain()", "\n\n\"\"\"\nAlgorithm:\n    - We can represent a combination of states of the switches as a binary number:\n        - a_1 a_2 ... a_N\n        - a_i is 0 when the state of Switch i is \"off\", and 1 when it is \"on\".\n        - The number means that the states of the switches are as follows:\n            - Switch 1 is \"off\"\n            - Switch 2 is \"on\"\n            - ...\n            - Switch N is \"off\"\n    - In general, a combination of states that light all the bulbs has the following property:\n        - If Bulb i is lighted when there is an even number of switches that are \"on\" among Switch s_{i1}, s_{i2}, ..., and s_{ik_i}, then the number of switches that are \"on\" among these switches is congruent to 0 modulo 2.\n        - If Bulb i is lighted when there is an odd number of switches that are \"on\" among Switch s_{i1}, s_{i2}, ..., and s_{ik_i}, then the number of switches that are \"on\" among these switches is congruent to 1 modulo 2.\n    - So we should count the number of combinations of states of the switches that satisfy the conditions for all the bulbs.\n    - For example, for the input in the problem statement, the four combinations of states of (Switch 1, Switch 2) are as follows:\n        - (on, on): Bulb 1 is lighted, and Bulb 2 is lighted.\n        - (on, off): Bulb 1 is lighted, and Bulb 2 is not lighted.\n        - (off, on): Bulb 1 is not lighted, and Bulb 2 is lighted.\n        - (off, off): Bulb 1 is not lighted, and Bulb 2 is not lighted.\n    - So we can count the number of combinations of states of the switches that satisfy the conditions for all the bulbs as follows:\n        - For each bulb, check if the number of switches that are \"on\" among the switches connected to the bulb is congruent to the parity p_i modulo 2.\n        - If this is true for all the bulbs, increment the count.\n    - We can represent a combination of states of the switches as a binary number as follows:\n        - if the state of Switch i is \"on\", we add 2^(i-1) to the number.\n        - if the state of Switch i is \"off\", we do nothing.\n        - For example, the number that represents the combination (on, on) is 2^0 + 2^1 = 3.\n\"\"\"\n\nimport sys\nfrom math import pow\nfrom typing import List\n\ndef count_combinations_of_states_of_switches(N: int, M: int, connections: List[List[int]], parities: List[int]) -> int:\n    \"\"\"\n    >>> count_combinations_of_states_of_switches(2, 2, [[2, 1, 2], [1, 2]], [0, 1])\n    1\n    \"\"\"\n    count = 0\n    for i in range(pow(2, N)):\n        light_all_bulbs = True\n        for j in range(M):\n            parity = parities[j]\n            number_of_switches_that_are_on = 0\n            for k in range(len(connections[j])):\n                if i & (1 << (connections[j][k] - 1)) != 0:\n                    number_of_switches_that_are_on += 1\n            if number_of_switches_that_are_on % 2 != parity:\n                light_all_bulbs = False\n                break\n        if light_all_bulbs:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    N, M = map(int, sys.stdin.readline().rstrip().split())\n    connections = []\n    for _ in range(M):\n        connections.append(list(map(int, sys.stdin.readline().rstrip().split())))\n        connections[-1] = connections[-1][1:]\n    parities = list(map(int, sys.stdin.readline().rstrip().split()))\n    print(count_combinations_of_states_of_switches(N, M, connections, parities))", "\n\nN, M = map(int, input().split())\n\n# \u5404\u96fb\u7403\u306e\u63a5\u7d9a\u5148\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u96c6\u5408(set)\u306e\u30ea\u30b9\u30c8\nbulbs = [set() for _ in range(M)]\n# \u96fb\u7403i\u304c\u3064\u3044\u3066\u3044\u308b\u304b\u5426\u304b\u306e\u30ea\u30b9\u30c8\nis_lighted = [False] * M\n\n# \u96fb\u7403i\u306e\u63a5\u7d9a\u5148\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u96c6\u5408(set)\u3092\u4f5c\u6210\nfor i in range(M):\n    k = int(input().split()[0])\n    bulbs[i] = set(map(int, input().split()[1:]))\n\n# \u96fb\u7403i\u304c\u3064\u3044\u3066\u3044\u308b\u304b\u5426\u304b\u306e\u30ea\u30b9\u30c8\u3092\u4f5c\u6210\nP = list(map(int, input().split()))\nfor i in range(M):\n    for j in bulbs[i]:\n        P[i] ^= (j % 2)\n    is_lighted[i] = (P[i] == 1)\n\n# \u96fb\u7403i\u304c\u3064\u3044\u3066\u3044\u308b\u96fb\u7403\u306e\u96c6\u5408(set)\u306e\u30ea\u30b9\u30c8\nlighted_bulbs = [set() for _ in range(N)]\n# \u96fb\u7403i\u304c\u3064\u3044\u3066\u3044\u308b\u96fb\u7403\u306e\u96c6\u5408(set)\u3092\u4f5c\u6210\nfor i in range(M):\n    if is_lighted[i]:\n        for j in bulbs[i]:\n            lighted_bulbs[j - 1].add(i)\n\n# \u5404\u30b9\u30a4\u30c3\u30c1\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u3092on\u306b\u3059\u308b\u304b\u5426\u304b\u3092\u6c7a\u3081\u308b\ns = [False] * N\nfor i in range(N):\n    # \u5947\u6570\u306e\u30b9\u30a4\u30c3\u30c1\u306b\u3064\u3044\u3066\u306f\u3001\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u3092on\u306b\u3059\u308c\u3070\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u306b\u63a5\u7d9a\u3055\u308c\u305f\u96fb\u7403\u304c\u3064\u304f\n    if (i + 1) % 2 == 1:\n        s[i] = True\n    # \u5076\u6570\u306e\u30b9\u30a4\u30c3\u30c1\u306b\u3064\u3044\u3066\u306f\u3001\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u3092on\u306b\u3057\u3066\u3082\u3057\u306a\u304f\u3066\u3082\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u306b\u63a5\u7d9a\u3055\u308c\u305f\u96fb\u7403\u304c\u3064\u304f\n    else:\n        # \u305d\u306e\u30b9\u30a4\u30c3\u30c1\u3092on\u306b\u3059\u308b\u3068\u3001\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u306b\u63a5\u7d9a\u3055\u308c\u305f\u96fb\u7403\u306e\u4e2d\u306b\n        # \u305d\u306e\u30b9\u30a4\u30c3\u30c1\u306b\u63a5\u7d9a\u3055\u308c\u3066\u3044\u306a\u3044\u96fb\u7403\u304c\u3064\u3044\u3066\u3044\u308b\u96fb\u7403\u304c\u3042\u308b\u5834\u5408\u306f\u3001\n        # \u305d\u306e\u30b9\u30a4\u30c3\u30c1\u3092on\u306b\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n        for j in lighted_bulbs[i]:\n            if not bulbs[j].issuperset(set([i + 1])):\n                s[i] = True\n                break\n\n# \u5404\u30b9\u30a4\u30c3\u30c1\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u3092on\u306b\u3057\u3066\u3044\u308b\u304b\u5426\u304b\u3067\u96fb\u7403\u304c\u3064\u304f\u304b\u5426\u304b\u3092\u5224\u5b9a\nfor i in range(M):\n    for j in bulbs[i]:\n        is_lighted[i] ^= s[j - 1]\n\n# \u5168\u3066\u306e\u96fb\u7403\u304c\u3064\u3044\u3066\u3044\u308b\u5834\u5408\u3001\u305d\u306e\u96fb\u7403\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\u30921\u5897\u3084\u3059\ncnt = 1 if all(is_lighted) else 0\n\n# \u7b54\u3048\u3092\u51fa\u529b\nprint(cnt)", "\n\nimport copy\n\n\ndef bit_search(N, bulbs, switches):\n    # N: number of switches\n    # bulbs: list of bulbs\n    # switches: list of switches\n    # bit search\n    bits = 2 ** N\n    for bit in range(bits):\n        # bit: binary value\n        # bit_str: bit in string format\n        bit_str = str(bin(bit)[2:]).zfill(N)\n        # check if the pattern of bit_str lights all the bulbs\n        if check_bulbs(bit_str, bulbs, switches):\n            return 1\n    return 0\n\n\ndef check_bulbs(bit_str, bulbs, switches):\n    # bit_str: binary value in string format\n    # bulbs: list of bulbs\n    # switches: list of switches\n    # check if the pattern of bit_str lights all the bulbs\n    for i in range(len(bulbs)):\n        # k: number of switches that are connected to bulb i\n        k = bulbs[i][0]\n        # connected_switches: list of switches that are connected to bulb i\n        connected_switches = copy.deepcopy(bulbs[i][1:k+1])\n        # count the number of switches that are \"on\"\n        cnt = 0\n        for j in range(len(connected_switches)):\n            # check if switch j is \"on\"\n            if bit_str[switches[connected_switches[j] - 1][0] - 1] == \"1\":\n                cnt += 1\n        # check if the number of switches that are \"on\" is congruent to p_i modulo 2\n        if cnt % 2 != bulbs[i][-1]:\n            return False\n    return True\n\n\ndef main():\n    # get input\n    N, M = map(int, input().split())\n    bulbs = [[int(i) for i in input().split()] for j in range(M)]\n    switches = [[i, 0] for i in range(1, N+1)]\n    # execute bit search\n    print(bit_search(N, bulbs, switches))\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport itertools\n\ndef main():\n    n, m = map(int, input().split())\n    bulbs = []\n    for _ in range(m):\n        k, *bulbs_to_switch = map(int, input().split())\n        bulbs.append(bulbs_to_switch)\n    p = list(map(int, input().split()))\n    switches = [0] * n\n    count = 0\n    for i in range(2 ** n):\n        for j in range(n):\n            switches[j] = 0\n        for j in range(n):\n            switches[n - j - 1] = i % 2\n            i = i // 2\n        #print(i, switches)\n        flag = True\n        for j in range(m):\n            num = 0\n            for k in range(len(bulbs[j])):\n                #print(j, bulbs[j][k], switches[bulbs[j][k] - 1])\n                num += switches[bulbs[j][k] - 1]\n            #print(j, p[j], num % 2)\n            if p[j] != num % 2:\n                flag = False\n                break\n        if flag:\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()", "\n\nfrom sys import stdin\n\nN, M = map(int, stdin.readline().rstrip().split())\n\nans = 0\nfor _ in range(M):\n    k, *s = list(map(int, stdin.readline().rstrip().split()))\n    if k % 2 == 0:\n        ans += 2 ** (N - k)\n    else:\n        ans -= 2 ** (N - k)\nprint(ans)", "\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# bit\u5168\u63a2\u7d22\ndef main():\n    n, m = map(int, input().split())\n    s = [[] for _ in range(m)]\n    p = []\n    for i in range(m):\n        si = list(map(int, input().split()))\n        s[i] = si[1:]\n        p.append(si[0] % 2)\n\n    # \u7d44\u307f\u5408\u308f\u305b\u306e\u6570\n    ans = 0\n    for i in range(2 ** n):\n        ok = True\n        # \u30d3\u30c3\u30c8\u6f14\u7b97\u3067\u72b6\u614b\u3092\u78ba\u8a8d\u3059\u308b\n        for j in range(m):\n            cnt = 0\n            for k in range(len(s[j])):\n                if ((i >> (s[j][k]-1)) & 1):\n                    cnt += 1\n            if cnt % 2 != p[j]:\n                ok = False\n        if ok:\n            ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"]