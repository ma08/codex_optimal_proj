["\n\ndef main():\n\tpass\n\nif __name__ == '__main__':\n\tmain()", "\nimport heapq\n\nn, m = map(int, input().split())\na = [int(x) for x in input().split()]\n\n# key = (x, y), value = cost\noffers = {}\n\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    x -= 1\n    y -= 1\n    if (x, y) in offers and w > offers[(x, y)]:\n        continue\n    offers[(x, y)] = w\n    if (y, x) in offers and w > offers[(y, x)]:\n        continue\n    offers[(y, x)] = w\n\nst = set()\n\n# nodes that have been visited\nvisited = set()\n\n# key = cost, value = node\npq = []\n\n# key = node, value = cost\ncosts = {}\n\nfor i in range(n):\n    st.add(i)\n    heapq.heappush(pq, (a[i], i))\n    costs[i] = a[i]\n\nres = 0\nwhile len(st) != 1:\n    cost, node = heapq.heappop(pq)\n    if node in visited:\n        continue\n    visited.add(node)\n    res += cost\n    st.remove(node)\n    for neighbor in st:\n        if (node, neighbor) in offers:\n            costs[neighbor] = min(costs[neighbor], offers[(node, neighbor)])\n        else:\n            costs[neighbor] = min(costs[neighbor], a[node] + a[neighbor])\n        heapq.heappush(pq, (costs[neighbor], neighbor))\n\nprint(res)", "\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        offers.append((x, y, w))\n\n    def get_component(x):\n        if x == parent[x]:\n            return x\n        parent[x] = get_component(parent[x])\n        return parent[x]\n\n    def merge(x, y):\n        x = get_component(x)\n        y = get_component(y)\n        if x != y:\n            if rank[x] < rank[y]:\n                x, y = y, x\n            parent[y] = x\n            size[x] += size[y]\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n    parent = list(range(1, n + 1))\n    rank = [0] * (n + 1)\n    size = [1] * (n + 1)\n    cost = 0\n    for x, y, w in offers:\n        if get_component(x) != get_component(y):\n            merge(x, y)\n            cost += w\n    for x in range(1, n + 1):\n        for y in range(x + 1, n + 1):\n            if get_component(x) != get_component(y):\n                merge(x, y)\n                cost += a[x - 1] + a[y - 1]\n    print(cost)\n\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef get_min_cost(n, m, a, offers):\n\n    d = {}\n    for offer in offers:\n        if offer[0] not in d:\n            d[offer[0]] = {}\n        d[offer[0]][offer[1]] = offer[2]\n\n    total_cost = 0\n    visited = [False] * n\n    min_cost = [sys.maxsize] * n\n    min_cost[0] = a[0]\n\n    while False in visited:\n        min_index = -1\n        min_value = sys.maxsize\n        for i in range(n):\n            if not visited[i] and min_cost[i] < min_value:\n                min_index = i\n                min_value = min_cost[i]\n        visited[min_index] = True\n        total_cost += min_value\n        for i in range(n):\n            if i != min_index:\n                if i in d and min_index in d[i]:\n                    min_cost[i] = min(min_cost[i], d[i][min_index])\n                else:\n                    min_cost[i] = min(min_cost[i], a[i] + a[min_index])\n\n    return total_cost\n\n\n\ndef main():\n    n, m = [int(x) for x in input().strip().split()]\n    a = [int(x) for x in input().strip().split()]\n    offers = []\n    for i in range(m):\n        x, y, w = [int(x) for x in input().strip().split()]\n        offers.append((x - 1, y - 1, w))\n    print(get_min_cost(n, m, a, offers))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef find_set(x):\n    if parent[x] != x:\n        parent[x] = find_set(parent[x])\n    return parent[x]\n\n\ndef union(x, y):\n    parent[find_set(x)] = find_set(y)\n\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    parent = list(range(n + 1))\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        offers.append((x, y, w))\n    offers.sort(key=lambda x: x[2])\n    ans = 0\n    for x, y, w in offers:\n        if find_set(x) != find_set(y):\n            union(x, y)\n            ans += w\n        else:\n            ans += a[x - 1] + a[y - 1]\n    for i in range(1, n + 1):\n        if find_set(i) != find_set(1):\n            ans += a[i - 1]\n    print(ans)", "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nd = {}\nfor i in range(m):\n    x, y, w = map(int, input().split())\n    x -= 1\n    y -= 1\n    if x > y:\n        x, y = y, x\n    if (x, y) not in d:\n        d[(x, y)] = w\n    else:\n        d[(x, y)] = min(d[(x, y)], w)\n\nres = 0\nfor i in range(n):\n    res += a[i]\n\nl = list(d.keys())\nl.sort()\n\nfor i in range(m):\n    x, y = l[i]\n    if x != 0:\n        res += d[(x, y)]\n        continue\n    for j in range(i + 1, m):\n        xx, yy = l[j]\n        if yy == 0:\n            continue\n        if yy == x + 1:\n            res += d[(xx, yy)]\n            l[j] = (0, yy)\n        else:\n            break\n\nprint(res)", "\n\n\nn, m = map(int, input().split())\n\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    edges.append((w, x, y))\n\nedges.sort()\n\nparent = list(range(n))\nsize = [1] * n\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    root_x = find(x)\n    root_y = find(y)\n\n    if root_x == root_y:\n        return False\n    if size[root_x] > size[root_y]:\n        root_x, root_y = root_y, root_x\n    \n    parent[root_x] = root_y\n    size[root_y] += size[root_x]\n    return True\n\ndef kruskal():\n    cost = 0\n    for w, x, y in edges:\n        if union(x - 1, y - 1):\n            cost += w\n    return cost\n\ndef prim():\n    parent = list(range(n))\n    weight = [float('inf')] * n\n    weight[0] = 0\n\n    cost = 0\n\n    for _ in range(n):\n        min_w = float('inf')\n        min_v = -1\n        for i in range(n):\n            if weight[i] < min_w:\n                min_w = weight[i]\n                min_v = i\n        if min_v == -1:\n            break\n        cost += weight[min_v]\n        weight[min_v] = float('inf')\n        for i in range(n):\n            if i == min_v:\n                continue\n            if find(i) != find(min_v):\n                union(i, min_v)\n                weight[i] = min(weight[i], a[i] + a[min_v])\n    return cost\n\nprint(prim())"]