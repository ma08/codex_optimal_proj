["\n\n# SOLUTION\n\nn = int(input())\ns = list(input())\nt = list(input())\n\nif s == t:\n    print(0)\n    exit()\n\n\ndef swap(lst, i, j):\n    lst[i], lst[j] = lst[j], lst[i]\n    return lst\n\n\ndef find_swap_points(s, t):\n    swap_points = []\n    i = 0\n    while i < n:\n        if s[i] != t[i]:\n            for j in range(i + 1, n):\n                if s[j] == t[i]:\n                    swap_points.append(j)\n                    s = swap(s, i, j)\n                    break\n        i += 1\n    return swap_points\n\n\ndef find_swap_points2(s, t):\n    swap_points = []\n    i = 0\n    while i < n:\n        if s[i] != t[i]:\n            j = i + 1\n            while j < n:\n                if s[j] == t[i]:\n                    swap_points.append(j)\n                    s = swap(s, i, j)\n                    break\n                j += 1\n        i += 1\n    return swap_points\n\n\nswap_points = find_swap_points(s, t)\n\nif s != t:\n    swap_points = find_swap_points2(s, t)\n\nif s != t:\n    print(-1)\nelse:\n    print(len(swap_points))\n    print(*swap_points)", "\n\nfrom collections import defaultdict\n\ndef get_neighbors(i, n):\n    if i == 0:\n        return [1]\n    elif i == n-1:\n        return [i-1]\n    else:\n        return [i-1, i+1]\n\ndef dfs_path(i, j, n, m, graph, visited, path):\n    visited[i] = True\n    path.append(i)\n\n    if i == j:\n        return path\n\n    for neighbor in get_neighbors(i, n):\n        if not visited[neighbor] and neighbor in graph:\n            new_path = dfs_path(neighbor, j, n, m, graph, visited, path)\n            if new_path:\n                return new_path\n\n    path.pop(-1)\n    return None\n\ndef find_path(i, j, n, m, graph):\n    return dfs_path(i, j, n, m, graph, visited=[False]*n, path=[])\n\ndef find_paths(n, m, graph):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            path = find_path(i, j, n, m, graph)\n            if path:\n                paths.append(path)\n    return paths\n\ndef get_paths(n, s, t):\n    graph = defaultdict(list)\n    for i in range(n):\n        if s[i] != t[i]:\n            graph[s[i]].append(t[i])\n    return find_paths(n, m=len(graph), graph=graph)\n\ndef main():\n    n = int(input())\n    s = input()\n    t = input()\n    paths = get_paths(n, s, t)\n    if paths:\n        print(len(paths))\n        for path in paths:\n            for i in range(1, len(path)):\n                print(path[i]-1, end=\" \")\n            print()\n    else:\n        print(-1)\n\n\nif __name__ == '__main__':\n    main()", "\n\n\nfrom collections import deque\n\n\ndef get_swap_moves(s, t):\n    if s == t:\n        return 0\n    if len(s) != len(t):\n        return -1\n    if sorted(s) != sorted(t):\n        return -1\n\n    def get_neighbors(index):\n        if index > 0:\n            yield index - 1\n        if index < len(s) - 1:\n            yield index + 1\n\n    def swap(index):\n        s[index], s[index + 1] = s[index + 1], s[index]\n\n    Q = deque([(s, 0, [])])\n    seen = set()\n    while Q:\n        s, moves, swap_moves = Q.popleft()\n        if s == t:\n            return moves, swap_moves\n\n        for index, (c1, c2) in enumerate(zip(s, t)):\n            if c1 != c2:\n                for neighbor in get_neighbors(index):\n                    swap(neighbor)\n                    new_s = tuple(s)\n                    swap(neighbor)\n                    if new_s in seen:\n                        continue\n                    seen.add(new_s)\n                    Q.append((list(new_s), moves + 1, swap_moves + [neighbor + 1]))\n\n    return -1\n\n\nif __name__ == '__main__':\n    n = int(input())\n    s = list(input())\n    t = list(input())\n    swap_moves = get_swap_moves(s, t)\n    if swap_moves == -1:\n        print(swap_moves)\n    else:\n        moves, swap_moves = swap_moves\n        print(moves)\n        print(*swap_moves)", "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\ns = input()\nt = input()\n\nif s == t:\n    print(\"0\")\nelse:\n    print(\"-1\")", "\n\n#------------------------------------------------------------------------------#\n\ndef solve(n, s, t):\n    \"\"\"\n    Solves the problem.\n    \n    Parameters:\n        n: \n        s: \n        t: \n        \n    Returns:\n        The solution as a string.\n    \"\"\"\n    # Check if the input is valid\n    if not n in range(1, 51):\n        return '-1'\n    for i in range(n):\n        if not s[i] in ascii_lowercase or not t[i] in ascii_lowercase:\n            return '-1'\n    \n    # If the two strings are equal, no moves are needed\n    if s == t:\n        return '0\\n'\n    \n    # Solve the problem\n    return '\\n'.join(str(i) for i in range(1, n))\n\n#------------------------------------------------------------------------------#\n\ndef read_input():\n    \"\"\"\n    Reads the input and returns it.\n    \n    Returns:\n        The input as a list of strings.\n    \"\"\"\n    n = int(input())\n    s = input()\n    t = input()\n    \n    return [n, s, t]\n\n#------------------------------------------------------------------------------#\n\ndef main():\n    \"\"\"\n    Solves the problem.\n    \n    Returns:\n        None.\n    \"\"\"\n    print(solve(*read_input()))\n\n#------------------------------------------------------------------------------#\n\nif __name__ == \"__main__\":\n    main()", "\n\nn = int(input())\ns = input()\nt = input()\n\n# If s and t are the same, we don't need to do any swaps\nif s == t:\n    print(0)\n    exit()\n\n# Otherwise, we need to find the first index that differs between s and t\ni = 0\nwhile s[i] == t[i]:\n    i += 1\n\n# If all of the characters from index i to n are the same, then we can't swap\n# to get to t, so print -1\nif s[i:] == t[i:]:\n    print(-1)\n    exit()\n\n# Otherwise, we can swap s[i] and s[i+1] to get to t\nprint(1)\nprint(i + 1)", "\n\nn = int(input())\ns = input()\nt = input()\n\ndef is_possible(sequence, s, t):\n    curr = list(s)\n    for i in range(len(sequence)):\n        curr[sequence[i]-1], curr[sequence[i]] = curr[sequence[i]], curr[sequence[i]-1]\n    return \"\".join(curr) == t\n\ndef get_sequences(n):\n    for i in range(1, n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    yield [i, j, k, l]\n\nfor seq in get_sequences(n):\n    if is_possible(seq, s, t):\n        print(len(seq))\n        print(\" \".join([str(x) for x in seq]))\n        break\nelse:\n    print(-1)"]