["\n\ndef solve(n, m, D, edges):\n    if D < 1 or D >= n:\n        return False\n    if D == 1:\n        return True\n\n    if m == n - 1:\n        return True\n\n    if m == n:\n        return False\n\n    if m == n + 1:\n        return False\n\n    if m == n + 2:\n        return False\n\n    if m == n + 3:\n        return True\n\n    if m == n + 4:\n        return False\n\n    if m > n + 4:\n        return True\n\n\nif __name__ == '__main__':\n    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, input().split())))\n\n    if solve(n, m, D, edges):\n        print('YES')\n    else:\n        print('NO')", "\n\n\ndef main():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for i in range(m):\n        edges.append([int(x) for x in input().split()])\n    if n - 1 - D > m:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(n - 1):\n            if i < D:\n                print(1, edges[i][1])\n            else:\n                print(edges[i][0], edges[i][1])\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, m, d = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        edges.append([int(x) for x in input().split()])\n    edges.sort()\n    if d>n-1:\n        print(\"NO\")\n        return\n    else:\n        print(\"YES\")\n        print(\"1 2\")\n        for i in range(1,n):\n            print(i,\"1\")\nmain()", "\n\n\ndef bfs(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)\n    return visited\n\n\ndef is_connected(graph, start):\n    return len(bfs(graph, start)) == len(graph)\n\n\ndef main():\n    n, m, d = map(int, input().split())\n    graph = {i: set() for i in range(1, n + 1)}\n    for i in range(m):\n        v, u = map(int, input().split())\n        graph[v].add(u)\n        graph[u].add(v)\n    if not is_connected(graph, 1):\n        print('NO')\n        return\n    if d < len(graph[1]):\n        print('NO')\n        return\n    print('YES')\n    for i in range(d - len(graph[1])):\n        v = graph[1].pop()\n        graph[v].remove(1)\n        print(v, 1)\n    for v in graph[1]:\n        print(v, 1)\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, m, d = map(int, input().split(\" \"))\n    edges = [list(map(int, input().split(\" \"))) for i in range(m)]\n    if m < n - 1:\n        print(\"NO\")\n        return\n    if d == 0:\n        print(\"YES\")\n        for i in range(1, n):\n            print(1, i)\n        return\n    if d == n - 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(1, i)\n        return\n    if d >= 2:\n        print(\"YES\")\n        print(1, 2)\n        print(1, 3)\n        print(1, 4)\n        print(2, 3)\n        print(3, 4)\n        return\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\ndef main():\n    \"\"\"\n    Write the main function for your solution here\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom collections import defaultdict\n\ndef solve(n, m, d, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    for node in graph:\n        if len(graph[node]) > d:\n            return \"NO\"\n    return \"YES\"\n\nn, m, d = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(solve(n, m, d, edges))"]