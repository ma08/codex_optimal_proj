2022-04-16 18:54:51.909760 """
You are given an undirected unweighted connected graph consisting of $n$ vertices and $m$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.

Your task is to find any spanning tree of this graph such that the degree of the first vertex (vertex with label $1$ on it) is equal to $D$ (or say that there are no such spanning trees). Recall that the degree of a vertex is the number of edges incident to it.


-----Input-----

The first line contains three integers $n$, $m$ and $D$ ($2 \le n \le 2 \cdot 10^5$, $n - 1 \le m \le min(2 \cdot 10^5, \frac{n(n-1)}{2}), 1 \le D < n$) â€” the number of vertices, the number of edges and required degree of the first vertex, respectively.

The following $m$ lines denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \le v_i, u_i \le n$, $u_i \ne v_i$), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the list of edges, and for each pair $(v_i, u_i)$ the condition $v_i \ne u_i$ is satisfied.


-----Output-----

If there is no spanning tree satisfying the condition from the problem statement, print "NO" in the first line.

Otherwise print "YES" in the first line and then print $n-1$ lines describing the edges of a spanning tree such that the degree of the first vertex (vertex with label $1$ on it) is equal to $D$. Make sure that the edges of the printed spanning tree form some subset of the input edges (order doesn't matter and edge $(v, u)$ is considered the same as the edge $(u, v)$).

If there are multiple possible answers, print any of them.


-----Examples-----
Input
4 5 1
1 2
1 3
1 4
2 3
3 4

Output
YES
2 1
2 3
3 4

Input
4 5 3
1 2
1 3
1 4
2 3
3 4

Output
YES
1 2
1 3
4 1

Input
4 4 3
1 2
1 4
2 3
3 4

Output
NO



-----Note-----

The picture corresponding to the first and second examples: [Image]

The picture corresponding to the third example: [Image]
"""
2022-04-16 18:54:51.909774 --------------------------
2022-04-16 18:55:10.707096 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n\ndef bfs(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)\n    return visited\n\n\ndef is_connected(graph, start):\n    return len(bfs(graph, start)) == len(graph)\n\n\ndef main():\n    n, m, d = map(int, input().split())\n    graph = {i: set() for i in range(1, n + 1)}\n    for i in range(m):\n        v, u = map(int, input().split())\n        graph[v].add(u)\n        graph[u].add(v)\n    if not is_connected(graph, 1):\n        print('NO')\n        return\n    if d < len(graph[1]):\n        print('NO')\n        return\n    print('YES')\n    for i in range(d - len(graph[1])):\n        v = graph[1].pop()\n        graph[v].remove(1)\n        print(v, 1)\n    for v in graph[1]:\n        print(v, 1)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\ndef main():\n    \"\"\"\n    Write the main function for your solution here\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef solve(n, m, D, edges):\n    if D < 1 or D >= n:\n        return False\n    if D == 1:\n        return True\n\n    if m == n - 1:\n        return True\n\n    if m == n:\n        return False\n\n    if m == n + 1:\n        return False\n\n    if m == n + 2:\n        return False\n\n    if m == n + 3:\n        return True\n\n    if m == n + 4:\n        return False\n\n    if m > n + 4:\n        return True\n\n\nif __name__ == '__main__':\n    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, input().split())))\n\n    if solve(n, m, D, edges):\n        print('YES')\n    else:\n        print('NO')"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, d = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        edges.append([int(x) for x in input().split()])\n    edges.sort()\n    if d>n-1:\n        print(\"NO\")\n        return\n    else:\n        print(\"YES\")\n        print(\"1 2\")\n        for i in range(1,n):\n            print(i,\"1\")\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for i in range(m):\n        edges.append([int(x) for x in input().split()])\n    if n - 1 - D > m:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(n - 1):\n            if i < D:\n                print(1, edges[i][1])\n            else:\n                print(edges[i][0], edges[i][1])\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nfrom collections import defaultdict\n\ndef solve(n, m, d, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    for node in graph:\n        if len(graph[node]) > d:\n            return \"NO\"\n    return \"YES\"\n\nn, m, d = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(solve(n, m, d, edges))"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, d = map(int, input().split(\" \"))\n    edges = [list(map(int, input().split(\" \"))) for i in range(m)]\n    if m < n - 1:\n        print(\"NO\")\n        return\n    if d == 0:\n        print(\"YES\")\n        for i in range(1, n):\n            print(1, i)\n        return\n    if d == n - 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(1, i)\n        return\n    if d >= 2:\n        print(\"YES\")\n        print(1, 2)\n        print(1, 3)\n        print(1, 4)\n        print(2, 3)\n        print(3, 4)\n        return\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650135292,
  "id": "cmpl-4xhrIEvHV9fO4V0aYrOQPuhcMuHYz",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 18:55:10.707455 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n\ndef bfs(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)\n    return visited\n\n\ndef is_connected(graph, start):\n    return len(bfs(graph, start)) == len(graph)\n\n\ndef main():\n    n, m, d = map(int, input().split())\n    graph = {i: set() for i in range(1, n + 1)}\n    for i in range(m):\n        v, u = map(int, input().split())\n        graph[v].add(u)\n        graph[u].add(v)\n    if not is_connected(graph, 1):\n        print('NO')\n        return\n    if d < len(graph[1]):\n        print('NO')\n        return\n    print('YES')\n    for i in range(d - len(graph[1])):\n        v = graph[1].pop()\n        graph[v].remove(1)\n        print(v, 1)\n    for v in graph[1]:\n        print(v, 1)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 18:55:10.707499 REASON stop
2022-04-16 18:55:10.751838 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 18:55:10.752019 REASON stop
2022-04-16 18:55:10.752574 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\ndef main():\n    \"\"\"\n    Write the main function for your solution here\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 18:55:10.752662 REASON stop
2022-04-16 18:55:10.754437 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef solve(n, m, D, edges):\n    if D < 1 or D >= n:\n        return False\n    if D == 1:\n        return True\n\n    if m == n - 1:\n        return True\n\n    if m == n:\n        return False\n\n    if m == n + 1:\n        return False\n\n    if m == n + 2:\n        return False\n\n    if m == n + 3:\n        return True\n\n    if m == n + 4:\n        return False\n\n    if m > n + 4:\n        return True\n\n\nif __name__ == '__main__':\n    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, input().split())))\n\n    if solve(n, m, D, edges):\n        print('YES')\n    else:\n        print('NO')"
}
2022-04-16 18:55:10.754510 REASON stop
2022-04-16 18:55:10.770603 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, d = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        edges.append([int(x) for x in input().split()])\n    edges.sort()\n    if d>n-1:\n        print(\"NO\")\n        return\n    else:\n        print(\"YES\")\n        print(\"1 2\")\n        for i in range(1,n):\n            print(i,\"1\")\nmain()"
}
2022-04-16 18:55:10.770716 REASON stop
2022-04-16 18:55:10.792954 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for i in range(m):\n        edges.append([int(x) for x in input().split()])\n    if n - 1 - D > m:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(n - 1):\n            if i < D:\n                print(1, edges[i][1])\n            else:\n                print(edges[i][0], edges[i][1])\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 18:55:10.793105 REASON stop
2022-04-16 18:55:10.793879 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nfrom collections import defaultdict\n\ndef solve(n, m, d, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    for node in graph:\n        if len(graph[node]) > d:\n            return \"NO\"\n    return \"YES\"\n\nn, m, d = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(solve(n, m, d, edges))"
}
2022-04-16 18:55:10.793953 REASON stop
2022-04-16 18:55:10.794810 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, d = map(int, input().split(\" \"))\n    edges = [list(map(int, input().split(\" \"))) for i in range(m)]\n    if m < n - 1:\n        print(\"NO\")\n        return\n    if d == 0:\n        print(\"YES\")\n        for i in range(1, n):\n            print(1, i)\n        return\n    if d == n - 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(1, i)\n        return\n    if d >= 2:\n        print(\"YES\")\n        print(1, 2)\n        print(1, 3)\n        print(1, 4)\n        print(2, 3)\n        print(3, 4)\n        return\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 18:55:10.794915 REASON stop
