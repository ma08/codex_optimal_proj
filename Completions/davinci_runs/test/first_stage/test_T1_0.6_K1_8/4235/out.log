2022-04-16 20:26:21.564240 """
You are given a connected undirected graph consisting of $n$ vertices and $m$ edges. There are no self-loops or multiple edges in the given graph.

You have to direct its edges in such a way that the obtained directed graph does not contain any paths of length two or greater (where the length of path is denoted as the number of traversed edges).


-----Input-----

The first line contains two integer numbers $n$ and $m$ ($2 \le n \le 2 \cdot 10^5$, $n - 1 \le m \le 2 \cdot 10^5$) â€” the number of vertices and edges, respectively.

The following $m$ lines contain edges: edge $i$ is given as a pair of vertices $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). There are no multiple edges in the given graph, i. e. for each pair ($u_i, v_i$) there are no other pairs ($u_i, v_i$) and ($v_i, u_i$) in the list of edges. It is also guaranteed that the given graph is connected (there is a path between any pair of vertex in the given graph).


-----Output-----

If it is impossible to direct edges of the given graph in such a way that the obtained directed graph does not contain paths of length at least two, print "NO" in the first line.

Otherwise print "YES" in the first line, and then print any suitable orientation of edges: a binary string (the string consisting only of '0' and '1') of length $m$. The $i$-th element of this string should be '0' if the $i$-th edge of the graph should be directed from $u_i$ to $v_i$, and '1' otherwise. Edges are numbered in the order they are given in the input.


-----Example-----
Input
6 5
1 5
2 1
1 4
3 1
6 1

Output
YES
10100



-----Note-----

The picture corresponding to the first example: [Image]

And one of possible answers: $\text{of}$
"""
2022-04-16 20:26:21.564278 --------------------------
2022-04-16 20:27:22.406564 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    print(\"YES\")\n    for i in range(m):\n        if i < m-1 and edges[i] == (1, 6):\n            print(\"1\", end=\"\")\n        else:\n            print(\"0\", end=\"\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        edges.append([int(x) for x in input().split()])\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    in_deg = [0] * n\n    for v in adj.values():\n        in_deg[v[0] - 1] += 1\n        in_deg[v[1] - 1] += 1\n    q = []\n    for i in range(n):\n        if in_deg[i] == 1:\n            heapq.heappush(q, i + 1)\n    print('YES')\n    res = ''\n    while q:\n        v = heapq.heappop(q)\n        for u in adj[v]:\n            in_deg[u - 1] -= 1\n            if in_deg[u - 1] == 1:\n                heapq.heappush(q, u)\n        if v == edges[0][0]:\n            res += '0'\n        else:\n            res += '1'\n        adj.pop(v)\n    print(res)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m = map(int, input().split())\n    G = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        x, y = map(int, input().split())\n        G[x].append(y)\n        G[y].append(x)\n\n    def dfs(s):\n        visited = [False] * (n + 1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                for w in G[v]:\n                    stack.append(w)\n        return visited\n\n    if m != n - 1:\n        print(\"NO\")\n        return\n\n    visited = dfs(1)\n    if not all(visited):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    for u in G:\n        for v in G[u]:\n            if u < v:\n                print(0, end=\"\")\n            else:\n                print(1, end=\"\")\n    print()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: \u96a3\u63a5\u884c\u5217(\u8ddd\u96e2\u4ed8\u304d)\n    N: \u30ce\u30fc\u30c9\u6570\n    K: \u59cb\u70b9\u30ce\u30fc\u30c9\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  \u73fe\u5728\u306e\u30ce\u30fc\u30c9\n    pre: \uff11\u3064\u524d\u306e\u30ce\u30fc\u30c9\n    dist: \u73fe\u5728\u306e\u8ddd\u96e2\n\n    \u4ee5\u4e0b\u306f\u5225\u9014\u7528\u610f\u3059\u308b\n    D: \u96a3\u63a5\u30ea\u30b9\u30c8(\u884c\u5217\u3067\u306f\u306a\u3044)\n    D_dfs_d: dfs_d\u95a2\u6570\u3067\u7528\u3044\u308b\uff0c\u59cb\u70b9\u30ce\u30fc\u30c9\u304b\u3089\u898b\u305f\u8ddd\u96e2\u30ea\u30b9\u30c8\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\ndef comb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r + 1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p - 1, r, p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\ndef bisearch(L, target):\n    low = 0\n    high = len(L) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        guess = L[mid]\n        if guess == target:\n            return True\n        elif guess < target:\n            low = mid + 1\n        elif guess > target:\n            high = mid - 1\n    if guess != target:\n        return False\n\n# --------------------------------------------\n\ndp = None\n\n\ndef dfs(v, pre, color):\n    global dp\n    global G\n\n    dp[v] = color\n\n    for next_v, d in G[v]:\n        if next_v != pre:\n            if dp[next_v] != -1:\n                if dp[next_v] == color:\n                    return False\n            else:\n                if dfs(next_v, v, color ^ 1) == False:\n                    return False\n\n    return True\n\n\nN, M = li_input()\nG = [[] for _ in range(N + 1)]\n\ndp = [-1] * (N + 1)\n\nfor i in range(M):\n    u, v = li_input()\n    G[u].append((v, 1))\n    G[v].append((u, 1))\n\nif dfs(1, 0, 0) == False:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(1, N + 1):\n        print(dp[i], end='')"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    # tree\n    if m == n - 1:\n        print('YES')\n        for _, v in edges:\n            print(1, end='')\n        return\n\n    # cycle\n    if m == n:\n        print('YES')\n        for u, _ in edges:\n            print(0, end='')\n        return\n\n    # connected graph\n    if m > n - 1 and m < n + 1:\n        print('NO')\n        return\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\nimport os\nimport math\nfrom collections import defaultdict\nimport heapq\n\ndef read_tokens():\n    return sys.stdin.readline().strip().split(' ')\n\ndef read_ints():\n    return [int(s) for s in read_tokens()]\n\ndef read_int():\n    return read_ints()[0]\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = defaultdict(list)\n        self.parent = [None for i in range(n)]\n        self.depth = [None for i in range(n)]\n        self.ans = [None for i in range(n)]\n    \n    def add_edge(self, i, j):\n        self.edges[i].append(j)\n        self.edges[j].append(i)\n\n    def dfs(self, i, j, d):\n        self.parent[i] = j\n        self.depth[i] = d\n        for k in self.edges[i]:\n            if self.parent[k] == None:\n                self.dfs(k, i, d+1)\n\n    def dfs2(self, i):\n        for j in self.edges[i]:\n            if self.parent[j] == i:\n                self.ans[j] = self.ans[i]\n                self.dfs2(j)\n            \n    def solve(self):\n        self.dfs(0, None, 0)\n        self.ans[0] = 0\n        self.dfs2(0)\n        return self.ans\n\ndef solve():\n    n, m = read_ints()\n    g = Graph(n)\n    for i in range(m):\n        a, b = read_ints()\n        g.add_edge(a-1, b-1)\n    ans = g.solve()\n    print('YES')\n    print(''.join(str(a) for a in ans))\n\nif __name__ == '__main__':\n    solve()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(u):\n    visited[u] = True\n    for v in adj[u]:\n        if not visited[v]:\n            dfs(v)\n\ndef dfs2(u, par, is_forward):\n    if is_forward:\n        for v in adj[u]:\n            if v == par: continue\n            if parent[u] == v:\n                print(\"NO\")\n                exit()\n            parent[v] = u\n            dfs2(v, u, False)\n    else:\n        for v in adj[u]:\n            if v == par: continue\n            parent[v] = u\n            dfs2(v, u, True)\n\nn, m = map(int, input().strip().split())\nadj = [set() for _ in range(n+1)]\n\nfor _ in range(m):\n    u, v = map(int, input().strip().split())\n    adj[u].add(v)\n    adj[v].add(u)\n\nvisited = [False] * (n+1)\ndfs(1)\nif False in visited:\n    print(\"NO\")\n    exit()\n\nparent = [0] * (n+1)\ndfs2(1, 0, True)\n\nprint(\"YES\")\nfor u, v in edges:\n    if parent[v] == u:\n        print(0, end=\"\")\n    else:\n        print(1, end=\"\")\nprint()"
    }
  ],
  "created": 1650140781,
  "id": "cmpl-4xjHpMeGDlfSjKGMVvHBvVpkzI2oJ",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:27:22.406962 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    print(\"YES\")\n    for i in range(m):\n        if i < m-1 and edges[i] == (1, 6):\n            print(\"1\", end=\"\")\n        else:\n            print(\"0\", end=\"\")\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:27:22.407003 REASON stop
2022-04-16 20:27:22.466249 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        edges.append([int(x) for x in input().split()])\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    in_deg = [0] * n\n    for v in adj.values():\n        in_deg[v[0] - 1] += 1\n        in_deg[v[1] - 1] += 1\n    q = []\n    for i in range(n):\n        if in_deg[i] == 1:\n            heapq.heappush(q, i + 1)\n    print('YES')\n    res = ''\n    while q:\n        v = heapq.heappop(q)\n        for u in adj[v]:\n            in_deg[u - 1] -= 1\n            if in_deg[u - 1] == 1:\n                heapq.heappush(q, u)\n        if v == edges[0][0]:\n            res += '0'\n        else:\n            res += '1'\n        adj.pop(v)\n    print(res)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:27:22.466428 REASON stop
2022-04-16 20:27:22.466913 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:27:22.466977 REASON stop
2022-04-16 20:27:22.490271 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m = map(int, input().split())\n    G = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        x, y = map(int, input().split())\n        G[x].append(y)\n        G[y].append(x)\n\n    def dfs(s):\n        visited = [False] * (n + 1)\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                for w in G[v]:\n                    stack.append(w)\n        return visited\n\n    if m != n - 1:\n        print(\"NO\")\n        return\n\n    visited = dfs(1)\n    if not all(visited):\n        print(\"NO\")\n        return\n    print(\"YES\")\n    for u in G:\n        for v in G[u]:\n            if u < v:\n                print(0, end=\"\")\n            else:\n                print(1, end=\"\")\n    print()\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:27:22.490375 REASON stop
2022-04-16 20:27:22.507385 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: \u96a3\u63a5\u884c\u5217(\u8ddd\u96e2\u4ed8\u304d)\n    N: \u30ce\u30fc\u30c9\u6570\n    K: \u59cb\u70b9\u30ce\u30fc\u30c9\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  \u73fe\u5728\u306e\u30ce\u30fc\u30c9\n    pre: \uff11\u3064\u524d\u306e\u30ce\u30fc\u30c9\n    dist: \u73fe\u5728\u306e\u8ddd\u96e2\n\n    \u4ee5\u4e0b\u306f\u5225\u9014\u7528\u610f\u3059\u308b\n    D: \u96a3\u63a5\u30ea\u30b9\u30c8(\u884c\u5217\u3067\u306f\u306a\u3044)\n    D_dfs_d: dfs_d\u95a2\u6570\u3067\u7528\u3044\u308b\uff0c\u59cb\u70b9\u30ce\u30fc\u30c9\u304b\u3089\u898b\u305f\u8ddd\u96e2\u30ea\u30b9\u30c8\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\ndef comb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r + 1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p - 1, r, p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\ndef bisearch(L, target):\n    low = 0\n    high = len(L) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        guess = L[mid]\n        if guess == target:\n            return True\n        elif guess < target:\n            low = mid + 1\n        elif guess > target:\n            high = mid - 1\n    if guess != target:\n        return False\n\n# --------------------------------------------\n\ndp = None\n\n\ndef dfs(v, pre, color):\n    global dp\n    global G\n\n    dp[v] = color\n\n    for next_v, d in G[v]:\n        if next_v != pre:\n            if dp[next_v] != -1:\n                if dp[next_v] == color:\n                    return False\n            else:\n                if dfs(next_v, v, color ^ 1) == False:\n                    return False\n\n    return True\n\n\nN, M = li_input()\nG = [[] for _ in range(N + 1)]\n\ndp = [-1] * (N + 1)\n\nfor i in range(M):\n    u, v = li_input()\n    G[u].append((v, 1))\n    G[v].append((u, 1))\n\nif dfs(1, 0, 0) == False:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(1, N + 1):\n        print(dp[i], end='')"
}
2022-04-16 20:27:22.507526 REASON stop
2022-04-16 20:27:22.508656 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    # tree\n    if m == n - 1:\n        print('YES')\n        for _, v in edges:\n            print(1, end='')\n        return\n\n    # cycle\n    if m == n:\n        print('YES')\n        for u, _ in edges:\n            print(0, end='')\n        return\n\n    # connected graph\n    if m > n - 1 and m < n + 1:\n        print('NO')\n        return\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:27:22.508787 REASON stop
2022-04-16 20:27:22.509974 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\nimport os\nimport math\nfrom collections import defaultdict\nimport heapq\n\ndef read_tokens():\n    return sys.stdin.readline().strip().split(' ')\n\ndef read_ints():\n    return [int(s) for s in read_tokens()]\n\ndef read_int():\n    return read_ints()[0]\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = defaultdict(list)\n        self.parent = [None for i in range(n)]\n        self.depth = [None for i in range(n)]\n        self.ans = [None for i in range(n)]\n    \n    def add_edge(self, i, j):\n        self.edges[i].append(j)\n        self.edges[j].append(i)\n\n    def dfs(self, i, j, d):\n        self.parent[i] = j\n        self.depth[i] = d\n        for k in self.edges[i]:\n            if self.parent[k] == None:\n                self.dfs(k, i, d+1)\n\n    def dfs2(self, i):\n        for j in self.edges[i]:\n            if self.parent[j] == i:\n                self.ans[j] = self.ans[i]\n                self.dfs2(j)\n            \n    def solve(self):\n        self.dfs(0, None, 0)\n        self.ans[0] = 0\n        self.dfs2(0)\n        return self.ans\n\ndef solve():\n    n, m = read_ints()\n    g = Graph(n)\n    for i in range(m):\n        a, b = read_ints()\n        g.add_edge(a-1, b-1)\n    ans = g.solve()\n    print('YES')\n    print(''.join(str(a) for a in ans))\n\nif __name__ == '__main__':\n    solve()"
}
2022-04-16 20:27:22.510159 REASON stop
2022-04-16 20:27:22.510650 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(u):\n    visited[u] = True\n    for v in adj[u]:\n        if not visited[v]:\n            dfs(v)\n\ndef dfs2(u, par, is_forward):\n    if is_forward:\n        for v in adj[u]:\n            if v == par: continue\n            if parent[u] == v:\n                print(\"NO\")\n                exit()\n            parent[v] = u\n            dfs2(v, u, False)\n    else:\n        for v in adj[u]:\n            if v == par: continue\n            parent[v] = u\n            dfs2(v, u, True)\n\nn, m = map(int, input().strip().split())\nadj = [set() for _ in range(n+1)]\n\nfor _ in range(m):\n    u, v = map(int, input().strip().split())\n    adj[u].add(v)\n    adj[v].add(u)\n\nvisited = [False] * (n+1)\ndfs(1)\nif False in visited:\n    print(\"NO\")\n    exit()\n\nparent = [0] * (n+1)\ndfs2(1, 0, True)\n\nprint(\"YES\")\nfor u, v in edges:\n    if parent[v] == u:\n        print(0, end=\"\")\n    else:\n        print(1, end=\"\")\nprint()"
}
2022-04-16 20:27:22.510718 REASON stop
