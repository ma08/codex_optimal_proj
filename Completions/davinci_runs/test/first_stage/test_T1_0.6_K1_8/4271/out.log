2022-04-16 20:36:29.308439 """
Takahashi went to an all-you-can-eat buffet with N kinds of dishes and ate all of them (Dish 1, Dish 2, \ldots, Dish N) once.
The i-th dish (1 \leq i \leq N) he ate was Dish A_i.
When he eats Dish i (1 \leq i \leq N), he gains B_i satisfaction points.
Additionally, when he eats Dish i+1 just after eating Dish i (1 \leq i \leq N - 1), he gains C_i more satisfaction points.
Find the sum of the satisfaction points he gained.

-----Constraints-----
 - All values in input are integers.
 - 2 \leq N \leq 20
 - 1 \leq A_i \leq N
 - A_1, A_2, ..., A_N are all different.
 - 1 \leq B_i \leq 50
 - 1 \leq C_i \leq 50

-----Input-----
Input is given from Standard Input in the following format:
N
A_1 A_2 ... A_N
B_1 B_2 ... B_N
C_1 C_2 ... C_{N-1}

-----Output-----
Print the sum of the satisfaction points Takahashi gained, as an integer.

-----Sample Input-----
3
3 1 2
2 5 4
3 6

-----Sample Output-----
14

Takahashi gained 14 satisfaction points in total, as follows:
 - First, he ate Dish 3 and gained 4 satisfaction points.
 - Next, he ate Dish 1 and gained 2 satisfaction points.
 - Lastly, he ate Dish 2 and gained 5 + 3 = 8 satisfaction points.
"""
2022-04-16 20:36:29.308456 --------------------------
2022-04-16 20:37:56.844623 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    dishes = list(map(int, sys.stdin.readline().split()))\n    points = list(map(int, sys.stdin.readline().split()))\n    bonus = list(map(int, sys.stdin.readline().split()))\n    result = 0\n    for i in range(n-1):\n        result += points[dishes[i]-1]\n        if dishes[i] == dishes[i+1]-1:\n            result += bonus[dishes[i]-1]\n    result += points[dishes[-1]-1]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\ndish = list(map(int, input().split()))\nsatisfaction = list(map(int, input().split()))\nbonus = list(map(int, input().split()))\n\npoints = 0\nfor i in range(n):\n    points += satisfaction[dish[i]-1]\n    if i != n-1:\n        if dish[i] == dish[i+1] - 1:\n            points += bonus[dish[i]-1]\n\nprint(points)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n# We can think of this as a graph problem.\n# We need to find the longest path from any node to another node, and then sum the weights of the edges in that path to get the answer.\n# This can be done with Dijkstra's algorithm, which finds the shortest path from one node to every other node in a graph.\n# However, we can consider the graph to be a digraph, and then we can simply apply Dijkstra's algorithm to the graph.\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# We need to make a matrix of values, which will be our graph.\n# The matrix will be NxN, with each edge in the graph represented by an entry in the matrix.\n# This edge will have a value of the weight of the edge.\n# If we consider the graph as a digraph, then we need to make the matrix symmetric, so that the weight of the edge is the same in both directions.\n# Also, if we have an edge that is a loop, then the value of the edge should be the weight of the edge, and not 0.\n# If we have an edge that does not exist, then the value of the edge should be 0.\nmat = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    mat[a[i] - 1][i] = b[i]\n    mat[i][a[i] - 1] = b[i]\nfor i in range(n - 1):\n    mat[a[i + 1] - 1][i] = c[i]\n    mat[i][a[i + 1] - 1] = c[i]\n\n# Now, we will apply Dijkstra's algorithm to the matrix to find the shortest path from a random node to every other node.\n# We will start by initializing the distance from the source node to every other node, as well as the previous node of every node.\n# Then, we will initialize the set of nodes we have already visited.\n# We will also initialize the set of nodes we have not yet visited.\n# We will set the distance from the source node to the source node to be 0, and then we will add the source node to the set of nodes we have already visited.\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\n# However, we cannot assume that the source node is the node with the longest path from it to another node.\n# Hence, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\n# We will initialize the source node to be the first node, and then we will initialize the distance from the source node to every other node to be 0.\n# We will also initialize the previous node of every node to be None.\n# Then, we will initialize the set of nodes we have already visited to be empty, and we will initialize the set of nodes we have not yet visited to be all of the nodes.\n# Then, we will set the distance from the source node to the source node to be 0, and we will add the source node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\n# However, we cannot assume that the source node is the node with the longest path from it to another node.\n# Hence, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\n# We will initialize the source node to be the first node, and then we will initialize the distance from the source node to every other node to be 0.\n# We will also initialize the previous node of every node to be None.\n# Then, we will initialize the set of nodes we have already visited to be empty, and we will initialize the set of nodes we have not yet visited to be all of the nodes.\ndist = [0] * n\nprev = [None] * n\nvisited = set()\nnot_visited = set([i for i in range(n)])\ndist[0] = 0\nvisited.add(0)\nnot_visited.remove(0)\n\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\n# However, we cannot assume that the source node is the node with the longest path from it to another node.\n# Hence, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\nwhile len(not_visited) > 0:\n    min_dist = float(\"inf\")\n    min_node = None\n    for node in not_visited:\n        if dist[node] < min_dist:\n            min_dist = dist[node]\n            min_node = node\n    visited.add(min_node)\n    not_visited.remove(min_node)\n    for node in not_visited:\n        if dist[node] > dist[min_node] + mat[min_node][node]:\n            dist[node] = dist[min_node] + mat[min_node][node]\n            prev[node] = min_node\n\n# Then, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\nmax_dist = 0\nmax_node = None\nfor node in visited:\n    if dist[node] > max_dist:\n        max_dist = dist[node]\n        max_node = node\ndist = [0] * n\nprev = [None] * n\nvisited = set()\nnot_visited = set([i for i in range(n)])\ndist[max_node] = 0\nvisited.add(max_node)\nnot_visited.remove(max_node)\n\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\nwhile len(not_visited) > 0:\n    min_dist = float(\"inf\")\n    min_node = None\n    for node in not_visited:\n        if dist[node] < min_dist:\n            min_dist = dist[node]\n            min_node = node\n    visited.add(min_node)\n    not_visited.remove(min_node)\n    for node in not_visited:\n        if dist[node] > dist[min_node] + mat[min_node][node]:\n            dist[node] = dist[min_node] + mat[min_node][node]\n            prev[node] = min_node\n\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\nans = 0\nnode = max_node\nwhile prev[node] is not None:\n    ans += mat[prev[node]][node]\n    node = prev[node]\n\n# Once we have the answer, we can print it.\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# Get the number of dishes\nn = int(input())\n\n# Get the dishes\na = list(map(int, input().split()))\n\n# Get the base satisfaction points for each dish\nb = list(map(int, input().split()))\n\n# Get the additional satisfaction points for each dish\nc = list(map(int, input().split()))\n\n# Initialize the total satisfaction points\ns = 0\n\n# Loop through the dishes\nfor i in range(n):\n\n    # The dish number is given by the i-th element of the dishes list\n    dish = a[i]\n\n    # Add the satisfaction points for this dish\n    s += b[dish-1]\n\n    # If this is not the last dish\n    if i < n-1:\n\n        # If the next dish is consecutive\n        if dish+1 == a[i+1]:\n\n            # Add the additional satisfaction points\n            s += c[dish-1]\n\n# Print the total satisfaction points\nprint(s)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\nN = int(stdin.readline())\nA = [int(x) for x in stdin.readline().split()]\nB = [int(x) for x in stdin.readline().split()]\nC = [int(x) for x in stdin.readline().split()]\n\na = [0 for i in range(N + 1)]\nfor i in range(N):\n    a[A[i]] = i\n\nans = 0\nfor i in range(N):\n    ans += B[i]\n    if i + 1 < N and a[i + 1] < a[i + 2]:\n        ans += C[i]\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\nimport sys\n\nnumDishes = int(input())\ndishes = list(map(int,input().split()))\ndishSatisfaction = list(map(int,input().split()))\ndishSatisfactionBonus = list(map(int,input().split()))\n\ntotalSatisfaction = 0\nfor i in range(numDishes-1):\n\ttotalSatisfaction += dishSatisfaction[dishes[i]-1]\n\tif dishes[i] == dishes[i+1] - 1:\n\t\ttotalSatisfaction += dishSatisfactionBonus[dishes[i]-1]\ntotalSatisfaction += dishSatisfaction[dishes[numDishes-1]-1]\n\nprint(totalSatisfaction)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nsum = 0\nsum += b[a[0]-1]\nfor i in range(n-1):\n    if a[i] < a[i+1]:\n        sum += c[a[i]-1]\n    sum += b[a[i+1]-1]\n\nprint(sum)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\n# n = int(input())\n# a = list(map(int, input().split()))\n# b = list(map(int, input().split()))\n# c = list(map(int, input().split()))\n\n# res = 0\n# for i in range(n):\n#     res += b[a[i] - 1]\n#     if i != 0:\n#         if a[i] - 1 == a[i - 1]:\n#             res += c[a[i] - 2]\n# print(res)\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nres = 0\nfor i in range(n):\n    res += b[a[i] - 1]\n    if i != 0:\n        if a[i] - 1 == a[i - 1]:\n            res += c[a[i] - 2]\nprint(res)"
    }
  ],
  "created": 1650141389,
  "id": "cmpl-4xjRd0vgXBDFbh3hizcHUwOA6ulul",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:37:56.845149 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    dishes = list(map(int, sys.stdin.readline().split()))\n    points = list(map(int, sys.stdin.readline().split()))\n    bonus = list(map(int, sys.stdin.readline().split()))\n    result = 0\n    for i in range(n-1):\n        result += points[dishes[i]-1]\n        if dishes[i] == dishes[i+1]-1:\n            result += bonus[dishes[i]-1]\n    result += points[dishes[-1]-1]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:37:56.845195 REASON stop
2022-04-16 20:37:56.857975 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\ndish = list(map(int, input().split()))\nsatisfaction = list(map(int, input().split()))\nbonus = list(map(int, input().split()))\n\npoints = 0\nfor i in range(n):\n    points += satisfaction[dish[i]-1]\n    if i != n-1:\n        if dish[i] == dish[i+1] - 1:\n            points += bonus[dish[i]-1]\n\nprint(points)"
}
2022-04-16 20:37:56.858155 REASON stop
2022-04-16 20:37:56.858647 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n# We can think of this as a graph problem.\n# We need to find the longest path from any node to another node, and then sum the weights of the edges in that path to get the answer.\n# This can be done with Dijkstra's algorithm, which finds the shortest path from one node to every other node in a graph.\n# However, we can consider the graph to be a digraph, and then we can simply apply Dijkstra's algorithm to the graph.\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# We need to make a matrix of values, which will be our graph.\n# The matrix will be NxN, with each edge in the graph represented by an entry in the matrix.\n# This edge will have a value of the weight of the edge.\n# If we consider the graph as a digraph, then we need to make the matrix symmetric, so that the weight of the edge is the same in both directions.\n# Also, if we have an edge that is a loop, then the value of the edge should be the weight of the edge, and not 0.\n# If we have an edge that does not exist, then the value of the edge should be 0.\nmat = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    mat[a[i] - 1][i] = b[i]\n    mat[i][a[i] - 1] = b[i]\nfor i in range(n - 1):\n    mat[a[i + 1] - 1][i] = c[i]\n    mat[i][a[i + 1] - 1] = c[i]\n\n# Now, we will apply Dijkstra's algorithm to the matrix to find the shortest path from a random node to every other node.\n# We will start by initializing the distance from the source node to every other node, as well as the previous node of every node.\n# Then, we will initialize the set of nodes we have already visited.\n# We will also initialize the set of nodes we have not yet visited.\n# We will set the distance from the source node to the source node to be 0, and then we will add the source node to the set of nodes we have already visited.\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\n# However, we cannot assume that the source node is the node with the longest path from it to another node.\n# Hence, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\n# We will initialize the source node to be the first node, and then we will initialize the distance from the source node to every other node to be 0.\n# We will also initialize the previous node of every node to be None.\n# Then, we will initialize the set of nodes we have already visited to be empty, and we will initialize the set of nodes we have not yet visited to be all of the nodes.\n# Then, we will set the distance from the source node to the source node to be 0, and we will add the source node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\n# However, we cannot assume that the source node is the node with the longest path from it to another node.\n# Hence, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\n# We will initialize the source node to be the first node, and then we will initialize the distance from the source node to every other node to be 0.\n# We will also initialize the previous node of every node to be None.\n# Then, we will initialize the set of nodes we have already visited to be empty, and we will initialize the set of nodes we have not yet visited to be all of the nodes.\ndist = [0] * n\nprev = [None] * n\nvisited = set()\nnot_visited = set([i for i in range(n)])\ndist[0] = 0\nvisited.add(0)\nnot_visited.remove(0)\n\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\n# However, we cannot assume that the source node is the node with the longest path from it to another node.\n# Hence, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\nwhile len(not_visited) > 0:\n    min_dist = float(\"inf\")\n    min_node = None\n    for node in not_visited:\n        if dist[node] < min_dist:\n            min_dist = dist[node]\n            min_node = node\n    visited.add(min_node)\n    not_visited.remove(min_node)\n    for node in not_visited:\n        if dist[node] > dist[min_node] + mat[min_node][node]:\n            dist[node] = dist[min_node] + mat[min_node][node]\n            prev[node] = min_node\n\n# Then, we will loop through the set of nodes we have already visited, and we will find the node with the maximum distance from the source node.\n# We will set this node to be the new source node, and then we will reset the sets of nodes we have visited and not yet visited, along with their distances and previous nodes.\n# Then, we will repeat this process.\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\nmax_dist = 0\nmax_node = None\nfor node in visited:\n    if dist[node] > max_dist:\n        max_dist = dist[node]\n        max_node = node\ndist = [0] * n\nprev = [None] * n\nvisited = set()\nnot_visited = set([i for i in range(n)])\ndist[max_node] = 0\nvisited.add(max_node)\nnot_visited.remove(max_node)\n\n# Then, we will loop through the set of nodes we have not yet visited, and we will find the node with the minimum distance from the source node.\n# We will add this node to the set of nodes we have already visited, and we will remove it from the set of nodes we have not yet visited.\n# Then, we will loop through all of the nodes we have not yet visited.\n# If the distance from the source node to this node is greater than the distance from the source node to the node we just visited plus the weight of the edge between those two nodes, then we will update the distance from the source node to this node.\n# We will also update the previous node of this node, and we will stop the loop.\n# Once the set of nodes we have not yet visited is empty, we will have the shortest path from the source node to every other node.\nwhile len(not_visited) > 0:\n    min_dist = float(\"inf\")\n    min_node = None\n    for node in not_visited:\n        if dist[node] < min_dist:\n            min_dist = dist[node]\n            min_node = node\n    visited.add(min_node)\n    not_visited.remove(min_node)\n    for node in not_visited:\n        if dist[node] > dist[min_node] + mat[min_node][node]:\n            dist[node] = dist[min_node] + mat[min_node][node]\n            prev[node] = min_node\n\n# Once we have the longest path from some node to another node, then we can sum the weights of the edges in this path to get the answer.\nans = 0\nnode = max_node\nwhile prev[node] is not None:\n    ans += mat[prev[node]][node]\n    node = prev[node]\n\n# Once we have the answer, we can print it.\nprint(ans)"
}
2022-04-16 20:37:56.858770 REASON stop
2022-04-16 20:37:56.889337 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# Get the number of dishes\nn = int(input())\n\n# Get the dishes\na = list(map(int, input().split()))\n\n# Get the base satisfaction points for each dish\nb = list(map(int, input().split()))\n\n# Get the additional satisfaction points for each dish\nc = list(map(int, input().split()))\n\n# Initialize the total satisfaction points\ns = 0\n\n# Loop through the dishes\nfor i in range(n):\n\n    # The dish number is given by the i-th element of the dishes list\n    dish = a[i]\n\n    # Add the satisfaction points for this dish\n    s += b[dish-1]\n\n    # If this is not the last dish\n    if i < n-1:\n\n        # If the next dish is consecutive\n        if dish+1 == a[i+1]:\n\n            # Add the additional satisfaction points\n            s += c[dish-1]\n\n# Print the total satisfaction points\nprint(s)"
}
2022-04-16 20:37:56.889442 REASON stop
2022-04-16 20:37:56.914789 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\nN = int(stdin.readline())\nA = [int(x) for x in stdin.readline().split()]\nB = [int(x) for x in stdin.readline().split()]\nC = [int(x) for x in stdin.readline().split()]\n\na = [0 for i in range(N + 1)]\nfor i in range(N):\n    a[A[i]] = i\n\nans = 0\nfor i in range(N):\n    ans += B[i]\n    if i + 1 < N and a[i + 1] < a[i + 2]:\n        ans += C[i]\n\nprint(ans)"
}
2022-04-16 20:37:56.914921 REASON stop
2022-04-16 20:37:56.916143 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\nimport sys\n\nnumDishes = int(input())\ndishes = list(map(int,input().split()))\ndishSatisfaction = list(map(int,input().split()))\ndishSatisfactionBonus = list(map(int,input().split()))\n\ntotalSatisfaction = 0\nfor i in range(numDishes-1):\n\ttotalSatisfaction += dishSatisfaction[dishes[i]-1]\n\tif dishes[i] == dishes[i+1] - 1:\n\t\ttotalSatisfaction += dishSatisfactionBonus[dishes[i]-1]\ntotalSatisfaction += dishSatisfaction[dishes[numDishes-1]-1]\n\nprint(totalSatisfaction)"
}
2022-04-16 20:37:56.916236 REASON stop
2022-04-16 20:37:56.917480 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nsum = 0\nsum += b[a[0]-1]\nfor i in range(n-1):\n    if a[i] < a[i+1]:\n        sum += c[a[i]-1]\n    sum += b[a[i+1]-1]\n\nprint(sum)"
}
2022-04-16 20:37:56.917563 REASON stop
2022-04-16 20:37:56.918620 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\n# n = int(input())\n# a = list(map(int, input().split()))\n# b = list(map(int, input().split()))\n# c = list(map(int, input().split()))\n\n# res = 0\n# for i in range(n):\n#     res += b[a[i] - 1]\n#     if i != 0:\n#         if a[i] - 1 == a[i - 1]:\n#             res += c[a[i] - 2]\n# print(res)\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nres = 0\nfor i in range(n):\n    res += b[a[i] - 1]\n    if i != 0:\n        if a[i] - 1 == a[i - 1]:\n            res += c[a[i] - 2]\nprint(res)"
}
2022-04-16 20:37:56.918705 REASON stop
