["\n\nfrom sys import stdin\n\ndef read_ints():\n    return list(map(int, stdin.readline().split()))\n\ndef read_int_edges(n):\n    edges = []\n    for _ in range(n-1):\n        edges.append(read_ints())\n    return edges\n\ndef create_adj(edges, n):\n    adj = [[] for _ in range(n)]\n    for edge in edges:\n        adj[edge[0]-1].append(edge[1])\n        adj[edge[1]-1].append(edge[0])\n    return adj\n\ndef dfs(adj, curr):\n    if curr == 0:\n        return 1\n    total = 0\n    for neighbor in adj[curr]:\n        if not visited[neighbor]:\n            visited[neighbor] = True\n            total += dfs(adj, neighbor)\n            visited[neighbor] = False\n    return total\n\ndef main():\n    n, m = read_ints()\n    edges = read_int_edges(m)\n    adj = create_adj(edges, n)\n    global visited\n    visited = [True] * n\n    print(dfs(adj, 1))\n\nmain()", "\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\nn, m = map(int, sys.stdin.readline().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, sys.stdin.readline().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\nvisited = [False] * n\nans = 0\n\ndef dfs(v, count):\n    global ans\n    visited[v] = True\n    count += 1\n    if count == n:\n        ans += 1\n        return\n    for e in edges[v]:\n        if not visited[e]:\n            dfs(e, count)\n    visited[v] = False\n    return\n\ndfs(0, 0)\nprint(ans)", "\n\nimport sys\n\nclass Problem():\n    def __init__(self):\n        self.graph = None\n        self.cache = {}\n    \n    def read(self):\n        def read_graph():\n            n, m = map(int, sys.stdin.readline().split())\n            graph = [[] for _ in range(n)]\n            for _ in range(m):\n                a, b = map(int, sys.stdin.readline().split())\n                graph[a - 1].append(b - 1)\n                graph[b - 1].append(a - 1)\n            return graph\n        self.graph = read_graph()\n\n    def solve(self):\n        def get_path_count(cur, visited):\n            if visited == (1 << n) - 1:\n                return 1\n            key = (cur, visited)\n            if key in self.cache:\n                return self.cache[key]\n            count = 0\n            for next in self.graph[cur]:\n                if (visited >> next) & 1:\n                    continue\n                count += get_path_count(next, visited | (1 << next))\n            self.cache[key] = count\n            return count\n        n = len(self.graph)\n        return get_path_count(0, 1)\n\ndef main():\n    problem = Problem()\n    problem.read()\n    print(problem.solve())\n\nif __name__ == '__main__':\n    sys.exit(main())", "\n\nn, m = map(int, input().split())\n\n#build the graph\ngraph = [[] for i in range(n+1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n#store all the possible paths\npaths = []\n\n#create a path\ndef create_path(current_path, visited, start, end):\n    #backtrack\n    if visited == (1<<n)-1:\n        #add the current path to the paths array\n        paths.append(current_path[:])\n        return\n\n    #check if the node is visited\n    if visited & (1<<start):\n        return\n\n    #set the node as visited\n    visited |= 1<<start\n\n    #go through all the neighbours\n    for i in graph[start]:\n        #if the node is not visited\n        if not visited & (1<<i):\n            #add it to the current path\n            current_path.append(i)\n            #create a path from the current one\n            create_path(current_path, visited, i, end)\n            #remove it from the current path\n            current_path.pop()\n    \n    #set the node as not visited\n    visited &= ~(1<<start)\n\n#the start node is 1\nstart = 1\n#the end node is n\nend = n\n\n#create a path\ncreate_path([1], 0, start, end)\n\n#print the length of the paths array\nprint(len(paths))", "\n\ndef perm(i, n):\n    if i == n:\n        return 1\n    else:\n        return i * perm(i+1, n)\n\ndef combination(n, r):\n    return perm(n, n-r+1) // perm(1, r)\n\ndef main():\n    n, m = map(int, input().split())\n    x = [0 for _ in range(m)]\n    y = [0 for _ in range(m)]\n    for i in range(m):\n        x[i], y[i] = map(int, input().split())\n    print(combination(n-1, m))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    N, M = map(int,input().split())\n    A = [[] for i in range(N+1)]\n    for i in range(M):\n        a,b = map(int,input().split())\n        A[a].append(b)\n        A[b].append(a)\n    print(dfs(A,N))\n\ndef dfs(G,N):\n    visited = [False for i in range(N+1)]\n    visited[1] = True\n    ans = dfs_rec(G,1,N,visited)\n    return ans\n\ndef dfs_rec(G,v,N,visited):\n    if v == N:\n        return 1\n    ans = 0\n    for i in G[v]:\n        if visited[i]:\n            continue\n        visited[i] = True\n        ans += dfs_rec(G,i,N,visited)\n        visited[i] = False\n    return ans\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport numpy as np\ndef permutation(n):\n\tif n == 1:\n\t\treturn 1\n\treturn n * permutation(n-1)\n\ndef dfs(graph, start, goal, max_depth, path, visited):\n\tif max_depth == 0:\n\t\treturn path\n\tif start == goal:\n\t\treturn path\n\tfor i in range(1, len(graph[start])):\n\t\tif graph[start][i] == 1 and visited[i] == 0:\n\t\t\tvisited[i] = 1\n\t\t\tpath.append(i)\n\t\t\tresult = dfs(graph, i, goal, max_depth-1, path, visited)\n\t\t\tif result != None:\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\tpath.pop()\n\t\t\t\tvisited[i] = 0\n\treturn None\n\nN, M = map(int, input().split())\ngraph = np.zeros((N+1, N+1), dtype=np.int32)\nfor i in range(M):\n\ta, b = map(int, input().split())\n\tgraph[a][b] = 1\n\tgraph[b][a] = 1\n\nvisited = np.zeros(N+1, dtype=np.int32)\nvisited[1] = 1\n\npath = [1]\nresult = dfs(graph, 1, N, N-1, path, visited)\nif result == None:\n\tprint(0)\nelse:\n\tprint(permutation(N-1))", "\n\ndef dfs(graph, v, visited):\n    visited += [v]\n    for e in graph[v]:\n        if not e in visited:\n            dfs(graph, e, visited)\n    return visited\n\ndef main():\n    n, m = map(int, input().split())\n    graph = {i:[] for i in range(1, n+1)}\n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    v = 1\n    visited = []\n    visited = dfs(graph, v, visited)\n    if len(visited) == n:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == '__main__':\n    main()"]