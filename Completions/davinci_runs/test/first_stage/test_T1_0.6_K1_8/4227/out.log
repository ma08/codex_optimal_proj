2022-04-16 20:24:11.040549 """
You are given an undirected unweighted graph with N vertices and M edges that contains neither self-loops nor double edges.

Here, a self-loop is an edge where a_i = b_i (1≤i≤M), and double edges are two edges where (a_i,b_i)=(a_j,b_j) or (a_i,b_i)=(b_j,a_j) (1≤i<j≤M).

How many different paths start from vertex 1 and visit all the vertices exactly once?

Here, the endpoints of a path are considered visited.  
For example, let us assume that the following undirected graph shown in Figure 1 is given.
Figure 1: an example of an undirected graph
The following path shown in Figure 2 satisfies the condition.
Figure 2: an example of a path that satisfies the condition
However, the following path shown in Figure 3 does not satisfy the condition, because it does not visit all the vertices.
Figure 3: an example of a path that does not satisfy the condition
Neither the following path shown in Figure 4, because it does not start from vertex 1.
Figure 4: another example of a path that does not satisfy the condition

-----Constraints-----
 - 2≦N≦8 
 - 0≦M≦N(N-1)/2 
 - 1≦a_i<b_i≦N 
 - The given graph contains neither self-loops nor double edges.

-----Input-----
The input is given from Standard Input in the following format:
N M  
a_1 b_1  
a_2 b_2
:  
a_M b_M  

-----Output-----
Print the number of the different paths that start from vertex 1 and visit all the vertices exactly once.

-----Sample Input-----
3 3
1 2
1 3
2 3

-----Sample Output-----
2

The given graph is shown in the following figure:
The following two paths satisfy the condition:
"""
2022-04-16 20:24:11.040586 --------------------------
2022-04-16 20:24:34.818069 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef perm(i, n):\n    if i == n:\n        return 1\n    else:\n        return i * perm(i+1, n)\n\ndef combination(n, r):\n    return perm(n, n-r+1) // perm(1, r)\n\ndef main():\n    n, m = map(int, input().split())\n    x = [0 for _ in range(m)]\n    y = [0 for _ in range(m)]\n    for i in range(m):\n        x[i], y[i] = map(int, input().split())\n    print(combination(n-1, m))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn, m = map(int, input().split())\n\n#build the graph\ngraph = [[] for i in range(n+1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n#store all the possible paths\npaths = []\n\n#create a path\ndef create_path(current_path, visited, start, end):\n    #backtrack\n    if visited == (1<<n)-1:\n        #add the current path to the paths array\n        paths.append(current_path[:])\n        return\n\n    #check if the node is visited\n    if visited & (1<<start):\n        return\n\n    #set the node as visited\n    visited |= 1<<start\n\n    #go through all the neighbours\n    for i in graph[start]:\n        #if the node is not visited\n        if not visited & (1<<i):\n            #add it to the current path\n            current_path.append(i)\n            #create a path from the current one\n            create_path(current_path, visited, i, end)\n            #remove it from the current path\n            current_path.pop()\n    \n    #set the node as not visited\n    visited &= ~(1<<start)\n\n#the start node is 1\nstart = 1\n#the end node is n\nend = n\n\n#create a path\ncreate_path([1], 0, start, end)\n\n#print the length of the paths array\nprint(len(paths))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport numpy as np\ndef permutation(n):\n\tif n == 1:\n\t\treturn 1\n\treturn n * permutation(n-1)\n\ndef dfs(graph, start, goal, max_depth, path, visited):\n\tif max_depth == 0:\n\t\treturn path\n\tif start == goal:\n\t\treturn path\n\tfor i in range(1, len(graph[start])):\n\t\tif graph[start][i] == 1 and visited[i] == 0:\n\t\t\tvisited[i] = 1\n\t\t\tpath.append(i)\n\t\t\tresult = dfs(graph, i, goal, max_depth-1, path, visited)\n\t\t\tif result != None:\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\tpath.pop()\n\t\t\t\tvisited[i] = 0\n\treturn None\n\nN, M = map(int, input().split())\ngraph = np.zeros((N+1, N+1), dtype=np.int32)\nfor i in range(M):\n\ta, b = map(int, input().split())\n\tgraph[a][b] = 1\n\tgraph[b][a] = 1\n\nvisited = np.zeros(N+1, dtype=np.int32)\nvisited[1] = 1\n\npath = [1]\nresult = dfs(graph, 1, N, N-1, path, visited)\nif result == None:\n\tprint(0)\nelse:\n\tprint(permutation(N-1))"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\ndef read_ints():\n    return list(map(int, stdin.readline().split()))\n\ndef read_int_edges(n):\n    edges = []\n    for _ in range(n-1):\n        edges.append(read_ints())\n    return edges\n\ndef create_adj(edges, n):\n    adj = [[] for _ in range(n)]\n    for edge in edges:\n        adj[edge[0]-1].append(edge[1])\n        adj[edge[1]-1].append(edge[0])\n    return adj\n\ndef dfs(adj, curr):\n    if curr == 0:\n        return 1\n    total = 0\n    for neighbor in adj[curr]:\n        if not visited[neighbor]:\n            visited[neighbor] = True\n            total += dfs(adj, neighbor)\n            visited[neighbor] = False\n    return total\n\ndef main():\n    n, m = read_ints()\n    edges = read_int_edges(m)\n    adj = create_adj(edges, n)\n    global visited\n    visited = [True] * n\n    print(dfs(adj, 1))\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\nclass Problem():\n    def __init__(self):\n        self.graph = None\n        self.cache = {}\n    \n    def read(self):\n        def read_graph():\n            n, m = map(int, sys.stdin.readline().split())\n            graph = [[] for _ in range(n)]\n            for _ in range(m):\n                a, b = map(int, sys.stdin.readline().split())\n                graph[a - 1].append(b - 1)\n                graph[b - 1].append(a - 1)\n            return graph\n        self.graph = read_graph()\n\n    def solve(self):\n        def get_path_count(cur, visited):\n            if visited == (1 << n) - 1:\n                return 1\n            key = (cur, visited)\n            if key in self.cache:\n                return self.cache[key]\n            count = 0\n            for next in self.graph[cur]:\n                if (visited >> next) & 1:\n                    continue\n                count += get_path_count(next, visited | (1 << next))\n            self.cache[key] = count\n            return count\n        n = len(self.graph)\n        return get_path_count(0, 1)\n\ndef main():\n    problem = Problem()\n    problem.read()\n    print(problem.solve())\n\nif __name__ == '__main__':\n    sys.exit(main())"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\ndef dfs(graph, v, visited):\n    visited += [v]\n    for e in graph[v]:\n        if not e in visited:\n            dfs(graph, e, visited)\n    return visited\n\ndef main():\n    n, m = map(int, input().split())\n    graph = {i:[] for i in range(1, n+1)}\n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    v = 1\n    visited = []\n    visited = dfs(graph, v, visited)\n    if len(visited) == n:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\nn, m = map(int, sys.stdin.readline().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, sys.stdin.readline().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\nvisited = [False] * n\nans = 0\n\ndef dfs(v, count):\n    global ans\n    visited[v] = True\n    count += 1\n    if count == n:\n        ans += 1\n        return\n    for e in edges[v]:\n        if not visited[e]:\n            dfs(e, count)\n    visited[v] = False\n    return\n\ndfs(0, 0)\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    N, M = map(int,input().split())\n    A = [[] for i in range(N+1)]\n    for i in range(M):\n        a,b = map(int,input().split())\n        A[a].append(b)\n        A[b].append(a)\n    print(dfs(A,N))\n\ndef dfs(G,N):\n    visited = [False for i in range(N+1)]\n    visited[1] = True\n    ans = dfs_rec(G,1,N,visited)\n    return ans\n\ndef dfs_rec(G,v,N,visited):\n    if v == N:\n        return 1\n    ans = 0\n    for i in G[v]:\n        if visited[i]:\n            continue\n        visited[i] = True\n        ans += dfs_rec(G,i,N,visited)\n        visited[i] = False\n    return ans\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650140651,
  "id": "cmpl-4xjFjealr3nGEstv6LTIWhyOevZnd",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-16 20:24:34.818570 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef perm(i, n):\n    if i == n:\n        return 1\n    else:\n        return i * perm(i+1, n)\n\ndef combination(n, r):\n    return perm(n, n-r+1) // perm(1, r)\n\ndef main():\n    n, m = map(int, input().split())\n    x = [0 for _ in range(m)]\n    y = [0 for _ in range(m)]\n    for i in range(m):\n        x[i], y[i] = map(int, input().split())\n    print(combination(n-1, m))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:24:34.818704 REASON stop
2022-04-16 20:24:34.850189 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn, m = map(int, input().split())\n\n#build the graph\ngraph = [[] for i in range(n+1)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n#store all the possible paths\npaths = []\n\n#create a path\ndef create_path(current_path, visited, start, end):\n    #backtrack\n    if visited == (1<<n)-1:\n        #add the current path to the paths array\n        paths.append(current_path[:])\n        return\n\n    #check if the node is visited\n    if visited & (1<<start):\n        return\n\n    #set the node as visited\n    visited |= 1<<start\n\n    #go through all the neighbours\n    for i in graph[start]:\n        #if the node is not visited\n        if not visited & (1<<i):\n            #add it to the current path\n            current_path.append(i)\n            #create a path from the current one\n            create_path(current_path, visited, i, end)\n            #remove it from the current path\n            current_path.pop()\n    \n    #set the node as not visited\n    visited &= ~(1<<start)\n\n#the start node is 1\nstart = 1\n#the end node is n\nend = n\n\n#create a path\ncreate_path([1], 0, start, end)\n\n#print the length of the paths array\nprint(len(paths))"
}
2022-04-16 20:24:34.850387 REASON stop
2022-04-16 20:24:34.850949 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport numpy as np\ndef permutation(n):\n\tif n == 1:\n\t\treturn 1\n\treturn n * permutation(n-1)\n\ndef dfs(graph, start, goal, max_depth, path, visited):\n\tif max_depth == 0:\n\t\treturn path\n\tif start == goal:\n\t\treturn path\n\tfor i in range(1, len(graph[start])):\n\t\tif graph[start][i] == 1 and visited[i] == 0:\n\t\t\tvisited[i] = 1\n\t\t\tpath.append(i)\n\t\t\tresult = dfs(graph, i, goal, max_depth-1, path, visited)\n\t\t\tif result != None:\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\tpath.pop()\n\t\t\t\tvisited[i] = 0\n\treturn None\n\nN, M = map(int, input().split())\ngraph = np.zeros((N+1, N+1), dtype=np.int32)\nfor i in range(M):\n\ta, b = map(int, input().split())\n\tgraph[a][b] = 1\n\tgraph[b][a] = 1\n\nvisited = np.zeros(N+1, dtype=np.int32)\nvisited[1] = 1\n\npath = [1]\nresult = dfs(graph, 1, N, N-1, path, visited)\nif result == None:\n\tprint(0)\nelse:\n\tprint(permutation(N-1))"
}
2022-04-16 20:24:34.851029 REASON stop
2022-04-16 20:24:34.864323 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\ndef read_ints():\n    return list(map(int, stdin.readline().split()))\n\ndef read_int_edges(n):\n    edges = []\n    for _ in range(n-1):\n        edges.append(read_ints())\n    return edges\n\ndef create_adj(edges, n):\n    adj = [[] for _ in range(n)]\n    for edge in edges:\n        adj[edge[0]-1].append(edge[1])\n        adj[edge[1]-1].append(edge[0])\n    return adj\n\ndef dfs(adj, curr):\n    if curr == 0:\n        return 1\n    total = 0\n    for neighbor in adj[curr]:\n        if not visited[neighbor]:\n            visited[neighbor] = True\n            total += dfs(adj, neighbor)\n            visited[neighbor] = False\n    return total\n\ndef main():\n    n, m = read_ints()\n    edges = read_int_edges(m)\n    adj = create_adj(edges, n)\n    global visited\n    visited = [True] * n\n    print(dfs(adj, 1))\n\nmain()"
}
2022-04-16 20:24:34.864463 REASON stop
2022-04-16 20:24:34.865954 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\nclass Problem():\n    def __init__(self):\n        self.graph = None\n        self.cache = {}\n    \n    def read(self):\n        def read_graph():\n            n, m = map(int, sys.stdin.readline().split())\n            graph = [[] for _ in range(n)]\n            for _ in range(m):\n                a, b = map(int, sys.stdin.readline().split())\n                graph[a - 1].append(b - 1)\n                graph[b - 1].append(a - 1)\n            return graph\n        self.graph = read_graph()\n\n    def solve(self):\n        def get_path_count(cur, visited):\n            if visited == (1 << n) - 1:\n                return 1\n            key = (cur, visited)\n            if key in self.cache:\n                return self.cache[key]\n            count = 0\n            for next in self.graph[cur]:\n                if (visited >> next) & 1:\n                    continue\n                count += get_path_count(next, visited | (1 << next))\n            self.cache[key] = count\n            return count\n        n = len(self.graph)\n        return get_path_count(0, 1)\n\ndef main():\n    problem = Problem()\n    problem.read()\n    print(problem.solve())\n\nif __name__ == '__main__':\n    sys.exit(main())"
}
2022-04-16 20:24:34.866072 REASON stop
2022-04-16 20:24:34.883333 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\ndef dfs(graph, v, visited):\n    visited += [v]\n    for e in graph[v]:\n        if not e in visited:\n            dfs(graph, e, visited)\n    return visited\n\ndef main():\n    n, m = map(int, input().split())\n    graph = {i:[] for i in range(1, n+1)}\n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    v = 1\n    visited = []\n    visited = dfs(graph, v, visited)\n    if len(visited) == n:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == '__main__':\n    main()"
}
2022-04-16 20:24:34.883476 REASON stop
2022-04-16 20:24:34.885166 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\nn, m = map(int, sys.stdin.readline().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, sys.stdin.readline().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\nvisited = [False] * n\nans = 0\n\ndef dfs(v, count):\n    global ans\n    visited[v] = True\n    count += 1\n    if count == n:\n        ans += 1\n        return\n    for e in edges[v]:\n        if not visited[e]:\n            dfs(e, count)\n    visited[v] = False\n    return\n\ndfs(0, 0)\nprint(ans)"
}
2022-04-16 20:24:34.885276 REASON stop
2022-04-16 20:24:34.886596 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    N, M = map(int,input().split())\n    A = [[] for i in range(N+1)]\n    for i in range(M):\n        a,b = map(int,input().split())\n        A[a].append(b)\n        A[b].append(a)\n    print(dfs(A,N))\n\ndef dfs(G,N):\n    visited = [False for i in range(N+1)]\n    visited[1] = True\n    ans = dfs_rec(G,1,N,visited)\n    return ans\n\ndef dfs_rec(G,v,N,visited):\n    if v == N:\n        return 1\n    ans = 0\n    for i in G[v]:\n        if visited[i]:\n            continue\n        visited[i] = True\n        ans += dfs_rec(G,i,N,visited)\n        visited[i] = False\n    return ans\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-16 20:24:34.886717 REASON stop
