["n = int(input())\na = [int(x) for x in input().split()]\n\nres = {}\n\nfor i in range(n):\n  sm = 0\n  for j in range(i, n):\n    sm += a[j]\n    if sm in res:\n      res[sm].append((i, j))\n    else:\n      res[sm] = [(i, j)]\n\nbest = 0\nbestI = -1\nfor key in res:\n  r = -1\n  cnt = 0\n  for (a,b) in sorted(res[key]):\n    if a > r:\n      cnt += 1\n      r = b\n    elif b < r:\n      r = b\n  if cnt > best:\n    best = cnt\n    bestI = key\n\nx = []\nr = -1\nfor (a, b) in sorted(res[bestI]):\n  if a > r:\n    x.append(str(a+1) + \" \" + str(b+1))\n    r = b\n  elif b < r:\n    r = b\n    x.pop()\n    x.append(str(a+1) + \" \" + str(b+1))\n  \nprint(best)\nprint(\"\\n\".join(x))\n", "from collections import defaultdict\nn = int(input())\na = list(map(int, input().split()))\n\nrec = defaultdict(list)\nfor j in range(n):\n    for k in range(j, n):\n        rec[sum(a[j:k + 1])].append((j, k))\n\nans = []\nfor k in rec.keys():\n    tmp = []\n    rec[k] = sorted(rec[k], key=lambda x: x[1])\n    pre = -1\n    for a, b in rec[k]:\n        if pre >= a:\n            continue\n        else:\n            tmp.append((a + 1, b + 1))\n            pre = b\n    if len(tmp) > len(ans):\n        ans = tmp\n\nprint(len(ans))\nfor a, b in ans:\n    print(a, b)", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 100_000_000\n# from heapq import heappush, heappop\nfrom collections import defaultdict\nt = 1#int(input())\n# from math import sqrt\n\n\nfor test in range(t):\n    n = int(input())\n    # H, n = (map(int, input().split()))\n    # a = []\n    # for i in range(n):\n    # l = input()\n    # r = input()\n    a = (list((list(map(int, input().split())))))\n    pre = [0 for i in range(n+1)]\n\n    for i in range(n):\n        pre[i+1] = pre[i]+a[i]\n    \n    Sum = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i, n):\n            tmp = pre[j+1]-pre[i]\n            # print(i,j,tmp)\n            Sum[tmp].append((i,j))\n\n    maxVal = 0\n    maxSum = -1\n    for key, val in list(Sum.items()):\n        val.sort()\n        tmp = 1\n        cur = val[0][1]\n        for i in range(1,len(val)):\n            if val[i][0]>cur:\n                tmp+=1\n                cur = val[i][1]\n            elif val[i][1]<=cur:\n                cur = val[i][1]\n        if maxVal < tmp:\n            maxVal = tmp\n            maxSum = key\n\n    print(maxVal)\n    val = Sum[maxSum]\n    val.sort()\n    ans = []\n    ans.append(val[0])\n    cur = val[0][1]\n    for i in range(1,len(val)):\n        if val[i][0]>cur:\n            ans.append(val[i])\n            cur = val[i][1]\n        elif val[i][1]<=cur:\n            ans.pop()\n            ans.append(val[i])\n            cur = val[i][1]\n    for i in ans:\n        print(i[0]+1, i[1]+1)\n\n\n\n", "from collections import defaultdict as dd, deque\nn = int(input())\nA = [int(x) for x in input().split()]\ncA = [0]\nfor a in A:\n    cA.append(cA[-1] + a)\n\nB = dd(list)\n\nfor l in range(1,n+1):\n    for i in range(n-l+1):\n        s = cA[i+l] - cA[i]\n        B[s].append((i,i+l))\n\nbest = 0\nbestb = None\nfor b in sorted(B, key=lambda b: len(B[b]), reverse=True):\n    if best > len(B[b]):\n        break\n    A = sorted(B[b], key=lambda x: x[1])\n    res = 0\n    lr = -1\n    for l,r in A:\n        if lr <= l:\n            lr = r\n            res += 1\n\n    if res > best:\n        best = res\n        bestb = b\n\nprint(best)\nA = sorted(B[bestb], key=lambda x: x[1])\nres = 0\nlr = -1\nfor l,r in A:\n    if lr <= l:\n        lr = r\n        res += 1\n        print(l+1,r)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nfrom itertools import accumulate\nSUM=list(accumulate(A))\nSUM.append(0)\n\nBLIST=[[0]*n for i in range(n)]\nB2=[]\n\nfor i in range(n):\n    for j in range(i,n):\n        BLIST[i][j]=SUM[j]-SUM[i-1]\n        B2.append(SUM[j]-SUM[i-1])\n\nB2=set(B2)\nANS=[]\nANSLEN=0\n\nfor bsum in B2:\n    i=0\n    j=0\n    CANDI=[]\n    USED=-1\n\n    for i in range(n):\n        for j in range(USED+1,i+1):\n            if BLIST[j][i]==bsum:\n                CANDI.append([j+1,i+1])\n                USED=i\n                break\n\n    if len(CANDI)>ANSLEN:\n        ANS=CANDI\n        ANSLEN=len(CANDI)\n\nprint(len(ANS))\nfor ans in ANS:\n    print(*ans)\n        \n        \n", "n = int(input())\nA = list(map(int, input().split()))\nif n == 1:\n    print(1)\n    print(1, 1)\n    return\nprefA = [0]\nhah = {}\nfor i in A:\n    prefA.append(prefA[-1] + i)\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        s = prefA[j] - prefA[i]\n        if s not in hah:\n            hah[s] = []\n        hah[s].append([i + 1, j])\n\n\ndef lol(a):\n    return a[1], a[0]\n\n\nansq = 0\nbm = []\nfor s in hah:\n    Q = hah[s]\n    cnt = 0\n    Q.sort(key=lol)\n    ans = []\n    for i in Q:\n        if i[0] > cnt:\n            cnt = i[1]\n            ans.append(i)\n    if ansq < len(ans):\n        ansq = len(ans)\n        bm = ans\nprint(ansq)\nfor i in bm:\n    print(*i)\n", "n = int(input())\na = [int(t) for t in input().split(' ')]\n\np = [0] * (n+1)\nfor i in range(n):\n    p[i+1] = p[i] + a[i]\n\nsums = set()\nfor i in range(n):\n    for j in range(i+1, n+1):\n        sums.add(p[j] - p[i])\n\nINF = n+100\nbest_blocks = []\nfor s in sums:\n    blocks = []\n    leftmost_p = 0\n    while leftmost_p < INF:\n        leftmost_j = INF\n        according_i = -1\n        for i in range(leftmost_p, n):\n            if i >= leftmost_j: break\n            for j in range(i+1, n+1):\n                if j >= leftmost_j: break\n                if p[j] - p[i] == s and j < leftmost_j:\n                    leftmost_j = j\n                    according_i = i\n\n        leftmost_p = leftmost_j\n        if leftmost_j < INF:\n            blocks.append((according_i+1, leftmost_j))\n\n    if len(blocks) > len(best_blocks):\n        best_blocks = blocks\n\nprint(len(best_blocks))\nfor b in best_blocks:\n    print(*b)\n", "def get(arr):\n    r = 0\n    c = 0\n    for i in arr:\n        if i[0] > r:\n            c += 1\n            r = i[1]\n    return c        \n    \nn = int(input())\na = [int(x) for x in input().split()]\np = [0]\nd = {}\nfor i in a:\n    p.append(p[-1] + i)\nfor i in range(len(p)):\n    for j in range(i, len(p)):\n        if i != j:\n            r = p[j] - p[i]\n            d[r] = d.get(r, []) + [(i + 1, j)]\ns = 0\nfor i in d:\n    k = sorted(d[i], key=lambda x: x[1])\n    if get(k) > s:\n        s = get(k)\n        ind = k\nr = 0\nprint(s)\nfor i in ind:\n    if i[0] > r:\n        print(i[0], i[1])\n        r = i[1]", "def main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    if n == 1:\n        print(1)\n        print(1, 1)\n        return\n    prefA = [0]\n    hah = {}\n    for i in A:\n        prefA.append(prefA[-1] + i)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            s = prefA[j] - prefA[i]\n            if s not in hah:\n                hah[s] = []\n            hah[s].append([i + 1, j])\n\n\n    def lol(a):\n        return a[1], a[0]\n\n\n    ansq = 0\n    bm = []\n    for s in hah:\n        Q = hah[s]\n        cnt = 0\n        Q.sort(key=lol)\n        ans = []\n        for i in Q:\n            if i[0] > cnt:\n                cnt = i[1]\n                ans.append(i)\n        if ansq < len(ans):\n            ansq = len(ans)\n            bm = ans\n    print(ansq)\n    for i in bm:\n        print(i[0], i[1])\n\n\nmain()", "n=int(input())\narr=list(map(int,input().split()))\ndict1={}\nfor i in range(n):\n\tval=0\n\tfor j in range(i,n):\n\t\tval+=arr[j]\n\t\ttry:\n\t\t\tdict1[val].append((i,j))\n\t\texcept:\n\t\t\tKeyError\n\t\t\tdict1[val]=[(i,j)]\nans=0\nansarr=[]\nfor i in dict1.keys():\n\tif(len(dict1[i])>ans):\n\t\tarr2=[]\n\t\tfor j in range(len(dict1[i])):\n\t\t\tarr2.append((dict1[i][j][1]-dict1[i][j][0],j))\n\t\tarr2.sort()\n\t\ttemp=[]\n\t\tfor j in range(len(arr2)):\n\t\t\tflag=0\n\t\t\tindexi=dict1[i][arr2[j][1]][0]\n\t\t\tindexj=dict1[i][arr2[j][1]][1]\n\t\t\tfor k in range(len(temp)):\n\t\t\t\tif(temp[k][0]<=indexi<=temp[k][1] or temp[k][0]<=indexj<=temp[k][1] or indexi<=temp[k][0]<=indexj or indexi<=temp[k][1]<=indexj):\n\t\t\t\t\tflag=1\n\t\t\tif(flag==0):\n\t\t\t\ttemp.append((indexi,indexj))\n\t\tif(len(temp)>ans):\n\t\t\tans=len(temp)\n\t\t\tansarr=temp\nprint(ans)\nfinalans=[]\nfor i in range(len(ansarr)):\n\tfinalans.append(ansarr[i][0]+1)\n\tfinalans.append(ansarr[i][1]+1)\nprint(*finalans)", "n=int(input())\narr=list(map(int,input().split()))\ndict1={}\nfor i in range(n):\n\tval=0\n\tfor j in range(i,n):\n\t\tval+=arr[j]\n\t\ttry:\n\t\t\tdict1[val].append((i,j))\n\t\texcept:\n\t\t\tKeyError\n\t\t\tdict1[val]=[(i,j)]\nans=0\nansarr=[]\nfor i in list(dict1.keys()):\n\t#print(i,len(dict1[i]))\n\tif(len(dict1[i])>ans):\n\t\tarr2=[]\n\t\tfor j in range(len(dict1[i])):\n\t\t\tcount=0\n\t\t\tfor k in range(len(dict1[i])):\n\t\t\t\tif(dict1[i][k][0]<=dict1[i][j][0]<=dict1[i][k][1] or dict1[i][k][0]<=dict1[i][j][1]<=dict1[i][k][1]  or dict1[i][j][0]<=dict1[i][k][0]<=dict1[i][j][1]  or dict1[i][j][0]<=dict1[i][k][1]<=dict1[i][j][1]):\n\t\t\t\t\tcount+=1\n\t\t\tarr2.append((count,j))\n\t\tarr2.sort()\n\t\ttemp=[]\n\t\tfor j in range(len(arr2)):\n\t\t\tflag=0\n\t\t\tindexi=dict1[i][arr2[j][1]][0]\n\t\t\tindexj=dict1[i][arr2[j][1]][1]\n\t\t\tfor k in range(len(temp)):\n\t\t\t\tif(temp[k][0]<=indexi<=temp[k][1] or temp[k][0]<=indexj<=temp[k][1] or indexi<=temp[k][0]<=indexj or indexi<=temp[k][1]<=indexj):\n\t\t\t\t\tflag=1\n\t\t\tif(flag==0):\n\t\t\t\ttemp.append((indexi,indexj))\n\t\tif(len(temp)>ans):\n\t\t\tans=len(temp)\n\t\t\tansarr=temp\nprint(ans)\nfinalans=[]\nfor i in range(len(ansarr)):\n\tfinalans.append(ansarr[i][0]+1)\n\tfinalans.append(ansarr[i][1]+1)\nprint(*finalans)\n\n\n", "n=int(input())\narr=list(map(int,input().split()))\ndict1={}\nfor i in range(n):\n\tval=0\n\tfor j in range(i,n):\n\t\tval+=arr[j]\n\t\ttry:\n\t\t\tdict1[val].append((i,j))\n\t\texcept:\n\t\t\tKeyError\n\t\t\tdict1[val]=[(i,j)]\nans=0\nansarr=[]\nfor i in list(dict1.keys()):\n\t#print(i,len(dict1[i]))\n\tif(len(dict1[i])>ans):\n\t\tarr2=[]\n\t\tfor j in range(len(dict1[i])):\n\t\t\tcount=0\n\t\t\tfor k in range(len(dict1[i])):\n\t\t\t\tif(dict1[i][k][0]<=dict1[i][j][0]<=dict1[i][k][1] or dict1[i][k][0]<=dict1[i][j][1]<=dict1[i][k][1]  or dict1[i][j][0]<=dict1[i][k][0]<=dict1[i][j][1]  or dict1[i][j][0]<=dict1[i][k][1]<=dict1[i][j][1]):\n\t\t\t\t\tcount+=1\n\t\t\tarr2.append((count,j))\n\t\tarr2.sort()\n\t\ttemp=[]\n\t\tfor j in range(len(arr2)):\n\t\t\tflag=0\n\t\t\tindexi=dict1[i][arr2[j][1]][0]\n\t\t\tindexj=dict1[i][arr2[j][1]][1]\n\t\t\tfor k in range(len(temp)):\n\t\t\t\tif(temp[k][0]<=indexi<=temp[k][1] or temp[k][0]<=indexj<=temp[k][1] or indexi<=temp[k][0]<=indexj or indexi<=temp[k][1]<=indexj):\n\t\t\t\t\tflag=1\n\t\t\tif(flag==0):\n\t\t\t\ttemp.append((indexi,indexj))\n\t\tif(len(temp)>ans):\n\t\t\tans=len(temp)\n\t\t\tansarr=temp\nprint(ans)\nfinalans=[]\nfor i in range(len(ansarr)):\n\tfinalans.append(ansarr[i][0]+1)\n\tfinalans.append(ansarr[i][1]+1)\nprint(*finalans)\n\n\n", "from collections import defaultdict\nn = int(input())\nnums = [int(x) for x in input().split()]\nmapas = [defaultdict(list) for _ in range(n)]\nfor i, nu in enumerate(nums):\n\tif i:\n\t\tmapas[i] = defaultdict(list, mapas[i-1])\n\t# print(mapas[i])\n\tmapas[i][nu] = mapas[i][nu] + [(i+1,i+1)]\n\tsu = nu\n\tfor j in reversed(range(1, i)):\n\t\tsu += nums[j]\n\t\t# if su == -2:\n\t\t# \tprint(nu, 1+j, i+1, mapas[j-1][su])\n\t\tif len(mapas[j-1][su])+1 > len(mapas[i][su]):\n\t\t\tmapas[i][su] = mapas[j-1][su] + [(j+1, i+1)]\n\t# print(su)\n\tif i:\n\t\tsu += nums[0]\n\t\t# print(su, mapas[i])\n\t\tif len(mapas[i][su]) == 0:\n\t\t\tmapas[i][su] = [(1, i+1)]\n\t# print(mapas[i])\n\t# print()\n\t# mapas[i][su] = max(1, mapas[i][su])\nmx, my = -1,-1\n# print(mapas[-1])\nfor x, y in mapas[-1].items():\n\tif len(y)> my:\n\t\tmx, my = x, len(y)\n# print(mx, my)\nprint(my)\n# print(mapas[-1][mx])\nfor a, b in mapas[-1][mx]:\n\tprint(a, b)", "from collections import defaultdict\nn = int(input())\nnums = [int(x) for x in input().split()]\nmapas = [defaultdict(list) for _ in range(n)]\nfor i, nu in enumerate(nums):\n\tif i:\n\t\tmapas[i] = defaultdict(list, mapas[i-1])\n\t# print(mapas[i])\n\tmapas[i][nu] = mapas[i][nu] + [(i+1,i+1)]\n\tsu = nu\n\tfor j in reversed(range(1, i)):\n\t\tsu += nums[j]\n\t\t# if su == -2:\n\t\t# \tprint(nu, 1+j, i+1, mapas[j-1][su])\n\t\tif len(mapas[j-1][su])+1 > len(mapas[i][su]):\n\t\t\tmapas[i][su] = mapas[j-1][su] + [(j+1, i+1)]\n\t# print(su)\n\tif i:\n\t\tsu += nums[0]\n\t\t# print(su, mapas[i])\n\t\tif len(mapas[i][su]) == 0:\n\t\t\tmapas[i][su] = [(1, i+1)]\n\t# print(mapas[i])\n\t# print()\n\t# mapas[i][su] = max(1, mapas[i][su])\nmx, my = -1,-1\n# print(mapas[-1])\nfor x, y in mapas[-1].items():\n\tif len(y)> my:\n\t\tmx, my = x, len(y)\n# print(mx, my)\nprint(my)\n# print(mapas[-1][mx])\nfor a, b in mapas[-1][mx]:\n\tprint(a, b)", "n=int(input())\na=list(map(int,input().split()))\ndic={}\nfor i in range(n):\n    sm=0\n    for j in range(i,n):\n        sm+=a[j]\n        if sm in dic:\n            dic[sm].append((i,j))\n        else:\n            dic[sm]=[(i,j)]\nans=0\nanskey=-1\nfor key in dic:\n    cnt=0\n    last=-1\n    for a,b in sorted(dic[key]):\n        if a>last:\n            cnt+=1\n            last=b\n        elif b<last:\n            last=b\n    if cnt>ans:\n        ans=cnt\n        anskey=key\nlast=-1\ntmp=[]\nfor a,b in sorted(dic[anskey]):\n    if a>last:\n        last=b\n        tmp.append(str(a+1)+\" \"+str(b+1))\n    elif b<last:\n        last=b\n        tmp.pop()\n        tmp.append(str(a+1)+\" \"+str(b+1))\nprint(ans,'\\n'.join(tmp),sep='\\n')", "# import time\ndef index(key, item, index):\n    if key in index:\n        index[key].add(item)\n    else:\n        index[key] = set([item])\n\ndef schedule(times):\n    index_by_a = {}\n    index_by_b = {}\n    result_indexs = []\n    for i in range(len(times)):\n        a, b = times[i]\n        index(a, i, index_by_a)\n        index(b, i, index_by_b)\n    b_keys = sorted(list(index_by_b.keys()))\n    # a_keys = sorted(list(index_by_a.keys()))\n    a_min = 0\n    while 1:\n        # collect pool\n        pool = set()\n        for k, v in index_by_a.items():\n            if k >= a_min:\n                pool |= v\n        if not pool:\n            break\n        # greedy select.\n        for k in (ele for ele in b_keys if ele > a_min):\n            candidates = pool & index_by_b[k]\n            if candidates:\n                chosen = candidates.pop()\n                result_indexs.append(chosen)\n                a, b = times[chosen]\n                a_min = b\n                break\n    return [times[i] for i in result_indexs]\n                \ndef test_schedule():\n    i = ((0, 4), (2, 4), (0, 2), (0, 1), (1, 2), (2, 3), (3, 4))\n    result = schedule(i)\n    print('len:', len(result))\n    for ele in result:\n        print(ele)\n\ndef solve(n, a_l):\n    index_by_sum = {}\n    for i in range(n):\n        sum_ = 0\n        for j in range(i + 1, n + 1):\n            sum_ += a_l[j - 1]\n            if sum_ in index_by_sum:\n                index_by_sum[sum_].append((i, j))\n            else:\n                index_by_sum[sum_] = [(i, j)]\n    result = []\n    for sum_, times in index_by_sum.items():\n        sub_result = schedule(times)\n        if len(sub_result) > len(result):\n            result = sub_result\n    return result\n\ndef main():\n    n = int(input())\n    a_l = list(map(int, input().split()))\n    # tick = time.time()\n    result = solve(n, a_l)\n    print(len(result))\n    for a, b in result:\n        print(a + 1, b)\n    # tock = time.time()\n    # print('T:', round(tock - tick, 5))\n\ndef __starting_point():\n    main()\n__starting_point()", "from bisect import insort\nn = int(input())\na = list(map(int,input().split()))\ncm=[0]*(n+1)\nfor i in range(n):\n    cm[i+1] = cm[i]+a[i]\nd = dict()\nfor i in range(n):\n    for j in range(i,n):\n        sm = cm[j+1]-cm[i]\n        if sm in d:\n           insort(d[sm],(j,i))\n        else:\n           d[sm]=[(j,i)]\nans = 0\narr=list()\ntmparr=[None]*n\nfor sm in d:\n    ct=0\n    end=-1\n    for el in d[sm]:\n        if el[1]>end:\n           #print(ct,el)\n           tmparr[ct]=el\n           ct+=1\n           end=el[0]\n    if ct>ans:\n       #print(sm)\n       ans=ct\n       #print(tmparr[:ans])\n       arr=tmparr[:ans]\n#print(d)\nprint(ans)\nfor el in arr:\n    print(el[1]+1,el[0]+1)", "def func(arr):\n  count=0\n  biggest=-1\n  store=[]\n  for x in range(len(arr)):\n    if arr[x][0]>biggest:\n      store.append(arr[x])\n      biggest=arr[x][1]\n      count+=1\n  return count,store\ndef main():\n  n=int(input())\n  arr=input().split()\n  store=[]\n  for x in range(n):\n    arr[x]=int(arr[x])\n    total=0\n    for y in range(x,-1,-1):\n      total+=arr[y]\n      bo=True\n      for z in range(len(store)):\n        if total==store[z][0]:\n          bo=False\n          store[z][1].append((y,x))\n      if bo:\n        store.append([total,[(y,x)]])\n  #print(store)\n  biggest=0\n  big_val=[]\n  for  x in range(len(store)):\n    test,test_s=func(store[x][1])\n    if test>biggest:\n      biggest=test\n      big_val=test_s\n  print(biggest)\n  for x in range(len(big_val)):\n    print(big_val[x][0]+1,big_val[x][1]+1)\n  \nmain()\n", "from collections import defaultdict\nfrom itertools import accumulate\n\nN = int(input())\nH = defaultdict(lambda: [])\nA = list(map(int, input().split()))\nAA = [0] + list(accumulate(A))\nfor i in range(1, N+1):\n    for j in range(i):\n        H[AA[i] - AA[j]].append((i, j)) \nctr = 0\nans = []\nfor L in list(H.values()):\n    if ctr >= len(L):\n        continue\n    L.sort()\n    ansc = []\n    pi = -1\n    for i, j in L:\n        if j >= pi:\n            ansc.append((j+1, i))\n            pi = i\n    if ctr < len(ansc):\n        ans = ansc.copy()\n        ctr = len(ans)\nprint(ctr)\nfor j, i in ans:\n    print(j, i)\n", "franxx = int(input())\n\nlife = input()\nlife = life.split()\n\ndarling = {}\n\nfor i in range(0, franxx):\n\ttmp = 0\n\tfor j in range(i, franxx):\n\t\ttmp += int(life[j])\n\t\tdarling[tmp] = (franxx, 0)\n\nfor i in range(franxx, 0, -1):\n\ttmp = 0\n\tfor j in range(i - 1, franxx):\n\t\ttmp += int(life[j])\n\t\tif (darling[tmp][0] > j):\n\t\t\tdarling[tmp] = (i - 1, 1 + darling[tmp][1])\n\n\noh_pay = \"I love my darling\"\n\nfor i in range(0, franxx):\n\ttmp = 0\n\tfor j in range(i, franxx):\n\t\ttmp += int(life[j])\n\t\tif (oh_pay == \"I love my darling\" or darling[tmp][1] > darling[oh_pay][1]):\n\t\t\toh_pay = tmp\n\n\nprint(darling[oh_pay][1])\ndarling[oh_pay] = (franxx, 0)\n\nfor i in range(franxx, 0, -1):\n\ttmp = 0\n\tfor j in range(i - 1, franxx):\n\t\ttmp += int(life[j])\n\t\tif (tmp != oh_pay):\n\t\t\tcontinue;\n\t\tif (darling[oh_pay][0] > j):\n\t\t\tprint(i, j + 1)\n\t\t\tdarling[oh_pay] = (i - 1, 1 + darling[oh_pay][1])", "franxx = int(input())\n\nlife = input()\nlife = life.split()\n\ndarling = {}\n\nfor i in range(0, franxx):\n\ttmp = 0\n\tfor j in range(i, franxx):\n\t\ttmp += int(life[j])\n\t\tdarling[tmp] = (franxx, 0)\n\t\t\noh_pay = \"I love my darling\"\n\nfor i in range(franxx, 0, -1):\n\ttmp = 0\n\tfor j in range(i - 1, franxx):\n\t\ttmp += int(life[j])\n\t\tif (darling[tmp][0] > j):\n\t\t\tdarling[tmp] = (i - 1, 1 + darling[tmp][1])\n\t\t\tif (oh_pay == \"I love my darling\" or darling[tmp][1] > darling[oh_pay][1]):\n\t\t\t\toh_pay = tmp\n\nprint(darling[oh_pay][1])\ndarling[oh_pay] = (franxx, 0)\n\nfor i in range(franxx, 0, -1):\n\ttmp = 0\n\tfor j in range(i - 1, franxx):\n\t\ttmp += int(life[j])\n\t\tif (tmp != oh_pay):\n\t\t\tcontinue;\n\t\tif (darling[oh_pay][0] > j):\n\t\t\tprint(i, j + 1)\n\t\t\tdarling[oh_pay] = (i - 1, 1 + darling[oh_pay][1])", "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict\n\n\ndef find_max_non_intersecting(segments):\n    n = len(segments)\n\n    r = -1\n    result = []\n    for i in range(n):\n        a, b = segments[i]\n        if a > r:\n            result.append((a, b))\n            r = b\n\n    return result\n\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    s = []\n    for ai in a:\n        s.append((s[-1] if s else 0) + ai)\n\n    d = defaultdict(list)\n    for j in range(n):\n        for i in range(j + 1):\n            d[s[j] - (s[i - 1] if i - 1 >= 0 else 0)].append((i, j))\n\n    vals = []\n    for v in d.values():\n        non_inters = find_max_non_intersecting(v)\n        if len(non_inters) > len(vals):\n            vals = non_inters\n\n    print(len(vals))\n    for l, r in vals:\n        print(l + 1, r + 1)\n__starting_point()", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/19 23:30\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : F1. Same Sum Blocks (Easy).py\n\nfrom collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    sum_dict = defaultdict(list)\n    for r in range(n):\n        tmp = 0\n        for l in range(r, -1, -1):\n            tmp += a[l]\n            sum_dict[tmp].append((l + 1, r + 1))\n\n    ret, blocks = 0, []\n    for k, v in list(sum_dict.items()):\n        right, tmp = -1, 0\n        curr_list = []\n        for s in v:\n            if s[0] > right:\n                tmp += 1\n                curr_list.append(s)\n                right = s[1]\n        if tmp > ret:\n            ret = tmp\n            blocks = curr_list\n\n    print(ret)\n    for s in blocks:\n        print(*s)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\n\na=[int(i) for i in input().split()]\n\npref=[0]\n\nd={}\n\nfor x in range(len(a)):\n\tpref.append(pref[x]+a[x])\n\nfor r in range(n):\n\tfor l in range(0,r+1):\n\t\tv=pref[r+1]-pref[l]\n\n\t\tif(v in d):\n\t\t\td[v].append([l,r])\n\t\telse:\n\t\t\td[v]=[[l,r]]\n\nmaxi=-2\n\nmax_set=[]\n\nfor key in d:\n\n\tstart=-1\n\n\ttmp_set=[]\n\n\tctr=0\n\n\tfor e in range(len(d[key])):\n\n\t\tif(d[key][e][0]>start):\n\t\t\ttmp_set.append(d[key][e])\n\t\t\tstart=d[key][e][1]\n\t\t\tctr+=1\n\n\tif(ctr>maxi):\n\t\tmaxi=ctr\n\t\tmax_set=tmp_set\n\nprint(maxi)\nfor w in range(maxi):\n\tprint(max_set[w][0]+1,max_set[w][1]+1)\n\n\n", "from itertools import accumulate\n\nn = int(input())\narr = list(map(int, input().split()))\narr_sums = [0] + list(accumulate(arr))\n\nblocks = {}\nfor i in range(1, n+1):\n    for j in range(i):\n        total = arr_sums[i] - arr_sums[j]\n        if total not in blocks:\n            blocks[total] = [(j+1, i)]\n        else:\n            if blocks[total][-1][1] < j+1:\n                blocks[total].append((j+1, i))\n\nmax_block = sorted([(i, len(x)) for i, x in list(blocks.items())], key=lambda y: (-y[1], y[0]))\nprint(max_block[0][1])\nfor item in blocks[max_block[0][0]]:\n    print(item[0], item[1])\n\n"]