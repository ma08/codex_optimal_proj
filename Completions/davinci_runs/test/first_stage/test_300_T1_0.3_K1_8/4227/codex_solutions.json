["\n\nimport sys\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(M)]\n    print(len(edges))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef dfs(graph, start, end):\n    stack = []\n    stack.append(start)\n    visited = [False] * len(graph)\n\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n    return visited[end]\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    print(dfs(graph, 0, n-1))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    print(n, m)\n    print(edges)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef dfs(v):\n    global N, M, G, visited\n    visited[v] = True\n    for i in range(N):\n        if G[v][i] == 1 and not visited[i]:\n            dfs(i)\n\ndef main():\n    global N, M, G, visited\n    N, M = map(int, sys.stdin.readline().split())\n    G = [[0 for i in range(N)] for j in range(N)]\n    visited = [False for i in range(N)]\n    for i in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        G[a-1][b-1] = 1\n        G[b-1][a-1] = 1\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n    else:\n        print(2**(N-1))\n\nif __name__ == '__main__':\n    main()", "\n\nfrom collections import defaultdict\n\ndef get_input():\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        edges.append(tuple(map(int, input().split())))\n    return N, M, edges\n\ndef get_graph(N, edges):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return graph\n\ndef get_paths(N, graph):\n    paths = []\n    def dfs(graph, start, visited):\n        visited.add(start)\n        for next in graph[start]:\n            if next not in visited:\n                dfs(graph, next, visited)\n        visited.remove(start)\n        paths.append(visited.copy())\n    dfs(graph, 1, set())\n    return paths\n\ndef main():\n    N, M, edges = get_input()\n    graph = get_graph(N, edges)\n    paths = get_paths(N, graph)\n    print(len(paths))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(M)]\n    print(edges)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport itertools\n\ndef main():\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    edges = [[a-1, b-1] for a, b in edges]\n    edges = [[a, b] if a < b else [b, a] for a, b in edges]\n    edges = set(tuple(edge) for edge in edges)\n    vertices = [i for i in range(n)]\n    paths = itertools.permutations(vertices[1:])\n    paths = [[0] + list(path) for path in paths]\n    paths = [path for path in paths if all(path[i] < path[i+1] for i in range(n-1))]\n    paths = [path for path in paths if all(tuple(sorted([path[i], path[i+1]])) in edges for i in range(n-1))]\n    print(len(paths))\n\nif __name__ == '__main__':\n    main()"]