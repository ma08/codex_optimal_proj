["\n\n# import sys\n# #import math\n# #import collections\n#\n# T = int(sys.stdin.readline())\n#\n# for caseNr in xrange(1, T + 1):\n#     N = int(sys.stdin.readline())\n#     print \"Case #%i:\" % (caseNr)\n\nimport sys\n#import math\n#import collections\n\ndef get_next(s, i):\n    if s[i] == '?':\n        return (i + 1, '?')\n    elif s[i] == ')':\n        return (i + 1, ')')\n    elif s[i] == ':':\n        return (i + 1, ':')\n    elif s[i] == '-':\n        return (i + 1, '-')\n    elif s[i] == '>':\n        return (i + 1, '>')\n    elif s[i] == ',':\n        return (i + 1, ',')\n    elif s[i] == '.':\n        return (i + 1, '.')\n    elif s[i] == '+':\n        return (i + 1, '+')\n    elif s[i] == '*':\n        return (i + 1, '*')\n    elif s[i] == '/':\n        return (i + 1, '/')\n    elif s[i] == '<':\n        return (i + 1, '<')\n    elif s[i] == '(':\n        return (i + 1, '(')\n    elif s[i] == '_':\n        return (i + 1, '_')\n\ndef get_expr(s, i):\n    expr = []\n    while s[i] != ')':\n        if s[i] == '?':\n            expr.append('?')\n            i += 1\n        elif s[i] == '(':\n            i, subexpr = get_expr(s, i + 1)\n            expr.append(subexpr)\n        else:\n            i, op = get_next(s, i)\n            expr.append(op)\n    return (i + 1, expr)\n\ndef get_cond(s, i):\n    cond = []\n    while s[i] != '.':\n        i, expr = get_expr(s, i)\n        cond.append(expr)\n        i, op = get_next(s, i)\n        cond.append(op)\n    return (i + 1, cond)\n\ndef get_conds(s, i):\n    conds = []\n    while s[i] != '.':\n        i, cond = get_cond(s, i)\n        conds.append(cond)\n        i, op = get_next(s, i)\n        conds.append(op)\n    return (i + 1, conds)\n\ndef get_prog(s, i):\n    i, expr = get_expr(s, i + 1)\n    i, conds = get_conds(s, i)\n    return (i, (expr, conds))\n\ndef eval_expr(expr, vars):\n    if expr == '?':\n        return vars.pop(0)\n    elif expr == '+':\n        return (eval_expr(expr[0], vars) + eval_expr(expr[1], vars)) % 10\n    elif expr == '*':\n        return (eval_expr(expr[0], vars) * eval_expr(expr[1], vars)) % 10\n    elif expr == '/':\n        return (eval_expr(expr[0], vars) / eval_expr(expr[1], vars)) % 10\n    elif expr == '-':\n        return (eval_expr(expr[0], vars) - eval_expr(expr[1], vars)) % 10\n    else:\n        return expr\n\ndef eval_cond(cond, vars):\n    if cond[1] == '>':\n        return eval_expr(cond[0], vars) > eval_expr(cond[2], vars)\n    elif cond[1] == '<':\n        return eval_expr(cond[0], vars) < eval_expr(cond[2], vars)\n\ndef eval_conds(conds, vars):\n    if conds[1] == ',':\n        return eval_cond(conds[0], vars) and eval_conds(conds[2:], vars)\n    else:\n        return eval_cond(conds[0], vars)\n\ndef eval_prog(prog, vars):\n    if eval_conds(prog[1], vars):\n        return eval_expr(prog[0], vars)\n    else:\n        return None\n\ndef get_vars(prog):\n    vars = []\n    for expr in prog[0] + [cond[0] for cond in prog[1] if cond[1] in ('>', '<')] + [cond[2] for cond in prog[1] if cond[1] in ('>', '<')]:\n        if expr == '?':\n            vars.append(expr)\n        elif isinstance(expr, list):\n            vars += get_vars(expr)\n    return vars\n\ndef get_all_vars(prog):\n    vars = []\n    for expr in prog[0] + [cond[0] for cond in prog[1] if cond[1] in ('>', '<')] + [cond[2] for cond in prog[1] if cond[1] in ('>', '<')]:\n        if expr == '?':\n            vars.append(expr)\n        elif isinstance(expr, list):\n            vars += get_all_vars(expr)\n    return vars\n\ndef solve(prog):\n    vars = get_vars(prog)\n    vars_all = get_all_vars(prog)\n    if len(vars) != len(vars_all):\n        return None\n    for i in xrange(10**len(vars)):\n        vars_val = [int(v) for v in str(i).zfill(len(vars))]\n        if eval_prog(prog, vars_val) is not None:\n            return vars_val\n    return None\n\ndef print_prog(prog):\n    print prog[0]\n    print prog[1]\n\ndef main():\n    s = sys.stdin.readline().strip()\n    i, prog = get_prog(s, 0)\n    #print_prog(prog)\n    vars = solve(prog)\n    if vars is None:\n        print 'false'\n    else:\n        print ''.join(str(v) for v in vars)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    golorp = sys.stdin.readline().strip()\n    print(golorps(golorp))\n\ndef golorps(golorp):\n    #print(golorp)\n    if len(golorp) == 0:\n        return \"\"\n    if golorp[0] == '?':\n        return golorps(golorp[1:])\n    if golorp[0] == ':':\n        return golorps(golorp[1:])\n    if golorp[0] == '.':\n        return \"\"\n    if golorp[0] == '-':\n        return golorps(golorp[1:])\n    if golorp[0] == '>':\n        return golorps(golorp[1:])\n    if golorp[0] == '<':\n        return golorps(golorp[1:])\n    if golorp[0] == '_':\n        return \"0\" + golorps(golorp[1:])\n    if golorp[0] == '+':\n        return \"1\" + golorps(golorp[1:])\n    if golorp[0] == '*':\n        return \"2\" + golorps(golorp[1:])\n    if golorp[0] == '/':\n        return \"3\" + golorps(golorp[1:])\n    if golorp[0] == '(':\n        if golorp[1] == '_':\n            return \"0\" + golorps(golorp[2:])\n        if golorp[1] == '+':\n            return \"1\" + golorps(golorp[2:])\n        if golorp[1] == '*':\n            return \"2\" + golorps(golorp[2:])\n        if golorp[1] == '/':\n            return \"3\" + golorps(golorp[2:])\n    if golorp[0] == ')':\n        return golorps(golorp[1:])\n    return \"false\"\n\nif __name__ == \"__main__\":\n    main()", "\n\n#import sys\n#test_cases = open(sys.argv[1], 'r')\n#data = test_cases.readlines()\ndata = [\"?(_-_/___*__):-___>__.\"]\nfor test in data:\n\ttest = test.rstrip()\n\t# ignore test if it is an empty line\n\t# 'test' represents the test case, do something with it\n\t# ...\n\t# ...\n\n#test_cases.close()", "\n\nimport sys\n\ndef main():\n    name = sys.stdin.readline()\n    name = name.replace('?', '')\n    name = name.replace(':', '')\n    name = name.replace('-', '')\n    name = name.replace('>', '')\n    name = name.replace('<', '')\n    name = name.replace('.', '')\n    name = name.replace('(', '')\n    name = name.replace(')', '')\n    name = name.replace('_', '')\n    name = name.replace('+', '')\n    name = name.replace('*', '')\n    name = name.replace('/', '')\n    name = name.replace(' ', '')\n    name = name.replace('\\n', '')\n    name = name.replace('\\r', '')\n    if len(name) == 0:\n        print 'false'\n    else:\n        print name\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport math\nimport re\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    name = data[0]\n    print(feed_golorp(name))\n\ndef feed_golorp(name):\n    # Find the number of variables needed to feed the golorp\n    num_vars = find_num_vars(name)\n    # Generate all possible sequences of variables\n    vars_seqs = generate_vars_seqs(num_vars)\n    # Filter out the sequences that are invalid\n    valid_vars_seqs = filter_invalid_vars_seqs(vars_seqs, name)\n    # Return the lexicographically smallest sequence\n    return min(valid_vars_seqs)\n\ndef find_num_vars(name):\n    \"\"\"\n    Find the number of variables needed to feed the golorp.\n    \"\"\"\n    # Find the first ':' in the name\n    colon_idx = name.index(':')\n    # Find the first '-' in the name\n    dash_idx = name.index('-')\n    # Find the first '>' in the name\n    greater_idx = name.index('>')\n    # Find the first '.' in the name\n    period_idx = name.index('.')\n    # Find the number of variables needed to feed the golorp\n    num_vars = 0\n    for i in range(colon_idx + 1, dash_idx):\n        if name[i] == '_':\n            num_vars += 1\n    return num_vars\n\ndef generate_vars_seqs(num_vars):\n    \"\"\"\n    Generate all possible sequences of variables.\n    \"\"\"\n    # Generate all possible sequences of variables\n    vars_seqs = []\n    for i in range(0, 10 ** num_vars):\n        vars_seqs.append(str(i).zfill(num_vars))\n    return vars_seqs\n\ndef filter_invalid_vars_seqs(vars_seqs, name):\n    \"\"\"\n    Filter out the sequences that are invalid.\n    \"\"\"\n    # Find the first ':' in the name\n    colon_idx = name.index(':')\n    # Find the first '-' in the name\n    dash_idx = name.index('-')\n    # Find the first '>' in the name\n    greater_idx = name.index('>')\n    # Find the first '.' in the name\n    period_idx = name.index('.')\n    # Find the number of variables needed to feed the golorp\n    num_vars = 0\n    for i in range(colon_idx + 1, dash_idx):\n        if name[i] == '_':\n            num_vars += 1\n    # Find the number of operations in the name\n    num_ops = 0\n    for i in range(dash_idx + 1, greater_idx):\n        if name[i] in '+-*/':\n            num_ops += 1\n    # Find the number of comparisons in the name\n    num_comps = 0\n    for i in range(greater_idx + 1, period_idx):\n        if name[i] in '<>':\n            num_comps += 1\n    # Filter out the sequences that are invalid\n    valid_vars_seqs = []\n    for vars_seq in vars_seqs:\n        # Check if the sequence is valid\n        valid = True\n        # Check if the sequence is valid for the operations\n        for i in range(0, num_ops):\n            # Find the operation\n            op = name[dash_idx + 1 + i]\n            # Find the first variable\n            var1 = int(vars_seq[i])\n            # Find the second variable\n            var2 = int(vars_seq[i + 1])\n            # Check if the operation is valid\n            if op == '+':\n                if var1 + var2 > 9:\n                    valid = False\n            elif op == '-':\n                if var1 - var2 < 0:\n                    valid = False\n            elif op == '*':\n                if var1 * var2 > 9:\n                    valid = False\n            elif op == '/':\n                if var1 / var2 != math.floor(var1 / var2):\n                    valid = False\n        # Check if the sequence is valid for the comparisons\n        for i in range(0, num_comps):\n            # Find the comparison\n            comp = name[greater_idx + 1 + i]\n            # Find the first variable\n            var1 = int(vars_seq[num_ops + i])\n            # Find the second variable\n            var2 = int(vars_seq[num_ops + i + 1])\n            # Check if the comparison is valid\n            if comp == '>':\n                if var1 <= var2:\n                    valid = False\n            elif comp == '<':\n                if var1 >= var2:\n                    valid = False\n        # Add the sequence to the list of valid sequences\n        if valid:\n            valid_vars_seqs.append(vars_seq)\n    return valid_vars_seqs\n\nif __name__ == \"__main__\":\n    main()"]