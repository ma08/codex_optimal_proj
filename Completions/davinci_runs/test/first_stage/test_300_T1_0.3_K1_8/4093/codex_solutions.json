["\n\n# SOLUTION\n# This is a simple math problem.\n# If the sum of the array is m, then the difference between the max and min element is m.\n# The max difference between adjacent elements is the difference between the max and min element.\n# So the answer is m.\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    print(m)", "\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        if n == 1:\n            print(0)\n        elif n == 2:\n            print(m)\n        elif n == m:\n            print(n-1)\n        else:\n            print(2*m)\n\nif __name__ == \"__main__\":\n    main()", "\n\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    if n == 1:\n        print(0)\n    elif n == 2:\n        print(m)\n    else:\n        print(m * 2)", "\n\n# SOLUTION\n# The solution is based on the fact that the sum of the absolute differences is maximized when the elements of the array are as far apart as possible.\n# The solution is to fill the array with the largest possible elements first, and then fill the remaining slots with the smallest possible elements.\n\n# The smallest possible element is 0.\n# The largest possible element is the sum of the array divided by the number of elements.\n# If the sum of the array is not divisible by the number of elements, then the largest possible element is the sum of the array divided by the number of elements + 1.\n\n# The time complexity is O(n)\n# The space complexity is O(n)\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    # If the sum of the array is not divisible by the number of elements, then the largest possible element is the sum of the array divided by the number of elements + 1.\n    if m % n != 0:\n        print(n * (m // n + 1) - m)\n    # If the sum of the array is divisible by the number of elements, then the largest possible element is the sum of the array divided by the number of elements.\n    else:\n        print(n * (m // n) - m)", "\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        if n == 1:\n            print(0)\n        elif n == 2:\n            print(m)\n        else:\n            print(m * 2)\n\nif __name__ == \"__main__\":\n    main()", "\n\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        print(max(m - n + 1, 0))\n\n\nif __name__ == '__main__':\n    main()", "\n\n# SOLUTION\n# This is a simple greedy problem.\n# The optimal answer is to have the maximum possible difference between adjacent elements.\n# This can be achieved by having the minimum element and the maximum element as far apart as possible.\n# The minimum element is always 0.\n# The maximum element is always the sum of all the elements.\n# The difference between the minimum and the maximum element is the sum of all the elements.\n# Thus, the answer is always the sum of all the elements.\n\nt = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    print(m)", "\n\n# SOLUTION\n# This is a greedy problem.\n# The goal is to maximize the sum of absolute differences between adjacent (consecutive) elements.\n# The absolute difference between two numbers is maximized when the two numbers are as far apart as possible.\n# So, we want to construct an array where the numbers are as far apart as possible.\n# The numbers are non-negative integers, so the farthest apart they can be is when one number is 0 and the other is the maximum possible value.\n# The maximum possible value is the sum of the array divided by the number of elements.\n# The sum of the array is given, so we can calculate the maximum possible value.\n# Now, we want to construct an array where the numbers are as close to the maximum possible value as possible.\n# We can do this by assigning the maximum possible value to the first element, and then subtracting 1 from the maximum possible value and assigning it to the second element, and so on.\n# We can do this until we reach the maximum possible value - 1.\n# Then, we can assign the remaining sum to the last element.\n\n# The time complexity is O(n) because we have to iterate through the array once.\n# The space complexity is O(1) because we don't use any additional space.\n\n# CODE\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    max_val = m // n\n    print((max_val - 1) * (n - 1) + m - max_val * (n - 1))"]