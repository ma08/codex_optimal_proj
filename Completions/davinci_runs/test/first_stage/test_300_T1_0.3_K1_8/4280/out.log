2022-04-20 03:55:38.533095 """
Treeland consists of $n$ cities and $n-1$ roads. Each road is bidirectional and connects two distinct cities. From any city you can get to any other city by roads. Yes, you are right — the country's topology is an undirected tree.

There are some private road companies in Treeland. The government decided to sell roads to the companies. Each road will belong to one company and a company can own multiple roads.

The government is afraid to look unfair. They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city. The government wants to make such privatization that the number of such cities doesn't exceed $k$ and the number of companies taking part in the privatization is minimal.

Choose the number of companies $r$ such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most $k$. In other words, if for a city all the roads belong to the different companies then the city is good. Your task is to find the minimal $r$ that there is such assignment to companies from $1$ to $r$ that the number of cities which are not good doesn't exceed $k$. [Image] The picture illustrates the first example ($n=6, k=2$). The answer contains $r=2$ companies. Numbers on the edges denote edge indices. Edge colors mean companies: red corresponds to the first company, blue corresponds to the second company. The gray vertex (number $3$) is not good. The number of such vertices (just one) doesn't exceed $k=2$. It is impossible to have at most $k=2$ not good cities in case of one company. 


-----Input-----

The first line contains two integers $n$ and $k$ ($2 \le n \le 200000, 0 \le k \le n - 1$) — the number of cities and the maximal number of cities which can have two or more roads belonging to one company.

The following $n-1$ lines contain roads, one road per line. Each line contains a pair of integers $x_i$, $y_i$ ($1 \le x_i, y_i \le n$), where $x_i$, $y_i$ are cities connected with the $i$-th road.


-----Output-----

In the first line print the required $r$ ($1 \le r \le n - 1$). In the second line print $n-1$ numbers $c_1, c_2, \dots, c_{n-1}$ ($1 \le c_i \le r$), where $c_i$ is the company to own the $i$-th road. If there are multiple answers, print any of them.


-----Examples-----
Input
6 2
1 4
4 3
3 5
3 6
5 2

Output
2
1 2 1 1 2 
Input
4 2
3 1
1 4
1 2

Output
1
1 1 1 
Input
10 2
10 3
1 2
1 3
1 4
2 5
2 6
2 7
3 8
3 9

Output
3
1 1 2 3 2 3 1 3 1
"""
2022-04-20 03:55:38.533129 --------------------------
2022-04-20 03:55:38.533278 using api key derek
2022-04-20 03:57:16.904782 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    roads = []\n    for i in range(n-1):\n        roads.append(list(map(int, sys.stdin.readline().split())))\n    print(n-1)\n    for i in range(n-1):\n        print(1, end=' ')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    color = [0] * (n+1)\n    def dfs(v, c):\n        color[v] = c\n        for u in adj[v]:\n            if color[u] == 0:\n                dfs(u, c)\n    c = 1\n    for i in range(1, n+1):\n        if color[i] == 0:\n            dfs(i, c)\n            c += 1\n    print(c-1)\n    print(*color[1:])\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport collections\nimport queue\n\nsys.setrecursionlimit(10000)\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\ndef read_int():\n    return int(input())\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return input().split(' ')\n\ndef read_grid(H, W):\n    return [read_str() for _ in range(H)]\n\ndef read_ints_grid(H, W):\n    return [[int(v) for v in read_str().split(' ')] for _ in range(H)]\n\ndef read_int_grid(H, W):\n    return [[int(v) for v in read_str().split(' ')] for _ in range(H)]\n\ndef read_ints_arr(N):\n    return [read_ints() for _ in range(N)]\n\ndef read_int_arr(N):\n    return [read_int() for _ in range(N)]\n\ndef read_str_arr(N):\n    return [read_str() for _ in range(N)]\n\ndef read_strs_arr(N):\n    return [read_strs() for _ in range(N)]\n\ndef read_grid_arr(N):\n    return [read_grid() for _ in range(N)]\n\ndef read_ints_grid_arr(N):\n    return [read_ints_grid() for _ in range(N)]\n\ndef read_int_grid_arr(N):\n    return [read_int_grid() for _ in range(N)]\n\ndef read_ints_arr_arr(N):\n    return [read_ints_arr() for _ in range(N)]\n\ndef read_int_arr_arr(N):\n    return [read_int_arr() for _ in range(N)]\n\ndef read_str_arr_arr(N):\n    return [read_str_arr() for _ in range(N)]\n\ndef read_strs_arr_arr(N):\n    return [read_strs_arr() for _ in range(N)]\n\ndef read_grid_arr_arr(N):\n    return [read_grid_arr() for _ in range(N)]\n\ndef read_ints_grid_arr_arr(N):\n    return [read_ints_grid_arr() for _ in range(N)]\n\ndef read_int_grid_arr_arr(N):\n    return [read_int_grid_arr() for _ in range(N)]\n\ndef solve(n, k, edges):\n    adj = [[] for _ in range(n)]\n    for x, y in edges:\n        adj[x-1].append(y-1)\n        adj[y-1].append(x-1)\n\n    def dfs(v, p):\n        cnt = collections.Counter()\n        for u in adj[v]:\n            if u != p:\n                cnt[dfs(u, v)] += 1\n        if cnt:\n            return max(cnt.keys()) + 1\n        else:\n            return 0\n\n    r = dfs(0, -1)\n    print(r)\n    ans = [0] * (n-1)\n    for i in range(n-1):\n        x, y = edges[i]\n        ans[i] = r\n        for u in adj[x-1]:\n            if u != y-1:\n                ans[i] = min(ans[i], dfs(u, x-1))\n        for u in adj[y-1]:\n            if u != x-1:\n                ans[i] = min(ans[i], dfs(u, y-1))\n    print(*ans)\n\ndef main():\n    n, k = read_ints()\n    edges = [read_ints() for _ in range(n-1)]\n    solve(n, k, edges)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n    global k\n    global c\n    global color\n    global used\n    global g\n    global ans\n    used[v] = True\n    c[v] = color\n    for to in g[v]:\n        if to == p:\n            continue\n        if used[to]:\n            continue\n        if c[to] == color:\n            k -= 1\n            ans.append(to)\n            color += 1\n            continue\n        dfs(to, v)\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    g[x - 1].append(y - 1)\n    g[y - 1].append(x - 1)\n\nc = [0] * n\nused = [False] * n\ncolor = 1\nans = []\ndfs(0, -1)\nprint(color - 1)\nfor i in range(n - 1):\n    if i in ans:\n        print(c[i], end=\" \")\n    else:\n        print(c[i + 1], end=\" \")"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n    print(solve(graph, k))\n\ndef solve(graph, k):\n    n = len(graph)\n    colors = [-1] * n\n    colors[0] = 0\n    queue = [0]\n    while queue:\n        node = queue.pop()\n        for neighbor in graph[node]:\n            if colors[neighbor] == -1:\n                colors[neighbor] = colors[node] ^ 1\n                queue.append(neighbor)\n    bad = [0] * n\n    for node in range(n):\n        for neighbor in graph[node]:\n            if colors[node] == colors[neighbor]:\n                bad[node] += 1\n    return colors, bad\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = [int(x) for x in sys.stdin.readline().split()]\n    roads = []\n    for i in range(n-1):\n        roads.append([int(x) for x in sys.stdin.readline().split()])\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print"
    },
    {
      "finish_reason": "length",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def dfs(self, u, p, c):\n        self.color[u] = c\n        for v in self.edges[u]:\n            if v != p:\n                self.dfs(v, u, c)\n\n    def find_components(self):\n        self.color = [0] * self.n\n        c = 0\n        for u in range(self.n):\n            if self.color[u] == 0:\n                c += 1\n                self.dfs(u, -1, c)\n\n    def get_component(self, u):\n        return self.color[u] - 1\n\n    def get_component_size(self, c):\n        return self.component_size[c]\n\n    def calc_component_size(self):\n        self.component_size = [0] * self.n\n        for u in range(self.n):\n            self.component_size[self.get_component(u)] += 1\n\n    def get_component_edges(self, c):\n        return self.component_edges[c]\n\n    def calc_component_edges(self):\n        self.component_edges = [[] for _ in range(self.n)]\n        for u in range(self.n):\n            for v in self.edges[u]:\n                if self.get_component(u) != self.get_component(v):\n                    self.component_edges[self.get_component(u)].append(self.get_component(v))\n\n    def calc_component_degrees(self):\n        self.component_degrees = [0] * self.n\n        for c in range(self.n):\n            for v in self.component_edges[c]:\n                self.component_degrees[v] += 1\n\n    def get_component_degrees(self):\n        return self.component_degrees\n\n    def get_component_degree(self, c):\n        return self.component_degrees[c]\n\n    def calc_component_degrees_heap(self):\n        self.component_degrees_heap = []\n        for c in range(self.n):\n            if self.component_degrees[c] > 0:\n                heapq.heappush(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap(self):\n        return self.component_degrees_heap\n\n    def get_component_degrees_heap_top(self):\n        return self.component_degrees_heap[0]\n\n    def get_component_degrees_heap_pop(self):\n        return heapq.heappop(self.component_degrees_heap)\n\n    def get_component_degrees_heap_push(self, c):\n        heapq.heappush(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_pushpop(self, c):\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_replace(self, c):\n        return heapq.heapreplace(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_size(self):\n        return len(self.component_degrees_heap)\n\n    def get_component_degrees_heap_empty(self):\n        return len(self.component_degrees_heap) == 0\n\n    def get_component_degrees_heap_clear(self):\n        self.component_degrees_heap = []\n\n    def get_component_degrees_heap_remove(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        heapq.heapify(self.component_degrees_heap)\n\n    def get_component_degrees_heap_remove_top(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heapify(self.component_degrees_heap)\n\n    def get_component_degrees_heap_update(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        heapq.heappush(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap_update_top(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_pop(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        return heapq.heappushpop(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap_update_replace(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        return heapq.heapreplace(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap_update_remove_top(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_replace(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_replace_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_replace_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heapreplace(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_replace_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_replace_push_pushpop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_replace_push_pushpop_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop_push_pushpop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n        heapq.heappushpop(self.component_degrees_heap, c)\n       "
    },
    {
      "finish_reason": "length",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    edges = []\n    for i in range(n - 1):\n        edges.append(list(map(int, sys.stdin.readline().split())))\n    edges.sort(key=lambda x: x[0])\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)"
    }
  ],
  "created": 1650426938,
  "id": "cmpl-4yvjG5Mm3BcG6yTKORpbUD9WX2Hu0",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 03:57:16.905538 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    roads = []\n    for i in range(n-1):\n        roads.append(list(map(int, sys.stdin.readline().split())))\n    print(n-1)\n    for i in range(n-1):\n        print(1, end=' ')\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 03:57:16.905641 REASON stop
2022-04-20 03:57:16.906643 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    color = [0] * (n+1)\n    def dfs(v, c):\n        color[v] = c\n        for u in adj[v]:\n            if color[u] == 0:\n                dfs(u, c)\n    c = 1\n    for i in range(1, n+1):\n        if color[i] == 0:\n            dfs(i, c)\n            c += 1\n    print(c-1)\n    print(*color[1:])\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 03:57:16.906728 REASON stop
2022-04-20 03:57:16.907442 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport collections\nimport queue\n\nsys.setrecursionlimit(10000)\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\ndef read_int():\n    return int(input())\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return input().split(' ')\n\ndef read_grid(H, W):\n    return [read_str() for _ in range(H)]\n\ndef read_ints_grid(H, W):\n    return [[int(v) for v in read_str().split(' ')] for _ in range(H)]\n\ndef read_int_grid(H, W):\n    return [[int(v) for v in read_str().split(' ')] for _ in range(H)]\n\ndef read_ints_arr(N):\n    return [read_ints() for _ in range(N)]\n\ndef read_int_arr(N):\n    return [read_int() for _ in range(N)]\n\ndef read_str_arr(N):\n    return [read_str() for _ in range(N)]\n\ndef read_strs_arr(N):\n    return [read_strs() for _ in range(N)]\n\ndef read_grid_arr(N):\n    return [read_grid() for _ in range(N)]\n\ndef read_ints_grid_arr(N):\n    return [read_ints_grid() for _ in range(N)]\n\ndef read_int_grid_arr(N):\n    return [read_int_grid() for _ in range(N)]\n\ndef read_ints_arr_arr(N):\n    return [read_ints_arr() for _ in range(N)]\n\ndef read_int_arr_arr(N):\n    return [read_int_arr() for _ in range(N)]\n\ndef read_str_arr_arr(N):\n    return [read_str_arr() for _ in range(N)]\n\ndef read_strs_arr_arr(N):\n    return [read_strs_arr() for _ in range(N)]\n\ndef read_grid_arr_arr(N):\n    return [read_grid_arr() for _ in range(N)]\n\ndef read_ints_grid_arr_arr(N):\n    return [read_ints_grid_arr() for _ in range(N)]\n\ndef read_int_grid_arr_arr(N):\n    return [read_int_grid_arr() for _ in range(N)]\n\ndef solve(n, k, edges):\n    adj = [[] for _ in range(n)]\n    for x, y in edges:\n        adj[x-1].append(y-1)\n        adj[y-1].append(x-1)\n\n    def dfs(v, p):\n        cnt = collections.Counter()\n        for u in adj[v]:\n            if u != p:\n                cnt[dfs(u, v)] += 1\n        if cnt:\n            return max(cnt.keys()) + 1\n        else:\n            return 0\n\n    r = dfs(0, -1)\n    print(r)\n    ans = [0] * (n-1)\n    for i in range(n-1):\n        x, y = edges[i]\n        ans[i] = r\n        for u in adj[x-1]:\n            if u != y-1:\n                ans[i] = min(ans[i], dfs(u, x-1))\n        for u in adj[y-1]:\n            if u != x-1:\n                ans[i] = min(ans[i], dfs(u, y-1))\n    print(*ans)\n\ndef main():\n    n, k = read_ints()\n    edges = [read_ints() for _ in range(n-1)]\n    solve(n, k, edges)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 03:57:16.907552 REASON stop
2022-04-20 03:57:16.927287 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n    global k\n    global c\n    global color\n    global used\n    global g\n    global ans\n    used[v] = True\n    c[v] = color\n    for to in g[v]:\n        if to == p:\n            continue\n        if used[to]:\n            continue\n        if c[to] == color:\n            k -= 1\n            ans.append(to)\n            color += 1\n            continue\n        dfs(to, v)\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    g[x - 1].append(y - 1)\n    g[y - 1].append(x - 1)\n\nc = [0] * n\nused = [False] * n\ncolor = 1\nans = []\ndfs(0, -1)\nprint(color - 1)\nfor i in range(n - 1):\n    if i in ans:\n        print(c[i], end=\" \")\n    else:\n        print(c[i + 1], end=\" \")"
}
2022-04-20 03:57:16.927435 REASON stop
2022-04-20 03:57:16.928132 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n    print(solve(graph, k))\n\ndef solve(graph, k):\n    n = len(graph)\n    colors = [-1] * n\n    colors[0] = 0\n    queue = [0]\n    while queue:\n        node = queue.pop()\n        for neighbor in graph[node]:\n            if colors[neighbor] == -1:\n                colors[neighbor] = colors[node] ^ 1\n                queue.append(neighbor)\n    bad = [0] * n\n    for node in range(n):\n        for neighbor in graph[node]:\n            if colors[node] == colors[neighbor]:\n                bad[node] += 1\n    return colors, bad\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 03:57:16.928244 REASON stop
2022-04-20 03:57:16.948870 5 {
  "finish_reason": "length",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, k = [int(x) for x in sys.stdin.readline().split()]\n    roads = []\n    for i in range(n-1):\n        roads.append([int(x) for x in sys.stdin.readline().split()])\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print(roads)\n    #print(roads)\n    #print(n, k)\n    #print"
}
2022-04-20 03:57:16.949133 REASON length
2022-04-20 03:57:16.949156 6 {
  "finish_reason": "length",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def dfs(self, u, p, c):\n        self.color[u] = c\n        for v in self.edges[u]:\n            if v != p:\n                self.dfs(v, u, c)\n\n    def find_components(self):\n        self.color = [0] * self.n\n        c = 0\n        for u in range(self.n):\n            if self.color[u] == 0:\n                c += 1\n                self.dfs(u, -1, c)\n\n    def get_component(self, u):\n        return self.color[u] - 1\n\n    def get_component_size(self, c):\n        return self.component_size[c]\n\n    def calc_component_size(self):\n        self.component_size = [0] * self.n\n        for u in range(self.n):\n            self.component_size[self.get_component(u)] += 1\n\n    def get_component_edges(self, c):\n        return self.component_edges[c]\n\n    def calc_component_edges(self):\n        self.component_edges = [[] for _ in range(self.n)]\n        for u in range(self.n):\n            for v in self.edges[u]:\n                if self.get_component(u) != self.get_component(v):\n                    self.component_edges[self.get_component(u)].append(self.get_component(v))\n\n    def calc_component_degrees(self):\n        self.component_degrees = [0] * self.n\n        for c in range(self.n):\n            for v in self.component_edges[c]:\n                self.component_degrees[v] += 1\n\n    def get_component_degrees(self):\n        return self.component_degrees\n\n    def get_component_degree(self, c):\n        return self.component_degrees[c]\n\n    def calc_component_degrees_heap(self):\n        self.component_degrees_heap = []\n        for c in range(self.n):\n            if self.component_degrees[c] > 0:\n                heapq.heappush(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap(self):\n        return self.component_degrees_heap\n\n    def get_component_degrees_heap_top(self):\n        return self.component_degrees_heap[0]\n\n    def get_component_degrees_heap_pop(self):\n        return heapq.heappop(self.component_degrees_heap)\n\n    def get_component_degrees_heap_push(self, c):\n        heapq.heappush(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_pushpop(self, c):\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_replace(self, c):\n        return heapq.heapreplace(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_size(self):\n        return len(self.component_degrees_heap)\n\n    def get_component_degrees_heap_empty(self):\n        return len(self.component_degrees_heap) == 0\n\n    def get_component_degrees_heap_clear(self):\n        self.component_degrees_heap = []\n\n    def get_component_degrees_heap_remove(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        heapq.heapify(self.component_degrees_heap)\n\n    def get_component_degrees_heap_remove_top(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heapify(self.component_degrees_heap)\n\n    def get_component_degrees_heap_update(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        heapq.heappush(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap_update_top(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_pop(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        return heapq.heappushpop(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap_update_replace(self, c):\n        self.component_degrees_heap.remove((-self.component_degrees[c], c))\n        return heapq.heapreplace(self.component_degrees_heap, (-self.component_degrees[c], c))\n\n    def get_component_degrees_heap_update_remove_top(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_replace(self):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_replace_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_replace_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        return heapq.heapreplace(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_replace_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        return heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_replace_push_pushpop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_replace_push_pushpop_push_pushpop(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heapreplace(self.component_degrees_heap, self.component_degrees_heap[0])\n        return heapq.heappushpop(self.component_degrees_heap, c)\n\n    def get_component_degrees_heap_update_remove_top_pop_push_pushpop_push_pushpop_push(self, c):\n        self.component_degrees_heap.remove(self.component_degrees_heap[0])\n        heapq.heappush(self.component_degrees_heap, c)\n        heapq.heappushpop(self.component_degrees_heap, self.component_degrees_heap[0])\n        heapq.heappushpop(self.component_degrees_heap, c)\n       "
}
2022-04-20 03:57:16.949292 REASON length
2022-04-20 03:57:16.949305 7 {
  "finish_reason": "length",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    edges = []\n    for i in range(n - 1):\n        edges.append(list(map(int, sys.stdin.readline().split())))\n    edges.sort(key=lambda x: x[0])\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)\n    #print(edges)\n    #print(n, k)"
}
2022-04-20 03:57:16.949549 REASON length
