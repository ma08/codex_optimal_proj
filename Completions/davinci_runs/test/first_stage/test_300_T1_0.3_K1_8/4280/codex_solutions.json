["\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    roads = []\n    for i in range(n-1):\n        roads.append(list(map(int, sys.stdin.readline().split())))\n    print(n-1)\n    for i in range(n-1):\n        print(1, end=' ')\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport collections\nimport queue\n\nsys.setrecursionlimit(10000)\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\ndef read_int():\n    return int(input())\n\ndef read_str():\n    return input()\n\ndef read_strs():\n    return input().split(' ')\n\ndef read_grid(H, W):\n    return [read_str() for _ in range(H)]\n\ndef read_ints_grid(H, W):\n    return [[int(v) for v in read_str().split(' ')] for _ in range(H)]\n\ndef read_int_grid(H, W):\n    return [[int(v) for v in read_str().split(' ')] for _ in range(H)]\n\ndef read_ints_arr(N):\n    return [read_ints() for _ in range(N)]\n\ndef read_int_arr(N):\n    return [read_int() for _ in range(N)]\n\ndef read_str_arr(N):\n    return [read_str() for _ in range(N)]\n\ndef read_strs_arr(N):\n    return [read_strs() for _ in range(N)]\n\ndef read_grid_arr(N):\n    return [read_grid() for _ in range(N)]\n\ndef read_ints_grid_arr(N):\n    return [read_ints_grid() for _ in range(N)]\n\ndef read_int_grid_arr(N):\n    return [read_int_grid() for _ in range(N)]\n\ndef read_ints_arr_arr(N):\n    return [read_ints_arr() for _ in range(N)]\n\ndef read_int_arr_arr(N):\n    return [read_int_arr() for _ in range(N)]\n\ndef read_str_arr_arr(N):\n    return [read_str_arr() for _ in range(N)]\n\ndef read_strs_arr_arr(N):\n    return [read_strs_arr() for _ in range(N)]\n\ndef read_grid_arr_arr(N):\n    return [read_grid_arr() for _ in range(N)]\n\ndef read_ints_grid_arr_arr(N):\n    return [read_ints_grid_arr() for _ in range(N)]\n\ndef read_int_grid_arr_arr(N):\n    return [read_int_grid_arr() for _ in range(N)]\n\ndef solve(n, k, edges):\n    adj = [[] for _ in range(n)]\n    for x, y in edges:\n        adj[x-1].append(y-1)\n        adj[y-1].append(x-1)\n\n    def dfs(v, p):\n        cnt = collections.Counter()\n        for u in adj[v]:\n            if u != p:\n                cnt[dfs(u, v)] += 1\n        if cnt:\n            return max(cnt.keys()) + 1\n        else:\n            return 0\n\n    r = dfs(0, -1)\n    print(r)\n    ans = [0] * (n-1)\n    for i in range(n-1):\n        x, y = edges[i]\n        ans[i] = r\n        for u in adj[x-1]:\n            if u != y-1:\n                ans[i] = min(ans[i], dfs(u, x-1))\n        for u in adj[y-1]:\n            if u != x-1:\n                ans[i] = min(ans[i], dfs(u, y-1))\n    print(*ans)\n\ndef main():\n    n, k = read_ints()\n    edges = [read_ints() for _ in range(n-1)]\n    solve(n, k, edges)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p):\n    global k\n    global c\n    global color\n    global used\n    global g\n    global ans\n    used[v] = True\n    c[v] = color\n    for to in g[v]:\n        if to == p:\n            continue\n        if used[to]:\n            continue\n        if c[to] == color:\n            k -= 1\n            ans.append(to)\n            color += 1\n            continue\n        dfs(to, v)\n\nn, k = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    x, y = map(int, input().split())\n    g[x - 1].append(y - 1)\n    g[y - 1].append(x - 1)\n\nc = [0] * n\nused = [False] * n\ncolor = 1\nans = []\ndfs(0, -1)\nprint(color - 1)\nfor i in range(n - 1):\n    if i in ans:\n        print(c[i], end=\" \")\n    else:\n        print(c[i + 1], end=\" \")", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n    print(solve(graph, k))\n\ndef solve(graph, k):\n    n = len(graph)\n    colors = [-1] * n\n    colors[0] = 0\n    queue = [0]\n    while queue:\n        node = queue.pop()\n        for neighbor in graph[node]:\n            if colors[neighbor] == -1:\n                colors[neighbor] = colors[node] ^ 1\n                queue.append(neighbor)\n    bad = [0] * n\n    for node in range(n):\n        for neighbor in graph[node]:\n            if colors[node] == colors[neighbor]:\n                bad[node] += 1\n    return colors, bad\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    color = [0] * (n+1)\n    def dfs(v, c):\n        color[v] = c\n        for u in adj[v]:\n            if color[u] == 0:\n                dfs(u, c)\n    c = 1\n    for i in range(1, n+1):\n        if color[i] == 0:\n            dfs(i, c)\n            c += 1\n    print(c-1)\n    print(*color[1:])\n\nif __name__ == '__main__':\n    main()"]