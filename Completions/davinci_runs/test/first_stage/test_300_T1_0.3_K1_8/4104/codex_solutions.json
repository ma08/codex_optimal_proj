["\n\ndef main():\n    exp = input()\n    exp = exp.split(\"-\")\n    exp = [int(i) for i in exp]\n    print(sum(exp))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    expr = input()\n    print(eval(expr))\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n\texpr = input()\n\texpr = expr.split('+')\n\texpr = [int(i) for i in expr]\n\tprint(sum(expr))\n\nif __name__ == '__main__':\n\tmain()", "\n\ndef main():\n    expression = input()\n    result = 0\n    for i in range(len(expression)):\n        if expression[i] == '+':\n            result += int(expression[i+1])\n        elif expression[i] == '-':\n            result -= int(expression[i+1])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline().strip()\n    result = int(line[0])\n    for i in range(1, len(line), 2):\n        if line[i] == '+':\n            result += int(line[i+1])\n        else:\n            result -= int(line[i+1])\n    print(result)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    The bug is that the reference solution doesn't take into account the order of operations.\n    \"\"\"\n    expression = sys.stdin.readline().strip()\n    result = eval(expression)\n    print(result)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    expr = input()\n    print(eval(expr))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    expression = input()\n    expression = expression.split('+')\n    result = 0\n    for i in range(len(expression)):\n        if i == 0:\n            result = int(expression[i])\n        else:\n            result += int(expression[i])\n    print(result)\n\nif __name__ == '__main__':\n    main()"]