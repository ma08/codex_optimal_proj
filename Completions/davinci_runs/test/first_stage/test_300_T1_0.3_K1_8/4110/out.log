2022-04-20 02:22:47.700404 """
A programming competition site AtCode provides algorithmic problems.
Each problem is allocated a score based on its difficulty.
Currently, for each integer i between 1 and D (inclusive), there are p_i problems with a score of 100i points.
These p_1 + … + p_D problems are all of the problems available on AtCode.
A user of AtCode has a value called total score.
The total score of a user is the sum of the following two elements:
 - Base score: the sum of the scores of all problems solved by the user.
 - Perfect bonuses: when a user solves all problems with a score of 100i points, he/she earns the perfect bonus of c_i points, aside from the base score (1 ≤ i ≤ D).
Takahashi, who is the new user of AtCode, has not solved any problem.
His objective is to have a total score of G or more points.
At least how many problems does he need to solve for this objective?

-----Constraints-----
 - 1 ≤ D ≤ 10
 - 1 ≤ p_i ≤ 100
 - 100 ≤ c_i ≤ 10^6
 - 100 ≤ G
 - All values in input are integers.
 - c_i and G are all multiples of 100.
 - It is possible to have a total score of G or more points.

-----Input-----
Input is given from Standard Input in the following format:
D G
p_1 c_1
:
p_D c_D

-----Output-----
Print the minimum number of problems that needs to be solved in order to have a total score of G or more points. Note that this objective is always achievable (see Constraints).

-----Sample Input-----
2 700
3 500
5 800

-----Sample Output-----
3

In this case, there are three problems each with 100 points and five problems each with 200 points. The perfect bonus for solving all the 100-point problems is 500 points, and the perfect bonus for solving all the 200-point problems is 800 points. Takahashi's objective is to have a total score of 700 points or more.
One way to achieve this objective is to solve four 200-point problems and earn a base score of 800 points. However, if we solve three 100-point problems, we can earn the perfect bonus of 500 points in addition to the base score of 300 points, for a total score of 800 points, and we can achieve the objective with fewer problems.
"""
2022-04-20 02:22:47.700421 --------------------------
2022-04-20 02:22:47.700534 using api key gabby
2022-04-20 02:23:09.693646 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nD, G = map(int, input().split())\np = [0] * D\nc = [0] * D\nfor i in range(D):\n    p[i], c[i] = map(int, input().split())\n\nans = float('inf')\nfor i in range(2 ** D):\n    score = 0\n    num = 0\n    rest_max = -1\n    for j in range(D):\n        if (i >> j) & 1:\n            score += (j + 1) * 100 * p[j] + c[j]\n            num += p[j]\n        else:\n            rest_max = j\n    if score < G:\n        score += (rest_max + 1) * 100 * (p[rest_max] - 1) + c[rest_max]\n        num += p[rest_max] - 1\n        if score < G:\n            score += (rest_max + 1) * 100\n            num += 1\n    ans = min(ans, num)\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nD, G = map(int, input().split())\np_c = [list(map(int, input().split())) for _ in range(D)]\n\nans = float('inf')\nfor i in range(1 << D):\n    score = 0\n    num = 0\n    rest_max = -1\n    for j in range(D):\n        if (i >> j) & 1:\n            num += p_c[j][0]\n            score += p_c[j][0] * (j + 1) * 100 + p_c[j][1]\n        else:\n            rest_max = j\n    if score < G:\n        num += -(- (G - score) // ((rest_max + 1) * 100))\n    ans = min(ans, num)\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nD, G = map(int, input().split())\np = [0] * D\nc = [0] * D\nfor i in range(D):\n    p[i], c[i] = map(int, input().split())\n\nans = float('inf')\nfor i in range(2 ** D):\n    s = 0\n    cnt = 0\n    for j in range(D):\n        if (i >> j) & 1:\n            s += 100 * (j + 1) * p[j] + c[j]\n            cnt += p[j]\n    for j in range(D - 1, -1, -1):\n        if (i >> j) & 1 == 0:\n            for k in range(p[j] - 1):\n                if s >= G:\n                    break\n                s += 100 * (j + 1)\n                cnt += 1\n            break\n    if s < G:\n        continue\n    ans = min(ans, cnt)\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# D, G = map(int, input().split())\n# p_c = [tuple(map(int, input().split())) for _ in range(D)]\n#\n# ans = 10**9\n# for i in range(2**D):\n#     score = 0\n#     cnt = 0\n#     for j in range(D):\n#         if (i >> j) & 1:\n#             score += p_c[j][0] * (j+1) * 100 + p_c[j][1]\n#             cnt += p_c[j][0]\n#     for j in range(D-1, -1, -1):\n#         if (i >> j) & 1 == 0:\n#             for k in range(p_c[j][0]):\n#                 score += (j+1) * 100\n#                 cnt += 1\n#                 if score >= G:\n#                     ans = min(ans, cnt)\n#                     break\n#             if score >= G:\n#                 break\n# print(ans)\n\nD, G = map(int, input().split())\np_c = [tuple(map(int, input().split())) for _ in range(D)]\n\nans = 10**9\nfor i in range(2**D):\n    score = 0\n    cnt = 0\n    for j in range(D):\n        if (i >> j) & 1:\n            score += p_c[j][0] * (j+1) * 100 + p_c[j][1]\n            cnt += p_c[j][0]\n    for j in range(D-1, -1, -1):\n        if (i >> j) & 1 == 0:\n            if p_c[j][0] * (j+1) * 100 + score < G:\n                cnt += p_c[j][0]\n            else:\n                cnt += (G - score) // ((j+1) * 100)\n                if (G - score) % ((j+1) * 100) != 0:\n                    cnt += 1\n            break\n    ans = min(ans, cnt)\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\ndef main():\n    d, g = map(int, input().split())\n    p, c = [], []\n    for i in range(d):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    ans = 0\n    for i in range(d):\n        ans += p[i]\n        g -= 100 * i * p[i] + c[i]\n    if g <= 0:\n        print(ans)\n        return\n    i = d - 1\n    while i >= 0:\n        if g <= 0:\n            break\n        if g <= 100 * (i + 1) * (p[i] - 1):\n            ans += (g + 100 * (i + 1) - 1) // (100 * (i + 1))\n            break\n        else:\n            g -= 100 * (i + 1) * (p[i] - 1)\n            ans -= p[i] - 1\n        i -= 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\n# D, G = map(int, input().split())\n# p_c = [[int(x) for x in input().split()] for _ in range(D)]\n\nD, G = 2, 700\np_c = [[3, 500], [5, 800]]\n\nans = D * 100\nfor i in range(D):\n    for j in range(p_c[i][0]):\n        if G > 0:\n            G -= (i + 1) * 100\n            ans -= 1\n        else:\n            break\n    if G > 0:\n        G -= p_c[i][1]\n        if G <= 0:\n            ans -= 1\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\ndef main():\n    d, g = map(int, input().split())\n    problems = []\n    for i in range(d):\n        p, c = map(int, input().split())\n        problems.append([p, c])\n    ans = 100 * 100\n    for i in range(1 << d):\n        score = 0\n        num = 0\n        rest_max = -1\n        rest_num = 0\n        for j in range(d):\n            if (i >> j) & 1:\n                score += 100 * (j + 1) * problems[j][0] + problems[j][1]\n                num += problems[j][0]\n            else:\n                rest_max = j\n                rest_num = problems[j][0]\n        if score >= g:\n            ans = min(ans, num)\n        else:\n            score += 100 * (rest_max + 1)\n            num += rest_num\n            if score >= g:\n                ans = min(ans, num)\n            else:\n                need = (g - score + 100 * (rest_max + 1) - 1) // (100 * (rest_max + 1))\n                ans = min(ans, num + need)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    P = [0] * D\n    C = [0] * D\n    for i in range(D):\n        P[i], C[i] = map(int, input().split())\n    ans = 0\n    for i in range(D):\n        ans += P[i]\n        if G <= C[i]:\n            print(ans)\n            exit()\n        G -= C[i]\n    if G % 100 == 0:\n        print(ans + (G // 100))\n        exit()\n    for i in range(D-1, -1, -1):\n        if P[i] < G // 100 + 1:\n            continue\n        if G % (100 * (i+1)) == 0:\n            print(ans + (G // (100 * (i+1))))\n            exit()\n        else:\n            print(ans + (G // (100 * (i+1))) + 1)\n            exit()\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650421367,
  "id": "cmpl-4yuHP8RuaVKlgIHasO169dwoPNAwi",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 02:23:09.694066 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nD, G = map(int, input().split())\np = [0] * D\nc = [0] * D\nfor i in range(D):\n    p[i], c[i] = map(int, input().split())\n\nans = float('inf')\nfor i in range(2 ** D):\n    score = 0\n    num = 0\n    rest_max = -1\n    for j in range(D):\n        if (i >> j) & 1:\n            score += (j + 1) * 100 * p[j] + c[j]\n            num += p[j]\n        else:\n            rest_max = j\n    if score < G:\n        score += (rest_max + 1) * 100 * (p[rest_max] - 1) + c[rest_max]\n        num += p[rest_max] - 1\n        if score < G:\n            score += (rest_max + 1) * 100\n            num += 1\n    ans = min(ans, num)\nprint(ans)"
}
2022-04-20 02:23:09.694117 REASON stop
2022-04-20 02:23:09.694684 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nD, G = map(int, input().split())\np_c = [list(map(int, input().split())) for _ in range(D)]\n\nans = float('inf')\nfor i in range(1 << D):\n    score = 0\n    num = 0\n    rest_max = -1\n    for j in range(D):\n        if (i >> j) & 1:\n            num += p_c[j][0]\n            score += p_c[j][0] * (j + 1) * 100 + p_c[j][1]\n        else:\n            rest_max = j\n    if score < G:\n        num += -(- (G - score) // ((rest_max + 1) * 100))\n    ans = min(ans, num)\n\nprint(ans)"
}
2022-04-20 02:23:09.694746 REASON stop
2022-04-20 02:23:09.695265 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nD, G = map(int, input().split())\np = [0] * D\nc = [0] * D\nfor i in range(D):\n    p[i], c[i] = map(int, input().split())\n\nans = float('inf')\nfor i in range(2 ** D):\n    s = 0\n    cnt = 0\n    for j in range(D):\n        if (i >> j) & 1:\n            s += 100 * (j + 1) * p[j] + c[j]\n            cnt += p[j]\n    for j in range(D - 1, -1, -1):\n        if (i >> j) & 1 == 0:\n            for k in range(p[j] - 1):\n                if s >= G:\n                    break\n                s += 100 * (j + 1)\n                cnt += 1\n            break\n    if s < G:\n        continue\n    ans = min(ans, cnt)\nprint(ans)"
}
2022-04-20 02:23:09.695332 REASON stop
2022-04-20 02:23:09.737322 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# D, G = map(int, input().split())\n# p_c = [tuple(map(int, input().split())) for _ in range(D)]\n#\n# ans = 10**9\n# for i in range(2**D):\n#     score = 0\n#     cnt = 0\n#     for j in range(D):\n#         if (i >> j) & 1:\n#             score += p_c[j][0] * (j+1) * 100 + p_c[j][1]\n#             cnt += p_c[j][0]\n#     for j in range(D-1, -1, -1):\n#         if (i >> j) & 1 == 0:\n#             for k in range(p_c[j][0]):\n#                 score += (j+1) * 100\n#                 cnt += 1\n#                 if score >= G:\n#                     ans = min(ans, cnt)\n#                     break\n#             if score >= G:\n#                 break\n# print(ans)\n\nD, G = map(int, input().split())\np_c = [tuple(map(int, input().split())) for _ in range(D)]\n\nans = 10**9\nfor i in range(2**D):\n    score = 0\n    cnt = 0\n    for j in range(D):\n        if (i >> j) & 1:\n            score += p_c[j][0] * (j+1) * 100 + p_c[j][1]\n            cnt += p_c[j][0]\n    for j in range(D-1, -1, -1):\n        if (i >> j) & 1 == 0:\n            if p_c[j][0] * (j+1) * 100 + score < G:\n                cnt += p_c[j][0]\n            else:\n                cnt += (G - score) // ((j+1) * 100)\n                if (G - score) % ((j+1) * 100) != 0:\n                    cnt += 1\n            break\n    ans = min(ans, cnt)\nprint(ans)"
}
2022-04-20 02:23:09.737464 REASON stop
2022-04-20 02:23:09.740382 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\ndef main():\n    d, g = map(int, input().split())\n    p, c = [], []\n    for i in range(d):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    ans = 0\n    for i in range(d):\n        ans += p[i]\n        g -= 100 * i * p[i] + c[i]\n    if g <= 0:\n        print(ans)\n        return\n    i = d - 1\n    while i >= 0:\n        if g <= 0:\n            break\n        if g <= 100 * (i + 1) * (p[i] - 1):\n            ans += (g + 100 * (i + 1) - 1) // (100 * (i + 1))\n            break\n        else:\n            g -= 100 * (i + 1) * (p[i] - 1)\n            ans -= p[i] - 1\n        i -= 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:23:09.740468 REASON stop
2022-04-20 02:23:09.742171 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\n# D, G = map(int, input().split())\n# p_c = [[int(x) for x in input().split()] for _ in range(D)]\n\nD, G = 2, 700\np_c = [[3, 500], [5, 800]]\n\nans = D * 100\nfor i in range(D):\n    for j in range(p_c[i][0]):\n        if G > 0:\n            G -= (i + 1) * 100\n            ans -= 1\n        else:\n            break\n    if G > 0:\n        G -= p_c[i][1]\n        if G <= 0:\n            ans -= 1\n\nprint(ans)"
}
2022-04-20 02:23:09.742241 REASON stop
2022-04-20 02:23:09.743807 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\ndef main():\n    d, g = map(int, input().split())\n    problems = []\n    for i in range(d):\n        p, c = map(int, input().split())\n        problems.append([p, c])\n    ans = 100 * 100\n    for i in range(1 << d):\n        score = 0\n        num = 0\n        rest_max = -1\n        rest_num = 0\n        for j in range(d):\n            if (i >> j) & 1:\n                score += 100 * (j + 1) * problems[j][0] + problems[j][1]\n                num += problems[j][0]\n            else:\n                rest_max = j\n                rest_num = problems[j][0]\n        if score >= g:\n            ans = min(ans, num)\n        else:\n            score += 100 * (rest_max + 1)\n            num += rest_num\n            if score >= g:\n                ans = min(ans, num)\n            else:\n                need = (g - score + 100 * (rest_max + 1) - 1) // (100 * (rest_max + 1))\n                ans = min(ans, num + need)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:23:09.743871 REASON stop
2022-04-20 02:23:09.745485 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    P = [0] * D\n    C = [0] * D\n    for i in range(D):\n        P[i], C[i] = map(int, input().split())\n    ans = 0\n    for i in range(D):\n        ans += P[i]\n        if G <= C[i]:\n            print(ans)\n            exit()\n        G -= C[i]\n    if G % 100 == 0:\n        print(ans + (G // 100))\n        exit()\n    for i in range(D-1, -1, -1):\n        if P[i] < G // 100 + 1:\n            continue\n        if G % (100 * (i+1)) == 0:\n            print(ans + (G // (100 * (i+1))))\n            exit()\n        else:\n            print(ans + (G // (100 * (i+1))) + 1)\n            exit()\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:23:09.745653 REASON stop
