["\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, sys.stdin.readline().split())))\n    edges.sort(key=lambda x: x[0])\n    edges.sort(key=lambda x: x[1])\n    print(\"YES\")\n    for i in range(m):\n        if i % 2 == 0:\n            print(\"0\", end=\"\")\n        else:\n            print(\"1\", end=\"\")\n    print()\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.degrees = defaultdict(int)\n        self.nodes = set()\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n        self.degrees[u] += 1\n        self.degrees[v] += 1\n        self.nodes.add(u)\n        self.nodes.add(v)\n\n    def get_degrees(self):\n        return self.degrees\n\n    def get_nodes(self):\n        return self.nodes\n\n    def get_edges(self):\n        return self.edges\n\n    def get_neighbors(self, node):\n        return self.edges[node]\n\n    def get_degree(self, node):\n        return self.degrees[node]\n\n    def remove_edge(self, u, v):\n        self.edges[u].remove(v)\n        self.edges[v].remove(u)\n        self.degrees[u] -= 1\n        self.degrees[v] -= 1\n\n    def remove_node(self, node):\n        for neighbor in self.edges[node]:\n            self.remove_edge(node, neighbor)\n        self.nodes.remove(node)\n\ndef dfs(graph, node, visited, parent=None):\n    visited.add(node)\n    for neighbor in graph.get_neighbors(node):\n        if neighbor == parent:\n            continue\n        if neighbor in visited:\n            return False\n        if not dfs(graph, neighbor, visited, node):\n            return False\n    return True\n\ndef is_connected(graph):\n    visited = set()\n    return dfs(graph, next(iter(graph.get_nodes())), visited)\n\ndef is_tree(graph):\n    return is_connected(graph) and len(graph.get_nodes()) - 1 == len(graph.get_edges())\n\ndef can_be_directed(graph):\n    if not is_tree(graph):\n        return False\n    degrees = graph.get_degrees()\n    for node, degree in degrees.items():\n        if degree != 1:\n            return False\n    return True\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = Graph()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph.add_edge(u, v)\n    if can_be_directed(graph):\n        print(\"YES\")\n        for node, neighbors in graph.get_edges().items():\n            for neighbor in neighbors:\n                if neighbor > node:\n                    print(0, end=\"\")\n        print()\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, graph, visited, parent):\n    visited[v] = True\n    for u in graph[v]:\n        if not visited[u]:\n            parent[u] = v\n            dfs(u, graph, visited, parent)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    parent = [0] * (n + 1)\n    dfs(1, graph, visited, parent)\n    if False in visited:\n        print('NO')\n        return\n    print('YES')\n    for i in range(2, n + 1):\n        if parent[i] > i:\n            print(0, end='')\n        else:\n            print(1, end='')\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    for u in adj[v]:\n        if u == p:\n            continue\n        if u in seen:\n            return True\n        seen.add(u)\n        if dfs(u, v):\n            return True\n    return False\n\ndef main():\n    global adj\n    n, m = map(int, input().split())\n    adj = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for v in range(1, n+1):\n        if len(adj[v]) == 1:\n            seen = set()\n            if dfs(v, -1):\n                print(\"NO\")\n                return\n    print(\"YES\")\n    print(\"\".join(\"0\" if len(adj[v]) == 1 else \"1\" for v in range(1, n+1)))\n\nif __name__ == \"__main__\":\n    main()", "\n\n# SOLUTION\n# This is a very interesting problem.\n# The problem is equivalent to finding a directed graph with no cycles,\n# which is the same as a DAG (Directed Acyclic Graph).\n# This is a very well-known problem in graph theory.\n# The solution is to use a topological sort.\n# A topological sort is a linear ordering of the vertices in a DAG.\n# The idea is to keep a list of vertices with no incoming edges,\n# and then remove the edges from the graph and add the vertices with no incoming edges.\n# This is the same as a BFS, but instead of adding the neighbours to the queue,\n# we add the vertices with no incoming edges.\n# The algorithm is as follows:\n# 1. Create a list of vertices with no incoming edges.\n# 2. While the list is not empty, do the following:\n#   2.1. Pop a vertex from the list.\n#   2.2. Add the vertex to the output list.\n#   2.3. For each edge from this vertex to another vertex,\n#        remove the edge and if the other vertex has no incoming edges, add it to the list.\n# 3. If the graph is empty, return the output list.\n#    Otherwise, the graph has a cycle and is not a DAG.\n#\n# The time complexity is O(V + E), where V is the number of vertices,\n# and E is the number of edges.\n# The space complexity is O(V + E).\n\nfrom collections import defaultdict\n\ndef topological_sort(graph):\n    # Create a list of vertices with no incoming edges.\n    no_incoming_edges = [vertex for vertex in graph if not graph[vertex]]\n    # Create an empty output list.\n    output = []\n    # While the list is not empty, do the following:\n    while no_incoming_edges:\n        # Pop a vertex from the list.\n        vertex = no_incoming_edges.pop()\n        # Add the vertex to the output list.\n        output.append(vertex)\n        # For each edge from this vertex to another vertex,\n        # remove the edge and if the other vertex has no incoming edges, add it to the list.\n        for other_vertex in graph[vertex]:\n            graph[other_vertex].remove(vertex)\n            if not graph[other_vertex]:\n                no_incoming_edges.append(other_vertex)\n        # Remove the vertex from the graph.\n        del graph[vertex]\n    # If the graph is empty, return the output list.\n    # Otherwise, the graph has a cycle and is not a DAG.\n    return output if not graph else []\n\ndef main():\n    # Read the input.\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n    # Get the topological sort.\n    topological_sort = topological_sort(graph)\n    # Print the output.\n    if topological_sort:\n        print('YES')\n        print(''.join('0' if u in topological_sort else '1' for u, v in edges))\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    main()"]