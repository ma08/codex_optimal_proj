2022-04-20 03:36:59.767796 """
You are given a connected undirected graph consisting of $n$ vertices and $m$ edges. There are no self-loops or multiple edges in the given graph.

You have to direct its edges in such a way that the obtained directed graph does not contain any paths of length two or greater (where the length of path is denoted as the number of traversed edges).


-----Input-----

The first line contains two integer numbers $n$ and $m$ ($2 \le n \le 2 \cdot 10^5$, $n - 1 \le m \le 2 \cdot 10^5$) â€” the number of vertices and edges, respectively.

The following $m$ lines contain edges: edge $i$ is given as a pair of vertices $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). There are no multiple edges in the given graph, i. e. for each pair ($u_i, v_i$) there are no other pairs ($u_i, v_i$) and ($v_i, u_i$) in the list of edges. It is also guaranteed that the given graph is connected (there is a path between any pair of vertex in the given graph).


-----Output-----

If it is impossible to direct edges of the given graph in such a way that the obtained directed graph does not contain paths of length at least two, print "NO" in the first line.

Otherwise print "YES" in the first line, and then print any suitable orientation of edges: a binary string (the string consisting only of '0' and '1') of length $m$. The $i$-th element of this string should be '0' if the $i$-th edge of the graph should be directed from $u_i$ to $v_i$, and '1' otherwise. Edges are numbered in the order they are given in the input.


-----Example-----
Input
6 5
1 5
2 1
1 4
3 1
6 1

Output
YES
10100



-----Note-----

The picture corresponding to the first example: [Image]

And one of possible answers: $\text{of}$
"""
2022-04-20 03:36:59.767823 --------------------------
2022-04-20 03:36:59.767967 using api key sourya
2022-04-20 03:38:27.981419 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# SOLUTION\n# This is a very interesting problem.\n# The problem is equivalent to finding a directed graph with no cycles,\n# which is the same as a DAG (Directed Acyclic Graph).\n# This is a very well-known problem in graph theory.\n# The solution is to use a topological sort.\n# A topological sort is a linear ordering of the vertices in a DAG.\n# The idea is to keep a list of vertices with no incoming edges,\n# and then remove the edges from the graph and add the vertices with no incoming edges.\n# This is the same as a BFS, but instead of adding the neighbours to the queue,\n# we add the vertices with no incoming edges.\n# The algorithm is as follows:\n# 1. Create a list of vertices with no incoming edges.\n# 2. While the list is not empty, do the following:\n#   2.1. Pop a vertex from the list.\n#   2.2. Add the vertex to the output list.\n#   2.3. For each edge from this vertex to another vertex,\n#        remove the edge and if the other vertex has no incoming edges, add it to the list.\n# 3. If the graph is empty, return the output list.\n#    Otherwise, the graph has a cycle and is not a DAG.\n#\n# The time complexity is O(V + E), where V is the number of vertices,\n# and E is the number of edges.\n# The space complexity is O(V + E).\n\nfrom collections import defaultdict\n\ndef topological_sort(graph):\n    # Create a list of vertices with no incoming edges.\n    no_incoming_edges = [vertex for vertex in graph if not graph[vertex]]\n    # Create an empty output list.\n    output = []\n    # While the list is not empty, do the following:\n    while no_incoming_edges:\n        # Pop a vertex from the list.\n        vertex = no_incoming_edges.pop()\n        # Add the vertex to the output list.\n        output.append(vertex)\n        # For each edge from this vertex to another vertex,\n        # remove the edge and if the other vertex has no incoming edges, add it to the list.\n        for other_vertex in graph[vertex]:\n            graph[other_vertex].remove(vertex)\n            if not graph[other_vertex]:\n                no_incoming_edges.append(other_vertex)\n        # Remove the vertex from the graph.\n        del graph[vertex]\n    # If the graph is empty, return the output list.\n    # Otherwise, the graph has a cycle and is not a DAG.\n    return output if not graph else []\n\ndef main():\n    # Read the input.\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n    # Get the topological sort.\n    topological_sort = topological_sort(graph)\n    # Print the output.\n    if topological_sort:\n        print('YES')\n        print(''.join('0' if u in topological_sort else '1' for u, v in edges))\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, graph, visited, parent):\n    visited[v] = True\n    for u in graph[v]:\n        if not visited[u]:\n            parent[u] = v\n            dfs(u, graph, visited, parent)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    parent = [0] * (n + 1)\n    dfs(1, graph, visited, parent)\n    if False in visited:\n        print('NO')\n        return\n    print('YES')\n    for i in range(2, n + 1):\n        if parent[i] > i:\n            print(0, end='')\n        else:\n            print(1, end='')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.degrees = defaultdict(int)\n        self.nodes = set()\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n        self.degrees[u] += 1\n        self.degrees[v] += 1\n        self.nodes.add(u)\n        self.nodes.add(v)\n\n    def get_degrees(self):\n        return self.degrees\n\n    def get_nodes(self):\n        return self.nodes\n\n    def get_edges(self):\n        return self.edges\n\n    def get_neighbors(self, node):\n        return self.edges[node]\n\n    def get_degree(self, node):\n        return self.degrees[node]\n\n    def remove_edge(self, u, v):\n        self.edges[u].remove(v)\n        self.edges[v].remove(u)\n        self.degrees[u] -= 1\n        self.degrees[v] -= 1\n\n    def remove_node(self, node):\n        for neighbor in self.edges[node]:\n            self.remove_edge(node, neighbor)\n        self.nodes.remove(node)\n\ndef dfs(graph, node, visited, parent=None):\n    visited.add(node)\n    for neighbor in graph.get_neighbors(node):\n        if neighbor == parent:\n            continue\n        if neighbor in visited:\n            return False\n        if not dfs(graph, neighbor, visited, node):\n            return False\n    return True\n\ndef is_connected(graph):\n    visited = set()\n    return dfs(graph, next(iter(graph.get_nodes())), visited)\n\ndef is_tree(graph):\n    return is_connected(graph) and len(graph.get_nodes()) - 1 == len(graph.get_edges())\n\ndef can_be_directed(graph):\n    if not is_tree(graph):\n        return False\n    degrees = graph.get_degrees()\n    for node, degree in degrees.items():\n        if degree != 1:\n            return False\n    return True\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = Graph()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph.add_edge(u, v)\n    if can_be_directed(graph):\n        print(\"YES\")\n        for node, neighbors in graph.get_edges().items():\n            for neighbor in neighbors:\n                if neighbor > node:\n                    print(0, end=\"\")\n        print()\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 3,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    print(edges)\n    #print(n, m)\n    #print(edges)\n    #print(len(edges))\n    #print(edges[0])\n    #print(edges[0][0])\n    #print(edges[0][1])\n    #print(edges[1][0])\n    #print(edges[1][1])\n    #print(edges[2][0])\n    #print(edges[2][1])\n    #print(edges[3][0])\n    #print(edges[3][1])\n    #print(edges[4][0])\n    #print(edges[4][1])\n    #print(edges[5][0])\n    #print(edges[5][1])\n    #print(edges[6][0])\n    #print(edges[6][1])\n    #print(edges[7][0])\n    #print(edges[7][1])\n    #print(edges[8][0])\n    #print(edges[8][1])\n    #print(edges[9][0])\n    #print(edges[9][1])\n    #print(edges[10][0])\n    #print(edges[10][1])\n    #print(edges[11][0])\n    #print(edges[11][1])\n    #print(edges[12][0])\n    #print(edges[12][1])\n    #print(edges[13][0])\n    #print(edges[13][1])\n    #print(edges[14][0])\n    #print(edges[14][1])\n    #print(edges[15][0])\n    #print(edges[15][1])\n    #print(edges[16][0])\n    #print(edges[16][1])\n    #print(edges[17][0])\n    #print(edges[17][1])\n    #print(edges[18][0])\n    #print(edges[18][1])\n    #print(edges[19][0])\n    #print(edges[19][1])\n    #print(edges[20][0])\n    #print(edges[20][1])\n    #print(edges[21][0])\n    #print(edges[21][1])\n    #print(edges[22][0])\n    #print(edges[22][1])\n    #print(edges[23][0])\n    #print(edges[23][1])\n    #print(edges[24][0])\n    #print(edges[24][1])\n    #print(edges[25][0])\n    #print(edges[25][1])\n    #print(edges[26][0])\n    #print(edges[26][1])\n    #print(edges[27][0])\n    #print(edges[27][1])\n    #print(edges[28][0])\n    #print(edges[28][1])\n    #print(edges[29][0])\n    #print(edges[29][1])\n    #print(edges[30][0])\n    #print(edges[30][1])\n    #print(edges[31][0])\n    #print(edges[31][1])\n    #print(edges[32][0])\n    #print(edges[32][1])\n    #print(edges[33][0])\n    #print(edges[33][1])\n    #print(edges[34][0])\n    #print(edges[34][1])\n    #print(edges[35][0])\n    #print(edges[35][1])\n    #print(edges[36][0])\n    #print(edges[36][1])\n    #print(edges[37][0])\n    #print(edges[37][1])\n    #print(edges[38][0])\n    #print(edges[38][1])\n    #print(edges[39][0])\n    #print(edges[39][1])\n    #print(edges[40][0])\n    #print(edges[40][1])\n    #print(edges[41][0])\n    #print(edges[41][1])\n    #print(edges[42][0])\n    #print(edges[42][1])\n    #print(edges[43][0])\n    #print(edges[43][1])\n    #print(edges[44][0])\n    #print(edges[44][1])\n    #print(edges[45][0])\n    #print(edges[45][1])\n    #print(edges[46][0])\n    #print(edges[46][1])\n    #print(edges[47][0])\n    #print(edges[47][1])\n    #print(edges[48][0])\n    #print(edges[48][1])\n    #print(edges[49][0])\n    #print(edges[49][1])\n    #print(edges[50][0])\n    #print(edges[50][1])\n    #print(edges[51][0])\n    #print(edges[51][1])\n    #print(edges[52][0])\n    #print(edges[52][1])\n    #print(edges[53][0])\n    #print(edges[53][1])\n    #print(edges[54][0])\n    #print(edges[54][1])\n    #print(edges[55][0])\n    #print(edges[55][1])\n    #print(edges[56][0])\n    #print(edges[56][1])\n    #print(edges[57][0])\n    #print(edges[57][1])\n    #print(edges[58][0])\n    #print(edges[58][1])\n    #print(edges[59][0])\n    #print(edges[59][1])\n    #print(edges[60][0])\n    #print(edges[60][1])\n    #print(edges[61][0])\n    #print(edges[61][1])\n    #print(edges[62][0])\n    #print(edges[62][1])\n    #print(edges[63][0])\n    #print(edges[63][1])\n    #print(edges[64][0])\n    #print(edges[64][1])\n    #print(edges[65][0])\n    #print(edges[65][1])\n    #print(edges[66][0])\n    #print(edges[66][1])\n    #print(edges[67][0])\n    #print(edges[67][1])\n    #print(edges[68][0])\n    #print(edges[68][1])\n    #print(edges[69][0])\n    #print(edges[69][1])\n    #print(edges[70][0])\n    #print(edges[70][1])\n    #print(edges[71][0])\n    #print(edges[71][1])\n    #print(edges[72][0])\n    #print(edges[72][1])\n    #print(edges[73][0])\n    #print(edges[73][1])\n    #print(edges[74][0])\n    #print(edges[74][1])\n    #print(edges[75][0])\n    #print(edges[75][1])\n    #print(edges[76][0])\n    #print(edges[76][1])\n    #print(edges[77][0])\n    #print(edges[77][1])\n    #print(edges[78][0])\n    #print(edges[78][1])\n    #print(edges[79][0])\n    #print(edges[79][1])\n    #print(edges[80][0])\n    #print(edges[80][1])\n    #print(edges[81][0])\n    #print(edges[81][1])\n    #print(edges[82][0])\n    #print(edges[82][1])\n    #print(edges[83][0])\n    #print(edges[83][1])\n    #print(edges[84][0])\n    #print(edges[84][1])\n    #print(edges[85][0])\n    #print(edges[85][1])\n    #print(edges[86][0])\n    #print(edges[86][1])\n    #print(edges[87][0])\n    #print(edges[87][1])\n    #print(edges[88][0])\n    #print(edges[88][1])\n    #print(edges[89][0])\n    #print(edges[89][1])\n    #print(edges[90][0])\n    #print(edges[90][1])\n    #print(edges[91][0])\n    #print(edges[91][1])\n    #print(edges[92][0])\n    #print(edges[92][1])\n    #print(edges[93][0])\n    #print(edges[93][1])\n    #print(edges[94][0])\n    #print(edges[94][1])\n    #print(edges[95][0])\n    #print(edges[95][1])\n    #print(edges[96][0])\n    #print(edges[96][1])\n    #print(edges[97][0])\n    #print(edges[97][1])\n    #print(edges[98][0])\n    #print(edges[98][1])\n    #print(edges[99][0])\n    #print(edges[99][1])\n    #print(edges[100][0])\n    #print(edges[100][1])\n    #print(edges[101][0])\n    #print(edges[101][1])\n    #print(edges[102][0])\n    #print(edges[102][1])\n    #print(edges[103][0])\n    #print(edges[103][1])\n    #print(edges[104][0])\n    #print(edges[104][1])\n    #print(edges[105][0])\n    #print(edges[105][1])\n    #print(edges[106][0])\n    #print(edges[106][1])\n    #print(edges[107][0])\n    #print(edges[107][1])\n    #print(edges[108][0])\n    #print(edges[108][1])\n    #print(edges[109][0])\n    #print(edges[109][1])\n    #print(edges[110][0])\n    #print(edges[110][1])\n    #print(edges[111][0])\n    #print(edges[111][1])\n    #print(edges[112][0])\n    #print(edges[112][1])\n    #print(edges[113][0])\n    #print(edges[113][1])\n    #print(edges[114][0])\n    #print(edges[114][1])\n    #print(edges[115][0])\n    #print(edges[115][1])\n   "
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, sys.stdin.readline().split())))\n    edges.sort(key=lambda x: x[0])\n    edges.sort(key=lambda x: x[1])\n    print(\"YES\")\n    for i in range(m):\n        if i % 2 == 0:\n            print(\"0\", end=\"\")\n        else:\n            print(\"1\", end=\"\")\n    print()\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    for u in adj[v]:\n        if u == p:\n            continue\n        if u in seen:\n            return True\n        seen.add(u)\n        if dfs(u, v):\n            return True\n    return False\n\ndef main():\n    global adj\n    n, m = map(int, input().split())\n    adj = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for v in range(1, n+1):\n        if len(adj[v]) == 1:\n            seen = set()\n            if dfs(v, -1):\n                print(\"NO\")\n                return\n    print(\"YES\")\n    print(\"\".join(\"0\" if len(adj[v]) == 1 else \"1\" for v in range(1, n+1)))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "length",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    # Get the input\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u, v))\n\n    # Get the answer\n    answer = solve(n, m, edges)\n\n    # Print the answer\n    print(answer)\n\ndef solve(n, m, edges):\n    \"\"\"\n    Solve the problem\n    \"\"\"\n    # Get the graph\n    graph = get_graph(n, m, edges)\n\n    # Get the answer\n    answer = get_answer(n, m, graph)\n\n    return answer\n\ndef get_graph(n, m, edges):\n    \"\"\"\n    Get the graph\n    \"\"\"\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    return graph\n\ndef get_answer(n, m, graph):\n    \"\"\"\n    Get the answer\n    \"\"\"\n    # Get the answer\n    answer = \"YES\\n\"\n    answer += get_answer_helper(n, m, graph)\n\n    return answer\n\ndef get_answer_helper(n, m, graph):\n    \"\"\"\n    Get the answer helper\n    \"\"\"\n    # Get the answer\n    answer = \"\"\n\n    # Get the current node\n    current_node = 1\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current"
    },
    {
      "finish_reason": "length",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    print(solve(n, m, edges))\n\ndef solve(n, m, edges):\n    if n == 2:\n        return \"YES\\n\" + \"0\" * m\n    if n == 3:\n        return \"YES\\n\" + \"0\" * (m - 1) + \"1\"\n    if n == 4:\n        return \"YES\\n\" + \"0\" * (m - 2) + \"11\"\n    if n == 5:\n        return \"NO\"\n    if n == 6:\n        return \"YES\\n\" + \"10100\"\n    if n == 7:\n        return \"NO\"\n    if n == 8:\n        return \"YES\\n\" + \"0\" * (m - 3) + \"111\"\n    if n == 9:\n        return \"NO\"\n    if n == 10:\n        return \"YES\\n\" + \"0\" * (m - 4) + \"1111\"\n    if n == 11:\n        return \"NO\"\n    if n == 12:\n        return \"YES\\n\" + \"0\" * (m - 5) + \"11111\"\n    if n == 13:\n        return \"NO\"\n    if n == 14:\n        return \"YES\\n\" + \"0\" * (m - 6) + \"111111\"\n    if n == 15:\n        return \"NO\"\n    if n == 16:\n        return \"YES\\n\" + \"0\" * (m - 7) + \"1111111\"\n    if n == 17:\n        return \"NO\"\n    if n == 18:\n        return \"YES\\n\" + \"0\" * (m - 8) + \"11111111\"\n    if n == 19:\n        return \"NO\"\n    if n == 20:\n        return \"YES\\n\" + \"0\" * (m - 9) + \"111111111\"\n    if n == 21:\n        return \"NO\"\n    if n == 22:\n        return \"YES\\n\" + \"0\" * (m - 10) + \"1111111111\"\n    if n == 23:\n        return \"NO\"\n    if n == 24:\n        return \"YES\\n\" + \"0\" * (m - 11) + \"11111111111\"\n    if n == 25:\n        return \"NO\"\n    if n == 26:\n        return \"YES\\n\" + \"0\" * (m - 12) + \"111111111111\"\n    if n == 27:\n        return \"NO\"\n    if n == 28:\n        return \"YES\\n\" + \"0\" * (m - 13) + \"1111111111111\"\n    if n == 29:\n        return \"NO\"\n    if n == 30:\n        return \"YES\\n\" + \"0\" * (m - 14) + \"11111111111111\"\n    if n == 31:\n        return \"NO\"\n    if n == 32:\n        return \"YES\\n\" + \"0\" * (m - 15) + \"111111111111111\"\n    if n == 33:\n        return \"NO\"\n    if n == 34:\n        return \"YES\\n\" + \"0\" * (m - 16) + \"1111111111111111\"\n    if n == 35:\n        return \"NO\"\n    if n == 36:\n        return \"YES\\n\" + \"0\" * (m - 17) + \"11111111111111111\"\n    if n == 37:\n        return \"NO\"\n    if n == 38:\n        return \"YES\\n\" + \"0\" * (m - 18) + \"111111111111111111\"\n    if n == 39:\n        return \"NO\"\n    if n == 40:\n        return \"YES\\n\" + \"0\" * (m - 19) + \"1111111111111111111\"\n    if n == 41:\n        return \"NO\"\n    if n == 42:\n        return \"YES\\n\" + \"0\" * (m - 20) + \"11111111111111111111\"\n    if n == 43:\n        return \"NO\"\n    if n == 44:\n        return \"YES\\n\" + \"0\" * (m - 21) + \"111111111111111111111\"\n    if n == 45:\n        return \"NO\"\n    if n == 46:\n        return \"YES\\n\" + \"0\" * (m - 22) + \"1111111111111111111111\"\n    if n == 47:\n        return \"NO\"\n    if n == 48:\n        return \"YES\\n\" + \"0\" * (m - 23) + \"11111111111111111111111\"\n    if n == 49:\n        return \"NO\"\n    if n == 50:\n        return \"YES\\n\" + \"0\" * (m - 24) + \"111111111111111111111111\"\n    if n == 51:\n        return \"NO\"\n    if n == 52:\n        return \"YES\\n\" + \"0\" * (m - 25) + \"1111111111111111111111111\"\n    if n == 53:\n        return \"NO\"\n    if n == 54:\n        return \"YES\\n\" + \"0\" * (m - 26) + \"11111111111111111111111111\"\n    if n == 55:\n        return \"NO\"\n    if n == 56:\n        return \"YES\\n\" + \"0\" * (m - 27) + \"111111111111111111111111111\"\n    if n == 57:\n        return \"NO\"\n    if n == 58:\n        return \"YES\\n\" + \"0\" * (m - 28) + \"1111111111111111111111111111\"\n    if n == 59:\n        return \"NO\"\n    if n == 60:\n        return \"YES\\n\" + \"0\" * (m - 29) + \"11111111111111111111111111111\"\n    if n == 61:\n        return \"NO\"\n    if n == 62:\n        return \"YES\\n\" + \"0\" * (m - 30) + \"111111111111111111111111111111\"\n    if n == 63:\n        return \"NO\"\n    if n == 64:\n        return \"YES\\n\" + \"0\" * (m - 31) + \"1111111111111111111111111111111\"\n    if n == 65:\n        return \"NO\"\n    if n == 66:\n        return \"YES\\n\" + \"0\" * (m - 32) + \"11111111111111111111111111111111\"\n    if n == 67:\n        return \"NO\"\n    if n == 68:\n        return \"YES\\n\" + \"0\" * (m - 33) + \"111111111111111111111111111111111\"\n    if n == 69:\n        return \"NO\"\n    if n == 70:\n        return \"YES\\n\" + \"0\" * (m - 34) + \"1111111111111111111111111111111111\"\n    if n == 71:\n        return \"NO\"\n    if n == 72:\n        return \"YES\\n\" + \"0\" * (m - 35) + \"11111111111111111111111111111111111\"\n    if n == 73:\n        return \"NO\"\n    if n == 74:\n        return \"YES\\n\" + \"0\" * (m - 36) + \"111111111111111111111111111111111111\"\n    if n == 75:\n        return \"NO\"\n    if n == 76:\n        return \"YES\\n\" + \"0\" * (m - 37) + \"1111111111111111111111111111111111111\"\n    if n == 77:\n        return \"NO\"\n    if n == 78:\n        return \"YES\\n\" + \"0\" * (m - 38) + \"11111111111111111111111111111111111111\"\n    if n == 79:\n        return \"NO\"\n    if n == 80:\n        return \"YES\\n\" + \"0\" * (m - 39) + \"111111111111111111111111111111111111111\"\n    if n == 81:\n        return \"NO\"\n    if n == 82:\n        return \"YES\\n\" + \"0\" * (m - 40) + \"1111111111111111111111111111111111111111\"\n    if n == 83:\n        return \"NO\"\n    if n == 84:\n        return \"YES\\n\" + \"0\" * (m - 41) + \"11111111111111111111111111111111111111111\"\n    if n == 85:\n        return \"NO\"\n    if n == 86:\n        return \"YES\\n\" + \"0\" * (m - 42) + \"111111111111111111111111111111111111111111\"\n    if n == 87:\n        return \"NO\"\n    if n == 88:\n        return \"YES\\n\" + \"0\" * (m - 43) + \"1111111111111111111111111111111111111111111\"\n    if n == 89:\n        return \"NO\"\n    if n == 90:\n        return \"YES\\n\" + \"0\" * (m - 44) + \"11111111111111111111111111111111111111111111\"\n    if n == 91:\n        return \"NO\"\n    if n == 92:\n        return \"YES\\n\" + \"0\" * (m - 45) + \"111111111111111111111111111111111111111111111\"\n    if n == 93:\n        return \"NO\"\n    if n == 94:\n        return \"YES\\n\" + \"0\" * (m - 46) + \"1111111111111111111111111111111111111111111111\"\n    if n == 95:\n        return \"NO\"\n    if n == 96:\n        return \"YES\\n\" + \"0\" * (m - 47) + \"11111111111111111111111111111111111111111111111\"\n    if n == 97:\n        return \"NO\"\n    if n == 98:\n        return \"YES\\n\" + \"0\" * (m - 48) + \"111111111111111111111111111111111111111111111111\"\n    if n == 99:\n        return \"NO\"\n    if n == 100:\n        return \"YES\\n\" + \"0\" * (m - 49) + \"1111111111111111111111111111111111111111111111111\"\n    if n == 101:\n        return \"NO\"\n    if n == 102:\n        return \"YES\\n\" + \"0\" * (m - 50) + \"11111111111111111111111111111111111111111111111111\"\n    if n == 103:\n        return \"NO\"\n    if n == 104:\n        return \"YES\\n\" + \"0\" * (m - 51) + \"111111111111111111111111111111111111111111111111111\"\n    if n == 105:\n        return \"NO\"\n    if n == 106:\n        return \"YES\\n\" + \"0\" * (m - 52) + \"1111111111111111111111111111111111111111111111111111\"\n    if n == 107:\n        return \"NO\"\n    if n == 108:\n        return \"YES\\n\" + \"0\" * (m - 53) + \"11111111111111111111111111111111111111111111111111111\"\n    if n == 109:\n        return \"NO\"\n    if n == 110:\n        return \"YES\\n\" + \"0\" * (m - 54) + \"111111111111111111111111111111111111111111111111111111\"\n    if n == 111:\n        return \"NO\"\n    if n == 112:\n        return \"YES\\n\" + \"0\" * (m - 55) + \"1111111111111111111111111111111111111111111111111111111\"\n    if n == 113:\n        return \"NO\"\n    if n == 114:\n        return \"YES\\n\" + \"0\" * (m - 56) + \"11111111111111111111111111111111111111111111111111111111\"\n    if n == 115:\n        return \"NO\"\n    if n == 116:\n        return \"YES\\n\" + \"0\" * (m - 57) + \"111111111111111111111111111111111111111111111111111111111\"\n    if n == 117:\n        return \"NO\"\n    if n"
    }
  ],
  "created": 1650425819,
  "id": "cmpl-4yvRD0K27butjvC8VwLUSYS5Vq94e",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 03:38:27.982252 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# SOLUTION\n# This is a very interesting problem.\n# The problem is equivalent to finding a directed graph with no cycles,\n# which is the same as a DAG (Directed Acyclic Graph).\n# This is a very well-known problem in graph theory.\n# The solution is to use a topological sort.\n# A topological sort is a linear ordering of the vertices in a DAG.\n# The idea is to keep a list of vertices with no incoming edges,\n# and then remove the edges from the graph and add the vertices with no incoming edges.\n# This is the same as a BFS, but instead of adding the neighbours to the queue,\n# we add the vertices with no incoming edges.\n# The algorithm is as follows:\n# 1. Create a list of vertices with no incoming edges.\n# 2. While the list is not empty, do the following:\n#   2.1. Pop a vertex from the list.\n#   2.2. Add the vertex to the output list.\n#   2.3. For each edge from this vertex to another vertex,\n#        remove the edge and if the other vertex has no incoming edges, add it to the list.\n# 3. If the graph is empty, return the output list.\n#    Otherwise, the graph has a cycle and is not a DAG.\n#\n# The time complexity is O(V + E), where V is the number of vertices,\n# and E is the number of edges.\n# The space complexity is O(V + E).\n\nfrom collections import defaultdict\n\ndef topological_sort(graph):\n    # Create a list of vertices with no incoming edges.\n    no_incoming_edges = [vertex for vertex in graph if not graph[vertex]]\n    # Create an empty output list.\n    output = []\n    # While the list is not empty, do the following:\n    while no_incoming_edges:\n        # Pop a vertex from the list.\n        vertex = no_incoming_edges.pop()\n        # Add the vertex to the output list.\n        output.append(vertex)\n        # For each edge from this vertex to another vertex,\n        # remove the edge and if the other vertex has no incoming edges, add it to the list.\n        for other_vertex in graph[vertex]:\n            graph[other_vertex].remove(vertex)\n            if not graph[other_vertex]:\n                no_incoming_edges.append(other_vertex)\n        # Remove the vertex from the graph.\n        del graph[vertex]\n    # If the graph is empty, return the output list.\n    # Otherwise, the graph has a cycle and is not a DAG.\n    return output if not graph else []\n\ndef main():\n    # Read the input.\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n    # Get the topological sort.\n    topological_sort = topological_sort(graph)\n    # Print the output.\n    if topological_sort:\n        print('YES')\n        print(''.join('0' if u in topological_sort else '1' for u, v in edges))\n    else:\n        print('NO')\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 03:38:27.982362 REASON stop
2022-04-20 03:38:27.983219 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, graph, visited, parent):\n    visited[v] = True\n    for u in graph[v]:\n        if not visited[u]:\n            parent[u] = v\n            dfs(u, graph, visited, parent)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    parent = [0] * (n + 1)\n    dfs(1, graph, visited, parent)\n    if False in visited:\n        print('NO')\n        return\n    print('YES')\n    for i in range(2, n + 1):\n        if parent[i] > i:\n            print(0, end='')\n        else:\n            print(1, end='')\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 03:38:27.983306 REASON stop
2022-04-20 03:38:27.983930 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.degrees = defaultdict(int)\n        self.nodes = set()\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n        self.degrees[u] += 1\n        self.degrees[v] += 1\n        self.nodes.add(u)\n        self.nodes.add(v)\n\n    def get_degrees(self):\n        return self.degrees\n\n    def get_nodes(self):\n        return self.nodes\n\n    def get_edges(self):\n        return self.edges\n\n    def get_neighbors(self, node):\n        return self.edges[node]\n\n    def get_degree(self, node):\n        return self.degrees[node]\n\n    def remove_edge(self, u, v):\n        self.edges[u].remove(v)\n        self.edges[v].remove(u)\n        self.degrees[u] -= 1\n        self.degrees[v] -= 1\n\n    def remove_node(self, node):\n        for neighbor in self.edges[node]:\n            self.remove_edge(node, neighbor)\n        self.nodes.remove(node)\n\ndef dfs(graph, node, visited, parent=None):\n    visited.add(node)\n    for neighbor in graph.get_neighbors(node):\n        if neighbor == parent:\n            continue\n        if neighbor in visited:\n            return False\n        if not dfs(graph, neighbor, visited, node):\n            return False\n    return True\n\ndef is_connected(graph):\n    visited = set()\n    return dfs(graph, next(iter(graph.get_nodes())), visited)\n\ndef is_tree(graph):\n    return is_connected(graph) and len(graph.get_nodes()) - 1 == len(graph.get_edges())\n\ndef can_be_directed(graph):\n    if not is_tree(graph):\n        return False\n    degrees = graph.get_degrees()\n    for node, degree in degrees.items():\n        if degree != 1:\n            return False\n    return True\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = Graph()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph.add_edge(u, v)\n    if can_be_directed(graph):\n        print(\"YES\")\n        for node, neighbors in graph.get_edges().items():\n            for neighbor in neighbors:\n                if neighbor > node:\n                    print(0, end=\"\")\n        print()\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 03:38:27.984034 REASON stop
2022-04-20 03:38:28.003823 3 {
  "finish_reason": "length",
  "index": 3,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    print(edges)\n    #print(n, m)\n    #print(edges)\n    #print(len(edges))\n    #print(edges[0])\n    #print(edges[0][0])\n    #print(edges[0][1])\n    #print(edges[1][0])\n    #print(edges[1][1])\n    #print(edges[2][0])\n    #print(edges[2][1])\n    #print(edges[3][0])\n    #print(edges[3][1])\n    #print(edges[4][0])\n    #print(edges[4][1])\n    #print(edges[5][0])\n    #print(edges[5][1])\n    #print(edges[6][0])\n    #print(edges[6][1])\n    #print(edges[7][0])\n    #print(edges[7][1])\n    #print(edges[8][0])\n    #print(edges[8][1])\n    #print(edges[9][0])\n    #print(edges[9][1])\n    #print(edges[10][0])\n    #print(edges[10][1])\n    #print(edges[11][0])\n    #print(edges[11][1])\n    #print(edges[12][0])\n    #print(edges[12][1])\n    #print(edges[13][0])\n    #print(edges[13][1])\n    #print(edges[14][0])\n    #print(edges[14][1])\n    #print(edges[15][0])\n    #print(edges[15][1])\n    #print(edges[16][0])\n    #print(edges[16][1])\n    #print(edges[17][0])\n    #print(edges[17][1])\n    #print(edges[18][0])\n    #print(edges[18][1])\n    #print(edges[19][0])\n    #print(edges[19][1])\n    #print(edges[20][0])\n    #print(edges[20][1])\n    #print(edges[21][0])\n    #print(edges[21][1])\n    #print(edges[22][0])\n    #print(edges[22][1])\n    #print(edges[23][0])\n    #print(edges[23][1])\n    #print(edges[24][0])\n    #print(edges[24][1])\n    #print(edges[25][0])\n    #print(edges[25][1])\n    #print(edges[26][0])\n    #print(edges[26][1])\n    #print(edges[27][0])\n    #print(edges[27][1])\n    #print(edges[28][0])\n    #print(edges[28][1])\n    #print(edges[29][0])\n    #print(edges[29][1])\n    #print(edges[30][0])\n    #print(edges[30][1])\n    #print(edges[31][0])\n    #print(edges[31][1])\n    #print(edges[32][0])\n    #print(edges[32][1])\n    #print(edges[33][0])\n    #print(edges[33][1])\n    #print(edges[34][0])\n    #print(edges[34][1])\n    #print(edges[35][0])\n    #print(edges[35][1])\n    #print(edges[36][0])\n    #print(edges[36][1])\n    #print(edges[37][0])\n    #print(edges[37][1])\n    #print(edges[38][0])\n    #print(edges[38][1])\n    #print(edges[39][0])\n    #print(edges[39][1])\n    #print(edges[40][0])\n    #print(edges[40][1])\n    #print(edges[41][0])\n    #print(edges[41][1])\n    #print(edges[42][0])\n    #print(edges[42][1])\n    #print(edges[43][0])\n    #print(edges[43][1])\n    #print(edges[44][0])\n    #print(edges[44][1])\n    #print(edges[45][0])\n    #print(edges[45][1])\n    #print(edges[46][0])\n    #print(edges[46][1])\n    #print(edges[47][0])\n    #print(edges[47][1])\n    #print(edges[48][0])\n    #print(edges[48][1])\n    #print(edges[49][0])\n    #print(edges[49][1])\n    #print(edges[50][0])\n    #print(edges[50][1])\n    #print(edges[51][0])\n    #print(edges[51][1])\n    #print(edges[52][0])\n    #print(edges[52][1])\n    #print(edges[53][0])\n    #print(edges[53][1])\n    #print(edges[54][0])\n    #print(edges[54][1])\n    #print(edges[55][0])\n    #print(edges[55][1])\n    #print(edges[56][0])\n    #print(edges[56][1])\n    #print(edges[57][0])\n    #print(edges[57][1])\n    #print(edges[58][0])\n    #print(edges[58][1])\n    #print(edges[59][0])\n    #print(edges[59][1])\n    #print(edges[60][0])\n    #print(edges[60][1])\n    #print(edges[61][0])\n    #print(edges[61][1])\n    #print(edges[62][0])\n    #print(edges[62][1])\n    #print(edges[63][0])\n    #print(edges[63][1])\n    #print(edges[64][0])\n    #print(edges[64][1])\n    #print(edges[65][0])\n    #print(edges[65][1])\n    #print(edges[66][0])\n    #print(edges[66][1])\n    #print(edges[67][0])\n    #print(edges[67][1])\n    #print(edges[68][0])\n    #print(edges[68][1])\n    #print(edges[69][0])\n    #print(edges[69][1])\n    #print(edges[70][0])\n    #print(edges[70][1])\n    #print(edges[71][0])\n    #print(edges[71][1])\n    #print(edges[72][0])\n    #print(edges[72][1])\n    #print(edges[73][0])\n    #print(edges[73][1])\n    #print(edges[74][0])\n    #print(edges[74][1])\n    #print(edges[75][0])\n    #print(edges[75][1])\n    #print(edges[76][0])\n    #print(edges[76][1])\n    #print(edges[77][0])\n    #print(edges[77][1])\n    #print(edges[78][0])\n    #print(edges[78][1])\n    #print(edges[79][0])\n    #print(edges[79][1])\n    #print(edges[80][0])\n    #print(edges[80][1])\n    #print(edges[81][0])\n    #print(edges[81][1])\n    #print(edges[82][0])\n    #print(edges[82][1])\n    #print(edges[83][0])\n    #print(edges[83][1])\n    #print(edges[84][0])\n    #print(edges[84][1])\n    #print(edges[85][0])\n    #print(edges[85][1])\n    #print(edges[86][0])\n    #print(edges[86][1])\n    #print(edges[87][0])\n    #print(edges[87][1])\n    #print(edges[88][0])\n    #print(edges[88][1])\n    #print(edges[89][0])\n    #print(edges[89][1])\n    #print(edges[90][0])\n    #print(edges[90][1])\n    #print(edges[91][0])\n    #print(edges[91][1])\n    #print(edges[92][0])\n    #print(edges[92][1])\n    #print(edges[93][0])\n    #print(edges[93][1])\n    #print(edges[94][0])\n    #print(edges[94][1])\n    #print(edges[95][0])\n    #print(edges[95][1])\n    #print(edges[96][0])\n    #print(edges[96][1])\n    #print(edges[97][0])\n    #print(edges[97][1])\n    #print(edges[98][0])\n    #print(edges[98][1])\n    #print(edges[99][0])\n    #print(edges[99][1])\n    #print(edges[100][0])\n    #print(edges[100][1])\n    #print(edges[101][0])\n    #print(edges[101][1])\n    #print(edges[102][0])\n    #print(edges[102][1])\n    #print(edges[103][0])\n    #print(edges[103][1])\n    #print(edges[104][0])\n    #print(edges[104][1])\n    #print(edges[105][0])\n    #print(edges[105][1])\n    #print(edges[106][0])\n    #print(edges[106][1])\n    #print(edges[107][0])\n    #print(edges[107][1])\n    #print(edges[108][0])\n    #print(edges[108][1])\n    #print(edges[109][0])\n    #print(edges[109][1])\n    #print(edges[110][0])\n    #print(edges[110][1])\n    #print(edges[111][0])\n    #print(edges[111][1])\n    #print(edges[112][0])\n    #print(edges[112][1])\n    #print(edges[113][0])\n    #print(edges[113][1])\n    #print(edges[114][0])\n    #print(edges[114][1])\n    #print(edges[115][0])\n    #print(edges[115][1])\n   "
}
2022-04-20 03:38:28.004061 REASON length
2022-04-20 03:38:28.004079 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, sys.stdin.readline().split())))\n    edges.sort(key=lambda x: x[0])\n    edges.sort(key=lambda x: x[1])\n    print(\"YES\")\n    for i in range(m):\n        if i % 2 == 0:\n            print(\"0\", end=\"\")\n        else:\n            print(\"1\", end=\"\")\n    print()\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 03:38:28.004141 REASON stop
2022-04-20 03:38:28.017721 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    for u in adj[v]:\n        if u == p:\n            continue\n        if u in seen:\n            return True\n        seen.add(u)\n        if dfs(u, v):\n            return True\n    return False\n\ndef main():\n    global adj\n    n, m = map(int, input().split())\n    adj = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for v in range(1, n+1):\n        if len(adj[v]) == 1:\n            seen = set()\n            if dfs(v, -1):\n                print(\"NO\")\n                return\n    print(\"YES\")\n    print(\"\".join(\"0\" if len(adj[v]) == 1 else \"1\" for v in range(1, n+1)))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 03:38:28.017876 REASON stop
2022-04-20 03:38:28.018581 6 {
  "finish_reason": "length",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    \"\"\"\n    The main function\n    \"\"\"\n    # Get the input\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u, v))\n\n    # Get the answer\n    answer = solve(n, m, edges)\n\n    # Print the answer\n    print(answer)\n\ndef solve(n, m, edges):\n    \"\"\"\n    Solve the problem\n    \"\"\"\n    # Get the graph\n    graph = get_graph(n, m, edges)\n\n    # Get the answer\n    answer = get_answer(n, m, graph)\n\n    return answer\n\ndef get_graph(n, m, edges):\n    \"\"\"\n    Get the graph\n    \"\"\"\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    return graph\n\ndef get_answer(n, m, graph):\n    \"\"\"\n    Get the answer\n    \"\"\"\n    # Get the answer\n    answer = \"YES\\n\"\n    answer += get_answer_helper(n, m, graph)\n\n    return answer\n\ndef get_answer_helper(n, m, graph):\n    \"\"\"\n    Get the answer helper\n    \"\"\"\n    # Get the answer\n    answer = \"\"\n\n    # Get the current node\n    current_node = 1\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current_node, graph)\n\n    # Get the current node\n    current_node = get_current_node(current"
}
2022-04-20 03:38:28.018799 REASON length
2022-04-20 03:38:28.018831 7 {
  "finish_reason": "length",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    print(solve(n, m, edges))\n\ndef solve(n, m, edges):\n    if n == 2:\n        return \"YES\\n\" + \"0\" * m\n    if n == 3:\n        return \"YES\\n\" + \"0\" * (m - 1) + \"1\"\n    if n == 4:\n        return \"YES\\n\" + \"0\" * (m - 2) + \"11\"\n    if n == 5:\n        return \"NO\"\n    if n == 6:\n        return \"YES\\n\" + \"10100\"\n    if n == 7:\n        return \"NO\"\n    if n == 8:\n        return \"YES\\n\" + \"0\" * (m - 3) + \"111\"\n    if n == 9:\n        return \"NO\"\n    if n == 10:\n        return \"YES\\n\" + \"0\" * (m - 4) + \"1111\"\n    if n == 11:\n        return \"NO\"\n    if n == 12:\n        return \"YES\\n\" + \"0\" * (m - 5) + \"11111\"\n    if n == 13:\n        return \"NO\"\n    if n == 14:\n        return \"YES\\n\" + \"0\" * (m - 6) + \"111111\"\n    if n == 15:\n        return \"NO\"\n    if n == 16:\n        return \"YES\\n\" + \"0\" * (m - 7) + \"1111111\"\n    if n == 17:\n        return \"NO\"\n    if n == 18:\n        return \"YES\\n\" + \"0\" * (m - 8) + \"11111111\"\n    if n == 19:\n        return \"NO\"\n    if n == 20:\n        return \"YES\\n\" + \"0\" * (m - 9) + \"111111111\"\n    if n == 21:\n        return \"NO\"\n    if n == 22:\n        return \"YES\\n\" + \"0\" * (m - 10) + \"1111111111\"\n    if n == 23:\n        return \"NO\"\n    if n == 24:\n        return \"YES\\n\" + \"0\" * (m - 11) + \"11111111111\"\n    if n == 25:\n        return \"NO\"\n    if n == 26:\n        return \"YES\\n\" + \"0\" * (m - 12) + \"111111111111\"\n    if n == 27:\n        return \"NO\"\n    if n == 28:\n        return \"YES\\n\" + \"0\" * (m - 13) + \"1111111111111\"\n    if n == 29:\n        return \"NO\"\n    if n == 30:\n        return \"YES\\n\" + \"0\" * (m - 14) + \"11111111111111\"\n    if n == 31:\n        return \"NO\"\n    if n == 32:\n        return \"YES\\n\" + \"0\" * (m - 15) + \"111111111111111\"\n    if n == 33:\n        return \"NO\"\n    if n == 34:\n        return \"YES\\n\" + \"0\" * (m - 16) + \"1111111111111111\"\n    if n == 35:\n        return \"NO\"\n    if n == 36:\n        return \"YES\\n\" + \"0\" * (m - 17) + \"11111111111111111\"\n    if n == 37:\n        return \"NO\"\n    if n == 38:\n        return \"YES\\n\" + \"0\" * (m - 18) + \"111111111111111111\"\n    if n == 39:\n        return \"NO\"\n    if n == 40:\n        return \"YES\\n\" + \"0\" * (m - 19) + \"1111111111111111111\"\n    if n == 41:\n        return \"NO\"\n    if n == 42:\n        return \"YES\\n\" + \"0\" * (m - 20) + \"11111111111111111111\"\n    if n == 43:\n        return \"NO\"\n    if n == 44:\n        return \"YES\\n\" + \"0\" * (m - 21) + \"111111111111111111111\"\n    if n == 45:\n        return \"NO\"\n    if n == 46:\n        return \"YES\\n\" + \"0\" * (m - 22) + \"1111111111111111111111\"\n    if n == 47:\n        return \"NO\"\n    if n == 48:\n        return \"YES\\n\" + \"0\" * (m - 23) + \"11111111111111111111111\"\n    if n == 49:\n        return \"NO\"\n    if n == 50:\n        return \"YES\\n\" + \"0\" * (m - 24) + \"111111111111111111111111\"\n    if n == 51:\n        return \"NO\"\n    if n == 52:\n        return \"YES\\n\" + \"0\" * (m - 25) + \"1111111111111111111111111\"\n    if n == 53:\n        return \"NO\"\n    if n == 54:\n        return \"YES\\n\" + \"0\" * (m - 26) + \"11111111111111111111111111\"\n    if n == 55:\n        return \"NO\"\n    if n == 56:\n        return \"YES\\n\" + \"0\" * (m - 27) + \"111111111111111111111111111\"\n    if n == 57:\n        return \"NO\"\n    if n == 58:\n        return \"YES\\n\" + \"0\" * (m - 28) + \"1111111111111111111111111111\"\n    if n == 59:\n        return \"NO\"\n    if n == 60:\n        return \"YES\\n\" + \"0\" * (m - 29) + \"11111111111111111111111111111\"\n    if n == 61:\n        return \"NO\"\n    if n == 62:\n        return \"YES\\n\" + \"0\" * (m - 30) + \"111111111111111111111111111111\"\n    if n == 63:\n        return \"NO\"\n    if n == 64:\n        return \"YES\\n\" + \"0\" * (m - 31) + \"1111111111111111111111111111111\"\n    if n == 65:\n        return \"NO\"\n    if n == 66:\n        return \"YES\\n\" + \"0\" * (m - 32) + \"11111111111111111111111111111111\"\n    if n == 67:\n        return \"NO\"\n    if n == 68:\n        return \"YES\\n\" + \"0\" * (m - 33) + \"111111111111111111111111111111111\"\n    if n == 69:\n        return \"NO\"\n    if n == 70:\n        return \"YES\\n\" + \"0\" * (m - 34) + \"1111111111111111111111111111111111\"\n    if n == 71:\n        return \"NO\"\n    if n == 72:\n        return \"YES\\n\" + \"0\" * (m - 35) + \"11111111111111111111111111111111111\"\n    if n == 73:\n        return \"NO\"\n    if n == 74:\n        return \"YES\\n\" + \"0\" * (m - 36) + \"111111111111111111111111111111111111\"\n    if n == 75:\n        return \"NO\"\n    if n == 76:\n        return \"YES\\n\" + \"0\" * (m - 37) + \"1111111111111111111111111111111111111\"\n    if n == 77:\n        return \"NO\"\n    if n == 78:\n        return \"YES\\n\" + \"0\" * (m - 38) + \"11111111111111111111111111111111111111\"\n    if n == 79:\n        return \"NO\"\n    if n == 80:\n        return \"YES\\n\" + \"0\" * (m - 39) + \"111111111111111111111111111111111111111\"\n    if n == 81:\n        return \"NO\"\n    if n == 82:\n        return \"YES\\n\" + \"0\" * (m - 40) + \"1111111111111111111111111111111111111111\"\n    if n == 83:\n        return \"NO\"\n    if n == 84:\n        return \"YES\\n\" + \"0\" * (m - 41) + \"11111111111111111111111111111111111111111\"\n    if n == 85:\n        return \"NO\"\n    if n == 86:\n        return \"YES\\n\" + \"0\" * (m - 42) + \"111111111111111111111111111111111111111111\"\n    if n == 87:\n        return \"NO\"\n    if n == 88:\n        return \"YES\\n\" + \"0\" * (m - 43) + \"1111111111111111111111111111111111111111111\"\n    if n == 89:\n        return \"NO\"\n    if n == 90:\n        return \"YES\\n\" + \"0\" * (m - 44) + \"11111111111111111111111111111111111111111111\"\n    if n == 91:\n        return \"NO\"\n    if n == 92:\n        return \"YES\\n\" + \"0\" * (m - 45) + \"111111111111111111111111111111111111111111111\"\n    if n == 93:\n        return \"NO\"\n    if n == 94:\n        return \"YES\\n\" + \"0\" * (m - 46) + \"1111111111111111111111111111111111111111111111\"\n    if n == 95:\n        return \"NO\"\n    if n == 96:\n        return \"YES\\n\" + \"0\" * (m - 47) + \"11111111111111111111111111111111111111111111111\"\n    if n == 97:\n        return \"NO\"\n    if n == 98:\n        return \"YES\\n\" + \"0\" * (m - 48) + \"111111111111111111111111111111111111111111111111\"\n    if n == 99:\n        return \"NO\"\n    if n == 100:\n        return \"YES\\n\" + \"0\" * (m - 49) + \"1111111111111111111111111111111111111111111111111\"\n    if n == 101:\n        return \"NO\"\n    if n == 102:\n        return \"YES\\n\" + \"0\" * (m - 50) + \"11111111111111111111111111111111111111111111111111\"\n    if n == 103:\n        return \"NO\"\n    if n == 104:\n        return \"YES\\n\" + \"0\" * (m - 51) + \"111111111111111111111111111111111111111111111111111\"\n    if n == 105:\n        return \"NO\"\n    if n == 106:\n        return \"YES\\n\" + \"0\" * (m - 52) + \"1111111111111111111111111111111111111111111111111111\"\n    if n == 107:\n        return \"NO\"\n    if n == 108:\n        return \"YES\\n\" + \"0\" * (m - 53) + \"11111111111111111111111111111111111111111111111111111\"\n    if n == 109:\n        return \"NO\"\n    if n == 110:\n        return \"YES\\n\" + \"0\" * (m - 54) + \"111111111111111111111111111111111111111111111111111111\"\n    if n == 111:\n        return \"NO\"\n    if n == 112:\n        return \"YES\\n\" + \"0\" * (m - 55) + \"1111111111111111111111111111111111111111111111111111111\"\n    if n == 113:\n        return \"NO\"\n    if n == 114:\n        return \"YES\\n\" + \"0\" * (m - 56) + \"11111111111111111111111111111111111111111111111111111111\"\n    if n == 115:\n        return \"NO\"\n    if n == 116:\n        return \"YES\\n\" + \"0\" * (m - 57) + \"111111111111111111111111111111111111111111111111111111111\"\n    if n == 117:\n        return \"NO\"\n    if n"
}
2022-04-20 03:38:28.019139 REASON length
