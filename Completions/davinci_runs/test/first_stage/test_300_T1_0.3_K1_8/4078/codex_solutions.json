["\n\ndef main():\n    # Read the input data.\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    segments = []\n    for _ in range(m):\n        segments.append(tuple(map(int, input().split())))\n    # Solve the problem.\n    result = solve(n, m, a, segments)\n    # Print the result.\n    print(result[0])\n    print(len(result[1]))\n    print(*result[1])\n\n\ndef solve(n, m, a, segments):\n    # Construct the graph.\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        graph[segments[i][0] - 1].append(segments[i][1] - 1)\n    # Find the maximum and minimum values of the array after applying the segments.\n    max_value = min(a)\n    min_value = max(a)\n    for i in range(n):\n        if a[i] > max_value:\n            max_value = a[i]\n        elif a[i] < min_value:\n            min_value = a[i]\n    # Find the maximum and minimum values of the array after applying the segments.\n    for i in range(m):\n        max_value = max(max_value, dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, max(a)))\n        min_value = min(min_value, dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, min(a)))\n    # Find the segments that should be applied.\n    result = []\n    for i in range(m):\n        if dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, max(a)) == max_value:\n            result.append(i + 1)\n    return (max_value - min_value, result)\n\n\ndef dfs(graph, a, start, end, value):\n    if start == end:\n        return value\n    for neighbour in graph[start]:\n        if neighbour <= end:\n            value = min(value, dfs(graph, a, neighbour, end, a[neighbour]))\n    return value\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\nimport heapq\nimport random\nimport collections\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, combinations_with_replacement\nfrom copy import deepcopy\ninf = 10 ** 20\ngosa = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\neps = 10 ** -7\n\ndef inp(): return int(sys.stdin.readline())\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nN, M = inp_list()\nA = inp_list()\n\nsegs = []\nfor i in range(M):\n    l, r = inp_list()\n    segs.append((l, r))\n\ndef solve():\n    segs.sort(key=lambda x: x[1])\n    ans = 0\n    for i in range(M):\n        l, r = segs[i]\n        if l == 1:\n            ans = max(ans, A[r - 1])\n        else:\n            ans = max(ans, A[r - 1] - A[l - 2])\n    return ans\n\nprint(solve())", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for i in range(m):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n    segments.sort(key=lambda x: x[1] - x[0])\n    print(segments)\n    return\n\nif __name__ == \"__main__\":\n    main()", "\n\n# TODO: solve it", "\n\nimport sys\nimport heapq\n\nclass SegmentTree:\n    def __init__(self, array):\n        self.array = array\n        self.tree = [None] * (4 * len(array))\n        self.build(0, 0, len(array) - 1)\n\n    def build(self, node, start, end):\n        if start == end:\n            self.tree[node] = (self.array[start], start)\n        else:\n            mid = (start + end) // 2\n            self.build(2 * node + 1, start, mid)\n            self.build(2 * node + 2, mid + 1, end)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n    def query(self, node, start, end, left, right):\n        if right < start or end < left:\n            return (float('-inf'), -1)\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return max(self.query(2 * node + 1, start, mid, left, right),\n                   self.query(2 * node + 2, mid + 1, end, left, right))\n\n    def update(self, node, start, end, index, value):\n        if start == end:\n            self.tree[node] = (value, index)\n        else:\n            mid = (start + end) // 2\n            if start <= index and index <= mid:\n                self.update(2 * node + 1, start, mid, index, value)\n            else:\n                self.update(2 * node + 2, mid + 1, end, index, value)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n\ndef solve(n, m, a, segments):\n    tree = SegmentTree(a)\n    segments.sort(key=lambda x: x[1], reverse=True)\n    heap = []\n    for segment in segments:\n        heapq.heappush(heap, (-tree.query(0, 0, n - 1, segment[0] - 1, segment[1] - 1)[0], segment))\n    result = []\n    while heap:\n        value, segment = heapq.heappop(heap)\n        if tree.query(0, 0, n - 1, segment[0] - 1, segment[1] - 1)[0] == -value:\n            result.append(segment)\n            for i in range(segment[0] - 1, segment[1]):\n                tree.update(0, 0, n - 1, i, a[i] - 1)\n    return result\n\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, m = next(reader)\n    a = list(next(reader))\n    segments = [tuple(next(reader)) for _ in range(m)]\n    result = solve(n, m, a, segments)\n    print(max(a) - min(a) - len(result))\n    print(len(result))\n    print(' '.join(str(segments.index(segment) + 1) for segment in result))\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef solve(n, m, a, l, r):\n    # Write your code here\n    # To print results to the standard output you can use print\n    # Example: print \"Hello world!\"\n    pass\n\nn, m = map(int, raw_input().split())\na = map(int, raw_input().split())\nl = []\nr = []\nfor i in range(m):\n    l_i, r_i = map(int, raw_input().split())\n    l.append(l_i)\n    r.append(r_i)\n\nsolve(n, m, a, l, r)", "\n\nimport sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n    \n    def build(self, a, v, tl, tr):\n        if tl == tr:\n            self.tree[v] = a[tl]\n        else:\n            tm = (tl + tr) // 2\n            self.build(a, v * 2, tl, tm)\n            self.build(a, v * 2 + 1, tm + 1, tr)\n            self.tree[v] = max(self.tree[v * 2], self.tree[v * 2 + 1])\n    \n    def push(self, v):\n        self.tree[v * 2] += self.lazy[v]\n        self.tree[v * 2 + 1] += self.lazy[v]\n        self.lazy[v * 2] += self.lazy[v]\n        self.lazy[v * 2 + 1] += self.lazy[v]\n        self.lazy[v] = 0\n    \n    def update(self, v, tl, tr, l, r, add):\n        if l > r:\n            return\n        if l == tl and r == tr:\n            self.tree[v] += add\n            self.lazy[v] += add\n        else:\n            tm = (tl + tr) // 2\n            self.push(v)\n            self.update(v * 2, tl, tm, l, min(r, tm), add)\n            self.update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, add)\n            self.tree[v] = max(self.tree[v * 2], self.tree[v * 2 + 1])\n    \n    def query(self, v, tl, tr, l, r):\n        if l > r:\n            return -math.inf\n        if l == tl and r == tr:\n            return self.tree[v]\n        tm = (tl + tr) // 2\n        self.push(v)\n        return max(self.query(v * 2, tl, tm, l, min(r, tm)), self.query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r))\n\ndef solve(n, m, a, segments):\n    tree = SegmentTree(n)\n    tree.build(a, 1, 0, n - 1)\n    for i in range(m):\n        tree.update(1, 0, n - 1, segments[i][0] - 1, segments[i][1] - 1, 1)\n    return tree.query(1, 0, n - 1, 0, n - 1)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for i in range(m):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(solve(n, m, a, segments))\n\nif __name__ == '__main__':\n    main()"]