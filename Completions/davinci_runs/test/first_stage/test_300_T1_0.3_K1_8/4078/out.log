2022-04-20 01:52:45.874766 """
The only difference between easy and hard versions is a number of elements in the array.

You are given an array $a$ consisting of $n$ integers. The value of the $i$-th element of the array is $a_i$.

You are also given a set of $m$ segments. The $j$-th segment is $[l_j; r_j]$, where $1 \le l_j \le r_j \le n$.

You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (independently). For example, if the initial array $a = [0, 0, 0, 0, 0]$ and the given segments are $[1; 3]$ and $[2; 4]$ then you can choose both of them and the array will become $b = [-1, -2, -2, -1, 0]$.

You have to choose some subset of the given segments (each segment can be chosen at most once) in such a way that if you apply this subset of segments to the array $a$ and obtain the array $b$ then the value $\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$ will be maximum possible.

Note that you can choose the empty set.

If there are multiple answers, you can print any.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n \le 300, 0 \le m \le 300$) — the length of the array $a$ and the number of segments, respectively.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^6 \le a_i \le 10^6$), where $a_i$ is the value of the $i$-th element of the array $a$.

The next $m$ lines are contain two integers each. The $j$-th of them contains two integers $l_j$ and $r_j$ ($1 \le l_j \le r_j \le n$), where $l_j$ and $r_j$ are the ends of the $j$-th segment.


-----Output-----

In the first line of the output print one integer $d$ — the maximum possible value $\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$ if $b$ is the array obtained by applying some subset of the given segments to the array $a$.

In the second line of the output print one integer $q$ ($0 \le q \le m$) — the number of segments you apply.

In the third line print $q$ distinct integers $c_1, c_2, \dots, c_q$ in any order ($1 \le c_k \le m$) — indices of segments you apply to the array $a$ in such a way that the value $\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$ of the obtained array $b$ is maximum possible.

If there are multiple answers, you can print any.


-----Examples-----
Input
5 4
2 -2 3 1 2
1 3
4 5
2 5
1 3

Output
6
2
1 4 

Input
5 4
2 -2 3 1 4
3 5
3 4
2 4
2 5

Output
7
2
3 2 

Input
1 0
1000000

Output
0
0




-----Note-----

In the first example the obtained array $b$ will be $[0, -4, 1, 1, 2]$ so the answer is $6$.

In the second example the obtained array $b$ will be $[2, -3, 1, -1, 4]$ so the answer is $7$.

In the third example you cannot do anything so the answer is $0$.
"""
2022-04-20 01:52:45.874784 --------------------------
2022-04-20 01:52:45.874883 using api key sourya
2022-04-20 01:54:08.405494 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef solve(n, m, a, l, r):\n    # Write your code here\n    # To print results to the standard output you can use print\n    # Example: print \"Hello world!\"\n    pass\n\nn, m = map(int, raw_input().split())\na = map(int, raw_input().split())\nl = []\nr = []\nfor i in range(m):\n    l_i, r_i = map(int, raw_input().split())\n    l.append(l_i)\n    r.append(r_i)\n\nsolve(n, m, a, l, r)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nimport random\nimport collections\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, combinations_with_replacement\nfrom copy import deepcopy\ninf = 10 ** 20\ngosa = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\neps = 10 ** -7\n\ndef inp(): return int(sys.stdin.readline())\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nN, M = inp_list()\nA = inp_list()\n\nsegs = []\nfor i in range(M):\n    l, r = inp_list()\n    segs.append((l, r))\n\ndef solve():\n    segs.sort(key=lambda x: x[1])\n    ans = 0\n    for i in range(M):\n        l, r = segs[i]\n        if l == 1:\n            ans = max(ans, A[r - 1])\n        else:\n            ans = max(ans, A[r - 1] - A[l - 2])\n    return ans\n\nprint(solve())"
    },
    {
      "finish_reason": "length",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    segments = []\n    for i in range(m):\n        l, r = [int(x) for x in input().split()]\n        segments.append((l, r))\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    # Read the input data.\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    segments = []\n    for _ in range(m):\n        segments.append(tuple(map(int, input().split())))\n    # Solve the problem.\n    result = solve(n, m, a, segments)\n    # Print the result.\n    print(result[0])\n    print(len(result[1]))\n    print(*result[1])\n\n\ndef solve(n, m, a, segments):\n    # Construct the graph.\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        graph[segments[i][0] - 1].append(segments[i][1] - 1)\n    # Find the maximum and minimum values of the array after applying the segments.\n    max_value = min(a)\n    min_value = max(a)\n    for i in range(n):\n        if a[i] > max_value:\n            max_value = a[i]\n        elif a[i] < min_value:\n            min_value = a[i]\n    # Find the maximum and minimum values of the array after applying the segments.\n    for i in range(m):\n        max_value = max(max_value, dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, max(a)))\n        min_value = min(min_value, dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, min(a)))\n    # Find the segments that should be applied.\n    result = []\n    for i in range(m):\n        if dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, max(a)) == max_value:\n            result.append(i + 1)\n    return (max_value - min_value, result)\n\n\ndef dfs(graph, a, start, end, value):\n    if start == end:\n        return value\n    for neighbour in graph[start]:\n        if neighbour <= end:\n            value = min(value, dfs(graph, a, neighbour, end, a[neighbour]))\n    return value\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\n# TODO: solve it"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport heapq\n\nclass SegmentTree:\n    def __init__(self, array):\n        self.array = array\n        self.tree = [None] * (4 * len(array))\n        self.build(0, 0, len(array) - 1)\n\n    def build(self, node, start, end):\n        if start == end:\n            self.tree[node] = (self.array[start], start)\n        else:\n            mid = (start + end) // 2\n            self.build(2 * node + 1, start, mid)\n            self.build(2 * node + 2, mid + 1, end)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n    def query(self, node, start, end, left, right):\n        if right < start or end < left:\n            return (float('-inf'), -1)\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return max(self.query(2 * node + 1, start, mid, left, right),\n                   self.query(2 * node + 2, mid + 1, end, left, right))\n\n    def update(self, node, start, end, index, value):\n        if start == end:\n            self.tree[node] = (value, index)\n        else:\n            mid = (start + end) // 2\n            if start <= index and index <= mid:\n                self.update(2 * node + 1, start, mid, index, value)\n            else:\n                self.update(2 * node + 2, mid + 1, end, index, value)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n\ndef solve(n, m, a, segments):\n    tree = SegmentTree(a)\n    segments.sort(key=lambda x: x[1], reverse=True)\n    heap = []\n    for segment in segments:\n        heapq.heappush(heap, (-tree.query(0, 0, n - 1, segment[0] - 1, segment[1] - 1)[0], segment))\n    result = []\n    while heap:\n        value, segment = heapq.heappop(heap)\n        if tree.query(0, 0, n - 1, segment[0] - 1, segment[1] - 1)[0] == -value:\n            result.append(segment)\n            for i in range(segment[0] - 1, segment[1]):\n                tree.update(0, 0, n - 1, i, a[i] - 1)\n    return result\n\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, m = next(reader)\n    a = list(next(reader))\n    segments = [tuple(next(reader)) for _ in range(m)]\n    result = solve(n, m, a, segments)\n    print(max(a) - min(a) - len(result))\n    print(len(result))\n    print(' '.join(str(segments.index(segment) + 1) for segment in result))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n    \n    def build(self, a, v, tl, tr):\n        if tl == tr:\n            self.tree[v] = a[tl]\n        else:\n            tm = (tl + tr) // 2\n            self.build(a, v * 2, tl, tm)\n            self.build(a, v * 2 + 1, tm + 1, tr)\n            self.tree[v] = max(self.tree[v * 2], self.tree[v * 2 + 1])\n    \n    def push(self, v):\n        self.tree[v * 2] += self.lazy[v]\n        self.tree[v * 2 + 1] += self.lazy[v]\n        self.lazy[v * 2] += self.lazy[v]\n        self.lazy[v * 2 + 1] += self.lazy[v]\n        self.lazy[v] = 0\n    \n    def update(self, v, tl, tr, l, r, add):\n        if l > r:\n            return\n        if l == tl and r == tr:\n            self.tree[v] += add\n            self.lazy[v] += add\n        else:\n            tm = (tl + tr) // 2\n            self.push(v)\n            self.update(v * 2, tl, tm, l, min(r, tm), add)\n            self.update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, add)\n            self.tree[v] = max(self.tree[v * 2], self.tree[v * 2 + 1])\n    \n    def query(self, v, tl, tr, l, r):\n        if l > r:\n            return -math.inf\n        if l == tl and r == tr:\n            return self.tree[v]\n        tm = (tl + tr) // 2\n        self.push(v)\n        return max(self.query(v * 2, tl, tm, l, min(r, tm)), self.query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r))\n\ndef solve(n, m, a, segments):\n    tree = SegmentTree(n)\n    tree.build(a, 1, 0, n - 1)\n    for i in range(m):\n        tree.update(1, 0, n - 1, segments[i][0] - 1, segments[i][1] - 1, 1)\n    return tree.query(1, 0, n - 1, 0, n - 1)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for i in range(m):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(solve(n, m, a, segments))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for i in range(m):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n    segments.sort(key=lambda x: x[1] - x[0])\n    print(segments)\n    return\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650419566,
  "id": "cmpl-4ytoM5qrzkSt6tsiZYT5Yazg0m7kb",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 01:54:08.405970 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef solve(n, m, a, l, r):\n    # Write your code here\n    # To print results to the standard output you can use print\n    # Example: print \"Hello world!\"\n    pass\n\nn, m = map(int, raw_input().split())\na = map(int, raw_input().split())\nl = []\nr = []\nfor i in range(m):\n    l_i, r_i = map(int, raw_input().split())\n    l.append(l_i)\n    r.append(r_i)\n\nsolve(n, m, a, l, r)"
}
2022-04-20 01:54:08.406014 REASON stop
2022-04-20 01:54:08.406562 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nimport random\nimport collections\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, combinations_with_replacement\nfrom copy import deepcopy\ninf = 10 ** 20\ngosa = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\neps = 10 ** -7\n\ndef inp(): return int(sys.stdin.readline())\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nN, M = inp_list()\nA = inp_list()\n\nsegs = []\nfor i in range(M):\n    l, r = inp_list()\n    segs.append((l, r))\n\ndef solve():\n    segs.sort(key=lambda x: x[1])\n    ans = 0\n    for i in range(M):\n        l, r = segs[i]\n        if l == 1:\n            ans = max(ans, A[r - 1])\n        else:\n            ans = max(ans, A[r - 1] - A[l - 2])\n    return ans\n\nprint(solve())"
}
2022-04-20 01:54:08.406629 REASON stop
2022-04-20 01:54:08.407085 2 {
  "finish_reason": "length",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    segments = []\n    for i in range(m):\n        l, r = [int(x) for x in input().split()]\n        segments.append((l, r))\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n    #print(segments)\n    #print(n, m)\n    #print(a)\n"
}
2022-04-20 01:54:08.407185 REASON length
2022-04-20 01:54:08.407193 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    # Read the input data.\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    segments = []\n    for _ in range(m):\n        segments.append(tuple(map(int, input().split())))\n    # Solve the problem.\n    result = solve(n, m, a, segments)\n    # Print the result.\n    print(result[0])\n    print(len(result[1]))\n    print(*result[1])\n\n\ndef solve(n, m, a, segments):\n    # Construct the graph.\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        graph[segments[i][0] - 1].append(segments[i][1] - 1)\n    # Find the maximum and minimum values of the array after applying the segments.\n    max_value = min(a)\n    min_value = max(a)\n    for i in range(n):\n        if a[i] > max_value:\n            max_value = a[i]\n        elif a[i] < min_value:\n            min_value = a[i]\n    # Find the maximum and minimum values of the array after applying the segments.\n    for i in range(m):\n        max_value = max(max_value, dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, max(a)))\n        min_value = min(min_value, dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, min(a)))\n    # Find the segments that should be applied.\n    result = []\n    for i in range(m):\n        if dfs(graph, a, segments[i][0] - 1, segments[i][1] - 1, max(a)) == max_value:\n            result.append(i + 1)\n    return (max_value - min_value, result)\n\n\ndef dfs(graph, a, start, end, value):\n    if start == end:\n        return value\n    for neighbour in graph[start]:\n        if neighbour <= end:\n            value = min(value, dfs(graph, a, neighbour, end, a[neighbour]))\n    return value\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 01:54:08.407228 REASON stop
2022-04-20 01:54:08.432013 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\n# TODO: solve it"
}
2022-04-20 01:54:08.432130 REASON stop
2022-04-20 01:54:08.453392 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport heapq\n\nclass SegmentTree:\n    def __init__(self, array):\n        self.array = array\n        self.tree = [None] * (4 * len(array))\n        self.build(0, 0, len(array) - 1)\n\n    def build(self, node, start, end):\n        if start == end:\n            self.tree[node] = (self.array[start], start)\n        else:\n            mid = (start + end) // 2\n            self.build(2 * node + 1, start, mid)\n            self.build(2 * node + 2, mid + 1, end)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n    def query(self, node, start, end, left, right):\n        if right < start or end < left:\n            return (float('-inf'), -1)\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return max(self.query(2 * node + 1, start, mid, left, right),\n                   self.query(2 * node + 2, mid + 1, end, left, right))\n\n    def update(self, node, start, end, index, value):\n        if start == end:\n            self.tree[node] = (value, index)\n        else:\n            mid = (start + end) // 2\n            if start <= index and index <= mid:\n                self.update(2 * node + 1, start, mid, index, value)\n            else:\n                self.update(2 * node + 2, mid + 1, end, index, value)\n            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])\n\n\ndef solve(n, m, a, segments):\n    tree = SegmentTree(a)\n    segments.sort(key=lambda x: x[1], reverse=True)\n    heap = []\n    for segment in segments:\n        heapq.heappush(heap, (-tree.query(0, 0, n - 1, segment[0] - 1, segment[1] - 1)[0], segment))\n    result = []\n    while heap:\n        value, segment = heapq.heappop(heap)\n        if tree.query(0, 0, n - 1, segment[0] - 1, segment[1] - 1)[0] == -value:\n            result.append(segment)\n            for i in range(segment[0] - 1, segment[1]):\n                tree.update(0, 0, n - 1, i, a[i] - 1)\n    return result\n\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, m = next(reader)\n    a = list(next(reader))\n    segments = [tuple(next(reader)) for _ in range(m)]\n    result = solve(n, m, a, segments)\n    print(max(a) - min(a) - len(result))\n    print(len(result))\n    print(' '.join(str(segments.index(segment) + 1) for segment in result))\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 01:54:08.453534 REASON stop
2022-04-20 01:54:08.454890 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n    \n    def build(self, a, v, tl, tr):\n        if tl == tr:\n            self.tree[v] = a[tl]\n        else:\n            tm = (tl + tr) // 2\n            self.build(a, v * 2, tl, tm)\n            self.build(a, v * 2 + 1, tm + 1, tr)\n            self.tree[v] = max(self.tree[v * 2], self.tree[v * 2 + 1])\n    \n    def push(self, v):\n        self.tree[v * 2] += self.lazy[v]\n        self.tree[v * 2 + 1] += self.lazy[v]\n        self.lazy[v * 2] += self.lazy[v]\n        self.lazy[v * 2 + 1] += self.lazy[v]\n        self.lazy[v] = 0\n    \n    def update(self, v, tl, tr, l, r, add):\n        if l > r:\n            return\n        if l == tl and r == tr:\n            self.tree[v] += add\n            self.lazy[v] += add\n        else:\n            tm = (tl + tr) // 2\n            self.push(v)\n            self.update(v * 2, tl, tm, l, min(r, tm), add)\n            self.update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, add)\n            self.tree[v] = max(self.tree[v * 2], self.tree[v * 2 + 1])\n    \n    def query(self, v, tl, tr, l, r):\n        if l > r:\n            return -math.inf\n        if l == tl and r == tr:\n            return self.tree[v]\n        tm = (tl + tr) // 2\n        self.push(v)\n        return max(self.query(v * 2, tl, tm, l, min(r, tm)), self.query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r))\n\ndef solve(n, m, a, segments):\n    tree = SegmentTree(n)\n    tree.build(a, 1, 0, n - 1)\n    for i in range(m):\n        tree.update(1, 0, n - 1, segments[i][0] - 1, segments[i][1] - 1, 1)\n    return tree.query(1, 0, n - 1, 0, n - 1)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for i in range(m):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(solve(n, m, a, segments))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 01:54:08.454999 REASON stop
2022-04-20 01:54:08.457135 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for i in range(m):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n    segments.sort(key=lambda x: x[1] - x[0])\n    print(segments)\n    return\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 01:54:08.457332 REASON stop
