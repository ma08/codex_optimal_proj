2022-04-20 02:36:57.736407 """
There is a rectangular grid of size $n \times m$. Each cell has a number written on it; the number on the cell ($i, j$) is $a_{i, j}$. Your task is to calculate the number of paths from the upper-left cell ($1, 1$) to the bottom-right cell ($n, m$) meeting the following constraints:

  You can move to the right or to the bottom only. Formally, from the cell ($i, j$) you may move to the cell ($i, j + 1$) or to the cell ($i + 1, j$). The target cell can't be outside of the grid.  The xor of all the numbers on the path from the cell ($1, 1$) to the cell ($n, m$) must be equal to $k$ (xor operation is the bitwise exclusive OR, it is represented as '^' in Java or C++ and "xor" in Pascal). 

Find the number of such paths in the given grid.


-----Input-----

The first line of the input contains three integers $n$, $m$ and $k$ ($1 \le n, m \le 20$, $0 \le k \le 10^{18}$) — the height and the width of the grid, and the number $k$.

The next $n$ lines contain $m$ integers each, the $j$-th element in the $i$-th line is $a_{i, j}$ ($0 \le a_{i, j} \le 10^{18}$).


-----Output-----

Print one integer — the number of paths from ($1, 1$) to ($n, m$) with xor sum equal to $k$.


-----Examples-----
Input
3 3 11
2 1 5
7 10 0
12 6 4

Output
3

Input
3 4 2
1 3 3 3
0 3 3 2
3 0 1 1

Output
5

Input
3 4 1000000000000000000
1 3 3 3
0 3 3 2
3 0 1 1

Output
0



-----Note-----

All the paths from the first example:   $(1, 1) \rightarrow (2, 1) \rightarrow (3, 1) \rightarrow (3, 2) \rightarrow (3, 3)$;  $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (3, 3)$;  $(1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (3, 2) \rightarrow (3, 3)$. 

All the paths from the second example:   $(1, 1) \rightarrow (2, 1) \rightarrow (3, 1) \rightarrow (3, 2) \rightarrow (3, 3) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (3, 2) \rightarrow (3, 3) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (2, 1) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (2, 4) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (1, 2) \rightarrow (2, 2) \rightarrow (2, 3) \rightarrow (3, 3) \rightarrow (3, 4)$;  $(1, 1) \rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (3, 3) \rightarrow (3, 4)$.
"""
2022-04-20 02:36:57.736437 --------------------------
2022-04-20 02:36:57.736588 using api key derek
2022-04-20 02:37:22.080797 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    grid = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if i < n - 1:\n                dp[i][j] = dp[i + 1][j]\n            if j < m - 1:\n                dp[i][j] += dp[i][j + 1]\n            if (grid[i][j] ^ k) == 0:\n                ans += dp[i][j]\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef solve(n, m, k, grid):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            if i == 1:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 1:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == n and j == m:\n                continue\n            if i == n:\n                if (grid[i - 1][j - 1] ^ k) == grid[i - 1][j]:\n                    ans += dp[i][j - 1]\n            elif j == m:\n                if (grid[i - 1][j - 1] ^ k) == grid[i][j - 1]:\n                    ans += dp[i - 1][j]\n            else:\n                if (grid[i - 1][j - 1] ^ k) == grid[i][j - 1]:\n                    ans += dp[i - 1][j]\n                if (grid[i - 1][j - 1] ^ k) == grid[i - 1][j]:\n                    ans += dp[i][j - 1]\n    return ans\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1][j - 1] ^ k == 0:\n                ans += dp[i][j]\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef solve(n, m, k, a):\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n            if i > 0 and j > 0:\n                dp[i][j] -= dp[i-1][j-1]\n            if i > 0 and j > 0 and a[i-1][j-1] ^ a[i][j] == k:\n                dp[i][j] += 1\n    return dp[n-1][m-1]\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, sys.stdin.readline().split())))\n    print(solve(n, m, k, a))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    grid = []\n    for i in range(n):\n        grid.append([int(x) for x in sys.stdin.readline().split()])\n    print(grid)\n    print(n, m, k)\n    print(solve(n, m, k, grid))\n\ndef solve(n, m, k, grid):\n    paths = [[0 for x in range(m)] for y in range(n)]\n    paths[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                paths[i][j] += paths[i-1][j]\n            if j > 0:\n                paths[i][j] += paths[i][j-1]\n            paths[i][j] %= 1000000007\n    print(paths)\n    return paths[n-1][m-1]\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    a = [[int(x) for x in sys.stdin.readline().split()] for _ in range(n)]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (a[i - 1][j - 1] ^ k) == 0:\n                ans += dp[i - 1][j - 1]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\ndp[1][1] = 1\n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if i == 1 and j == 1:\n            continue\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\nans = 0\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if i == 1 and j == 1:\n            continue\n        if (a[i-1][j-1] ^ k) == 0:\n            ans += dp[i-1][j]\n        if (a[i-1][j-1] ^ k) == a[i-1][j-1]:\n            ans += dp[i][j-1]\n\nprint(ans)"
    }
  ],
  "created": 1650422217,
  "id": "cmpl-4yuV7FbWs3TZD7Kx1iU4VkMH9Zatp",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 02:37:22.081409 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 02:37:22.081497 REASON stop
2022-04-20 02:37:22.082239 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    grid = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if i < n - 1:\n                dp[i][j] = dp[i + 1][j]\n            if j < m - 1:\n                dp[i][j] += dp[i][j + 1]\n            if (grid[i][j] ^ k) == 0:\n                ans += dp[i][j]\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:37:22.082326 REASON stop
2022-04-20 02:37:22.083136 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef solve(n, m, k, grid):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            if i == 1:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 1:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == n and j == m:\n                continue\n            if i == n:\n                if (grid[i - 1][j - 1] ^ k) == grid[i - 1][j]:\n                    ans += dp[i][j - 1]\n            elif j == m:\n                if (grid[i - 1][j - 1] ^ k) == grid[i][j - 1]:\n                    ans += dp[i - 1][j]\n            else:\n                if (grid[i - 1][j - 1] ^ k) == grid[i][j - 1]:\n                    ans += dp[i - 1][j]\n                if (grid[i - 1][j - 1] ^ k) == grid[i - 1][j]:\n                    ans += dp[i][j - 1]\n    return ans\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 02:37:22.083236 REASON stop
2022-04-20 02:37:22.106561 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1][j - 1] ^ k == 0:\n                ans += dp[i][j]\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:37:22.106734 REASON stop
2022-04-20 02:37:22.121933 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef solve(n, m, k, a):\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n            if i > 0 and j > 0:\n                dp[i][j] -= dp[i-1][j-1]\n            if i > 0 and j > 0 and a[i-1][j-1] ^ a[i][j] == k:\n                dp[i][j] += 1\n    return dp[n-1][m-1]\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, sys.stdin.readline().split())))\n    print(solve(n, m, k, a))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:37:22.122127 REASON stop
2022-04-20 02:37:22.123392 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    grid = []\n    for i in range(n):\n        grid.append([int(x) for x in sys.stdin.readline().split()])\n    print(grid)\n    print(n, m, k)\n    print(solve(n, m, k, grid))\n\ndef solve(n, m, k, grid):\n    paths = [[0 for x in range(m)] for y in range(n)]\n    paths[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                paths[i][j] += paths[i-1][j]\n            if j > 0:\n                paths[i][j] += paths[i][j-1]\n            paths[i][j] %= 1000000007\n    print(paths)\n    return paths[n-1][m-1]\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 02:37:22.123520 REASON stop
2022-04-20 02:37:22.124830 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    a = [[int(x) for x in sys.stdin.readline().split()] for _ in range(n)]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (a[i - 1][j - 1] ^ k) == 0:\n                ans += dp[i - 1][j - 1]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 02:37:22.124931 REASON stop
2022-04-20 02:37:22.125819 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\ndp[1][1] = 1\n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if i == 1 and j == 1:\n            continue\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\nans = 0\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if i == 1 and j == 1:\n            continue\n        if (a[i-1][j-1] ^ k) == 0:\n            ans += dp[i-1][j]\n        if (a[i-1][j-1] ^ k) == a[i-1][j-1]:\n            ans += dp[i][j-1]\n\nprint(ans)"
}
2022-04-20 02:37:22.126067 REASON stop
