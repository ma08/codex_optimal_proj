["\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    grid = []\n    for i in range(n):\n        grid.append([int(x) for x in sys.stdin.readline().split()])\n    print(grid)\n    print(n, m, k)\n    print(solve(n, m, k, grid))\n\ndef solve(n, m, k, grid):\n    paths = [[0 for x in range(m)] for y in range(n)]\n    paths[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                paths[i][j] += paths[i-1][j]\n            if j > 0:\n                paths[i][j] += paths[i][j-1]\n            paths[i][j] %= 1000000007\n    print(paths)\n    return paths[n-1][m-1]\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\n\ndef main():\n    n, m, k = [int(x) for x in sys.stdin.readline().split()]\n    a = [[int(x) for x in sys.stdin.readline().split()] for _ in range(n)]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (a[i - 1][j - 1] ^ k) == 0:\n                ans += dp[i - 1][j - 1]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    grid = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if i < n - 1:\n                dp[i][j] = dp[i + 1][j]\n            if j < m - 1:\n                dp[i][j] += dp[i][j + 1]\n            if (grid[i][j] ^ k) == 0:\n                ans += dp[i][j]\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef solve(n, m, k, a):\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n            if i > 0 and j > 0:\n                dp[i][j] -= dp[i-1][j-1]\n            if i > 0 and j > 0 and a[i-1][j-1] ^ a[i][j] == k:\n                dp[i][j] += 1\n    return dp[n-1][m-1]\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, sys.stdin.readline().split())))\n    print(solve(n, m, k, a))\n\nif __name__ == '__main__':\n    main()", "\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\ndp[1][1] = 1\n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if i == 1 and j == 1:\n            continue\n        dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\nans = 0\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if i == 1 and j == 1:\n            continue\n        if (a[i-1][j-1] ^ k) == 0:\n            ans += dp[i-1][j]\n        if (a[i-1][j-1] ^ k) == a[i-1][j-1]:\n            ans += dp[i][j-1]\n\nprint(ans)", "\n\ndef solve(n, m, k, grid):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            if i == 1:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 1:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == n and j == m:\n                continue\n            if i == n:\n                if (grid[i - 1][j - 1] ^ k) == grid[i - 1][j]:\n                    ans += dp[i][j - 1]\n            elif j == m:\n                if (grid[i - 1][j - 1] ^ k) == grid[i][j - 1]:\n                    ans += dp[i - 1][j]\n            else:\n                if (grid[i - 1][j - 1] ^ k) == grid[i][j - 1]:\n                    ans += dp[i - 1][j]\n                if (grid[i - 1][j - 1] ^ k) == grid[i - 1][j]:\n                    ans += dp[i][j - 1]\n    return ans\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split())))\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1][j - 1] ^ k == 0:\n                ans += dp[i][j]\n    print(ans)\n\nif __name__ == '__main__':\n    main()"]