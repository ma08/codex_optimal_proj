["\n\ndef read_ints():\n    return [int(x) for x in input().split()]\n\ndef read_int():\n    return int(input())\n\ndef main():\n    n, m = read_ints()\n    a = read_ints()\n    segments = []\n    for _ in range(m):\n        l, r = read_ints()\n        segments.append((l, r))\n    segments.sort(key=lambda x: (x[1] - x[0], x[0]))\n    segments.reverse()\n    # print(segments)\n    # print(a)\n    answer = 0\n    chosen = []\n    for l, r in segments:\n        if l == r:\n            continue\n        if a[l-1] > a[r-1]:\n            answer += a[l-1] - a[r-1]\n            a[l-1] = a[r-1]\n            chosen.append((l, r))\n    # print(a)\n    # print(chosen)\n    print(answer)\n    print(len(chosen))\n    for l, r in chosen:\n        print(l, r)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(10000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: \u96a3\u63a5\u884c\u5217(\u8ddd\u96e2\u4ed8\u304d)\n    N: \u30ce\u30fc\u30c9\u6570\n    K: \u59cb\u70b9\u30ce\u30fc\u30c9\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  \u73fe\u5728\u306e\u30ce\u30fc\u30c9\n    pre: \uff11\u3064\u524d\u306e\u30ce\u30fc\u30c9\n    dist: \u73fe\u5728\u306e\u8ddd\u96e2\n\n    \u4ee5\u4e0b\u306f\u5225\u9014\u7528\u610f\u3059\u308b\n    D: \u96a3\u63a5\u30ea\u30b9\u30c8(\u884c\u5217\u3067\u306f\u306a\u3044)\n    D_dfs_d: dfs_d\u95a2\u6570\u3067\u7528\u3044\u308b\uff0c\u59cb\u70b9\u30ce\u30fc\u30c9\u304b\u3089\u898b\u305f\u8ddd\u96e2\u30ea\u30b9\u30c8\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\ndef comb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r + 1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p - 1, r, p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\ndef bisearch(L, target):\n    low = 0\n    high = len(L) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        guess = L[mid]\n        if guess == target:\n            return True\n        elif guess < target:\n            low = mid + 1\n        elif guess > target:\n            high = mid - 1\n    if guess != target:\n        return False\n\n# --------------------------------------------\n\ndp = None\n\n\ndef main():\n    N, M = li_input()\n    A = li_input()\n    S = []\n    for i in range(M):\n        S.append(li_input())\n\n    S.sort(key=lambda x: x[1])\n\n    ans = 0\n    ans_seg = []\n    for i in range(M):\n        seg = S[i]\n        l = seg[0]\n        r = seg[1]\n        tmp = 0\n        for j in range(l - 1, r):\n            tmp += A[j]\n        if tmp > ans:\n            ans = tmp\n            ans_seg = [i + 1]\n        elif tmp == ans:\n            ans_seg.append(i + 1)\n\n    print(ans)\n    print(len(ans_seg))\n    print(*ans_seg)\n\n\nmain()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    segments = []\n    for _ in range(m):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append([l-1, r-1])\n    segments.sort(key=lambda x: (x[1]-x[0], x[0]))\n    #print(segments)\n    #print(a)\n    #print()\n    d = 0\n    chosen = []\n    for l, r in segments:\n        if l == r:\n            continue\n        if a[l] < a[r]:\n            a[l] += 1\n            a[r] -= 1\n            d += 2\n            chosen.append([l, r])\n        else:\n            a[l] -= 1\n            a[r] += 1\n            d += 2\n            chosen.append([l, r])\n    #print(a)\n    #print(d)\n    #print(chosen)\n    print(d)\n    print(len(chosen))\n    for l, r in chosen:\n        print(l+1, r+1)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    a = map(int, sys.stdin.readline().strip().split())\n    segs = []\n    for i in range(m):\n        l, r = map(int, sys.stdin.readline().strip().split())\n        segs.append((l, r))\n    segs.sort(key=lambda x: x[1])\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(m):\n        l, r = segs[i]\n        for j in range(l-1, r):\n            dp[j] -= 1\n    d = max(dp) - min(dp)\n    print d\n    print 0\n\nif __name__ == '__main__':\n    main()", "\n\n#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    segments = []\n    for i in range(m):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n    segments.sort(key=lambda x: x[1])\n    dp = [0]*n\n    for i in range(n):\n        dp[i] = a[i]\n    for i in range(m):\n        l, r = segments[i]\n        for j in range(l-1, r):\n            dp[j] -= 1\n    print(max(dp) - min(dp))\n    print(0)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    segments = []\n    for _ in range(m):\n        segments.append(list(map(int, input().split())))\n    d = 0\n    q = 0\n    c = []\n    for i in range(m):\n        if segments[i][0] == 1 and segments[i][1] == n:\n            q += 1\n            c.append(i+1)\n            d += min(a)\n    if q == 0:\n        for i in range(m):\n            if segments[i][0] == 1:\n                q += 1\n                c.append(i+1)\n                d += min(a[:segments[i][1]])\n            elif segments[i][1] == n:\n                q += 1\n                c.append(i+1)\n                d += min(a[segments[i][0]-1:])\n    print(d)\n    print(q)\n    print(*c)\n\nif __name__ == '__main__':\n    main()"]