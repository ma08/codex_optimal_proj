["\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    edges = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        edges.append((x, y, w))\n    edges.sort(key=lambda x: x[2])\n    dsu = DSU(n)\n    res = 0\n    for x, y, w in edges:\n        x -= 1\n        y -= 1\n        if dsu.find(x) != dsu.find(y):\n            dsu.union(x, y)\n            res += w\n    for i in range(n):\n        if dsu.find(i) != i:\n            res += a[i]\n    print(res)\n\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        offers.append((x, y, w))\n    offers.sort(key=lambda x: x[2])\n    p = [i for i in range(n + 1)]\n    r = [0] * (n + 1)\n    def find(x):\n        if p[x] != x:\n            p[x] = find(p[x])\n        return p[x]\n    def union(x, y):\n        xr = find(x)\n        yr = find(y)\n        if xr == yr:\n            return\n        if r[xr] < r[yr]:\n            p[xr] = yr\n        elif r[xr] > r[yr]:\n            p[yr] = xr\n        else:\n            p[yr] = xr\n            r[xr] += 1\n    ans = 0\n    for x, y, w in offers:\n        if find(x) != find(y):\n            union(x, y)\n            ans += w\n    for i in range(1, n + 1):\n        if find(i) != find(1):\n            ans += a[i - 1]\n            union(i, 1)\n    print(ans)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for i in range(m):\n        x, y, w = map(int, input().split())\n        offers.append((x, y, w))\n    print(solve(n, a, offers))\n\ndef solve(n, a, offers):\n    # TODO\n    return 0\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    offers = []\n    for _ in range(m):\n        x, y, w = map(int, sys.stdin.readline().split())\n        offers.append((x, y, w))\n    offers.sort(key=lambda x: x[2])\n    print(offers)\n    # TODO\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    offers = []\n    for _ in range(m):\n        x, y, w = map(int, sys.stdin.readline().split())\n        offers.append((x, y, w))\n    print(solve(n, a, offers))\n\ndef solve(n, a, offers):\n    # TODO\n    return 0\n\nif __name__ == '__main__':\n    main()", "\n\nimport heapq\n\ndef prim(n, edges):\n    \"\"\"\n    Prim's algorithm to find the minimum spanning tree of a graph.\n    \"\"\"\n\n    # Initialize the heap with the first vertex.\n    heap = [(0, 0)]\n    visited = set()\n    total = 0\n\n    # While there are still vertices to visit.\n    while heap:\n        # Get the next lowest cost vertex.\n        cost, vertex = heapq.heappop(heap)\n\n        # If we've already visited this vertex, skip it.\n        if vertex in visited:\n            continue\n\n        # Add the cost of this vertex to the total.\n        total += cost\n\n        # Add this vertex to the visited set.\n        visited.add(vertex)\n\n        # Add all of the edges from this vertex to the heap.\n        for edge in edges[vertex]:\n            heapq.heappush(heap, edge)\n\n    # If we didn't visit all of the vertices, the graph is not connected.\n    if len(visited) != n:\n        return -1\n\n    return total\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Initialize the edges list.\n    edges = [[] for _ in range(n)]\n\n    # Add the edges to the list.\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        edges[x - 1].append((w, y - 1))\n        edges[y - 1].append((w, x - 1))\n\n    # Add the edges that are not in the special offers.\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges[i].append((a[i] + a[j], j))\n            edges[j].append((a[i] + a[j], i))\n\n    # Use Prim's algorithm to find the minimum spanning tree.\n    print(prim(n, edges))\n\nif __name__ == '__main__':\n    main()"]