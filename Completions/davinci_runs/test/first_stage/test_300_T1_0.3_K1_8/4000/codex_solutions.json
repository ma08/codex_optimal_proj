["\n\nimport sys\n\ndef main():\n    # read input\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    # solve\n    res = solve(n, edges)\n    # print output\n    print(res[0])\n    print(res[1], res[2], res[3])\n\ndef solve(n, edges):\n    # build graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    # find a leaf\n    leaf = None\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaf = i\n            break\n    # find the farthest vertex from the leaf\n    farthest = None\n    max_dist = 0\n    visited = set()\n    queue = [(leaf, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # find the farthest vertex from the farthest vertex\n    farthest2 = None\n    max_dist = 0\n    visited = set()\n    queue = [(farthest, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest2 = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # find the farthest vertex from the farthest2 vertex\n    farthest3 = None\n    max_dist = 0\n    visited = set()\n    queue = [(farthest2, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest3 = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # return result\n    return (max_dist, farthest, farthest2, farthest3)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport collections\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, sys.stdin.readline().split()))\ndef LF(): return list(map(float, sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n = I()\n    edges = []\n    for i in range(n-1):\n        a, b = LI_()\n        edges.append((a, b))\n        edges.append((b, a))\n\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n\n    # print(uf)\n    # print(uf.all_group_members())\n\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if uf.same(i, j):\n                continue\n            for k in range(j+1, n):\n                if uf.same(i, k) or uf.same(j, k):\n                    continue\n                res = max(res, uf.size(i) + uf.size(j) + uf.size(k))\n\n    print(res)\n    for i in range(n):\n        for j in range(i+1, n):\n            if uf.same(i, j):\n                continue\n            for k in range(j+1, n):\n                if uf.same(i, k) or uf.same(j, k):\n                    continue\n                if res == uf.size(i) + uf.size(j) + uf.size(k):\n                    print(i+1, j+1, k+1)\n                    return\n\nmain()", "\n\nimport sys\n\n# TODO: implement\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()", "\n\n# Solution\n\n# Solution Approach\n\"\"\"\n\"\"\"\n\n# Solution Code\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(v, p):\n    global max_edges, ans\n    for u in adj[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        if len(adj[u]) == 1:\n            max_edges += 1\n            if max_edges > ans:\n                ans = max_edges\n                ans_v = v\n                ans_u = u\n\nmax_edges = 0\nans = 0\nans_v = 0\nans_u = 0\ndfs(1, 0)\n\nprint(ans)\nprint(ans_v, ans_u, ans_v)", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # dfs\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from node 1\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from the farthest node\n    visited = [False] * (n + 1)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from the farthest node\n    visited = [False] * (n + 1)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    print(n - 1)\n    print(1, node, node2)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport collections\n\ndef main():\n    n = int(input())\n    edges = [list(map(int, line.split())) for line in sys.stdin.readlines()]\n    graph = collections.defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n    max_edges = 0\n    for a in graph:\n        for b in graph[a]:\n            for c in graph[a]:\n                if b == c:\n                    continue\n                edges = set()\n                for v in graph[a]:\n                    if v == b or v == c:\n                        continue\n                    edges.add((a, v))\n                for v in graph[b]:\n                    if v == a or v == c:\n                        continue\n                    edges.add((b, v))\n                for v in graph[c]:\n                    if v == a or v == b:\n                        continue\n                    edges.add((c, v))\n                if len(edges) > max_edges:\n                    max_edges = len(edges)\n                    max_a = a\n                    max_b = b\n                    max_c = c\n    print(max_edges)\n    print(max_a, max_b, max_c)\n\nif __name__ == '__main__':\n    main()"]