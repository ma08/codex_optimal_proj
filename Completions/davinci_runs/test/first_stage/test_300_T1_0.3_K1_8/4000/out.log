2022-04-20 00:39:13.567642 """
You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.

Your task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.

The simple path is the path that visits each vertex at most once.


-----Input-----

The first line contains one integer number $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of vertices in the tree. 

Next $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \le a_i$, $b_i \le n$, $a_i \ne b_i$). It is guaranteed that given graph is a tree.


-----Output-----

In the first line print one integer $res$ — the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.

In the second line print three integers $a, b, c$ such that $1 \le a, b, c \le n$ and $a \ne, b \ne c, a \ne c$.

If there are several answers, you can print any.


-----Example-----
Input
8
1 2
2 3
3 4
4 5
4 6
3 7
3 8

Output
5
1 8 6



-----Note-----

The picture corresponding to the first example (and another one correct answer):

[Image]

If you choose vertices $1, 5, 6$ then the path between $1$ and $5$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 5)$, the path between $1$ and $6$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 6)$ and the path between $5$ and $6$ consists of edges $(4, 5), (4, 6)$. The union of these paths is $(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)$ so the answer is $5$. It can be shown that there is no better answer.
"""
2022-04-20 00:39:13.567657 --------------------------
2022-04-20 00:39:13.567763 using api key sourya
2022-04-20 00:40:37.827279 {
  "choices": [
    {
      "finish_reason": "length",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    adj_list = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n    # print(adj_list)\n    # print(n)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\n# TODO: implement\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport collections\n\ndef main():\n    n = int(input())\n    edges = [list(map(int, line.split())) for line in sys.stdin.readlines()]\n    graph = collections.defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n    max_edges = 0\n    for a in graph:\n        for b in graph[a]:\n            for c in graph[a]:\n                if b == c:\n                    continue\n                edges = set()\n                for v in graph[a]:\n                    if v == b or v == c:\n                        continue\n                    edges.add((a, v))\n                for v in graph[b]:\n                    if v == a or v == c:\n                        continue\n                    edges.add((b, v))\n                for v in graph[c]:\n                    if v == a or v == b:\n                        continue\n                    edges.add((c, v))\n                if len(edges) > max_edges:\n                    max_edges = len(edges)\n                    max_a = a\n                    max_b = b\n                    max_c = c\n    print(max_edges)\n    print(max_a, max_b, max_c)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\n# Solution\n\n# Solution Approach\n\"\"\"\n\"\"\"\n\n# Solution Code\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(v, p):\n    global max_edges, ans\n    for u in adj[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        if len(adj[u]) == 1:\n            max_edges += 1\n            if max_edges > ans:\n                ans = max_edges\n                ans_v = v\n                ans_u = u\n\nmax_edges = 0\nans = 0\nans_v = 0\nans_u = 0\ndfs(1, 0)\n\nprint(ans)\nprint(ans_v, ans_u, ans_v)"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport collections\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, sys.stdin.readline().split()))\ndef LF(): return list(map(float, sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n = I()\n    edges = []\n    for i in range(n-1):\n        a, b = LI_()\n        edges.append((a, b))\n        edges.append((b, a))\n\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n\n    # print(uf)\n    # print(uf.all_group_members())\n\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if uf.same(i, j):\n                continue\n            for k in range(j+1, n):\n                if uf.same(i, k) or uf.same(j, k):\n                    continue\n                res = max(res, uf.size(i) + uf.size(j) + uf.size(k))\n\n    print(res)\n    for i in range(n):\n        for j in range(i+1, n):\n            if uf.same(i, j):\n                continue\n            for k in range(j+1, n):\n                if uf.same(i, k) or uf.same(j, k):\n                    continue\n                if res == uf.size(i) + uf.size(j) + uf.size(k):\n                    print(i+1, j+1, k+1)\n                    return\n\nmain()"
    },
    {
      "finish_reason": "length",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\n\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1): res.append(res[i-1]*i%DVSR)\n    return res\n\nN=II()\n\ngraph = [[] for i in range(N+1)]\nfor i in range(N-1):\n    a, b = LI()\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef dfs(cur, prev):\n    res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        res += dfs(nxt, cur) + 1\n    return res\n\ndef dfs2(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs2(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs3(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs3(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs4(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs4(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs5(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs5(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs6(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs6(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs7(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs7(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs8(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs8(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs9(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs9(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs10(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs10(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs11(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs11(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs12(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs12(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs13(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs13(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs14(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs14(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs15(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs15(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs16(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs16(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs17(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs17(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs18(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs18(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs19(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs19(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs20(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs20(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs21(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs21(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs22(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs22(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs23(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs23(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs24(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs24(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs25(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs25(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs26(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs26(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs27(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs27(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs28(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs28(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs29(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs29(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs30(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs30(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs31(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs31(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs32(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs32(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs33(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs33(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs34(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs34(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs35(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs35(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs36(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs36(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs37(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max("
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    # read input\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    # solve\n    res = solve(n, edges)\n    # print output\n    print(res[0])\n    print(res[1], res[2], res[3])\n\ndef solve(n, edges):\n    # build graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    # find a leaf\n    leaf = None\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaf = i\n            break\n    # find the farthest vertex from the leaf\n    farthest = None\n    max_dist = 0\n    visited = set()\n    queue = [(leaf, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # find the farthest vertex from the farthest vertex\n    farthest2 = None\n    max_dist = 0\n    visited = set()\n    queue = [(farthest, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest2 = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # find the farthest vertex from the farthest2 vertex\n    farthest3 = None\n    max_dist = 0\n    visited = set()\n    queue = [(farthest2, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest3 = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # return result\n    return (max_dist, farthest, farthest2, farthest3)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # dfs\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from node 1\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from the farthest node\n    visited = [False] * (n + 1)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from the farthest node\n    visited = [False] * (n + 1)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    print(n - 1)\n    print(1, node, node2)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650415153,
  "id": "cmpl-4ysfBLmVJ46Kvq7WGlxh6cf4KHTXO",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 00:40:37.827801 0 {
  "finish_reason": "length",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef main():\n    n = int(sys.stdin.readline())\n    adj_list = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, sys.stdin.readline().split())\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n    # print(adj_list)\n    # print(n)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list)\n    # print(adj_list"
}
2022-04-20 00:40:37.827922 REASON length
2022-04-20 00:40:37.827935 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\n# TODO: implement\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 00:40:37.827976 REASON stop
2022-04-20 00:40:37.830319 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport collections\n\ndef main():\n    n = int(input())\n    edges = [list(map(int, line.split())) for line in sys.stdin.readlines()]\n    graph = collections.defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n    max_edges = 0\n    for a in graph:\n        for b in graph[a]:\n            for c in graph[a]:\n                if b == c:\n                    continue\n                edges = set()\n                for v in graph[a]:\n                    if v == b or v == c:\n                        continue\n                    edges.add((a, v))\n                for v in graph[b]:\n                    if v == a or v == c:\n                        continue\n                    edges.add((b, v))\n                for v in graph[c]:\n                    if v == a or v == b:\n                        continue\n                    edges.add((c, v))\n                if len(edges) > max_edges:\n                    max_edges = len(edges)\n                    max_a = a\n                    max_b = b\n                    max_c = c\n    print(max_edges)\n    print(max_a, max_b, max_c)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 00:40:37.830481 REASON stop
2022-04-20 00:40:37.830976 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\n# Solution\n\n# Solution Approach\n\"\"\"\n\"\"\"\n\n# Solution Code\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(v, p):\n    global max_edges, ans\n    for u in adj[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        if len(adj[u]) == 1:\n            max_edges += 1\n            if max_edges > ans:\n                ans = max_edges\n                ans_v = v\n                ans_u = u\n\nmax_edges = 0\nans = 0\nans_v = 0\nans_u = 0\ndfs(1, 0)\n\nprint(ans)\nprint(ans_v, ans_u, ans_v)"
}
2022-04-20 00:40:37.831059 REASON stop
2022-04-20 00:40:37.870972 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport collections\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, sys.stdin.readline().split()))\ndef LF(): return list(map(float, sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n = I()\n    edges = []\n    for i in range(n-1):\n        a, b = LI_()\n        edges.append((a, b))\n        edges.append((b, a))\n\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n\n    # print(uf)\n    # print(uf.all_group_members())\n\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if uf.same(i, j):\n                continue\n            for k in range(j+1, n):\n                if uf.same(i, k) or uf.same(j, k):\n                    continue\n                res = max(res, uf.size(i) + uf.size(j) + uf.size(k))\n\n    print(res)\n    for i in range(n):\n        for j in range(i+1, n):\n            if uf.same(i, j):\n                continue\n            for k in range(j+1, n):\n                if uf.same(i, k) or uf.same(j, k):\n                    continue\n                if res == uf.size(i) + uf.size(j) + uf.size(k):\n                    print(i+1, j+1, k+1)\n                    return\n\nmain()"
}
2022-04-20 00:40:37.871115 REASON stop
2022-04-20 00:40:37.872123 5 {
  "finish_reason": "length",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\n\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1): res.append(res[i-1]*i%DVSR)\n    return res\n\nN=II()\n\ngraph = [[] for i in range(N+1)]\nfor i in range(N-1):\n    a, b = LI()\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef dfs(cur, prev):\n    res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        res += dfs(nxt, cur) + 1\n    return res\n\ndef dfs2(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs2(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs3(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs3(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs4(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs4(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs5(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs5(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs6(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs6(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs7(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs7(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs8(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs8(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs9(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs9(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs10(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs10(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs11(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs11(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs12(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs12(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs13(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs13(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs14(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs14(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs15(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs15(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs16(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs16(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs17(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs17(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs18(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs18(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs19(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs19(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs20(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs20(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs21(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs21(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs22(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs22(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs23(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs23(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs24(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs24(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs25(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs25(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs26(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs26(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs27(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs27(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs28(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs28(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs29(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs29(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs30(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs30(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs31(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs31(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs32(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs32(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs33(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs33(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs34(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs34(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs35(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs35(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs36(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max(max_res, dfs36(nxt, cur, res) + 1)\n    return max_res\n\ndef dfs37(cur, prev, res):\n    max_res = 0\n    for nxt in graph[cur]:\n        if nxt == prev: continue\n        max_res = max("
}
2022-04-20 00:40:37.872291 REASON length
2022-04-20 00:40:37.872300 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    # read input\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    # solve\n    res = solve(n, edges)\n    # print output\n    print(res[0])\n    print(res[1], res[2], res[3])\n\ndef solve(n, edges):\n    # build graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    # find a leaf\n    leaf = None\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaf = i\n            break\n    # find the farthest vertex from the leaf\n    farthest = None\n    max_dist = 0\n    visited = set()\n    queue = [(leaf, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # find the farthest vertex from the farthest vertex\n    farthest2 = None\n    max_dist = 0\n    visited = set()\n    queue = [(farthest, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest2 = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # find the farthest vertex from the farthest2 vertex\n    farthest3 = None\n    max_dist = 0\n    visited = set()\n    queue = [(farthest2, 0)]\n    while queue:\n        v, dist = queue.pop(0)\n        if dist > max_dist:\n            max_dist = dist\n            farthest3 = v\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                queue.append((u, dist + 1))\n    # return result\n    return (max_dist, farthest, farthest2, farthest3)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 00:40:37.872344 REASON stop
2022-04-20 00:40:37.873201 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # dfs\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from node 1\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from the farthest node\n    visited = [False] * (n + 1)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    # find the farthest node from the farthest node\n    visited = [False] * (n + 1)\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n\n    print(n - 1)\n    print(1, node, node2)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 00:40:37.873388 REASON stop
