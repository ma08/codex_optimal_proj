["\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    roads = []\n    for i in range(m):\n        roads.append(list(map(int, sys.stdin.readline().split())))\n    print(roads)\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport heapq\n\ndef dijkstra(graph, start):\n    dist = {start: 0}\n    queue = [(0, start)]\n    while queue:\n        dist_u, u = heapq.heappop(queue)\n        for v, w in graph[u]:\n            alt = dist_u + w\n            if v not in dist or alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(queue, (alt, v))\n    return dist\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append((b, 1))\n        graph[b].append((a, 1))\n    dist = dijkstra(graph, 1)\n    min_sum = sum(dist.values())\n    min_roads = [0] * m\n    for i in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        if dist[a] + 1 == dist[b]:\n            min_roads[i] = 1\n    print(1)\n    print(''.join(map(str, min_roads)))\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\nimport math\nimport collections\nimport itertools\nimport array\nimport inspect\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\n# Debug output\ndef chkprint(*args):\n    names = {\n        id(v): k\n        for k, v in inspect.currentframe().f_back.f_locals.items()\n    }\n    print(', '.join(\n        names.get(id(arg), '???') + ' = ' + repr(arg) for arg in args))\n\n\n# Binary converter\ndef to_bin(x):\n    return bin(x)[2:]\n\n\ndef li_input():\n    return [int(_) for _ in input().split()]\n\n\ndef gcd(n, m):\n    if n % m == 0:\n        return m\n    else:\n        return gcd(m, n % m)\n\n\ndef gcd_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = gcd(v, L[i])\n\n    return v\n\n\ndef lcm(n, m):\n    return (n * m) // gcd(n, m)\n\n\ndef lcm_list(L):\n    v = L[0]\n\n    for i in range(1, len(L)):\n        v = lcm(v, L[i])\n\n    return v\n\n\n# Width First Search (+ Distance)\ndef wfs_d(D, N, K):\n    \"\"\"\n    D: \u96a3\u63a5\u884c\u5217(\u8ddd\u96e2\u4ed8\u304d)\n    N: \u30ce\u30fc\u30c9\u6570\n    K: \u59cb\u70b9\u30ce\u30fc\u30c9\n    \"\"\"\n\n    dfk = [-1] * (N + 1)\n    dfk[K] = 0\n\n    cps = [(K, 0)]\n    r = [False] * (N + 1)\n    r[K] = True\n    while len(cps) != 0:\n        n_cps = []\n        for cp, cd in cps:\n            for i, dfcp in enumerate(D[cp]):\n                if dfcp != -1 and not r[i]:\n                    dfk[i] = cd + dfcp\n                    n_cps.append((i, cd + dfcp))\n                    r[i] = True\n\n        cps = n_cps[:]\n\n    return dfk\n\n\n# Depth First Search (+Distance)\ndef dfs_d(v, pre, dist):\n    \"\"\"\n    v:  \u73fe\u5728\u306e\u30ce\u30fc\u30c9\n    pre: \uff11\u3064\u524d\u306e\u30ce\u30fc\u30c9\n    dist: \u73fe\u5728\u306e\u8ddd\u96e2\n\n    \u4ee5\u4e0b\u306f\u5225\u9014\u7528\u610f\u3059\u308b\n    D: \u96a3\u63a5\u30ea\u30b9\u30c8(\u884c\u5217\u3067\u306f\u306a\u3044)\n    D_dfs_d: dfs_d\u95a2\u6570\u3067\u7528\u3044\u308b\uff0c\u59cb\u70b9\u30ce\u30fc\u30c9\u304b\u3089\u898b\u305f\u8ddd\u96e2\u30ea\u30b9\u30c8\n    \"\"\"\n\n    global D\n    global D_dfs_d\n\n    D_dfs_d[v] = dist\n\n    for next_v, d in D[v]:\n        if next_v != pre:\n            dfs_d(next_v, v, dist + d)\n\n    return\n\n\ndef sigma(N):\n    ans = 0\n    for i in range(1, N + 1):\n        ans += i\n    return ans\n\n\nclass Combination:\n    def __init__(self, n, mod):\n\n        g1 = [1, 1]\n        g2 = [1, 1]\n        inverse = [0, 1]\n        for i in range(2, n + 1):\n            g1.append((g1[-1] * i) % mod)\n            inverse.append((-inverse[mod % i] * (mod // i)) % mod)\n            g2.append((g2[-1] * inverse[-1]) % mod)\n\n        self.MOD = mod\n        self.N = n\n        self.g1 = g1\n        self.g2 = g2\n        self.inverse = inverse\n\n    def __call__(self, n, r):\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.g1[n] * self.g2[r] * self.g2[n - r] % self.MOD\n\n\ndef bisearch(L, target):\n    low = 0\n    high = len(L) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = L[mid]\n        if guess == target:\n            return True\n        elif guess < target:\n            low = mid + 1\n        elif guess > target:\n            high = mid - 1\n    if guess != target:\n        return False\n\n\n# --------------------------------------------\n\ndp = None\n\n\ndef main():\n    N, M, K = li_input()\n    D = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = li_input()\n        D[a].append((b, 1))\n        D[b].append((a, 1))\n\n    dfs_d(1, -1, 0)\n    D_dfs_d[1] = 0\n    D_dfs_d = D_dfs_d[1:]\n    D_dfs_d.sort()\n\n    D_dfs_d_set = set(D_dfs_d)\n    D_dfs_d_set = list(D_dfs_d_set)\n    D_dfs_d_set.sort()\n\n    D_dfs_d_dict = {}\n    for i, v in enumerate(D_dfs_d_set):\n        D_dfs_d_dict[v] = i\n\n    D_dfs_d_dict_rev = {}\n    for k, v in D_dfs_d_dict.items():\n        D_dfs_d_dict_rev[v] = k\n\n    D_dfs_d_cnt = [0] * len(D_dfs_d_set)\n    for v in D_dfs_d:\n        D_dfs_d_cnt[D_dfs_d_dict[v]] += 1\n\n    D_dfs_d_cnt_sum = [0] * len(D_dfs_d_set)\n    for i in range(len(D_dfs_d_set)):\n        D_dfs_d_cnt_sum[i] = D_dfs_d_cnt[i] + D_dfs_d_cnt_sum[i - 1]\n\n    D_dfs_d_cnt_sum_rev = [0] * len(D_dfs_d_set)\n    for i in range(len(D_dfs_d_set)):\n        D_dfs_d_cnt_sum_rev[i] = D_dfs_d_cnt_sum[i] - D_dfs_d_cnt[i]\n\n    D_dfs_d_cnt_sum_rev[0] = 0\n\n    D_dfs_d_cnt_sum_rev_dict = {}\n    for i in range(len(D_dfs_d_set)):\n        D_dfs_d_cnt_sum_rev_dict[D_dfs_d_cnt_sum_rev[i]] = i\n\n    D_dfs_d_cnt_sum_rev_dict_rev = {}\n    for k, v in D_dfs_d_cnt_sum_rev_dict.items():\n        D_dfs_d_cnt_sum_rev_dict_rev[v] = k\n\n    ans = []\n    for i in range(len(D_dfs_d_set)):\n        if D_dfs_d_cnt_sum_rev[i] <= K:\n            ans.append(D_dfs_d_cnt_sum_rev[i])\n\n    print(len(ans))\n    for a in ans:\n        print(to_bin(a).zfill(M))\n\n\nmain()", "\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    roads = []\n    for i in range(m):\n        roads.append(tuple(map(int, sys.stdin.readline().strip().split())))\n    roads = sorted(roads, key=lambda x: x[0])\n    print(roads)\n    for i in range(m):\n        print(roads[i][0], roads[i][1])\n\nif __name__ == '__main__':\n    main()", "\n\nimport sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    edges = []\n    for i in range(m):\n        edges.append(map(int, sys.stdin.readline().split()))\n    print(n, m, k)\n    print(edges)\n\nif __name__ == '__main__':\n    main()"]