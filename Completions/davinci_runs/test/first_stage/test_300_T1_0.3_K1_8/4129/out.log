2022-04-20 02:33:50.920624 """
There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.

What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?

New roads will also be one-way.


-----Input-----

The first line of input consists of three integers $n$, $m$ and $s$ ($1 \le n \le 5000, 0 \le m \le 5000, 1 \le s \le n$) — the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.

The following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).


-----Output-----

Print one integer — the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.


-----Examples-----
Input
9 9 1
1 2
1 3
2 3
1 5
5 6
6 1
1 8
9 8
7 1

Output
3

Input
5 4 5
1 2
2 3
3 4
4 1

Output
1



-----Note-----

The first example is illustrated by the following: [Image] 

For example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.

The second example is illustrated by the following: [Image] 

In this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.
"""
2022-04-20 02:33:50.920650 --------------------------
2022-04-20 02:33:50.920833 using api key gabby
2022-04-20 02:34:16.388494 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# Solution\n\n#!/usr/bin/python\n\nimport sys\n\nsys.setrecursionlimit(100000)\n\ndef dfs(v, visited, adj):\n    visited[v] = True\n    for u in adj[v]:\n        if not visited[u]:\n            dfs(u, visited, adj)\n\ndef main():\n    n, m, s = map(int, raw_input().split())\n    adj = [[] for i in xrange(n)]\n    for i in xrange(m):\n        u, v = map(int, raw_input().split())\n        adj[u - 1].append(v - 1)\n    visited = [False for i in xrange(n)]\n    dfs(s - 1, visited, adj)\n    print sum(map(lambda x: not x, visited))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u-1].append(v-1)\n    visited = [False for i in range(n)]\n    stack = [s-1]\n    while stack:\n        u = stack.pop()\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                stack.append(v)\n    print(sum(not visited[i] for i in range(n)))\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj_list[u-1].append(v-1)\n    visited = [False] * n\n    queue = [s-1]\n    visited[s-1] = True\n    while queue:\n        u = queue.pop(0)\n        for v in adj_list[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n    print(sum(not visited[i] for i in range(n)))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 3,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n\n    visited = [0]*(n+1)\n    visited[s] = 1\n    queue = [s]\n    while queue:\n        u = queue.pop(0)\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = 1\n                queue.append(v)\n\n    print(sum(1 for i in range(1, n+1) if not visited[i]))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 4,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\ndef debug(func):\n    \"\"\"Print the function signature and return value\"\"\"\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        print(func.__name__, args, kwargs, \"->\", result)\n        return result\n    return wrapper\n\n\n@debug\ndef reachable(graph, start, visited=None):\n    \"\"\"Return the set of nodes reachable from the start node\"\"\"\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            reachable(graph, node, visited)\n    return visited\n\n\n@debug\ndef build_graph(roads):\n    \"\"\"Return a graph of the roads\"\"\"\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n    return graph\n\n\n@debug\ndef solve(graph, start):\n    \"\"\"Return the minimum number of extra roads needed to make all the cities reachable from city s\"\"\"\n    reachable_cities = reachable(graph, start)\n    extra_roads = 0\n    for city in range(1, len(graph)+1):\n        if city not in reachable_cities:\n            extra_roads += 1\n    return extra_roads\n\n\nif __name__ == \"__main__\":\n\n    # Single variables\n    n, m, s = [int(val) for val in input().split()]\n\n    # Vector of integers\n    roads = []\n    for i in range(m):\n        # Single variables in list\n        roads.append([int(val) for val in input().split()])\n\n    graph = build_graph(roads)\n    result = solve(graph, s)\n    print(result)"
    },
    {
      "finish_reason": "stop",
      "index": 5,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u-1].append(v-1)\n    visited = [False] * n\n    visited[s-1] = True\n    queue = [s-1]\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n    print(n - sum(visited) - 1)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 6,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    roads = []\n    for _ in range(m):\n        roads.append(tuple(map(int, sys.stdin.readline().split())))\n    print(roads)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 7,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport string\nimport queue\nimport collections\nimport time\nimport re\n\n#sys.stdin = open('input.txt', 'r')\n#sys.stdout = open('output.txt', 'w')\n\ndef main():\n    n, m, s = map(int, input().split())\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n    vis = [0 for i in range(n + 1)]\n    q = queue.Queue()\n    q.put(s)\n    vis[s] = 1\n    while not q.empty():\n        u = q.get()\n        for v in adj[u]:\n            if not vis[v]:\n                vis[v] = 1\n                q.put(v)\n    ans = 0\n    for i in range(1, n + 1):\n        if not vis[i]:\n            ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650422031,
  "id": "cmpl-4yuS7K6dXMEWQ2lw9G9EMTriiPyzO",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-20 02:34:16.388984 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# Solution\n\n#!/usr/bin/python\n\nimport sys\n\nsys.setrecursionlimit(100000)\n\ndef dfs(v, visited, adj):\n    visited[v] = True\n    for u in adj[v]:\n        if not visited[u]:\n            dfs(u, visited, adj)\n\ndef main():\n    n, m, s = map(int, raw_input().split())\n    adj = [[] for i in xrange(n)]\n    for i in xrange(m):\n        u, v = map(int, raw_input().split())\n        adj[u - 1].append(v - 1)\n    visited = [False for i in xrange(n)]\n    dfs(s - 1, visited, adj)\n    print sum(map(lambda x: not x, visited))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:34:16.389171 REASON stop
2022-04-20 02:34:16.389898 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u-1].append(v-1)\n    visited = [False for i in range(n)]\n    stack = [s-1]\n    while stack:\n        u = stack.pop()\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                stack.append(v)\n    print(sum(not visited[i] for i in range(n)))\n\nmain()"
}
2022-04-20 02:34:16.389998 REASON stop
2022-04-20 02:34:16.390605 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj_list[u-1].append(v-1)\n    visited = [False] * n\n    queue = [s-1]\n    visited[s-1] = True\n    while queue:\n        u = queue.pop(0)\n        for v in adj_list[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n    print(sum(not visited[i] for i in range(n)))\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 02:34:16.390696 REASON stop
2022-04-20 02:34:16.416660 3 {
  "finish_reason": "stop",
  "index": 3,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, m, s = map(int, input().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n\n    visited = [0]*(n+1)\n    visited[s] = 1\n    queue = [s]\n    while queue:\n        u = queue.pop(0)\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = 1\n                queue.append(v)\n\n    print(sum(1 for i in range(1, n+1) if not visited[i]))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:34:16.416859 REASON stop
2022-04-20 02:34:16.417613 4 {
  "finish_reason": "stop",
  "index": 4,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# Set max recursion limit\nsys.setrecursionlimit(1000000)\n\n\ndef debug(func):\n    \"\"\"Print the function signature and return value\"\"\"\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        print(func.__name__, args, kwargs, \"->\", result)\n        return result\n    return wrapper\n\n\n@debug\ndef reachable(graph, start, visited=None):\n    \"\"\"Return the set of nodes reachable from the start node\"\"\"\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for node in graph[start]:\n        if node not in visited:\n            reachable(graph, node, visited)\n    return visited\n\n\n@debug\ndef build_graph(roads):\n    \"\"\"Return a graph of the roads\"\"\"\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n    return graph\n\n\n@debug\ndef solve(graph, start):\n    \"\"\"Return the minimum number of extra roads needed to make all the cities reachable from city s\"\"\"\n    reachable_cities = reachable(graph, start)\n    extra_roads = 0\n    for city in range(1, len(graph)+1):\n        if city not in reachable_cities:\n            extra_roads += 1\n    return extra_roads\n\n\nif __name__ == \"__main__\":\n\n    # Single variables\n    n, m, s = [int(val) for val in input().split()]\n\n    # Vector of integers\n    roads = []\n    for i in range(m):\n        # Single variables in list\n        roads.append([int(val) for val in input().split()])\n\n    graph = build_graph(roads)\n    result = solve(graph, s)\n    print(result)"
}
2022-04-20 02:34:16.417741 REASON stop
2022-04-20 02:34:16.431140 5 {
  "finish_reason": "stop",
  "index": 5,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u-1].append(v-1)\n    visited = [False] * n\n    visited[s-1] = True\n    queue = [s-1]\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n    print(n - sum(visited) - 1)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:34:16.431292 REASON stop
2022-04-20 02:34:16.432263 6 {
  "finish_reason": "stop",
  "index": 6,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    roads = []\n    for _ in range(m):\n        roads.append(tuple(map(int, sys.stdin.readline().split())))\n    print(roads)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-20 02:34:16.432373 REASON stop
2022-04-20 02:34:16.433330 7 {
  "finish_reason": "stop",
  "index": 7,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nimport bisect\nimport random\nimport itertools\nimport string\nimport queue\nimport collections\nimport time\nimport re\n\n#sys.stdin = open('input.txt', 'r')\n#sys.stdout = open('output.txt', 'w')\n\ndef main():\n    n, m, s = map(int, input().split())\n    adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n    vis = [0 for i in range(n + 1)]\n    q = queue.Queue()\n    q.put(s)\n    vis[s] = 1\n    while not q.empty():\n        u = q.get()\n        for v in adj[u]:\n            if not vis[v]:\n                vis[v] = 1\n                q.put(v)\n    ans = 0\n    for i in range(1, n + 1):\n        if not vis[i]:\n            ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-20 02:34:16.433556 REASON stop
