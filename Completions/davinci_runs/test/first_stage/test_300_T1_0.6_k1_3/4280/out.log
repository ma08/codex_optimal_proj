2022-04-18 04:02:47.833063 """
Treeland consists of $n$ cities and $n-1$ roads. Each road is bidirectional and connects two distinct cities. From any city you can get to any other city by roads. Yes, you are right — the country's topology is an undirected tree.

There are some private road companies in Treeland. The government decided to sell roads to the companies. Each road will belong to one company and a company can own multiple roads.

The government is afraid to look unfair. They think that people in a city can consider them unfair if there is one company which owns two or more roads entering the city. The government wants to make such privatization that the number of such cities doesn't exceed $k$ and the number of companies taking part in the privatization is minimal.

Choose the number of companies $r$ such that it is possible to assign each road to one company in such a way that the number of cities that have two or more roads of one company is at most $k$. In other words, if for a city all the roads belong to the different companies then the city is good. Your task is to find the minimal $r$ that there is such assignment to companies from $1$ to $r$ that the number of cities which are not good doesn't exceed $k$. [Image] The picture illustrates the first example ($n=6, k=2$). The answer contains $r=2$ companies. Numbers on the edges denote edge indices. Edge colors mean companies: red corresponds to the first company, blue corresponds to the second company. The gray vertex (number $3$) is not good. The number of such vertices (just one) doesn't exceed $k=2$. It is impossible to have at most $k=2$ not good cities in case of one company. 


-----Input-----

The first line contains two integers $n$ and $k$ ($2 \le n \le 200000, 0 \le k \le n - 1$) — the number of cities and the maximal number of cities which can have two or more roads belonging to one company.

The following $n-1$ lines contain roads, one road per line. Each line contains a pair of integers $x_i$, $y_i$ ($1 \le x_i, y_i \le n$), where $x_i$, $y_i$ are cities connected with the $i$-th road.


-----Output-----

In the first line print the required $r$ ($1 \le r \le n - 1$). In the second line print $n-1$ numbers $c_1, c_2, \dots, c_{n-1}$ ($1 \le c_i \le r$), where $c_i$ is the company to own the $i$-th road. If there are multiple answers, print any of them.


-----Examples-----
Input
6 2
1 4
4 3
3 5
3 6
5 2

Output
2
1 2 1 1 2 
Input
4 2
3 1
1 4
1 2

Output
1
1 1 1 
Input
10 2
10 3
1 2
1 3
1 4
2 5
2 6
2 7
3 8
3 9

Output
3
1 1 2 3 2 3 1 3 1
"""
2022-04-18 04:02:47.833086 --------------------------
2022-04-18 04:04:10.090375 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n, k = map(int, raw_input().split())\n    edges = {}\n    for i in range(n-1):\n        a, b = map(int, raw_input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(\" \".join([str(i%r+1) for i in range(n-1)]))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\"\"\"\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n\"\"\"\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t\"\"\"\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t\"\"\"\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t\"\"\"\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t\"\"\"\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t\"\"\"\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t\"\"\"\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components):\n\t\t\"\"\"\n\t\t\tGroup roads in connected components\n\t\t\"\"\"\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t\"\"\"\n\t\t\tAssign companies to roads\n\t\t\"\"\"\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t\"\"\"\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t\"\"\"\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint -1\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint company_assignment[(g.edges[i][0], g.edges[i][1])],\n\tprint\n\n\nif __name__ == '__main__':\n\tmain()"
    }
  ],
  "created": 1650254567,
  "id": "cmpl-4yCt5pcpleJikzbOIuBotAmQoew4i",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 04:04:10.090721 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 04:04:10.090795 REASON stop
2022-04-18 04:04:10.111086 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n, k = map(int, raw_input().split())\n    edges = {}\n    for i in range(n-1):\n        a, b = map(int, raw_input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(\" \".join([str(i%r+1) for i in range(n-1)]))\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-18 04:04:10.111150 REASON stop
2022-04-18 04:04:10.111695 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\"\"\"\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n\"\"\"\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t\"\"\"\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t\"\"\"\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t\"\"\"\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t\"\"\"\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t\"\"\"\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t\"\"\"\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components):\n\t\t\"\"\"\n\t\t\tGroup roads in connected components\n\t\t\"\"\"\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t\"\"\"\n\t\t\tAssign companies to roads\n\t\t\"\"\"\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t\"\"\"\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t\"\"\"\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint -1\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint company_assignment[(g.edges[i][0], g.edges[i][1])],\n\tprint\n\n\nif __name__ == '__main__':\n\tmain()"
}
2022-04-18 04:04:10.111790 REASON stop
