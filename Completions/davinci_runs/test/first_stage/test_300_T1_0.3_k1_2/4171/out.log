2022-04-18 21:06:05.711608 """
The only difference between easy and hard versions is the number of elements in the array.

You are given an array $a$ consisting of $n$ integers. In one move you can choose any $a_i$ and divide it by $2$ rounding down (in other words, in one move you can set $a_i := \lfloor\frac{a_i}{2}\rfloor$).

You can perform such an operation any (possibly, zero) number of times with any $a_i$.

Your task is to calculate the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.

Don't forget that it is possible to have $a_i = 0$ after some operations, thus the answer always exists.


-----Input-----

The first line of the input contains two integers $n$ and $k$ ($1 \le k \le n \le 2 \cdot 10^5$) — the number of elements in the array and the number of equal numbers required.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 2 \cdot 10^5$), where $a_i$ is the $i$-th element of $a$.


-----Output-----

Print one integer — the minimum possible number of operations required to obtain at least $k$ equal numbers in the array.


-----Examples-----
Input
5 3
1 2 2 4 5

Output
1

Input
5 3
1 2 3 4 5

Output
2

Input
5 3
1 2 3 3 3

Output
0
"""
2022-04-18 21:06:05.711639 --------------------------
2022-04-18 21:06:40.093146 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)"
    }
  ],
  "created": 1650315965,
  "id": "cmpl-4ySrNikAJ4nqr5fCHYQapTie2Mc57",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 21:06:40.093480 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == a[-1]:\n        print(0)\n    else:\n        print(a[-1] - a[0] - 1)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 21:06:40.093520 REASON stop
2022-04-18 21:06:40.135050 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n#-----Solution-----\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Find the maximum number of operations required to make all elements equal\n# This is the number of operations required to make the largest element equal to the smallest element\nmax_ops = a[0] - a[-1]\n\n# Find the minimum number of operations required to make all elements equal\n# This is the number of operations required to make the smallest element equal to the largest element divided by 2\nmin_ops = (a[0] - a[-1]) // 2\n\n# If the minimum number of operations required to make all elements equal is less than the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the minimum number of operations\nif min_ops < max_ops:\n    print(min_ops)\n\n# If the minimum number of operations required to make all elements equal is greater than or equal to the maximum number of operations required to make all elements equal\n# Then we can make all elements equal in the maximum number of operations\nelse:\n    # Find the number of elements that are equal to the largest element\n    num_largest = a.count(a[0])\n\n    # If the number of elements that are equal to the largest element is greater than or equal to the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations\n    if num_largest >= k:\n        print(max_ops)\n\n    # If the number of elements that are equal to the largest element is less than the number of elements required to be equal\n    # Then we can make all elements equal in the maximum number of operations plus the number of operations required to make the largest element equal to the second largest element\n    else:\n        print(max_ops + (a[1] - a[0]) // 2)"
}
2022-04-18 21:06:40.135199 REASON stop
