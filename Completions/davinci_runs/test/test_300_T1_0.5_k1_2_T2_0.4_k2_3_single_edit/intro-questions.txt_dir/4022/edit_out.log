2022-04-20 00:38:58.266758 num operations 1
2022-04-20 00:38:58.266778 size on input set 1
2022-04-20 00:38:58.266933 using api key gabby
2022-04-20 00:39:00.587175 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution 1:\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2:\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        a = min(a, x[j][0])\n        b = max(b, x[j][1])\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650415138,
  "object": "edit"
}
2022-04-20 00:39:00.587468 fix syntax errors 3 ['\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1:\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2:\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        a = min(a, x[j][0])\n        b = max(b, x[j][1])\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-20 00:39:00.587518 size on output set 3
2022-04-20 00:39:00.587531 num operations 1
2022-04-20 00:39:00.587538 size on input set 1
2022-04-20 00:39:00.587707 using api key soukgp
2022-04-20 00:39:33.544548 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n"
    },
    {
      "index": 1,
      "text": "\n"
    },
    {
      "index": 2,
      "text": "\n\ndef solution(A):\n    # write your code in Python 3.6\n    pass\n"
    }
  ],
  "created": 1650415140,
  "object": "edit"
}
2022-04-20 00:39:33.544963 fix syntax errors 3 ["\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n\n# # SOLUTION\n# # The problem is to find the segment with the least intersection length.\n# # If we sort the segments by their left endpoints, we can consider the\n# # problem as finding the segment with the least intersection length with\n# # the segment before it.\n\n# # To do this, we can keep track of the right endpoint of the previous\n# # segment.  For the first segment, we just set the right endpoint to\n# # -infinity.  For the next segment, we compute the intersection length\n# # and update the right endpoint to the right endpoint of the current\n# # segment.  We can then keep track of the minimum intersection length\n# # and return at the end.\n\n# # We can use a heap to keep track of the right endpoint of the previous\n# # segment and then just pop the first element, which will be the\n# # minimum.\n\n# import heapq\n\n# n = int(input())\n# segments = []\n# for i in range(n):\n#     l, r = map(int, input().split())\n#     segments.append((l, r))\n\n# segments.sort()\n\n# heap = [float('-inf')]\n# min_intersection = float('inf')\n\n# for l, r in segments:\n#     min_intersection = min(min_intersection, heap[0] - l)\n#     heapq.heappush(heap, r)\n\n# print(min_intersection)\n", '\n', '\n\ndef solution(A):\n    # write your code in Python 3.6\n    pass\n']
2022-04-20 00:39:33.545043 size on output set 3
