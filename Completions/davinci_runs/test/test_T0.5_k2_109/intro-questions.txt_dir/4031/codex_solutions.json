["\n\ndef main():\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(input())\n    l.sort(key=len)\n    for i in range(n):\n        for j in range(i+1,n):\n            if l[j].find(l[i]) == -1:\n                print(\"NO\")\n                return\n    print(\"YES\")\n    for i in l:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()", "\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    \"\"\"Performs a depth-first search and returns a Topological Sort of the graph.\n    Raises an exception if the graph has a cycle.\n    \"\"\"\n    # A list to keep track of the visit status of nodes\n    visited = [False]*len(graph)\n    # A list to store the sorted elements\n    top_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store Topological Sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == \"__main__\":\n    main()"]