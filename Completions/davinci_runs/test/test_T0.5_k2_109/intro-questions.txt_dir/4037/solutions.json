["'''input\n5 20\n45 -6\n34 -15\n10 34\n1 27\n40 -45\n\n\n'''\nimport sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn, r = ri()\n\neventspos = []\neventsneg = []\nfor i in range(n):\n\ttemp =ri()\n\tif temp[1]>=0:\n\t\teventspos.append(temp)\n\telse:\n\t\teventsneg.append(temp)\n\neventspos.sort()\neventsneg.sort(key = lambda x: x[0]+x[1])\neventsneg.reverse()\n\nstatus =1\n\nans=0 \n\nfor i in range(len(eventspos)):\n\tif eventspos[i][0] <= r:\n\t\tr+= eventspos[i][1]\n\t\tans+=1\n\telse:\n\t\tstatus = 0\n\n\ncheck = [0 for i in range(r+1)]\n\n#print(eventsneg)\n\nfor i in range(len(eventsneg)):\n\tfor j in range(eventsneg[i][0] , r+1):\n\t\tif j+eventsneg[i][1]>=0:\n\t\t\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \n\n\n\n# if status and r>=0 and sum(check)==len(check):\n# \tprint(\"YES\")\n# else:\n# \tprint(\"NO\")\n\n#print(eventsneg,eventspos)\n\nprint(max(check) + ans\t)\n", "import sys\nfrom collections import defaultdict as dd\n \nmod=10**9+7\n \ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n \n \nn, r = ri()\n \neventspos = []\neventsneg = []\nfor i in range(n):\n\ttemp =ri()\n\tif temp[1]>=0:\n\t\teventspos.append(temp)\n\telse:\n\t\teventsneg.append(temp)\n \neventspos.sort()\neventsneg.sort(key = lambda x: x[0]+x[1])\neventsneg.reverse()\n \nstatus =1\n \nans=0 \n \nfor i in range(len(eventspos)):\n\tif eventspos[i][0] <= r:\n\t\tr+= eventspos[i][1]\n\t\tans+=1\n\telse:\n\t\tstatus = 0\n \n \ncheck = [0 for i in range(r+1)]\n \n#print(eventsneg)\n \nfor i in range(len(eventsneg)):\n\tfor j in range(eventsneg[i][0] , r+1):\n\t\tif j+eventsneg[i][1]>=0:\n\t\t\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \n \n \n \n# if status and r>=0 and sum(check)==len(check):\n# \tprint(\"YES\")\n# else:\n# \tprint(\"NO\")\n \n#print(eventsneg,eventspos)\n \nprint(max(check) + ans)", "N, R = [int(x) for x in input().split()]\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\npos = []\nneg = []\nfor a, b in projects:\n    if b < 0:\n        neg.append((a, b))\n    else:\n        pos.append((a, b))\npos.sort()\nans = 0\nfor a, b in pos:\n    if R >= a:\n        R += b\n        ans += 1\nneg.sort(key=sum, reverse=True)\nmemo = {}\ndef dp(i, r):\n    if(i, r) in memo:\n        return memo[i, r]\n    if i == len(neg):return 0\n    a, b = neg[i]\n    ans  = dp(i+1, r)\n    if r >= a and r + b >= 0:\n        ans = max(ans, dp(i+1, r + b) + 1)\n    memo[i, r] = ans\n    return ans\nprint( dp(0, R) + ans  )  \n", "from bisect import bisect_right\n\nn,r = map(int, input().split())\naa = [0]*n\nbb = [0]*n\nfor i in range(n):\n    aa[i], bb[i] = map(int, input().split())\nppi = [(aa[i], bb[i]) for i in range(n) if bb[i] >= 0]\nppd = [(max(aa[i], -bb[i]), bb[i]) for i in range(n) if bb[i] < 0]\nppi.sort()\ncount = 0\nfor (a,b) in ppi:\n    if a > r:\n        break\n    r += b\n    count+=1\nppd.sort(reverse=True,key=lambda p: p[0] + p[1] )\ndp = [[0]*(r+1) for _ in range(len(ppd)+1)]\ndp[0][r] = count\nfor i,(a,b) in enumerate(ppd):\n    for v in range(r+1):\n        if v >= a and v+b >= 0:\n            dp[i+1][v + b] = max(dp[i+1][v + b], dp[i][v] + 1)\n        dp[i+1][v] = max(dp[i+1][v], dp[i][v])\nprint(max(dp[len(ppd)]))", "import sys\ninput = sys.stdin.readline\n\nn, r = map(int, input().split())\nl = []\nfor _ in range(n):\n\tl.append(list(map(int, input().split())))\np = 0\nans = 0\nwhile (p < n):\n\tif l[p][0] <= r and l[p][1] >= 0:\n\t\tr += l[p][1]\n\t\tl = l[:p] + l[p + 1:]\n\t\tp = 0\n\t\tn -= 1\n\t\tans += 1\n\telse:\n\t\tp += 1\nif l == []:\n\tprint(ans)\n\treturn\nq = len(l)\nfor i in range(q):\n\tl[i][0] = max(l[i][0], -l[i][1])\nl = sorted(l, key = lambda x: x[0] + x[1])\nl.reverse()\n#print(l, r)\ndp = [[0 for _ in range(r + 1)] for _ in range(q + 1)]\nfor i in range(q):\n\tfor j in range(r + 1):\n\t\t#dp[i][j] = dp[i][j-1]\n\t\tif j >= l[i][0] and 0 <= j + l[i][1] <= r:\n\t\t\tdp[i+1][j+l[i][1]] = max(dp[i+1][j+l[i][1]], dp[i][j] + 1)\n\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j])\n# for i,x in enumerate(dp):\n# \tprint(i, *x)\nprint(max(dp[-1]) + ans)", "from sys import stdin\nfrom sys import setrecursionlimit as SRL; SRL(10**7)\nrd = stdin.readline\nrrd = lambda: list(map(int, rd().strip().split()))\n\nn,r = rrd()\n\n\npos = []\nneg = []\n\nfor i in range(n):\n    a,b = rrd()\n    if b < 0:\n        neg.append([a,b])\n    else:\n        pos.append([a,b])\n\npos.sort(key=lambda x: x[0])\nneg.sort(key=lambda x: x[0]+x[1])\n\nans = 0\n\nfor a,b in pos:\n\n    if r>=a:\n        r += b\n        ans += 1\n    else:\n        break\n\ndp = [[0]*105 for _i in range(60005)]\n\nfor i in range(r+10):\n    for j in range(len(neg)):\n        if i >= neg[j][0] and i+neg[j][1] >= 0:\n            if j:\n                dp[i][j] = max(dp[i][j], dp[i + neg[j][1]][j - 1] + 1,dp[i][j-1])\n            else:\n                dp[i][j] = 1\n        else:\n            if j:\n                dp[i][j] = dp[i][j-1]\n\n\nprint(dp[r][len(neg)-1] + ans)\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport math\nimport copy\n \n#T = int(input())\n#N = int(input())\n#print(N)\nN,r = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n \nvisited = [0]*N\n \na = [0]*N\nb = [0]*N\n \npos = 0\n\ndp = {}\n \nfor i in range(N):\n    arr = [int(x) for x in stdin.readline().split()]\n    a[i] = arr[0]\n    b[i] = arr[1]\n    \n    if b[i]>=0:\n        pos += 1\n\nvalid = 0\nfor i in range(pos):\n    idx = -1\n    start = 0\n    gain = -50000\n    for j in range(N):\n        # find available and largest gain\n        # if gain tie, find largest start r\n        if visited[j]==1 or b[j]<0:\n            continue\n            \n        if b[j]>gain and r>=a[j]:\n            gain = b[j]\n            idx = j\n            start = a[j]\n        elif b[j]==gain and r>=a[j]:\n            if a[j]>start:\n                idx = j\n                start = a[j]\n                \n    if idx==-1:\n        break\n    else:\n        visited[idx] = 1\n        r += b[idx]\n        valid = i+1\n        #print(idx,r)\n        \ndp[r] = valid\ntmp = []\nfor i in range(N):\n    if visited[i]==1 or b[i]>=0:\n        continue\n    tmp.append((a[i],b[i],i))\n    \ntmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)\n\n#print(dp)\nfor i in range(len(tmp)):\n    dp_tmp = copy.deepcopy(dp)\n    \n    for threshold in dp:\n        if threshold>=tmp[i][0]:\n            new_r = threshold + tmp[i][1]\n            if new_r in dp_tmp:\n                dp_tmp[new_r] = max(dp[new_r],dp[threshold]+1)\n            else:\n                dp_tmp[new_r] = dp[threshold]+1\n    \n    #print(dp_tmp)\n    dp = dp_tmp\n    \nres = 0\n#print(dp)\nfor key in dp:\n    if key>=0:\n        res = max(res,dp[key])\n    \nprint(res)\n    \n        \n \n", "n, r = map(int, input().split())\n\npt = []\nnt = []\nr2 = r\nresult = 0\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    r2 += b\n    if b >= 0:\n        pt.append((a, b))\n    else:\n        nt.append((a, b))\n\npt.sort()\nnt.sort(key=lambda t: t[1]+t[0], reverse=True)\n\nfor a, b in pt:\n    if r < a:\n        break\n    result += 1\n    r += b\n\nk = len(nt)\nws = [[0]*(k+1) for i in range(r+1)]\n\nfor i in range(1, k+1):\n    for w in range(1, r+1):\n        a, b = nt[i-1]\n        if w+b >= 0 and a <= r and ws[r-a][i-1] >= ws[w][i-1]:\n            ws[w][i] = max(ws[w][i-1], 1+ws[w+b][i-1])\n        else:\n            ws[w][i] = ws[w][i-1]\n\n\nresult += ws[r][k]\n'''\nprint(*enumerate(nt))\nprint(r, k)\nprint(*enumerate(ws), sep='\\n')\n'''\nprint(result)", "n,r=list(map(int,input().split()))\na=[list(map(int,input().split())) for i in range(n)]\npos = []\nneg = []\nans=0\nfor x in a:\n\tif x[1]>0:\n\t\tpos.append(x)\n\telse:\n\t\tneg.append(x)\npos.sort(key=lambda k: k[0])\nflag=True\nfor x in pos:\n\tif r>=x[0]:\n\t\tr+=x[1]\n\t\tans+=1\n\nneg.sort(key=lambda i: i[0]+i[1],reverse=True)\narr=[0]*(r+1)\nfor i in range(len(neg)):\n\tfor j in range(neg[i][0],r+1):\n\t\tif j+neg[i][1]>=0:\n\t\t\tarr[j+neg[i][1]]=max(arr[j+neg[i][1]],arr[j]+1)\nans+=max(arr)\nprint(ans)\n", "from collections import namedtuple\n\nn, r = list(map(int, input().split()))\nplus = []\nminus = []\nProject = namedtuple('Project', 'value a b')\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    if b >= 0:\n        plus.append((a, b))\n    else:\n        minus.append(Project(max(0, a + b), a, b))\nplus.sort()\nminus.sort(reverse=True)\nans = 0\nfor a, b in plus:\n    if r >= a:\n        r += b\n        ans += 1\ndp = [[-1 for _ in range(60001)] for _ in range(len(minus) + 1)]\ndp[0][r] = 0\nfor i in range(len(dp) - 1):\n    for j in range(len(dp[0])):\n        if dp[i][j] == -1:\n            continue\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n        if j + minus[i].b >= 0 and minus[i].a <= j:\n            dp[i + 1][j + minus[i].b] = max(dp[i + 1][j + minus[i].b], dp[i][j] + 1)\nans += max(dp[-1])\nprint(ans)\n", "from functools import cmp_to_key\nfrom operator import itemgetter\n\n\ndef main():\n    n, r = list(map(int, input().split()))\n    ps = [tuple(map(int, input().split())) for _ in range(n)]\n\n    pos_ps = [(a, b) for a, b in ps if b >= 0]\n    neg_ps = [(a, b) for a, b in ps if b < 0]\n\n    def cmp(a, b):\n        (aa, ab), (ba, bb) = a, b\n        return max(aa, max(*b) - ab) - max(ba, max(*a) - bb)\n\n    pos_ps.sort(key=itemgetter(0))\n    neg_ps.sort(key=cmp_to_key(cmp))\n    del cmp\n\n    res = 0\n    for a, b in pos_ps:\n        if r >= a:\n            res += 1\n            r += b\n\n    cur = [r]\n    for a, b in neg_ps:\n        nxt = [-1]*(len(cur)+1)\n        for i, r in enumerate(cur):\n            if r >= 0:\n                nxt[i] = max(nxt[i], r)\n                if r >= a:\n                    nxt[i+1] = r + b\n        while nxt[-1] < 0:\n            nxt.pop()\n        cur = nxt\n\n    print(res + len(cur) - 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import cmp_to_key\nfrom operator import itemgetter\n\n\ndef main():\n    n, r = list(map(int, input().split()))\n    ps = [tuple(map(int, input().split())) for _ in range(n)]\n\n    pos_ps = [(a, b) for a, b in ps if b >= 0]\n    neg_ps = [(a, b) for a, b in ps if b < 0]\n\n    def cmp(a, b):\n        (aa, ab), (ba, bb) = a, b\n        return max(aa, max(*b) - ab) - max(ba, max(*a) - bb)\n\n    pos_ps.sort(key=itemgetter(0))\n    neg_ps.sort(key=cmp_to_key(cmp))\n    del cmp\n\n    res = 0\n    for a, b in pos_ps:\n        if r >= a:\n            res += 1\n            r += b\n\n    cur = [r]\n    for a, b in neg_ps:\n        nxt = [-1]*(len(cur)+1)\n        for i, r in enumerate(cur):\n            if r >= 0:\n                nxt[i] = max(nxt[i], r)\n                if r >= a:\n                    nxt[i+1] = r + b\n        while nxt[-1] < 0:\n            nxt.pop()\n        cur = nxt\n\n    print(res + len(cur) - 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import reduce\n\ndef doProject(r, proj, nproj):\n    count=0\n    for i in range(len(proj)):\n        if(proj[i][0]<=r):\n            r+=proj[i][1]\n            count+=1\n        else:\n            pass\n\n    dp=[[0 for j in range(r+1)] for i in range(len(nproj)+1)]\n    dp[0][r] = count\n\n    for i in range(len(nproj)):\n        for cr in range(r+1):\n            if(nproj[i][0] <= cr and cr + nproj[i][1] >= 0):\n                dp[i+1][cr + nproj[i][1]] = max(dp[i+1][cr + nproj[i][1]], dp[i][cr]+1)\n\n            dp[i+1][cr] = max(dp[i+1][cr], dp[i][cr])\n\n    count = reduce(lambda x,y: max(x,y) , dp[len(nproj)])\n    \n    return count\n\ndef main():\n\n    n, r = map(int, input().rstrip().split())\n    \n    proj, nproj = [], []\n    for _ in range(n):\n\n        temp = list(map(int, input().rstrip().split()))\n\n        if(temp[1]<0):\n            nproj.append(temp)\n        else:\n            proj.append(temp)\n\n    proj.sort()\n    nproj.sort(reverse=True, key=lambda x: x[0]+x[1])\n    \n    ans = doProject(r,proj, nproj)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nimport sys\nfrom collections import defaultdict\n\n# input = sys.stdin.readline\nnt = lambda: map(int, input().split())\n\n\ndef main():\n    n, r = nt()\n    projects = [tuple(nt()) for _ in range(n)]\n    positive = [t for t in projects if t[1] > 0]\n    negative = [t for t in projects if t[1] <= 0]\n\n    max_pos = 0\n    for p in sorted(positive):\n        if p[0] <= r:\n            r += p[1]\n            max_pos += 1\n        else:\n            break\n    negative.sort(key=lambda x: -x[0] - x[1])\n    MAX = 60001\n    dp = [[-1 for _ in range(MAX)] for _ in range(len(negative)+1)]\n    dp[0][r] = 0\n    for i in range(len(negative)):\n        for j in range(MAX):\n            if dp[i][j] == -1:\n                continue\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j])\n            if j >= negative[i][0] and j+negative[i][1] >= 0:\n                dp[i+1][j+negative[i][1]] = max(dp[i+1][j+negative[i][1]], dp[i][j]+1)\n    max_neg = 0\n    for i in range(MAX):\n        max_neg = max(max_neg, dp[len(negative)][i])\n\n    print(max_pos + max_neg)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import *\n\nMOD = int(1e9)+7\n\ndef nextInt():\n    return int(input())\n\ndef nextInts():\n    return list(map(int,input().split()))\n\ndef YN(x):\n    return \"YES\" if x else \"NO\"\n\ndef solve():\n    n,r = nextInts()\n    pos = []\n    neg = []\n    for i in range(n):\n        a,b = nextInts()\n        a = max(a,-b)\n        if b >= 0:\n            pos.append((a,b))\n        else:\n            neg.append((a,b))\n    pos.sort(key = lambda x:x[0])\n    neg.sort(key = lambda x:-(x[0]+x[1]))\n    ans = 0\n    for t in pos:\n        if r >= t[0]:\n            r += t[1]\n            ans += 1\n\n    dp = [-MOD]*60001\n    dp[r] = ans\n\n    for t in neg:\n        for j in range(t[0],60001):\n            dp[j+t[1]] = max(dp[j+t[1]],dp[j]+1)\n    return max(dp)\n\nprint(solve())\n\n# q = nextInt()\n# for i in range(q):\n#     print(YN(solve()))\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Jan  9 11:12:02 2020\n\n@author: Rodro\n\"\"\"\n\ninp = str(input()).split()\nsize = int(inp[0])\nr = int(inp[1])\n\npos = []\nneg = []\nfor i in range(size):\n    inp = str(input()).split()\n    a = int(inp[0])\n    b = int(inp[1])\n    if b >= 0: pos.append((a, b))\n    else: neg.append((a,b))\npos = sorted(pos)\nprojects = 0\nfor ab in pos:\n    a, b = ab\n    if r >= a:\n        r += b\n        projects += 1\n    else: break\n\nneg = sorted(neg, key = lambda ab: ab[0] + ab[1], reverse = True)\nn = len(neg)\ndp = [[0]*(r + 1) for _ in range(n + 1)]\ndp[0][r] = projects\nfor i in range(0, n):\n    for j in range(0, r + 1):\n        if j >= neg[i][0] and j + neg[i][1] >= 0:\n            dp[i + 1][j + neg[i][1]] = max(dp[i + 1][j + neg[i][1]], dp[i][j] + 1)\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n\nprint(max(dp[n]))", "#https://codeforces.com/contest/1203/problem/F2 \n\nn, r = list(map(int, input().split()))\narr  = [list(map(int, input().split())) for _ in range(n)] \n\ndef solve1(cur, arr):\n    cnt=0\n\n    while len(arr) > 0:\n        max_inc = -9999\n        choose  = None \n        for a, b in arr:\n            if cur >= a and max_inc < b:\n                max_inc = b\n                choose  = a\n                \n        if choose is None:\n            flg=False\n            break\n        \n        cnt+=1\n        cur+=max_inc\n        arr.remove([choose, max_inc])\n\n    return cur, cnt\n\narr1 = [[x, y] for x, y in arr if y >= 0]\narr2 = [[x, y] for x, y in arr if y <  0]\n\nr, cnt = solve1(r, arr1) \nn      = len(arr2) \narr2   = [[]] + sorted(arr2, key=lambda x:x[0]+x[1], reverse=True) \ndp     = [[-1] * (n+1) for _ in range(n+1)]\n\nfor i in range(n+1):\n    dp[i][0] = r\n    \nfor i in range(1, n+1):\n    for j in range(1, i+1):\n        dp[i][j] = dp[i-1][j]\n        if dp[i-1][j-1] >= arr2[i][0] and dp[i-1][j-1] + arr2[i][1] >= 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-1]+arr2[i][1])\n            \nans = 0            \nfor j in range(n+1):\n    if dp[n][j] >= 0:\n        ans = j\n\nprint(ans+cnt)        \n\n#3 4\n#4 6\n#10 -2\n#8 -1\n", "n, r = list(map(int, input().split()))\na = []\ncnt = 0\nfor i in range(n):\n    a.append([int(j) for j in input().split()])\nflag = True\nwhile flag:\n    flag = False\n    for i in a:\n        if r >= i[0] and i[1] >= 0:\n            flag = True\n            r += i[1]\n            cnt += 1\n            a.remove(i)\n            break\na = sorted(a, key=lambda x: x[0] + x[1])\ndp = [[0] * (r + 1) for i in range(len(a) + 1)]\nfor i in range(len(a)):\n\tfor j in range(r + 1):\n\t\tdp[i][j] = dp[i - 1][j]\n\t\tif j >= a[i][0] and j + a[i][1] >= 0:\n\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i][1]] + 1)\nprint(cnt + dp[len(a) - 1][r])\n#print(dp, a)\n", "n, r = list(map(int, input().split()))\na = []\ncnt = 0\nfor i in range(n):\n    a.append([int(j) for j in input().split()])\nflag = True\nwhile flag:\n    flag = False\n    for i in a:\n        if r >= i[0] and i[1] >= 0:\n            flag = True\n            r += i[1]\n            cnt += 1\n            a.remove(i)\n            break\na = sorted(a, key=lambda x: x[0] + x[1])\ndp = [[0] * (r + 1) for i in range(len(a) + 1)]\nfor i in range(len(a)):\n\tfor j in range(r + 1):\n\t\tdp[i][j] = dp[i - 1][j]\n\t\tif j >= a[i][0] and j + a[i][1] >= 0:\n\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i][1]] + 1)\nprint(cnt + dp[len(a) - 1][r])\n#print(dp, a)\n", "z, r = list(map(int, input().split()))\na = []\ncnt = 0\nfor i in range(z):\n    a.append([int(j) for j in input().split()])\nflag = True\nwhile flag:\n    flag = False\n    for i in a:\n        if r >= i[0] and i[1] >= 0:\n            flag = True\n            r += i[1]\n            cnt += 1\n            a.remove(i)\n            break\na = sorted(a, key=lambda x: x[0] + x[1])\ndp = [[0] * (r + 1) for i in range(len(a) + 1)]\nfor i in range(len(a)):\n\tfor j in range(r + 1):\n\t\tdp[i][j] = dp[i - 1][j]\n\t\tif j >= a[i][0] and j + a[i][1] >= 0:\n\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i][1]] + 1)\nprint(cnt + dp[len(a) - 1][r])\n#print(dp, a)\n", "N, R = [int(x) for x in input().split()]\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\npos = []\nneg = []\nfor a, b in projects:\n    if b < 0:\n        neg.append((a, b))\n    else:\n        pos.append((a, b))\npos.sort()\nans = 0\nfor a, b in pos:\n    if R >= a:\n        R += b\n        ans += 1\nneg.sort(key=sum, reverse=True)\nmemo = {}\ndef dp(i, r):\n    if(i, r) in memo:\n        return memo[i, r]\n    if i == len(neg):return 0\n    a, b = neg[i]\n    ans  = dp(i+1, r)\n    if r >= a and r + b >= 0:\n        ans = max(ans, dp(i+1, r + b) + 1)\n    memo[i, r] = ans\n    return ans\nprint( dp(0, R) + ans  ) \n#JSR\n", "N, R = [int(x) for x in input().split()]\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\npos = []\nneg = []\nfor a, b in projects:\n    if b < 0:\n        neg.append((a, b))\n    else:\n        pos.append((a, b))\npos.sort()\nans = 0\nfor a, b in pos:\n    if R >= a:\n        R += b\n        ans += 1\nneg.sort(key=sum, reverse=True)\nmemo = {}\ndef dp(i, r):\n    if(i, r) in memo:\n        return memo[i, r]\n    if i == len(neg):return 0\n    a, b = neg[i]\n    ans  = dp(i+1, r)\n    if r >= a and r + b >= 0:\n        ans = max(ans, dp(i+1, r + b) + 1)\n    memo[i, r] = ans\n    return ans\nprint( dp(0, R) + ans  ) \n#purvikaurraina\n", "\nN, R = [int(x) for x in input().split()]\nprojects = [[int(x) for x in input().split()] for _ in range(N)]\npos = []\nneg = []\nfor a, b in projects:\n    if b < 0:\n        neg.append((a, b))\n    else:\n        pos.append((a, b))\npos.sort()\nans = 0\nfor a, b in pos:\n    if R >= a:\n        R += b\n        ans += 1\nneg.sort(key=sum, reverse=True)\nmemo = {}\ndef dp(i, r):\n    if(i, r) in memo:\n        return memo[i, r]\n    if i == len(neg):return 0\n    a, b = neg[i]\n    ans  = dp(i+1, r)\n    if r >= a and r + b >= 0:\n        ans = max(ans, dp(i+1, r + b) + 1)\n    memo[i, r] = ans\n    return ans\nprint( dp(0, R) + ans  )\n", "def myFunc(e):\n    return e[0] + e[1]\n\ncount, rating = list(map(int, input().split()))\ngoodJob = []\nbadJob = []\n\ntaken = 0\n\nfor i in range(count):\n    a, b = list(map(int, input().split()))\n    if b >= 0:\n        goodJob.append([a, b])\n    else:\n        badJob.append([a, b])\n\ngoodJob.sort()\nbadJob.sort(reverse=True, key=myFunc)\n\nfor job in goodJob:\n    if job[0] <= rating:\n        rating += job[1]\n        taken += 1\n    else:\n        break\n\ndp = []\n\nfor i in range(len(badJob) + 1):\n    row = []\n    for j in range(rating + 2):\n        row.append(0)\n    dp.append(row)\n\ndp[0][rating] = taken\n\nfor i in range(len(badJob)):\n    for curRating in range(rating + 1):\n        if curRating >= badJob[i][0] and curRating + badJob[i][1] >= 0: \n            dp[i + 1][curRating + badJob[i][1]] = max(dp[i + 1][curRating + badJob[i][1]], dp[i][curRating] + 1)\n        dp[i + 1][curRating] = max(dp[i + 1][curRating], dp[i][curRating])\n\nans = 0\n\nfor curRating in range(rating + 1): \n    ans = max(ans, dp[len(badJob)][curRating])\n\nprint(ans)\n\n\n\n", "from operator import itemgetter, attrgetter\nn,r=list(map(int,input().split()))\nps,neg=[],[]\nfor i in range(n):\n    a,b=list(map(int,input().split()))\n    if(b>=0):\n        ps.append([a,b,-a-b])\n    else:\n        neg.append([a,b,-a-b])\nps=sorted(ps)\nneg=sorted(neg,key=itemgetter(2))\nps=ps+neg\n#print(*ps)\ndp=[-float('inf')]*(n+1)\ndp[0]=r\nfor i in range(n):\n    for j in range(n-1,-1,-1):\n        if(dp[j]>=ps[i][0]):\n            dp[j+1]=max(dp[j+1],dp[j]+ps[i][1])\nfor j in range(n,-1,-1):\n    if(dp[j]>=0):\n        print(j)\n        break\n"]