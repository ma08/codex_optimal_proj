["import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [0]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.min(0,n)\n    Ai = -Aneg.min(i,i+1)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [j for j in range(m) if inter_copy[j][0]<=besta_ind<inter_copy[j][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.data[1]\n    Ai = A[i]-(j1-j2)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.data[1]\n    Ai = A[i]-(j1-j2)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.data[1]\n    Ai = A[i]-(j1-j2)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls. /pajenegod\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\nbucketsl = [[] for _ in range(n)]\nbucketsr = [[] for _ in range(n)]\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    bucketsl[l].append(r)\n    if r<n:\n        bucketsr[r].append(l)\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nactive_intervals = 0\nfor i in range(n):\n    # Activate\n    for r in bucketsl[i]:\n        Aneg.add(i,r,1)\n        active_intervals += 1\n    # Deactivate\n    for l in bucketsr[i]:\n        Aneg.add(l,i,-1)\n        active_intervals -= 1\n    Amax = -Aneg.data[1]\n    Ai = A[i] - active_intervals\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls. /pajenegod\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\nbucketsl = [[] for _ in range(n)]\nbucketsr = [[] for _ in range(n)]\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    bucketsl[l].append(r)\n    if r<n:\n        bucketsr[r].append(l)\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nactive_intervals = 0\nfor i in range(n):\n    # Activate\n    for r in bucketsl[i]:\n        Aneg.add(i,r,1)\n        active_intervals += 1\n    # Deactivate\n    for l in bucketsr[i]:\n        Aneg.add(l,i,-1)\n        active_intervals -= 1\n    Amax = -Aneg.data[1]\n    Ai = A[i] - active_intervals\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls. /pajenegod\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\nupdate = [[] for _ in range(n+1)]\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    update[l].append((l,r))\n    update[r].append((l,r))\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nactive_intervals = 0\nfor i in range(n):\n    for l,r in update[i]:\n        Aneg.add(l,r,1 if l==i else -1)\n        active_intervals += 1 if l==i else -1 \n    Amax = -Aneg.data[1]\n    Ai = A[i] - active_intervals\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls. /pajenegod\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\ninter = []\nupdate = [[] for _ in range(n+1)]\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    update[l].append((l,r))\n    update[r].append((l,r))\n\nAneg = super_seg([-a for a in A])\nbesta = -1\nbesta_ind = -1\n\nactive_intervals = 0\nfor i in range(n):\n    for l,r in update[i]:\n        Aneg.add(l,r,1 if l==i else -1)\n        active_intervals += 1 if l==i else -1 \n    Amax = -Aneg.data[1]\n    Ai = A[i] - active_intervals\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\nimport copy\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nA=list(map(int,input().split()))\n\nLR=[list(map(int,input().split())) for i in range(m)]\n\n\nMLIST=[]\nfor l,r in LR:\n    MLIST.append(l)\n    MLIST.append(r)\n\nMLIST=list(set(MLIST))\nMLIST.sort()\nMLIST.append(10**9)\n\n\nMDICT=dict()\nMLEN=len(MLIST)\nfor i in range(MLEN):\n    MDICT[MLIST[i]]=i\n\n\nMINUSLIST=[[0]*(MLEN*2-1) for i in range(MLEN)]\n\nfor l,r in LR:\n    for j in range(MDICT[l],MDICT[r]+1):\n        for k in range(MDICT[l]*2+1,MDICT[r]*2+2):\n            MINUSLIST[j][k]+=1\n            \n#print(MLIST)\n#print(MINUSLIST)\n\n\nA_m=[[float(\"inf\"),-float(\"inf\")] for i in range(MLEN*2-1)]\n\nif MLIST[0]!=1:\n    A_m[0]=[min(A[:MLIST[0]-1]),max(A[:MLIST[0]-1])]\n#if MLIST[MLEN-2]!=n:\n#    A_m[MLEN*2-2]=[min(A[MLIST[MLEN-2]:]),max(A[MLIST[MLEN-2]:])]\n\nfor i in range(MLEN-1):\n    x=MLIST[i]-1\n    y=MLIST[i+1]-1\n\n    A_m[2*i+1]=[A[x],A[x]]\n    if x+1!=y and x!=n-1:\n        A_m[2*i+2]=[min(A[x+1:y]),max(A[x+1:y])]\n    \ndef MINUS(A,B):\n    MIN=float(\"inf\")\n    MAX=-float(\"inf\")\n\n    for i in range(MLEN*2-1):\n        if MIN>A[i][0]-B[i]:\n            MIN=A[i][0]-B[i]\n        if MAX<A[i][1]-B[i]:\n            MAX=A[i][1]-B[i]\n\n    return MAX-MIN\n\nANSLIST=[0]*MLEN\n\nfor i in range(MLEN):\n    ANSLIST[i]=MINUS(A_m,MINUSLIST[i])\n\nprint(max(ANSLIST))\ntarget=MLIST[ANSLIST.index(max(ANSLIST))]\n\nAN=[]\nfor i in range(m):\n    z,w=LR[i]\n    if z<=target<=w:\n        AN.append(i+1)\n\nprint(len(AN))\nfor a in AN:\n    print(a,end=\" \")\n\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls. /pajenegod\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\ninter = []\nupdate = [[] for _ in range(n+1)]\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    update[l].append((l,r))\n    update[r].append((l,r))\n\nAneg = super_seg([-a for a in A])\nbesta = -1\nbesta_ind = -1\n\nactive_intervals = 0\nfor i in range(n):\n    for l,r in update[i]:\n        Aneg.add(l,r,1 if l==i else -1)\n        active_intervals += 1 if l==i else -1 \n    Amax = -Aneg.data[1]\n    Ai = A[i] - active_intervals\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls. /pajenegod\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\ninter = []\nupdate = [[] for _ in range(n+1)]\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    update[l].append((l,r))\n    update[r].append((l,r))\n\nAneg = super_seg([-a for a in A])\nbesta = -1\nbesta_ind = -1\n\nactive_intervals = 0\nfor i in range(n):\n    for l,r in update[i]:\n        Aneg.add(l,r,1 if l==i else -1)\n        active_intervals += 1 if l==i else -1 \n    Amax = -Aneg.data[1]\n    Ai = A[i] - active_intervals\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter[i][0]<=besta_ind<inter[i][1]]\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])", "def main():\n    n, m = list(map(int, input().split()))\n    aa = list(map(int, input().split()))\n    res = max(aa) - min(aa)\n    ll, rr = [n + 1], [n + 1]\n    segments = res_segments = [False] * (m + 1)\n    bounds = {0, n, n + 1}\n    for _ in range(m):\n        l, r = list(map(int, input().split()))\n        l -= 1\n        ll.append(l)\n        rr.append(r)\n        bounds.add(l)\n        bounds.add(r)\n    xlat = sorted(bounds)\n    mi, ma = [], []\n    for l, r in zip(xlat, xlat[1:-1]):\n        t = aa[l:r]\n        mi.append(min(t))\n        ma.append(max(t))\n    bounds = {x: i for i, x in enumerate(xlat)}\n    for xx in (ll, rr):\n        for i, x in enumerate(xx):\n            xx[i] = bounds[x]\n    il, ir = (sorted(list(range(m + 1)), key=xx.__getitem__, reverse=True) for xx in (ll, rr))\n    for i in range(len(xlat) - 1):\n        while True:\n            k = il[-1]\n            lo = ll[k]\n            if lo > i:\n                break\n            segments[k] = True\n            for j in range(lo, rr[k]):\n                mi[j] -= 1\n                ma[j] -= 1\n            del il[-1]\n\n        x = max(ma) - min(mi)\n        if res < x:\n            res = x\n            res_segments = segments[:]\n        while True:\n            k = ir[-1]\n            hi = rr[k]\n            if hi > i:\n                break\n            segments[k] = False\n            for j in range(ll[k], hi):\n                mi[j] += 1\n                ma[j] += 1\n            del ir[-1]\n\n    print(res)\n    segments = [i for i, f in enumerate(res_segments) if f]\n    print(len(segments))\n    print(*segments)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nLf = [[] for _ in range(n)]\nRb = [[] for _ in range(n)]\nLR = []\nfor i in range(m):\n    l, r = list(map(int, input().split()))\n    l, r = l-1, r-1\n    Lf[r].append(l)\n    Rb[l].append(r)\n    LR.append((l, r))\n\nminus = [0]*n\nINF = 10**18\nans = [-INF]*n\nmn = A[0]\n\nfor i in range(n):\n    ans[i] = max(ans[i], A[i]-mn)\n    for l in Lf[i]:\n        for j in range(l, i+1):\n            minus[j] -= 1\n            mn = min(mn, A[j]+minus[j])\n    mn = min(mn, A[i]+minus[i])\n\nminus = [0]*n\nmn = A[n-1]\nfor i in reversed(list(range(n))):\n    ans[i] = max(ans[i], A[i]-mn)\n    for r in Rb[i]:\n        for j in range(i, r+1):\n            minus[j] -= 1\n            mn = min(mn, A[j]+minus[j])\n    mn = min(mn, A[i]+minus[i])\nans_ = max(ans)\nres = []\nfor i in range(n):\n    if ans[i] == ans_:\n        for j in range(m):\n            l, r = LR[j]\n            if not (l <= i and i <= r):\n                res.append(j+1)\n        break\nprint(ans_)\nprint(len(res))\nprint(*res)\n"]