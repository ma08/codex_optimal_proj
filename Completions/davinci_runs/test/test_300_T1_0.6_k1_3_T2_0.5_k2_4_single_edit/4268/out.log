2022-04-18 03:56:37.464231 """
There are N points in a D-dimensional space.
The coordinates of the i-th point are (X_{i1}, X_{i2}, ..., X_{iD}).
The distance between two points with coordinates (y_1, y_2, ..., y_D) and (z_1, z_2, ..., z_D) is \sqrt{(y_1 - z_1)^2 + (y_2 - z_2)^2 + ... + (y_D - z_D)^2}.
How many pairs (i, j) (i < j) are there such that the distance between the i-th point and the j-th point is an integer?

-----Constraints-----
 - All values in input are integers.
 - 2 \leq N \leq 10
 - 1 \leq D \leq 10
 - -20 \leq X_{ij} \leq 20
 - No two given points have the same coordinates. That is, if i \neq j, there exists k such that X_{ik} \neq X_{jk}.

-----Input-----
Input is given from Standard Input in the following format:
N D
X_{11} X_{12} ... X_{1D}
X_{21} X_{22} ... X_{2D}
\vdots
X_{N1} X_{N2} ... X_{ND}

-----Output-----
Print the number of pairs (i, j) (i < j) such that the distance between the i-th point and the j-th point is an integer.

-----Sample Input-----
3 2
1 2
5 5
-2 8

-----Sample Output-----
1

The number of pairs with an integer distance is one, as follows:
 - The distance between the first point and the second point is \sqrt{|1-5|^2 + |2-5|^2} = 5, which is an integer.
 - The distance between the second point and the third point is \sqrt{|5-(-2)|^2 + |5-8|^2} = \sqrt{58}, which is not an integer.
 - The distance between the third point and the first point is \sqrt{|-2-1|^2+|8-2|^2} = 3\sqrt{5}, which is not an integer.
"""
2022-04-18 03:56:37.464246 --------------------------
2022-04-18 03:57:08.424354 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef distance(point1, point2):\n    sum = 0\n    for i in range(len(point1)):\n        sum += (point1[i] - point2[i])**2\n    return sum\n\ndef main():\n    num_points, dim = map(int, input().split())\n    points = []\n    for _ in range(num_points):\n        points.append(list(map(int, input().split())))\n    count = 0\n    for i in range(num_points):\n        for j in range(i+1, num_points):\n            if int(distance(points[i], points[j])**0.5) == distance(points[i], points[j])**0.5:\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport math\n\nN, D = list(map(int, input().split()))\npoints = list()\n\nfor i in range(N):\n    points.append(list(map(int, input().split())))\n\nnum_pairs = 0\n\nfor i in range(N):\n    for j in range(i + 1, N):\n        distance = 0\n        for k in range(D):\n            distance += (points[i][k] - points[j][k]) ** 2\n        distance = math.sqrt(distance)\n\n        if distance % 1 == 0:\n            num_pairs += 1\n\nprint(num_pairs)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\nstdin.readline()\npoints = [tuple(map(int, line.strip().split())) for line in stdin.readlines()]\n\ndef sq(n):\n    return n*n\n\n# This is O(n^2) time and O(n) space.\ndef num_pairs_with_integer_distance(points):\n    num_pairs = 0\n    distances = {}\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            key = tuple(sorted([p1, p2]))\n            if key in distances:\n                continue\n            else:\n                distances[key] = sum(sq(x1 - x2) for x1, x2 in zip(p1, p2))\n            if distances[key] == int(distances[key]):\n                num_pairs += 1\n    return num_pairs\n\nprint(num_pairs_with_integer_distance(points))"
    }
  ],
  "created": 1650254197,
  "id": "cmpl-4yCn7Ktzi64vB6js7idZBMozsGGSY",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 03:57:08.424660 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef distance(point1, point2):\n    sum = 0\n    for i in range(len(point1)):\n        sum += (point1[i] - point2[i])**2\n    return sum\n\ndef main():\n    num_points, dim = map(int, input().split())\n    points = []\n    for _ in range(num_points):\n        points.append(list(map(int, input().split())))\n    count = 0\n    for i in range(num_points):\n        for j in range(i+1, num_points):\n            if int(distance(points[i], points[j])**0.5) == distance(points[i], points[j])**0.5:\n                count += 1\n    print(count)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 03:57:08.424701 REASON stop
2022-04-18 03:57:08.426344 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport math\n\nN, D = list(map(int, input().split()))\npoints = list()\n\nfor i in range(N):\n    points.append(list(map(int, input().split())))\n\nnum_pairs = 0\n\nfor i in range(N):\n    for j in range(i + 1, N):\n        distance = 0\n        for k in range(D):\n            distance += (points[i][k] - points[j][k]) ** 2\n        distance = math.sqrt(distance)\n\n        if distance % 1 == 0:\n            num_pairs += 1\n\nprint(num_pairs)"
}
2022-04-18 03:57:08.426408 REASON stop
2022-04-18 03:57:08.426894 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\nstdin.readline()\npoints = [tuple(map(int, line.strip().split())) for line in stdin.readlines()]\n\ndef sq(n):\n    return n*n\n\n# This is O(n^2) time and O(n) space.\ndef num_pairs_with_integer_distance(points):\n    num_pairs = 0\n    distances = {}\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            key = tuple(sorted([p1, p2]))\n            if key in distances:\n                continue\n            else:\n                distances[key] = sum(sq(x1 - x2) for x1, x2 in zip(p1, p2))\n            if distances[key] == int(distances[key]):\n                num_pairs += 1\n    return num_pairs\n\nprint(num_pairs_with_integer_distance(points))"
}
2022-04-18 03:57:08.426947 REASON stop
