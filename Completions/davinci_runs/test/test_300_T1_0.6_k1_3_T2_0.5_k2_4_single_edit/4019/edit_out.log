2022-04-23 15:57:43.249448 num operations 1
2022-04-23 15:57:43.249469 size on input set 1
2022-04-23 15:57:43.249639 using api key jaanu
2022-04-23 15:58:02.767919 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# # Read input\n# n, m, d = map(int, input().split())\n# edges = []\n# for _ in range(m):\n#     u, v = map(int, input().split())\n#     edges.append((u, v))\n#\n# # Check if possible\n# possible = False\n# for i in range(m):\n#     if edges[i][0] == 1:\n#         possible = True\n#         break\n#\n# if not possible:\n#     print(\"NO\")\n#     exit()\n#\n# # Build graph\n# graph = {}\n# for i in range(1, n+1):\n#     graph[i] = []\n# for edge in edges:\n#     graph[edge[0]].append(edge[1])\n#     graph[edge[1]].append(edge[0])\n#\n# # Find spanning tree\n# tree = []\n# visited = [False for _ in range(n+1)]\n# queue = [1, None]\n# visited[1] = True\n# while len(queue) > 0:\n#     node = queue.pop(0)\n#     if node is not None:\n#         for neighbor in graph[node]:\n#             if not visited[neighbor]:\n#                 tree.append((node, neighbor))\n#                 visited[neighbor] = True\n#                 queue.append(neighbor)\n#                 queue.append(None)\n#                 break\n#\n# # Check if tree is valid\n# d1 = 0\n# for edge in tree:\n#     if edge[0] == 1 or edge[1] == 1:\n#         d1 += 1\n# if d1 != d:\n#     print(\"NO\")\n#     exit()\n#\n# # Print tree\n# print(\"YES\")\n# for edge in tree:\n#     print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split()) - 1\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 0:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(n):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n)]\nqueue = [0, None]\nvisited[0] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 2,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    x, y = map(int, input().split())\n    edges.append((x, y))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif possible is False:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n + 1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n + 1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) != 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 3,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1650729463,
  "object": "edit"
}
2022-04-23 15:58:02.768393 fix syntax errors 4 ['\n\n# # Read input\n# n, m, d = map(int, input().split())\n# edges = []\n# for _ in range(m):\n#     u, v = map(int, input().split())\n#     edges.append((u, v))\n#\n# # Check if possible\n# possible = False\n# for i in range(m):\n#     if edges[i][0] == 1:\n#         possible = True\n#         break\n#\n# if not possible:\n#     print("NO")\n#     exit()\n#\n# # Build graph\n# graph = {}\n# for i in range(1, n+1):\n#     graph[i] = []\n# for edge in edges:\n#     graph[edge[0]].append(edge[1])\n#     graph[edge[1]].append(edge[0])\n#\n# # Find spanning tree\n# tree = []\n# visited = [False for _ in range(n+1)]\n# queue = [1, None]\n# visited[1] = True\n# while len(queue) > 0:\n#     node = queue.pop(0)\n#     if node is not None:\n#         for neighbor in graph[node]:\n#             if not visited[neighbor]:\n#                 tree.append((node, neighbor))\n#                 visited[neighbor] = True\n#                 queue.append(neighbor)\n#                 queue.append(None)\n#                 break\n#\n# # Check if tree is valid\n# d1 = 0\n# for edge in tree:\n#     if edge[0] == 1 or edge[1] == 1:\n#         d1 += 1\n# if d1 != d:\n#     print("NO")\n#     exit()\n#\n# # Print tree\n# print("YES")\n# for edge in tree:\n#     print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split()) - 1\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 0:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(n):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n)]\nqueue = [0, None]\nvisited[0] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    x, y = map(int, input().split())\n    edges.append((x, y))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif possible is False:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n + 1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n + 1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) != 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n']
2022-04-23 15:58:02.768640 size on output set 4
2022-04-23 15:58:02.768671 num operations 1
2022-04-23 15:58:02.768684 size on input set 1
2022-04-23 15:58:02.768978 using api key sunu
2022-04-23 15:58:13.635231 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, d = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, d, edges\n\ndef check_degree(n, m, d, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as d exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == d:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650729482,
  "object": "edit"
}
2022-04-23 15:58:13.635483 fix syntax errors 4 ['\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, d = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, d, edges\n\ndef check_degree(n, m, d, edges):\n    """\n    return True if a spanning tree with degree of 1 as d exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == d:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 15:58:13.635637 size on output set 3
2022-04-23 15:58:13.635651 num operations 1
2022-04-23 15:58:13.635657 size on input set 1
2022-04-23 15:58:13.635776 using api key soukgp
2022-04-23 15:58:31.886598 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from collections import deque\nfrom math import ceil\n\n\n\nif __name__ == \"__main__\":\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    if s == sum(a):\n        print(n)\n        exit()\n\n    if s < sum(a):\n        print(-1)\n        exit()\n\n    a.sort()\n    a.reverse()\n\n    t = s // a[0]\n    i = 0\n    while i < t:\n        if s % a[i] == 0:\n            print(i + 1)\n            exit()\n        i += 1\n\n    print(ceil(s / a[0]))\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import Counter\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import OrderedDict\nfrom collections import deque\nfrom collections import namedtuple\nfrom collections import ChainMap\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 3,
      "text": "from collections import deque\n\nn, m, d = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    v, u = map(int, input().split())\n    g[v - 1].append(u - 1)\n    g[u - 1].append(v - 1)\n\nq = deque([0])\nused = [False] * n\nused[0] = True\nans = []\n\nwhile q:\n    v = q.popleft()\n    for u in g[v]:\n        if not used[u]:\n            used[u] = True\n            ans.append((v, u))\n            q.append(u)\n\nif len(ans) < n - 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    if d == 0:\n        for v, u in ans:\n            print(v + 1, u + 1)\n    else:\n        print(\"YES\")\n        if d == 0:\n        for v, u in ans[:-1]:\n            print(v + 1, u + 1)\n        print(ans[-1][0] + 1, ans[-1][1] + 1)\n        print(1, ans[-1][0] + 1)\n        for i in range(d - 2):\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    }
  ],
  "created": 1650729493,
  "object": "edit"
}
2022-04-23 15:58:31.886818 fix syntax errors 4 ['from collections import deque\nfrom math import ceil\n\n\n\nif __name__ == "__main__":\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    if s == sum(a):\n        print(n)\n        exit()\n\n    if s < sum(a):\n        print(-1)\n        exit()\n\n    a.sort()\n    a.reverse()\n\n    t = s // a[0]\n    i = 0\n    while i < t:\n        if s % a[i] == 0:\n            print(i + 1)\n            exit()\n        i += 1\n\n    print(ceil(s / a[0]))\n', '\nfrom collections import Counter\n', '\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import OrderedDict\nfrom collections import deque\nfrom collections import namedtuple\nfrom collections import ChainMap\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', 'from collections import deque\n\nn, m, d = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    v, u = map(int, input().split())\n    g[v - 1].append(u - 1)\n    g[u - 1].append(v - 1)\n\nq = deque([0])\nused = [False] * n\nused[0] = True\nans = []\n\nwhile q:\n    v = q.popleft()\n    for u in g[v]:\n        if not used[u]:\n            used[u] = True\n            ans.append((v, u))\n            q.append(u)\n\nif len(ans) < n - 1:\n    print("NO")\nelse:\n    print("YES")\n    if d == 0:\n        for v, u in ans:\n            print(v + 1, u + 1)\n    else:\n        print("YES")\n        if d == 0:\n        for v, u in ans[:-1]:\n            print(v + 1, u + 1)\n        print(ans[-1][0] + 1, ans[-1][1] + 1)\n        print(1, ans[-1][0] + 1)\n        for i in range(d - 2):\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n']
2022-04-23 15:58:31.886863 size on output set 4
