["\n\ndef get_groups(n, arr):\n    groups = []\n    for i in range(n):\n        groups.append(arr[i])\n    return groups\n\n\ndef get_sets(n, arr):\n    sets = []\n    for i in range(n):\n        sets.append(set(arr[i]))\n\n    return sets\n\ndef get_set_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append(arr[i])\n    return bounds\n\n\ndef get_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append(arr[i])\n    return bounds\n\n\ndef find_groups(n, arr):\n    groups = get_groups(n, arr)\n    sets = get_sets(n, groups)\n    bounds = get_bounds(n, groups)\n    set_bounds = get_set_bounds(n, groups)\n    while len(sets) > 1:\n        i = 0\n        j = 0\n        while i < len(sets) - 1:\n            if i == len(sets) - 1:\n                break\n            while j < len(sets):\n                if j == len(sets):\n                    break\n                if sets[i] == sets[j]:\n                    if bounds[i][1] + 1 == bounds[j][0] or bounds[j][1] + 1 == bounds[i][0]:\n                        if bounds[i][0] < bounds[j][0]:\n                            bounds[i][1] = bounds[j][1]\n                        else:\n                            bounds[i][0] = bounds[j][0]\n                        bounds[j][0] = -1\n                        bounds[j][1] = -1\n                        sets.pop(j)\n                        bounds.pop(j)\n                        continue\n                j += 1\n            i += 1\n            j = 0\n    i = 0\n    while i < len(bounds):\n        if bounds[i][0] == -1:\n            bounds.pop(i)\n            continue\n        i += 1\n    i = 0\n    while i < len(bounds):\n        for j in range(len(set_bounds)):\n            if set_bounds[j][0] == bounds[i][0] and set_bounds[j][1] == bounds[i][1]:\n                set_bounds.pop(j)\n        i += 1\n    i = 0\n    while i < len(set_bounds):\n        if set_bounds[i][0] == -1:\n            set_bounds.pop(i)\n            continue\n        i += 1\n    return bounds + set_bounds\n\n\ndef main():\n    n = int(input())\n    arr = input().split()\n    arr = [int(x) for x in arr]\n    groups = find_groups(n, arr)\n    print(len(groups))\n    for i in range(len(groups)):\n        print(str(groups[i][0]) + \" \" + str(groups[i][1]))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# TODO: Timeout\n\ndef find_max_block_set(arr):\n    max_block_count = 1\n    max_block_set = [[]]\n    for i in range(len(arr)-1):\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)-1):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                if len(curr_block_set) > max_block_count:\n                    max_block_count = len(curr_block_set)\n                    max_block_set = [curr_block_set]\n                elif len(curr_block_set) == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    # print(max_block_set)\n    return max_block_set\n\ndef find_max_block_set_2(arr):\n    max_block_count = 1\n    max_block_set = [[]]\n    for i in range(len(arr)-1):\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)-1):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                if len(curr_block_set) > max_block_count:\n                    max_block_count = len(curr_block_set)\n                    max_block_set = [curr_block_set]\n                elif len(curr_block_set) == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    return max_block_set\n\ndef find_max_block_set_3(arr):\n    max_block_count = 1\n    max_block_set = [[]]\n    for i in range(len(arr)-1):\n        curr_block_count = 1\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)-1):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                curr_block_count += 1\n                if curr_block_count > max_block_count:\n                    max_block_count = curr_block_count\n                    max_block_set = [curr_block_set]\n                elif curr_block_count == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    return max_block_set\n\ndef find_max_block_set_4(arr):\n    max_block_count = 1\n    max_block_set = [[]]\n    for i in range(len(arr)-1):\n        curr_block_count = 1\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)-1):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                curr_block_count += 1\n                if curr_block_count > max_block_count:\n                    max_block_count = curr_block_count\n                    max_block_set = [curr_block_set]\n                elif curr_block_count == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    return max_block_set\n\n\ndef main():\n    arr = [int(i) for i in input().split()]\n    max_block_set = find_max_block_set_4(arr)\n    print(len(max_block_set))\n    for block in max_block_set:\n        print(block[0], block[-1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_groups(n, arr):\n    groups = []\n    for i in range(n):\n        groups.append([arr[i]])\n    return groups\n\ndef get_sets(n, arr):\n    sets = []\n    for i in range(n):\n        sets.append(set(arr[i][0]))\n    return sets\n\ndef get_set_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append([arr[i][0][0], arr[i][0][-1]])\n    return bounds\n\ndef get_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append([arr[i][0], arr[i][-1]])\n    return bounds\n\ndef find_groups(n, arr):\n    groups = get_groups(n, arr)\n    sets = get_sets(n, groups)\n    bounds = get_bounds(n, groups)\n    set_bounds = get_set_bounds(n, groups)\n    while len(sets) > 1:\n        i = 0\n        j = 0\n        while i < len(sets)-1:\n            if i == len(sets)-1:\n                break\n            while j < len(sets):\n                if j == len(sets):\n                    break\n                if sets[i] == sets[j]:\n                    if bounds[i][1] + 1 == bounds[j][0] or bounds[j][1] + 1 == bounds[i][0]:\n                        if bounds[i][0] < bounds[j][0]:\n                            bounds[i][1] = bounds[j][1]\n                            sets[i] = set(groups[i])\n                        else:\n                            bounds[i][0] = bounds[j][0]\n                            sets[i] = set(groups[i])\n                        bounds[j][0] = -1\n                        bounds[j][1] = -1\n                        sets.pop(j)\n                        bounds.pop(j)\n                        groups.pop(j)\n                        continue\n                j += 1\n            i += 1\n            j = 0\n    i = 0\n    while i < len(bounds):\n        if bounds[i][0] == -1:\n            bounds.pop(i)\n            groups.pop(i)\n            continue\n        i += 1\n    i = 0\n    while i < len(bounds):\n        for j in range(len(set_bounds)):\n            if set_bounds[j][0] == bounds[i][0] and set_bounds[j][1] == bounds[i][1]:\n                set_bounds.pop(j)\n        i += 1\n    i = 0\n    while i < len(set_bounds):\n        if set_bounds[i][0] == -1:\n            set_bounds.pop(i)\n            groups.pop(i)\n            continue\n        i += 1\n    return groups + set_bounds\n\ndef main():\n    n = int(input())\n    arr = input().split()\n    arr = [int(x) for x in arr]\n    groups = find_groups(n, arr)\n    print(len(groups))\n    for i in range(len(groups)):\n        print(str(groups[i][0]) + \" \" + str(groups[i][1]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# TODO: Timeout (use divide and conquer)\n\ndef find_max_block_set(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                if len(curr_block_set) > max_block_count:\n                    max_block_count = len(curr_block_set)\n                    max_block_set = [curr_block_set]\n                elif len(curr_block_set) == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = [j+1]\n    return max_block_set\n\ndef find_max_block_set_2(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                if len(curr_block_set) > max_block_count:\n                    max_block_count = len(curr_block_set)\n                    max_block_set = [curr_block_set]\n                elif len(curr_block_set) == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = [j+1]\n    return max_block_set\n\ndef find_max_block_set_3(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_block_count = 1\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                curr_block_count += 1\n                if curr_block_count > max_block_count:\n                    max_block_count = curr_block_count\n                    max_block_set = [curr_block_set]\n                elif curr_block_count == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = [j+1]\n    return max_block_set\n\ndef find_max_block_set_4(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_block_count = 1\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                curr_block_count += 1\n                if curr_block_count > max_block_count:\n                    max_block_count = curr_block_count\n                    max_block_set = [curr_block_set]\n                elif curr_block_count == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = [j+1]\n    return max_block_set\n\n\ndef main():\n    arr = [int(i) for i in input().split()]\n    max_block_set = find_max_block_set(arr)\n    print(len(max_block_set))\n    for block in max_block_set:\n        print(block[0], block[-1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_groups(n, arr):\n    groups = []\n    for i in range(n):\n        groups.append(arr[i])\n    return groups\n\ndef get_sets(n, arr):\n    sets = []\n    for i in range(n):\n        sets.append(set(arr[i]))\n    return sets\n\ndef get_set_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append([arr[i][0], arr[i][-1]])\n    return bounds\n\ndef get_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append(arr[i])\n    return bounds\n\ndef find_groups(n, arr):\n    groups = get_groups(n, arr)\n    sets = get_sets(n, groups)\n    bounds = get_bounds(n, groups) # groups = [[1, 2, 3, 4], [5, 6], [7, 8, 9]]\n    set_bounds = get_set_bounds(n, groups)\n    while len(sets) > 1:\n        i = 0\n        j = 0\n        while i < len(sets)-1:\n            if i == len(sets)-1:\n                break\n            while j < len(sets):\n                if j == len(sets):\n                    break\n                if sets[i] == sets[j]: # [1, 2, 3, 4] == [5, 6]\n                    if bounds[i][1] + 1 == bounds[j][0] or bounds[j][1] + 1 == bounds[i][0]:\n                        if bounds[i][0] < bounds[j][0]:\n                            bounds[i][1] = bounds[j][1]\n                        else:\n                            bounds[i][0] = bounds[j][0]\n                        bounds[j][0] = -1 # [1, 4] = [1, 4]\n                        bounds[j][1] = -1\n                        sets.pop(j) # [7, 8, 9]\n                        bounds.pop(j)\n                        continue\n                j += 1\n            i += 1\n            j = 0\n    i = 0\n    while i < len(bounds): # [1, 4]\n        if bounds[i][0] == -1:\n            bounds.pop(i) # [1, 4]\n            continue\n        i += 1\n    i = 0\n    while i < len(bounds): # [1, 4]\n        for j in range(len(set_bounds)):\n            if set_bounds[j][0] == bounds[i][0] and set_bounds[j][1] == bounds[i][1]: # [1, 4] == [1, 4]\n                set_bounds.pop(j)\n        i += 1\n    i = 0\n    while i < len(set_bounds): # [7, 9]\n        if set_bounds[i][0] == -1:\n            set_bounds.pop(i)\n            continue\n        i += 1\n    return bounds + set_bounds # [1, 4], [7, 9]\n\ndef main():\n    n = int(input())\n    arr = input().split()\n    arr = [int(x) for x in arr]\n    groups = find_groups(n, arr)\n    print(len(groups))\n    for i in range(len(groups)):\n        print(str(groups[i][0]) + \" \" + str(groups[i][1]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# TODO: Timeout\n\ndef find_max_block_set(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                if len(curr_block_set) > max_block_count:\n                    max_block_count = len(curr_block_set)\n                    max_block_set = [curr_block_set]\n                elif len(curr_block_set) == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    # print(max_block_set)\n    return max_block_set\n\ndef find_max_block_set_2(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                if len(curr_block_set) > max_block_count:\n                    max_block_count = len(curr_block_set)\n                    max_block_set = [curr_block_set]\n                elif len(curr_block_set) == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    return max_block_set\n\ndef find_max_block_set_3(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_block_count = 1\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                curr_block_count += 1\n                if curr_block_count > max_block_count:\n                    max_block_count = curr_block_count\n                    max_block_set = [curr_block_set]\n                elif curr_block_count == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    return max_block_set\n\ndef find_max_block_set_4(arr):\n    max_block_count = 1\n    max_block_set = []\n    for i in range(len(arr)):\n        curr_block_count = 1\n        curr_sum = arr[i]\n        curr_block_set = [i+1]\n        for j in range(i+1, len(arr)):\n            curr_sum += arr[j]\n            if curr_sum <= 0:\n                curr_block_set.append(j+1)\n                curr_block_count += 1\n                if curr_block_count > max_block_count:\n                    max_block_count = curr_block_count\n                    max_block_set = [curr_block_set]\n                elif curr_block_count == max_block_count:\n                    max_block_set.append(curr_block_set)\n                curr_sum = 0\n                curr_block_set = []\n    return max_block_set\n\n\ndef main():\n    arr = [int(i) for i in input().split()]\n    max_block_set = find_max_block_set_4(arr)\n    print(len(max_block_set))\n    for block in max_block_set:\n        print(block[0], block[-1])\n\nif __name__ == \"__main__\":\n    main()\n", "\n# Solution\n\ndef is_valid_block(block):\n    return block[0] <= block[1]\n\ndef get_sum(block, arr):\n    return sum(arr[block[0]-1:block[1]])\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    blocks = [(i, j) for i in range(1, n+1) for j in range(i, n+1)] # generate all possible blocks\n    blocks = [block for block in blocks if is_valid_block(block)]\n    blocks = [(i, block) for i, block in enumerate(blocks)] # enumerate all blocks\n    blocks = sorted(blocks, key=lambda x: get_sum(x[1], arr))\n    blocks = [(block[0]+1, block[1]) for _, block in blocks] # restore block format\n\n    i = 0\n    while i < len(blocks)-1:\n        if get_sum(blocks[i], arr) != get_sum(blocks[i+1], arr):\n            blocks = blocks[:i+1]\n            break\n        if blocks[i][1] >= blocks[i+1][0]:\n            blocks[i] = (blocks[i][0], blocks[i+1][1])\n            del blocks[i+1]\n            continue\n        i += 1\n\n    print(len(blocks))\n    for block in blocks:\n        print(block[0], block[1])\n\nmain()\n", "\n# Solution\n\ndef is_valid_block(block):\n    return block[0] < block[1]\n\ndef get_sum(block, arr):\n    return sum(arr[block[0]-1:block[1]])\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    blocks = [(i, j) for i in range(1, n+1) for j in range(i, n+2)]\n    blocks = [block for block in blocks if is_valid_block(block)]\n    blocks = [(i, block) for i, block in enumerate(blocks)]\n    blocks = sorted(blocks, key=lambda x: get_sum(x[1], arr))\n    blocks = [(block[0]+1, block[1]) for _, block in blocks]\n\n    i = 0\n    while i < len(blocks)-1:\n        if get_sum(blocks[i], arr) != get_sum(blocks[i+1], arr):\n            blocks = blocks[:i+1]\n            break\n        if blocks[i][1] >= blocks[i+1][0]:\n            blocks[i] = (blocks[i][0], blocks[i+1][1])\n            del blocks[i+1]\n            continue\n        i += 1\n\n    print(len(blocks))\n    for block in blocks:\n        print(block[0], block[1])\n\nmain()\n", "# Solution\n\ndef is_valid_block(block):\n    return block[0] <= block[1]\n\ndef get_sum(block, arr):\n    return sum(arr[block[0]-1:block[1]])\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    blocks = [(i, j) for i in range(1, n+1) for j in range(i, n+1)]\n    blocks = [block for block in blocks if is_valid_block(block)]\n    blocks = [(i, block) for i, block in enumerate(blocks)]\n    blocks = sorted(blocks, key=lambda x: get_sum(x[1], arr))\n    blocks = [(block[0]+1, block[1]) for _, block in blocks]\n\n    i = 0\n    while i < len(blocks)-1:\n        if get_sum(blocks[i], arr) != get_sum(blocks[i+1], arr):\n            blocks = blocks[:i+1]\n            break\n        if blocks[i][1] >= blocks[i+1][0]:\n            blocks[i] = (blocks[i][0], blocks[i+1][1])\n            del blocks[i+1]\n            continue\n        i += 1\n\n    print(len(blocks))\n    for block in blocks:\n        print(block[0], block[1])\n\nmain()\n", "\n#!/usr/bin/env python3\n\ndef is_valid_block(block):\n    return block[0] <= block[1]\n\ndef get_sum(block, arr):\n    return sum(arr[block[0]-1:block[1]-1])\n\ndef main():\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    blocks = [(i, j) for i in range(1, n+1) for j in range(i, n+1)]\n    blocks = [block for block in blocks if is_valid_block(block)]\n    blocks = [(i, block) for i, block in enumerate(blocks)]\n    blocks = sorted(blocks, key=lambda x: get_sum(x[1], arr))\n    blocks = [(block[0]+1, block[1]) for _, block in blocks]\n\n    i = 0\n    while i < len(blocks)-1:\n        if get_sum(blocks[i], arr) != get_sum(blocks[i+1], arr):\n            blocks = blocks[:i+1]\n            break\n        if blocks[i][1] >= blocks[i+1][0]:\n            blocks[i] = (blocks[i][0], blocks[i+1][1])\n            del blocks[i+1]\n            continue\n        i += 1\n\n    print(len(blocks))\n    for block in blocks:\n        print(block[0], block[1])\n\nmain()\n", "\n\ndef get_groups(n, arr):\n    groups = []\n    for i in range(n):\n        groups.append(arr[i])\n    return groups\n\ndef get_sets(n, arr):\n    sets = []\n    for i in range(n):\n        sets.append(set(arr[i]))\n    return sets\n\ndef get_set_bounds(n, arr, sets):\n    bounds = []\n    for i in range(n):\n        bounds.append([-1, -1])\n        for j in range(len(sets)):\n            if arr[i] in sets[j]:\n                bounds[i][0] = sets[j][0]\n                bounds[i][1] = sets[j][1]\n                break\n    return bounds\n\ndef get_bounds(n, arr):\n    bounds = []\n    for i in range(n):\n        bounds.append(arr[i])\n    return bounds\n\ndef find_groups(n, arr):\n    groups = get_groups(n, arr)\n    sets = get_sets(n, groups)\n    bounds = get_bounds(n, groups)\n    set_bounds = get_set_bounds(n, groups, sets)\n    while len(sets) > 1:\n        i = 0\n        j = 0\n        while i < len(sets)-1:\n            if i == len(sets)-1:\n                break\n            while j < len(sets):\n                if j == len(sets):\n                    break\n                if sets[i] == sets[j]:\n                    if bounds[i][1] + 1 == bounds[j][0] or bounds[j][1] + 1 == bounds[i][0]:\n                        if bounds[i][0] < bounds[j][0]:\n                            bounds[i][1] = bounds[j][1]\n                        else:\n                            bounds[i][0] = bounds[j][0]\n                        bounds[j][0] = -1\n                        bounds[j][1] = -1\n                        sets.pop(j)\n                        bounds.pop(j)\n                        continue\n                j += 1\n            i += 1\n            j = 0\n    i = 0\n    while i < len(bounds):\n        if bounds[i][0] == -1:\n            bounds.pop(i)\n            continue\n        i += 1\n    i = 0\n    while i < len(bounds):\n        for j in range(len(set_bounds)):\n            if set_bounds[j][0] == bounds[i][0] and set_bounds[j][1] == bounds[i][1]:\n                set_bounds.pop(j)\n        i += 1\n    return bounds + set_bounds\n\ndef main():\n    n = int(input())\n    arr = input().split()\n    arr = [int(x) for x in arr]\n    groups = find_groups(n, arr)\n    print(len(groups))\n    for i in range(len(groups)):\n        print(str(groups[i][0]) + \" \" + str(groups[i][1]))\n\nif __name__ == \"__main__\":\n    main()\n"]