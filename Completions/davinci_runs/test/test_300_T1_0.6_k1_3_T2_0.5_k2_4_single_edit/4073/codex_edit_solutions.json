["\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    result = 1\n    for i in range(1, n):\n        if a[i-1] + 1 < a[i]:\n            result += 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# for each possible number of people,\n# determine whether it is possible to have\n# exactly that many people\n\ndef solve(a):\n\tn = len(a)\n\tb = [0]\n\tfor i in range(n):\n\t\tb.append(b[i] + a[i])\n\t\tb.append(b[i] - a[i])\n\tb.sort()\n\tc = [0]\n\tfor i in range(1, len(b)):\n\t\tif b[i] != b[i-1]:\n\t\t\tc.append(b[i])\n\tm = len(c)\n\t# dp[i][j] = whether it's possible to have j people\n\t# and use people from the first i groups\n\tdp = [[False for j in range(m)] for i in range(n)]\n\tfor i in range(n):\n\t\tdp[i][0] = True\n\tfor i in range(n):\n\t\tfor j in range(1, m):\n\t\t\tdp[i][j] = dp[i][j-1] or (dp[i-1][j-1] and c[j] == c[j-1] + a[i])\n\tfor j in range(m):\n\t\tif dp[n-1][j]:\n\t\t\treturn j + 1\n\nn = int(raw_input())\na = map(int, raw_input().split())\nprint solve(a)\n", "\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    result = 2\n    for i in range(1, n):\n        if a[i-1] + 1 == a[i]:\n            result += 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# for each possible number of people,\n# determine whether it is possible to have\n# exactly that many people\n\ndef solve(a):\n\tn = len(a)\n\tb = [0]\n\tfor i in range(n):\n\t\tb.append(b[i] + a[i])\n\t\tb.append(b[i] - a[i])\n\tb.sort()\n\tc = [0]\n\tfor i in range(1, len(b)):\n\t\tif b[i] != b[i-1]:\n\t\t\tc.append(b[i])\n\tm = len(c)\n\t# dp[i][j] = whether it's possible to have j people\n\t# and use people from the first i groups\n\tdp = [[False for j in range(m)] for i in range(n)]\n\tfor i in range(n):\n\t\tdp[i][0] = True\n\tfor i in range(n):\n\t\tfor j in range(1, m):\n\t\t\tdp[i][j] = dp[i][j-1] or (i > 0 and dp[i-1][j-1] and c[j] == c[j-1] + a[i])\n\tfor j in range(m):\n\t\tif dp[n-1][j]:\n\t\t\treturn j + 1\n\t\t\t\nn = int(raw_input())\na = map(int, raw_input().split())\nprint solve(a)\n", "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    result = 1\n    for i in range(1, n):\n            result += 1\n            break\n        elif a[i-1] == a[i]:\n        if a[i-1] + 1 == a[i]:\n            result += 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print answer\nprint(sum(a) - n)\n", "\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print answer\nprint(sum(a) - n)\n", "# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print answer\nprint(sum(a) - n)\n", "\n\n# find the minimum number of people\n# that must be removed to make the rest\n# satisfied\n\ndef solve(n, a):\n\t# dp[i][j] = minimum number of people to be removed\n\t# to make the first i people happy, with j additional\n\t# people removed\n\tdp = [[0 for j in range(n + 1)] for i in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(n + 1):\n\t\t\tdp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n\t\t\tif a[i] + j <= n:\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][a[i] + j])\n\t\t\tif a[i] - j >= 0:\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][j-a[i] + j])\n\treturn dp[n-1][0]\n\ntest = int(raw_input())\nfor t in range(test):\n\tn = int(raw_input())\n\ta = map(int, raw_input().split())\n\tprint solve(n, a)\n", "\n\n# for each possible number of people,\n# determine whether it is possible to have\n# exactly that many people\n\ndef solve(a):\n\tn = len(a)\n\tb = [0]\n\tfor i in range(n):\n\t\tb.append(b[i] + a[i])\n\t\tb.append(b[i] - a[i])\n\tb.sort()\n\tc = [0]\n\tfor i in range(1, len(b)):\n\t\tif b[i] != b[i-1]:\n\t\t\tc.append(b[i])\n\tm = len(c)\n\t# dp[i][j] = whether it's possible to have j people\n\t# and use people from the first i groups\n\tdp = [[False for j in range(m)] for i in range(n)]\n\tfor i in range(n):\n\t\tdp[i][0] = True\n\tfor i in range(n):\n\t\tfor j in range(1, m):\n\t\t\tdp[i][j] = dp[i][j-1] or (dp[i-1][j-1] and c[j] == c[j-1] + a[i])\n\tfor j in range(m):\n\t\tif dp[n-1][j]:\n\t\t\tprint j + 1\n\t\t\t\nn = int(raw_input())\na = map(int, raw_input().split())\nsolve(a)\n"]