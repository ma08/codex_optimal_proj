2022-04-23 17:32:54.784767 num operations 1
2022-04-23 17:32:54.784783 size on input set 1
2022-04-23 17:32:54.784974 using api key derek
2022-04-23 17:33:07.934309 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "def main():\n    n, k = map(int, input().split())\n    edges = {}\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(\" \".join([str(i % r + 1) for i in range(n - 1)]))\n\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 1
    },
    {
      "index": 2,
      "text": "\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = {}\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(\" \".join([str(i%r+1) for i in range(n-1)]))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n, k = map(int, raw_input().split())\n    edges = {}\n    for i in range(n-1):\n        a, b = map(int, raw_input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(\" \".join([str(i%r+1) for i in range(n-1)]))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650735174,
  "object": "edit"
}
2022-04-23 17:33:07.934640 NO RESULT
2022-04-23 17:33:07.934651 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 1
}
2022-04-23 17:33:07.934701 fix syntax errors 3 ['def main():\n    n, k = map(int, input().split())\n    edges = {}\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(" ".join([str(i % r + 1) for i in range(n - 1)]))\n\n\n\nif __name__ == \'__main__\':\n    main()\n', '\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = {}\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(" ".join([str(i%r+1) for i in range(n-1)]))\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, raw_input().split())\n    edges = {}\n    for i in range(n-1):\n        a, b = map(int, raw_input().split())\n        if a in edges:\n            edges[a].append(i)\n        else:\n            edges[a] = [i]\n        if b in edges:\n            edges[b].append(i)\n        else:\n            edges[b] = [i]\n    counts = {}\n    for i in edges.keys():\n        counts[i] = len(edges[i])\n    r = 0\n    while counts:\n        r += 1\n        for i in counts.keys():\n            if counts[i] == 1:\n                del counts[i]\n                break\n            else:\n                counts[i] -= 1\n    print(r)\n    print(" ".join([str(i%r+1) for i in range(n-1)]))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 17:33:07.934740 size on output set 3
2022-04-23 17:33:07.934754 num operations 1
2022-04-23 17:33:07.934759 size on input set 1
2022-04-23 17:33:07.934896 using api key kouti
2022-04-23 17:33:15.140581 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n\"\"\"\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t\"\"\"\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t\"\"\"\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t\"\"\"\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t\"\"\"\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t\"\"\"\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t\"\"\"\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components, roads):\n\t\t\"\"\"\n\t\t\tGroup roads in connected components\n\t\t\"\"\"\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in roads[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t\"\"\"\n\t\t\tAssign companies to roads\n\t\t\"\"\"\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t\"\"\"\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t\"\"\"\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components, roads)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint -1\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint company_assignment[(g.edges[i][0], g.edges[i][1])],\n\tprint\n\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n\"\"\"\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t\"\"\"\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t\"\"\"\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t\"\"\"\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t\"\"\"\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t\"\"\"\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t\"\"\"\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components):\n\t\t\"\"\"\n\t\t\tGroup roads in connected components\n\t\t\"\"\"\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t\"\"\"\n\t\t\tAssign companies to roads\n\t\t\"\"\"\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t\"\"\"\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t\"\"\"\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint(-1)\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint(company_assignment[(g.edges[i][0], g.edges[i][1])], end=' ')\n\tprint\n\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n\"\"\"\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t\"\"\"\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t\"\"\"\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t\"\"\"\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t\"\"\"\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t\"\"\"\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t\"\"\"\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components):\n\t\t\"\"\"\n\t\t\tGroup roads in connected components\n\t\t\"\"\"\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t\"\"\"\n\t\t\tAssign companies to roads\n\t\t\"\"\"\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t\"\"\"\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t\"\"\"\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint(-1)\n\t\treturn\n\n\tprint(len(company_assignment))\n\tfor i in xrange(len(g.edges)):\n\t\tprint(company_assignment[(g.edges[i][0], g.edges[i][1])], end=\" \")\n\tprint\n\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 3,
      "text": "\n\n\"\"\"\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n\"\"\"\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t\"\"\"\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t\"\"\"\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t\"\"\"\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t\"\"\"\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t\"\"\"\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t\"\"\"\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components, roads):\n\t\t\"\"\"\n\t\t\tGroup roads in connected components\n\t\t\"\"\"\n\t\tcomponent_roads = []\n\t\tfor component in components:\n\t\t\troads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\tcomponent_roads.append(roads)\n\t\treturn component_roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t\"\"\"\n\t\t\tAssign companies to roads\n\t\t\"\"\"\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t\"\"\"\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t\"\"\"\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components, roads)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies-1, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint -1\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint company_assignment[(g.edges[i][0], g.edges[i][1])],\n\tprint\n\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1650735187,
  "object": "edit"
}
2022-04-23 17:33:15.141075 fix syntax errors 4 ['\n\n"""\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n"""\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t"""\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t"""\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t"""\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t"""\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t"""\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t"""\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components, roads):\n\t\t"""\n\t\t\tGroup roads in connected components\n\t\t"""\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in roads[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t"""\n\t\t\tAssign companies to roads\n\t\t"""\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t"""\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t"""\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components, roads)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint -1\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint company_assignment[(g.edges[i][0], g.edges[i][1])],\n\tprint\n\n\nif __name__ == \'__main__\':\n\tmain()\n', '\n\n"""\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n"""\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t"""\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t"""\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t"""\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t"""\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t"""\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t"""\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components):\n\t\t"""\n\t\t\tGroup roads in connected components\n\t\t"""\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t"""\n\t\t\tAssign companies to roads\n\t\t"""\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t"""\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t"""\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint(-1)\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint(company_assignment[(g.edges[i][0], g.edges[i][1])], end=\' \')\n\tprint\n\n\nif __name__ == \'__main__\':\n\tmain()\n', '\n\n"""\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n"""\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t"""\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t"""\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t"""\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t"""\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t"""\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t"""\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components):\n\t\t"""\n\t\t\tGroup roads in connected components\n\t\t"""\n\t\troads = []\n\t\tfor component in components:\n\t\t\tcomponent_roads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\troads.append(component_roads)\n\t\treturn roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t"""\n\t\t\tAssign companies to roads\n\t\t"""\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t"""\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t"""\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint(-1)\n\t\treturn\n\n\tprint(len(company_assignment))\n\tfor i in xrange(len(g.edges)):\n\t\tprint(company_assignment[(g.edges[i][0], g.edges[i][1])], end=" ")\n\tprint\n\n\nif __name__ == \'__main__\':\n\tmain()\n', '\n\n"""\nSolution outline:\n\t1. Find all connected components in the graph (roads)\n\t2. Each of these components has to be assigned to a separate company\n\t3. For each of these components, find the number of cities that have two or more roads.\n\t4. If the sum of this count for each component is > k, then the answer is -1\n\t5. Otherwise, assign each connected component to a separate company (1,2,3,..)\n\t6. Print the company number assigned to each road.\n"""\n\nfrom collections import defaultdict\nimport heapq\n\nclass Graph(object):\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.edges = defaultdict(list)\n\n\tdef add_edge(self, u, v):\n\t\tself.edges[u].append(v)\n\t\tself.edges[v].append(u)\n\n\tdef connected_components(self):\n\t\t"""\n\t\t\tFind the connected components in the graph\n\t\t\tDFS approach\n\t\t"""\n\t\tvisited = set()\n\t\tcomponents = []\n\t\tfor node in xrange(1, self.n+1):\n\t\t\tif node in visited:\n\t\t\t\tcontinue\n\t\t\tcomponent = set()\n\t\t\tstack = [node]\n\t\t\twhile stack:\n\t\t\t\tnode = stack.pop()\n\t\t\t\tvisited.add(node)\n\t\t\t\tcomponent.add(node)\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor not in visited:\n\t\t\t\t\t\tstack.append(neighbor)\n\t\t\tcomponents.append(component)\n\t\treturn components\n\n\tdef roads_to_cities(self, roads):\n\t\t"""\n\t\t\tConvert list of roads to cities\n\t\t\tcities are a list of lists\n\t\t"""\n\t\tcities = defaultdict(list)\n\t\tfor i,(u,v) in enumerate(roads):\n\t\t\tcities[u].append(i)\n\t\t\tcities[v].append(i)\n\t\treturn cities\n\n\tdef companies_in_connected_components(self, components, k):\n\t\t"""\n\t\t\tFind number of companies required to satisfy \n\t\t\tthe problem constraint\n\t\t\tk: max number of cities with more than 1 road with same company\n\t\t"""\n\t\tif not k: # No constraint, one company per component\n\t\t\treturn len(components)\n\n\t\t# Find the number of cities with more than 1 road\n\t\t# for each connected component\n\t\tcities = self.roads_to_cities(self.edges)\n\t\tcounts = [0]*len(components)\n\t\tfor i,component in enumerate(components):\n\t\t\tfor node in component:\n\t\t\t\tif len(cities[node]) > 1:\n\t\t\t\t\tcounts[i] += 1\n\t\t# If the sum of these counts for all components\n\t\t# is more than k, then the answer is impossible\n\t\tif sum(counts) > k:\n\t\t\treturn -1\n\t\t# Otherwise, number of companies is the number of components\n\t\treturn len(components)\n\n\tdef roads_in_connected_components(self, components, roads):\n\t\t"""\n\t\t\tGroup roads in connected components\n\t\t"""\n\t\tcomponent_roads = []\n\t\tfor component in components:\n\t\t\troads = []\n\t\t\tfor node in component:\n\t\t\t\tfor neighbor in self.edges[node]:\n\t\t\t\t\tif neighbor in component:\n\t\t\t\t\t\tcomponent_roads.append((node,neighbor))\n\t\t\tcomponent_roads.append(roads)\n\t\treturn component_roads\n\n\tdef company_assignment(self, companies, roads):\n\t\t"""\n\t\t\tAssign companies to roads\n\t\t"""\n\t\tcompany_road_map = {}\n\t\tfor i,component in enumerate(roads):\n\t\t\tfor u,v in component:\n\t\t\t\tcompany_road_map[(u,v)] = i+1\n\t\t\t\tcompany_road_map[(v,u)] = i+1\n\t\treturn company_road_map\n\n\tdef company_assignment_for_roads(self, roads, k):\n\t\t"""\n\t\t\tAssign companies to roads in a way that\n\t\t\tsatisfies the problem constraint\n\t\t"""\n\t\t# Find connected components\n\t\tcomponents = self.connected_components()\n\t\t# Find number of companies required\n\t\tcompanies = self.companies_in_connected_components(components, k)\n\t\tif companies == -1:\n\t\t\treturn -1\n\t\t# Group roads in connected components\n\t\troads = self.roads_in_connected_components(components, roads)\n\t\t# Assign companies to roads\n\t\treturn self.company_assignment(companies-1, roads)\n\n\ndef main():\n\tn,k = map(int, raw_input().strip().split())\n\tg = Graph(n)\n\tfor _ in xrange(n-1):\n\t\tu,v = map(int, raw_input().strip().split())\n\t\tg.add_edge(u,v)\n\n\tcompany_assignment = g.company_assignment_for_roads(g.edges, k)\n\tif company_assignment == -1:\n\t\tprint -1\n\t\treturn\n\n\tprint len(company_assignment)\n\tfor i in xrange(len(g.edges)):\n\t\tprint company_assignment[(g.edges[i][0], g.edges[i][1])],\n\tprint\n\n\nif __name__ == \'__main__\':\n\tmain()\n']
2022-04-23 17:33:15.141235 size on output set 4
2022-04-23 17:33:15.141253 num operations 1
2022-04-23 17:33:15.141259 size on input set 1
2022-04-23 17:33:15.141385 using api key derek
2022-04-23 17:33:18.048816 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=\" \")\n    print()\n    \"\"\"\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650735195,
  "object": "edit"
}
2022-04-23 17:33:18.049320 fix syntax errors 4 ['\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n\nif __name__ == \'__main__\':\n    main()\n', '\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n\nif __name__ == \'__main__\':\n    main()\n', '\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n\nif __name__ == \'__main__\':\n    main()\n', '\n#!/usr/bin/python\nimport sys\nimport os\nimport math\n\ndef get_max_cluster_size(cluster_size_list):\n    max_size = 0\n    for i in cluster_size_list:\n        if i > max_size:\n            max_size = i\n    return max_size\n\ndef get_max_cluster_size_index(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            return i\n\ndef get_max_cluster_size_index_list(cluster_size_list):\n    max_size = get_max_cluster_size(cluster_size_list)\n    max_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == max_size:\n            max_size_index_list.append(i)\n    return max_size_index_list\n\ndef get_min_cluster_size(cluster_size_list):\n    min_size = sys.maxsize\n    for i in cluster_size_list:\n        if i < min_size:\n            min_size = i\n    return min_size\n\ndef get_min_cluster_size_index(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            return i\n\ndef get_min_cluster_size_index_list(cluster_size_list):\n    min_size = get_min_cluster_size(cluster_size_list)\n    min_size_index_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] == min_size:\n            min_size_index_list.append(i)\n    return min_size_index_list\n\ndef get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list_len)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index):\n    max_size_index_list = get_max_cluster_size_index_list(cluster_size_list)\n    min_size_index_list = get_min_cluster_size_index_list(cluster_size_list)\n    max_size_index = max_size_index_list[0]\n    min_size_index = min_size_index_list[0]\n    for i in range(len(cluster_list)):\n        if cluster_list[i] == max_size_index:\n            cluster_list[i] = min_size_index\n    cluster_size_list[min_size_index] += cluster_size_list[max_size_index]\n    cluster_size_list[max_size_index] = 0\n    cluster_size_list_len -= 1\n    cluster_size_list_max_size = get_max_cluster_size(cluster_size_list)\n    cluster_size_list_min_size = get_min_cluster_size(cluster_size_list)\n\ndef is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k):\n    if cluster_size_list_max_size > k:\n        return True\n    else:\n        return False\n\ndef get_cluster_number(cluster_size_list, cluster_size_list_len):\n    cluster_number = 0\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_number += 1\n    return cluster_number\n\ndef get_cluster_list(cluster_size_list, cluster_size_list_len):\n    cluster_list = []\n    for i in range(len(cluster_size_list)):\n        if cluster_size_list[i] > 0:\n            cluster_list.append(i)\n    return cluster_list\n\ndef get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size):\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(len(cluster_list)):\n        cluster_size_list[cluster_list[i]] += 1\n\ndef main():\n    n, k = map(int, input().split())\n    n_min_1 = n-1\n    cluster_list = []\n    cluster_size_list = []\n    cluster_size_list_len = 0\n    cluster_size_list_max_size = 0\n    cluster_size_list_min_size = 0\n    for i in range(n_min_1):\n        cluster_list.append(i)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n    for i in range(len(cluster_list)):\n        cluster_list[i] = 0\n    for i in range(len(cluster_size_list)):\n        cluster_size_list[i] = 0\n    for i in range(n_min_1):\n        cluster_list.append(0)\n        cluster_size_list.append(0)\n    cluster_size_list_len = n_min_1\n    get_cluster_size(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    while is_cluster_equal_to_k(cluster_size_list, cluster_size_list_max_size, k) == True:\n        merge_cluster(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size, cluster_size_list_max_size_index, cluster_size_list_min_size_index)\n    cluster_number = get_cluster_number(cluster_size_list, cluster_size_list_len)\n    cluster_list = get_cluster_list(cluster_size_list, cluster_size_list_len)\n    cluster_size_list = get_cluster_size_list(cluster_list, cluster_size_list, cluster_size_list_len, cluster_size_list_max_size, cluster_size_list_min_size)\n    print(cluster_number)\n    for i in range(n_min_1):\n        print(cluster_list[cluster_list[i]]+1, end=" ")\n    print()\n    """\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-23 17:33:18.049511 size on output set 1
