2022-04-23 15:59:40.768861 num operations 1
2022-04-23 15:59:40.768911 size on input set 1
2022-04-23 15:59:40.769074 using api key jaanu
2022-04-23 15:59:54.632931 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport re\n\ndef find_max_intersection_length(filename):\n    # Find the intersection of all segments\n    with open(filename) as f:\n        n = int(f.readline())\n        segments = []\n        for line in f:\n            l, r = [int(i) for i in re.split('\\D+', line)]\n            segments.append([l, r])\n\n        # Sort segments by starting point\n        segments = sorted(segments, key = lambda x: x[0])\n\n        intersection = [segments[0][0], segments[0][1]]\n        for segment in segments:\n            if segment[1] < intersection[0]:\n                # The segment does not intersect the intersection\n                continue\n            elif segment[0] > intersection[1]:\n                # The segment does not intersect the intersection\n                continue\n            else:\n                # The segment intersects the intersection\n                intersection[0] = max(intersection[0], segment[0])\n                intersection[1] = min(intersection[1], segment[1])\n        intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    filename = input()\n    print(find_max_intersection_length(filename))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650729580,
  "object": "edit"
}
2022-04-23 15:59:54.633277 fix syntax errors 4 ["\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport re\n\ndef find_max_intersection_length(filename):\n    # Find the intersection of all segments\n    with open(filename) as f:\n        n = int(f.readline())\n        segments = []\n        for line in f:\n            l, r = [int(i) for i in re.split('\\D+', line)]\n            segments.append([l, r])\n\n        # Sort segments by starting point\n        segments = sorted(segments, key = lambda x: x[0])\n\n        intersection = [segments[0][0], segments[0][1]]\n        for segment in segments:\n            if segment[1] < intersection[0]:\n                # The segment does not intersect the intersection\n                continue\n            elif segment[0] > intersection[1]:\n                # The segment does not intersect the intersection\n                continue\n            else:\n                # The segment intersects the intersection\n                intersection[0] = max(intersection[0], segment[0])\n                intersection[1] = min(intersection[1], segment[1])\n        intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    filename = input()\n    print(find_max_intersection_length(filename))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-23 15:59:54.633356 size on output set 4
2022-04-23 15:59:54.633387 num operations 1
2022-04-23 15:59:54.633394 size on input set 1
2022-04-23 15:59:54.633520 using api key derek
2022-04-23 15:59:58.486389 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in input().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort(reverse = True)\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n"
    }
  ],
  "created": 1650729594,
  "object": "edit"
}
2022-04-23 15:59:58.486604 fix syntax errors 4 ['\n\nimport sys\n\ndef main():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in input().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n', 'import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort(reverse = True)\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n']
2022-04-23 15:59:58.486649 size on output set 4
2022-04-23 15:59:58.486663 num operations 1
2022-04-23 15:59:58.486669 size on input set 1
2022-04-23 15:59:58.486798 using api key derek
2022-04-23 16:00:11.755629 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    # # n = randint(2, 3 * 10 ** 5)\n    # segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    # segments.sort()\n    # return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)] \n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(solution(n - 1, segments[:middle + 1] + segments[middle + 2:]), min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0]))\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments)) \n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, list(map(tuple, segments))\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[1][0], segments[0][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),  # Recursive call\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])  # Intersection\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),  # Recursive call\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])  # Intersection\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n = next(reader)\n    segments = list(reader)\n    segments.sort()\n    print(solution(n, list(map(tuple, segments))))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n segments. \"\"\"\n\n    # If there are two segments, return the length of the intersection of the two segments.\n    if n == 2 and segments[0][1] >= segments[1][0]:\n        return segments[1][0] - segments[0][1]\n\n    # If there are three segments and no intersection, return 0.\n    if n == 3 and segments[0][1] < segments[1][0] and segments[1][1] < segments[2][0]:\n        return 0\n\n    # Find the middle and the highest right endpoint.\n    middle = n // 2\n    maximum = max(segments[middle][1], segments[middle - 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    elif segments[middle - 1][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650729598,
  "object": "edit"
}
2022-04-23 16:00:11.755936 fix syntax errors 4 ['\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    # n = 3\n    # # n = randint(2, 3 * 10 ** 5)\n    # segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    # segments.sort()\n    # return n, segments\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n', '\nfrom random import randint\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)] \n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(solution(n - 1, segments[:middle + 1] + segments[middle + 2:]), min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0]))\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments)) \n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, list(map(tuple, segments))\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[1][0], segments[0][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),  # Recursive call\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])  # Intersection\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),  # Recursive call\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])  # Intersection\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n = next(reader)\n    segments = list(reader)\n    segments.sort()\n    print(solution(n, list(map(tuple, segments))))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n segments. """\n\n    # If there are two segments, return the length of the intersection of the two segments.\n    if n == 2 and segments[0][1] >= segments[1][0]:\n        return segments[1][0] - segments[0][1]\n\n    # If there are three segments and no intersection, return 0.\n    if n == 3 and segments[0][1] < segments[1][0] and segments[1][1] < segments[2][0]:\n        return 0\n\n    # Find the middle and the highest right endpoint.\n    middle = n // 2\n    maximum = max(segments[middle][1], segments[middle - 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    elif segments[middle - 1][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 16:00:11.756030 size on output set 4
