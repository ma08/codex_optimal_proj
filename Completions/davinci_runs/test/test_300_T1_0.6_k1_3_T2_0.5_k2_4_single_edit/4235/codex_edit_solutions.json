["\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)  # check if the graph is connected\n\n    if not all(seen):\n        return False\n\n    # find a cycle that has at least one even degree node\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "\nimport sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    print(''.join(str(1 - color[u - 1]) if color[u - 1] < color[v - 1] else str(color[u - 1]) for u, v in edges))\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)  # connected?\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "import sys\n\n\ndef dfs(graph, v, parent, used):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\ndef solve(n, m, edges, color):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    for i in range(n):\n        for j in range(len(graph[i])):\n            if color[i] == color[graph[i][j]]:\n                print('NO')\n                return\n    print('YES')\n\n\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "class File\n  def self.read_file(file)\n    file = File.open(file, \"r\")\n\n    while !file.eof?\n      puts file.gets\n    end\n  end\n\n  def self.write_file(file, string)\n    file = File.open(file, \"a\")\n    file.puts string\n    file.close\n  end\nend\n\nFile.read_file(\"file.rb\")\nFile.write_file(\"file.rb\", \"puts 'hello'\")\n", "#!/usr/bin/python\n\n#!/usr/bin/python\n\nimport sys\nimport random\nimport math\nimport os\n\n\n# Open a file\npath = \"/Users/sakshiudeshi/Desktop/files\"\ndirs = os.listdir( path )\n\n# This would print all the files and directories\nfor file in dirs:\n   print file\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Open a file\npath = \"/Users/sakshiudeshi/Desktop/files\"\ndirs = os.listdir( path )\n\n# This would print all the files and directories\nfor file in dirs:\n   print file\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "var fs = require('fs');\n\nfs.readFile('text.txt', 'utf8', function(err, data) {\n    if(err) throw err;\n    console.log(data);\n});\n", "// var http = require('http');\n// var fs = require('fs');\n// var path = require('path');\n// var hostname = 'localhost';\n// var port = 3000;\n\n// var server = http.createServer(function(req, res){\n//     console.log('Request for ' + req.url + ' by method ' + req.method);\n//     if (req.method == 'GET') {\n//         var fileUrl;\n//         if (req.url == '/') fileUrl = '/index.html';\n//         else fileUrl = req.url;\n\n//         var filePath = path.resolve('./public'+fileUrl);\n//         var fileExt = path.extname(filePath);\n//         if (fileExt == '.html') {\n//             fs.exists(filePath, function(exists) {                 if (!exists) {\n//                     res.writeHead(404, { 'Content-Type': 'text/html' });\n//                     res.end('<html><body><h1>Error 404: ' + fileUrl + \n//                             ' not found</h1></body></html>');\n//                     return;\n//                 }\n//                 res.writeHead(200, { 'Content-Type': 'text/html' });\n//                 fs.createReadStream(filePath).pipe(res);\n//             });\n//         }\n//         else {\n//             res.writeHead(404, { 'Content-Type': 'text/html' });\n//             res.end('<html><body><h1>Error 404: ' + fileUrl + \n//                     ' not a HTML file</h1></body></html>');\n//         }\n//     }\n//     else {\n//         res.writeHead(404, { 'Content-Type': 'text/html' });\n//         res.end('<html><body><h1>Error 404: ' + req.method + \n//                 ' not supported</h1></body></html>');\n//     }\n// })\n\n// server.listen(port, hostname, function(){\n//   console.log(`Server running at http://${hostname}:${port}/`);\n// });\n\nvar http = require('http');\nvar fs = require('fs');\nvar path = require('path');\nvar mime = require('mime');\nvar cache = {};\n\nfunction send404(response) {\n    response.writeHead(404, {'Content-Type': 'text/plain'});\n    response.write('Error 404: resource not found.');\n    response.end();\n}\n\nfunction sendFile(response, filePath, fileContents) {\n    response.writeHead(\n        200,\n        {\"content-type\": mime.lookup(path.basename(filePath))}\n    );\n    response.end(fileContents);\n}\n\nfunction serveStatic(response, cache, absPath) {\n    if (cache[absPath]) {\n        sendFile(response, absPath, cache[absPath]);\n    } else {\n        fs.exists(absPath, function(exists) {\n            if (exists) {\n                fs.readFile(absPath, function(err, data) {\n                    if (err) {\n                        send404(response);\n                    } else {\n                        cache[absPath] = data;\n                        sendFile(response, absPath, data);\n                    }\n                });\n            } else {\n                send404(response);\n            }\n        });\n    }\n}\n\nvar server = http.createServer(function(request, response) {\n    var filePath = false;\n\n    if (request.url == '/') {\n        filePath = 'public/index.html';\n    } else {\n        filePath = 'public' + request.url;\n    }\n\n    var absPath = './' + filePath;\n    serveStatic(response, cache, absPath);\n});\n\nserver.listen(3000, function() {\n    console.log(\"Server listening on port 3000.\");\n});\n", "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "\nimport sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v, _ in edges:\n        if color[u] == color[v]:\n            print('NO')\n            return\n    print('YES')\n    for u, v, _ in edges:\n        if color[u] < color[v]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader) - 1, next(reader) - 1, i] for i in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"]