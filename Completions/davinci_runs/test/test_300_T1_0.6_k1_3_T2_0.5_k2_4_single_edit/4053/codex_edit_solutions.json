["\n\ndef main():\n    n = int(input())\n    prefixes = []\n    suffixes = []\n    for _ in range(2*n-2):\n        x = input()\n        if x not in prefixes:\n            prefixes.append(x)\n        else:\n            suffixes.append(x)\n    print(\"P\"*len(prefixes) + \"S\"*len(suffixes))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    prefixes = []\n    suffixes = []\n    for _ in range(2*n-2):\n        x = input()\n        if x not in prefixes:\n            prefixes.append(x)\n        else:\n            suffixes.append(x)\n    for x in prefixes:\n        print(\"P\", end=\" \")\n    for x in suffixes:\n        print(\"S\", end=\" \")\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    strings = [sys.stdin.readline().strip() for i in range(2*n-2)]\n    strings = [strings[i] + strings[i+1] for i in range(0, len(strings), 2)]\n    print(strings)\n    for s in strings:\n        for i in range(n-1):\n            if s[:i] not in strings:\n                sys.stdout.write(\"P\")\n                break\n        else:\n            sys.stdout.write(\"S\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    prefixes = []\n    suffixes = []\n    for _ in range(2 * n - 2):\n        x = input()\n        if x not in prefixes:\n            prefixes.append(x)\n        else:\n            suffixes.append(x)\n    for x in prefixes:\n        print(\"P\", end=\"\")\n    for x in suffixes:\n        print(\"S\", end=\"\")\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    strings = [sys.stdin.readline().strip() for i in range(2*n-2)]\n    strings = [strings[i] + strings[i+1] for i in range(0, len(strings), 2)]\n    for s in strings:\n        for i in range(n-1):\n            if s[:i] not in strings:\n                sys.stdout.write(\"P\")\n                break\n        else:\n            sys.stdout.write(\"S\")\n\nif __name__ == \"__main__\":\n    main()\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <errno.h>\n\n#include \"ext2.h\"\n#include \"ext2_utils.h\"\n\nunsigned char *disk;\n\nint main(int argc, char **argv) {\n\n    if(argc != 4) {\n        fprintf(stderr, \"Usage: %s <image file name> <source file path> <destination path>\\n\", argv[0]);\n        exit(1);\n    }\n    int fd = open(argv[1], O_RDWR);\n\n    disk = mmap(NULL, 128 * 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(disk == MAP_FAILED) {\n\t   perror(\"mmap\");\n\t   exit(1);\n    }\n\n    return 0;\n}\n", "/*\n * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage jdk.internal.module;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.module.ModuleDescriptor.Requires.Modifier;\nimport java.lang.module.ModuleDescriptor.Version;\nimport java.lang.module.ModuleFinder;\nimport java.lang.module.ModuleReference;\nimport java.lang.module.ModuleReader;\nimport java.lang.module.ModuleReader.Index;\nimport java.lang.module.ModuleReader.IndexEntry;\nimport java.lang.module.ModuleReader.IndexGroup;\nimport java.lang.module.ModuleReader.IndexGroupEntry;\nimport java.lang.module.ModuleReader.IndexReader;\nimport java.lang.module.ModuleReader.IndexTree;\nimport java.lang.module.ModuleReader.IndexTreeEntry;\nimport java.lang.module.ModuleReference.Attributes;\nimport java.lang.module.ModuleReference.Builder;\nimport java.lang.module.ModuleReference.Requires;\nimport java.lang.module.ModuleReference.Provides;\nimport java.lang.module.ModuleReference.Exports;\nimport java.lang.module.ModuleReference.Opens;\nimport java.lang.module.ModuleReference.Conceals;\nimport java.lang.module.ModuleReference.MainClass;\nimport java.lang.module.ModuleReference.Target;\nimport java.lang.module.ModuleReference.VersionedTarget;\nimport java.lang.module.ModuleReference.CompiledVersion;\nimport java.lang.module.ModuleReference.Requires.Modifier;\nimport java.lang.module.ModuleReference.Exports.Target;\nimport java.lang.module.ModuleReference.Opens.Target;\nimport java.lang.module.ModuleReference.Conceals.Target;\nimport java.lang.module.ModuleReference.CompiledVersion.Version;\nimport java.lang.module.ModuleReference.CompiledVersion.Target;\nimport java.lang.module.ModuleReference.CompiledVersion.VersionedTarget;\nimport java.lang.module.ModuleReference.CompiledVersion.VersionedTarget.Version;\nimport java.lang.module.ModuleReference.CompiledVersion.VersionedTarget.Target;\nimport java.lang.module.ModuleReference.CompiledVersion.VersionedTarget.Target.Version;\nimport java.lang.module.ModuleReference.CompiledVersion.VersionedTarget.Target.Target;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport jdk.internal.org.objectweb.asm.ClassReader;\nimport jdk.internal.org.objectweb.asm.ClassVisitor;\nimport jdk.internal.org.objectweb.asm.FieldVisitor;\nimport jdk.internal.org.objectweb.asm.Opcodes;\nimport jdk.internal.org.objectweb.asm.Type;\n\nimport static jdk.internal.org.objectweb.asm.Opcodes.ASM6;\n\n/**\n * Utility to read the module-info.class file.\n */\n\npublic final class ModuleInfo {\n\n    private ModuleInfo() { }\n\n    public static ModuleDescriptor read(Path path) {\n        try (InputStream in = Files.newInputStream(path)) {\n            return read(in);\n        } catch (IOException ioe) {\n            throw new UncheckedIOException(ioe);\n        }\n    }\n\n    public static ModuleDescriptor read(InputStream in) {\n        return new ClassFileReader(in).read();\n    }\n\n    private static final class ClassFileReader {\n        private final InputStream in;\n        private ModuleDescriptor.Builder builder;\n        private Set<String> packages;\n        private ModuleDescriptor descriptor;\n\n        ClassFileReader(InputStream in) {\n            this.in = in;\n        }\n\n        ModuleDescriptor read() {\n            new ClassReader(in).accept(new ClassVisitor(ASM6) {\n                @Override\n                public void visit(int version, int access, String name,\n                                  String signature, String superName,\n                                  String[] interfaces)\n                {\n                    if (!name.equals(\"module-info\")) {\n                        throw new IllegalArgumentException(\"Not a module-info.class file\");\n                    }\n                }\n\n                @Override\n                public FieldVisitor visitField(int access, String name,\n                                               String descriptor, String signature,\n                                               Object value)\n                {\n                    if (name.equals(\"module_version\")) {\n                        if (!descriptor.equals(\"Ljava/lang/String;\")) {\n                            throw new IllegalArgumentException(\"Invalid module_version field\");\n                        }\n                        Optional<String> version = Optional.ofNullable((String)value);\n                        builder.version(version.map(Version::parse));\n                    }\n                    return null;\n                }\n            }, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);\n            return descriptor;\n        }\n    }\n\n}\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    strings = [sys.stdin.readline().strip() for i in range(2*n-2)]\n    strings = [strings[i] + strings[i + 1] for i in range(0, len(strings), 2)]\n    print(strings)\n    for s in strings:\n        for i in range(n - 1):\n            if s[:i] not in strings:\n                sys.stdout.write(\"P\")\n                break\n        else:\n            sys.stdout.write(\"S\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    f = open(sys.argv[1], \"r\")\n    print(f.read())\n    f.close()\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    strings = [sys.stdin.readline().strip() for i in range(2*n-2)]\n    strings = [strings[i] + strings[i+1] for i in range(0, len(strings)-1, 2)]\n    for s in strings:\n        for i in range(n-1):\n            if s[:i] not in strings:\n                sys.stdout.write(\"P\")\n                break\n        else:\n            sys.stdout.write(\"S\")\n\nif __name__ == \"__main__\":\n    main()\n", "import os\nimport sys\n\n\nclass File:\n    def __init__(self, filepath):\n        self.filepath = filepath\n\n    def read_file(self):\n        try:\n            with open(self.filepath, 'r') as f:\n                return f.read()\n        except FileNotFoundError:\n            return ''\n\n    def write_file(self, data):\n        with open(self.filepath, 'w') as f:\n            f.write(data)\n\n\nclass Directory:\n    def __init__(self, dirpath):\n        self.dirpath = dirpath\n\n    def get_files(self):\n        return [os.path.join(self.dirpath, f) for f in os.listdir(self.dirpath) if os.path.isfile(os.path.join(self.dirpath, f))]\n\n    def get_subdirectories(self):\n        return [os.path.join(self.dirpath, f) for f in os.listdir(self.dirpath) if os.path.isdir(os.path.join(self.dirpath, f))]\n\n\ndef main():\n    if len(sys.argv) < 2:\n        print('Usage: python file.py <dirpath>')\n        sys.exit(1)\n\n    dirpath = sys.argv[1]\n    directory = Directory(dirpath)\n\n    for f in directory.get_files():\n        file = File(f)\n        data = file.read_file()\n        file.write_file(data.upper())\n\n\nif __name__ == '__main__':\n    main()\n"]