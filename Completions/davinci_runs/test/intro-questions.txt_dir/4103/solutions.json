["n, b, a = map(int, input().split())\nA = list(map(int, input().split()))\na0 = a\nans = 0\nfor elem in A:\n\tif a + b == 0:\n\t\tbreak\n\tif elem == 0:\n\t\tif a > 0:\n\t\t\ta -= 1\n\t\t\tans += 1\n\t\telse:\n\t\t\tb -= 1\n\t\t\tans += 1\n\telse:\n\t\tif a == a0:\n\t\t\ta -= 1\n\t\t\tans += 1\n\t\telif b > 0:\n\t\t\tb -= 1\n\t\t\ta += 1\n\t\t\tans += 1\n\t\telse:\n\t\t\ta -= 1\n\t\t\tans += 1\nprint(ans)", "def main():\n    n, b, a = map(int, input().split())\n    arr = list(map(int, input().split()))\n    B = b\n    A = a\n    for i in range(n + 1):\n        if (A == 0 and B == 0) or i == n:\n            print(i)\n            break\n        if arr[i]:\n            if A == a:\n                A -= 1\n            elif B:\n                B -= 1\n                A += 1\n            else:\n                A -= 1\n        else:\n            if A:\n                A -= 1\n            else:\n                B -= 1\n    return 0\n\nmain()", "IN = input\nrint = lambda: int(IN())\nrmint = lambda: list(map(int, IN().split()))\nrlist = lambda: list(rmint())\n\nn, b, a = rmint()\ny = a\nx = b\nd = 0\n\n\ndef ex():\n    print(d)\n    return\n\n\nfor s in rlist():\n    if s:\n        if x and y < a:\n            y += 1\n            x -= 1\n        else:\n            if y:\n                y -= 1\n            else:\n                if x:\n                    x -= 1\n                else:\n                    ex()\n    else:\n        if y:\n            y -= 1\n        else:\n            if x:\n                x -= 1\n            else:\n                ex()\n    d += 1\n\nprint(d)\n", "\n\n\ndef main():\n    dest, battmax, accumax = list(map(int, input().split()))\n    batt = battmax\n    accum = accumax\n    \n    light = list([bool(int(x)) for x in input().split()])\n    path = 0\n    for i in range(len(light)):\n        if not batt and not accum:\n            break\n        if accum == accumax:\n            # if accum is full\n            accum -= 1\n            path += 1\n        elif batt > 0 and light[i]:\n            batt -= 1\n            accum += 1\n            path += 1\n        elif accum > 0:\n            accum -= 1\n            path += 1\n        else:\n            batt -= 1\n            path += 1\n    print(path)\n        \n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, B, A = list(map(int, input().split()))\nmaxA = A\nS = [int(a) for a in input().split()]\n\nfor i in range(N):\n    # print(B, A)\n    s = S[i]\n    if A + B == 0:\n        print(i)\n        break\n    else:\n        if s > 0 and A < maxA and B > 0:\n            B -= 1\n            A += 1\n        elif A > 0:\n            A -= 1\n        else:\n            B -= 1\nelse:\n    print(N)\n", "nn, bb, aa = map(int, input().split())\nn, b, a = nn, bb, aa\nS = list(map(int, input().split()))\nfor i in range(n):\n    if a == 0 and b == 0:\n        print(i)\n        return\n    if S[i] == 1:\n        if b > 0 and a < aa:\n            b -= 1\n            a += 1\n        else:\n            a -= 1\n    else:\n        if a > 0:\n            a -= 1\n        else:\n            b -= 1\nprint(n)", "n, b, a = map(int, input().split())\n\npath = map(int, input().split())\n\nmax_a = a\ncurrent_a = a\n\ncount = 0\nfor segment in path:\n\n\tif segment == 0:\n\t\tif current_a > 0:\n\t\t\tcurrent_a -= 1\n\t\telse:\n\t\t\tb -= 1\n\n\telse:\n\t\tif current_a == max_a or b == 0:\n\t\t\tcurrent_a -= 1\n\n\t\telse:\n\t\t\tb -= 1\n\t\t\tcurrent_a += 1\n\n\tcount += 1\n\tif current_a == 0 and b == 0:\n\t\tbreak\n\nprint(count)", "n, mb, ma = [int(i) for i in input().split()]\nl = [int(i) for i in input().split()]\n\na, b = ma, mb\nfor i in range(n):\n    if a + b == 0:\n        print(i)\n        return\n    elif a != ma and b > 0 and l[i] == 1:\n        b -= 1\n        a += 1\n    elif a > 0:\n        a -= 1\n    else:\n        b -= 1\nprint(n)\n", "n,a,b=list(map(int,input().split()))\nmab=b\nl=list(map(int,input().split()))\nans=0\nfor x in l :\n    if x==0 :\n        if b>0 :\n            b-=1\n            ans+=1\n        else :\n            if a>0 :\n                a-=1\n                ans+=1\n            else :\n                break\n    else :\n        if mab==b :\n            b-=1\n            ans+=1\n        else :\n            if a>0 :\n                a-=1\n                b+=1\n                ans+=1\n            else :\n                if b>0 :\n                    ans+=1\n                    b-=1\n                else :\n                    break\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn,b,a=list(map(int,input().split()))\nS=list(map(int,input().split()))\n\nbn=b\nan=a\n\nfor i in range(n):\n    #print(bn,an)\n    if bn==0 and an==0:\n        print(i)\n        return\n    if S[i]==1 and bn>0 and an<a:\n        bn-=1\n        an+=1\n    elif an>0:\n        an-=1\n    else:\n        bn-=1\n\nprint(n)\n\n", "n,b,a = list(map(int,input().split()))\nsi = list(map(int,input().split()))\na2 = a\nans = n\nfor i in range(n):\n    if b != 0:\n        if a2 == a:\n            a2 -= 1\n        else:\n            if a2 != 0:\n                if si[i] == 1:\n                    b -= 1\n                    a2 += 1\n                else:\n                    a2 -= 1\n            else:\n                b -= 1\n                if si[i] == 1:\n                    a2 += 1\n    else:\n        if a2 == 0:\n            ans = i\n            break\n        a2 -= 1\nprint(ans)\n        \n", "n, battery, accumulator = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\nb = battery\na = accumulator\nans = 0\nfor i in range(n):\n    if a == 0 and b == 0:\n        break\n    elif s[i] == 0:\n        if a > 0:\n            a -= 1\n            ans += 1\n        else:\n            b -= 1\n            ans += 1\n    else:\n        if a == accumulator:\n            a -= 1\n            ans += 1\n        elif b > 0:\n            b -= 1\n            a += 1\n            ans += 1\n        else:\n            a -= 1\n            ans += 1\nprint(ans)\n", "n, b, a = list(map(int, input().split()))\n\n\ns = list(map(int, input().split()))\n\nb1, a1 = b, a\n\nk = 0\n\nfor c in s:\n\tif a1 == 0 and b1 == 0:\n\t\tbreak\n\t\t\n\tif c == 0:\n\t\tif a1 > 0:\n\t\t\ta1 -= 1\n\t\telif b1 > 0:\n\t\t\tb1 -= 1\n\t\telse:\n\t\t\tbreak\n\telse:\n\t\t\n\t\tif a1 != a:\n\t\t\tif b1 > 0:\n\t\t\t\tb1 -= 1\n\t\t\t\ta1 += 1\n\t\t\telif a1 > 0:\n\t\t\t\ta1 -= 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\telse:\n\t\t\ta1 -= 1\n\tk += 1\n\n\nprint(k)\n", "n, b, a = list(map(int, input().split()))\nl = list(map(int, input().split()))\naa = a\nfor i in range(n):\n\tif a == 0 and b == 0:\n\t\tprint(i)\n\t\tbreak\n\tif l[i] == 0:\n\t\tif a > 0:\n\t\t\ta -= 1\n\t\telse:\n\t\t\tb -= 1\n\tif l[i] == 1:\n\t\tif a == aa:\n\t\t\ta -= 1\n\t\telse:\n\t\t\tif b > 0:\n\t\t\t\tb -= 1\n\t\t\t\ta = min(aa, a + 1)\n\t\t\telse:\n\t\t\t\ta -= 1\n\tif i == n - 1:\n\t\tprint(n)", "n,b,a = map(int, input().split())\n\ns = list(map(int, input().split()))\n\ncb, ca = b, a\n\ni = 0\n\nwhile (cb or ca) and i < len(s):\n\n\tif s[i] == 1:\n\n\t\tif ca < a:\n\t\t\tif cb:\n\n\t\t\t\tcb -= 1\n\n\t\t\t\tca += 1\n\n\t\t\telse:\n\t\t\t\tca -= 1\n\t\telse:\n\n\t\t\tca -= 1\n\n\telse:\n\n\t\tif ca:\n\n\t\t\tca -= 1\n\n\t\telse:\n\n\t\t\tcb -= 1\n\n\ti += 1\n\nprint(i)", "n,b,a=map(int,input().split())\nl1=list(map(int,input().split()))\nmaxa=a\ndist=0\nx=0\nwhile ( b!=0 or a!=0 ) and dist<n:\n    if a==maxa:\n        a-=1\n        x+=1\n        dist+=1\n    elif l1[x]==0:\n        if a>0:\n            dist+=1\n            a-=1\n            x+=1\n        else :\n            x+=1\n            dist+=1\n            b-=1\n    else :\n        if b>0:\n            dist+=1\n            b-=1\n            a+=1\n            x+=1\n        else :\n            dist+=1\n            a-=1\n            x+=1\nprint(dist)", "n, b, a = [int(item) for item in input().split()]\ns = [int(item) for item in input().split()]\n\nmax_a = a\nans = 0\n\nrem = [0] * n\nrem[-1] = s[-1]\nfor i in range(n - 2, -1, -1):\n    rem[i] = rem[i + 1] + s[i]\n\nfor i, sun in enumerate(s):\n    # print(b, a, sun)\n    if b == 0 and a == 0:\n        break\n    if b == 0:\n        a -= 1\n    elif a == 0:\n        b -= 1\n        if sun and a < max_a:\n            a += 1\n    else:\n        if a == max_a:\n            a -= 1\n        else:\n            if sun:\n                a += 1\n                b -= 1\n            else:\n                if max_a - a < rem[i]:\n                    a -= 1\n                else:\n                    b -= 1\n\n    ans += 1\n\nprint(ans)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\n\ndef main():\n    n,b,a = get_tuple()\n    b_fuel, a_fuel = b,a\n    li = get_list()\n    for i,ele in enumerate(li):\n        if a_fuel==0 and b_fuel==0:\n            print(i)\n            return\n        if (ele==1):\n            if b_fuel>0 and a_fuel<a:\n                b_fuel-=1\n                a_fuel+=1\n            elif (b_fuel>0 and a_fuel==a) or b_fuel==0:\n                a_fuel-=1\n            else:\n                b_fuel-=1\n        else:\n            if a_fuel>0:\n                a_fuel-=1\n            else: b_fuel-=1\n\n    print(n)\n\n\n    \n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main(i) \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n,b,a=list(map(int,input().split()))\narr=list(map(int,input().split()))\narr1=[b]\nval=b\nfor i in range(1,n):\n\tif(arr[i]==1):\n\t\tval-=1\n\tarr1.append(val)\nval=b\narr2=[a-1]\nval2=a-1\nans=-1\nfor i in range(1,n):\n\tif(arr[i]==1):\n\t\tif(val>0):\n\t\t\tif(val2==a):\n\t\t\t\tval2-=1\n\t\t\telse:\n\t\t\t\tval-=1\n\t\t\t\tval2=min(val2+1,a)\n\t\telse:\n\t\t\tif(val2==0):\n\t\t\t\tans=i\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tval2-=1\n\t\t\n\telse:\n\t\tif(val2==0):\n\t\t\tif(val>0):\n\t\t\t\tval-=1\n\t\t\telse:\n\t\t\t\tans=i\n\t\t\t\tbreak\n\t\telse:\n\t\t\tval2-=1\nif(ans==-1):\n\tprint(n)\nelse:\n\tprint(ans)\n\n\n\n\n\n\n\n\n\n", "n, b, a = (int(x) for x in input().split())\ns = [int(x) for x in input().split()]\n\ncharge = a\nfor ans, t in enumerate(s):\n    if t:\n        if charge < a and b:\n            b -= 1\n            charge += 1\n        elif charge:\n            charge -= 1\n        elif b:\n            b -= 1\n        else:\n            print(ans)\n            raise SystemExit(0)\n    else:\n        if charge:\n            charge -= 1\n        elif b:\n            b -= 1\n        else:\n            print(ans)\n            raise SystemExit(0)\nprint(ans + 1)\n", "def main():\n    n, b, a = map(int, input().split())\n    cb, ca = b, a\n    p = 0\n    for s in input().split():\n        if ca == 0 and cb == 0:\n            break\n        \n        if int(s):\n            if ca < a and cb > 0:\n                ca += 1\n                cb -= 1\n            else:\n                ca -= 1\n        else:\n            if ca > 0:\n                ca -= 1\n            else:\n                cb -= 1\n        p += 1\n    \n    print(p)\n\nmain()", "import collections\n\ndef solve():\n    n,b,a=list(map(int,input().split()))\n    a_max=a\n    S=list(map(int,input().split()))\n    ans=0\n    for i in range(n):\n        #print(i,b,a)\n        if S[i]==1:\n            if a<a_max and b>0:\n                b-=1\n                a+=1\n            elif a>0:\n                a-=1\n            elif b>0:\n                b-=1\n            else:\n                return i\n        else:\n            if a>0:\n                a-=1\n            elif b>0:\n                b-=1\n            else:\n                return i\n    return n\n\nprint(solve())\n", "n,b,a=[int(x) for x in input().split()]\nsun=[int(x) for x in input().split()]\na_max=a\ncur_len=0\nfor element in sun:\n    if(b==0 and a==0):\n        break\n    else:\n        if(b>0 and a<a_max and element==1):\n            b-=1\n            a+=1\n        else:\n            if(a>0):\n                a-=1\n            else:\n                b-=1\n    cur_len+=1\nprint(cur_len)\n\n    \n", "n, b, a = list(map(int, input().split()))\nline = list(map(int, input().split()))\nb1, a1 = b, a\ndist = 0\nfor cell in line:\n    if cell == 1:\n        if a1 < a and b1 > 0:\n            b1 -= 1\n            a1 += 1\n            dist += 1\n        elif a1 > 0:\n            a1 -= 1\n            dist += 1\n        else:\n            break\n    else:\n        if a1 > 0:\n            a1 -= 1\n            dist += 1\n        elif b1 > 0:\n            b1 -= 1\n            dist += 1\n        else:\n            break\nprint(dist)\n", "n,b,a = list(map(int,input().split()))\nam = a\ns = list(map(int,input().split()))\ndist = 0\nfor i in s:\n    if i == 0:\n        if a > 0:\n            a -= 1\n            dist += 1\n        elif b > 0:\n            b -= 1\n            dist += 1\n        else:\n            break\n    else:\n        if a == am:\n            a -= 1\n            dist += 1\n        elif b > 0:\n            b -= 1\n            a += 1\n            dist += 1\n        elif a > 0:\n            a -= 1\n            dist += 1\nprint(dist)\n"]