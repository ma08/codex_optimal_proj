["import sys\n\nN, M = list(map(int, input().split()))\n\na = [False]*(N+1)\nfor i in range(M):\n    a[int(input())] = True\n\nb = [0]*(N+1)\n\nif N < 2:\n    print((1))\n    return\n\nb[-1] = 1\n\nfor i in reversed(list(range(0, N))):\n    if a[i]:\n        b[i] = 0\n        continue\n    if i == N-1:\n        b[i] = b[i+1]\n    else:\n        b[i] = (b[i+1] + b[i+2])%(10**9+7)\n\nprint((b[0]))\n\n\n\n", "N,M=map(int,input().split())\na=[0]*(N+1)\nINF=10**100\nNUM=7+10**9\ndp=[0]*(N+1)\n\nfor _ in range(M):\n    tmp=int(input())\n    a[tmp]=1\n\ndp[0]=1\nif not a[1]: dp[1]+=dp[0]\nfor i in range(2,N+1):\n    if a[i]: continue\n    dp[i]+=dp[i-1]+dp[i-2]\n    dp[i]%=NUM\n\nprint(dp[N])", "n, m = map(int, input().split())\na = [int(input()) for _ in range(m)]\n\nmod = 10**9 + 7\nc = [0]*(n+1)\nfor i in a:\n    c[i] = -1\ndp = [0]*(n+1)\ndp[0] = 1\ndp[1] = 0 if m > 0 and a[0] == 1 else 1\nfor i in range(2, n+1):\n    if c[i] == -1:\n        continue\n    dp[i] = (dp[i-1] + dp[i-2]) % mod\nprint(dp[-1])", "N, M, *A = list(map(int, open(0).read().split()))\nAset=set(A)\nmod=10**9+7\nnum=[0]*(N+1)\nfor i in range(2):\n    if not i in Aset:\n        num[i]+=1\nfor i in range(2,N+1):\n    if i in Aset:\n        num[i]=0\n    else:\n        num[i]+=num[i-1]+num[i-2]\n        num[i]%=mod\nprint((num[-1]%mod))\n", "n, m = list(map(int, input().split()))\na = set(list(int(input()) for i in  range(m)))\n\np = 10**9+7\ndp = [0]*(n+1)\ndp[0] = 1\n\nfor i in range(1, n+1):\n    dp[i] = (dp[i-1] + dp[i-2])%p\n    if i in a:\n        dp[i] = 0\nprint((dp[n]))\n\n", "n, m = map(int,input().split())\nbroken = [False] * (n+1)\nfor _ in range(m):\n  i = int(input())\n  broken[i] = True\n\ndp = [0] * (n+1)\ndp[0] = 1\nmod = 1000000007\n\nfor i in range(1, n+1):\n  if broken[i]: continue\n  if i == 1:\n    dp[1] = 1\n    continue\n  dp[i] = dp[i - 1] + dp[i - 2]\n\nprint(dp[n] % mod)", "INF = 10 ** 9 + 7\n\nN, M = map(int, input().split())\na = [int(input()) for _ in range(M)]\ndp = [0] * (N + 1)\nfor i in range(M):\n    dp[a[i]] = -1\n\ndp[0] = 1\nfor i in range(1, N + 1):\n    if dp[i] == -1: continue\n    tmp = 0\n    if dp[i - 1] != -1:\n        tmp += dp[i - 1]\n    if dp[i - 2] != -1 and i > 1:\n        tmp += dp[i - 2]\n    dp[i] = tmp % INF\n\nprint(dp[N])", "N,M=map(int,input().split())\nA=set([int(input()) for _ in range(M)])\nmod=10**9+7\n\ndp=[0]*(N+1)\ndp[0]=1\n\nif 1 not in A:dp[1]=1\nelse:dp[1]=0\n\n#DP\nfor i in range(2,N+1):\n  if i in A:\n    continue\n  dp[i]=dp[i - 1] + dp[i - 2]\n  dp[i]%=mod\nprint(dp[N])", "N,M=map(int,input().split())\nA = [0]*(N+1)\n\nfor _ in range(M):\n  a = int(input())\n  A[a] = 1\n\n#\u521d\u671f\u5316\ndp=[0]*(N+1)\ndp[0] = 1\nif A[1] == 0:\n  dp[1] = 1\n\n#dp\nfor i in range(2,N+1):\n  if A[i] == 0:\n    dp[i] = dp[i-1] + dp[i-2]\n      \nprint(dp[N]%1000000007)", "n,m = map(int,input().split())\na = [int(input()) for _ in range(m)]\naset = set(a)\nmod = 10**9+7\ndp = [0]*(n+1)\ndp[0] = 1\nfor i in range(1,n+1):\n    if i in aset:\n        continue\n    dp[i] = (dp[i-1]+dp[i-2])%mod\nprint(dp[n]%mod)", "def main():\n    N, M = [int(i) for i in input().split()]\n\n    pos = 0\n    ans = 1\n\n    fib = [1 for _ in range(N+1)]\n    for i in range(2, N+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    for _ in range(M):\n\n        a = int(input())\n\n        if a == pos:\n            ans = 0\n            pos = N\n            break\n        elif a == pos + 1:\n            pos = a + 1\n        else:\n            ans *= fib[(a - 1 - pos)]\n            pos = a + 1\n\n    if pos + 1 < N:\n        ans *= fib[(N - pos)]\n\n    print(ans % 1_000_000_007)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nmod = 1000000007\nN, M = map(int, input().split())\na = np.array([int(input()) for _ in range(M)])\n\ndp = np.full(N+1, -1)\ndp[0] = 1\nindex = 0 # a\u3092\u9806\u306b\u8d70\u67fb\u3059\u308b\u305f\u3081\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\nfor i in range(1, N+1):\n    if index < M and i == a[index]: # \u58ca\u308c\u3066\u3044\u308b\u5834\u5408\n        dp[i] = 0\n        index += 1\n    else: # \u58ca\u308c\u3066\u3044\u306a\u3044\u5834\u5408\n        dp[i] = dp[i-1]\n        if i >= 2:\n            dp[i] += dp[i-2]\n        dp[i] %= mod\n\nprint(dp[N])", "\nurl = \"https://atcoder.jp//contests/abc129/tasks/abc129_c\"\n\ndef main():\n    n, m = list(map(int, input().split()))\n    isbreak = [False] * (n+1)\n    for _ in range(m):\n        isbreak[int(input())] = True\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(i+1, min(i+3, n+1)):\n            if not isbreak[j]:\n                dp[j] += dp[i]\n                dp[j] %= 1000000007\n    print((dp[-1]))\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = map(int, input().split())\n\n# issafe => 0\u6bb5\u76ee\u304b\u3089N\u6bb5\u76ee\u307e\u3067, \u5b89\u5168\u306a\u3089True, \u58ca\u308c\u3066\u3044\u308b\u306a\u3089False\nissafe = [1] * (N+1)\nfor i in range(M):\n  a = int(input())\n  issafe[a] = 0\n\n# dp => 0\u6bb5\u76ee\u304b\u3089N\u6bb5\u76ee\u307e\u3067, \u305d\u306e\u79fb\u52d5\u65b9\u6cd5\u306e\u6570\ndp = [0] * (N+1)\ndp[0] = 1\nif issafe[1]: dp[1] = 1\nfor i in range(2, N+1):\n  if issafe[i-1]: dp[i] += dp[i-1]\n  if issafe[i-2]: dp[i] += dp[i-2]\n  dp[i] %= 10**9+7\n    \nprint(dp[N])", "n, m = map(int, input().split())\na = [int(input()) for _ in range(m)]\n\nmod = 10**9+7\na.append(float('INF'))\na = a[::-1]\ndp = [0] * (n+1)\ndp[0] = 1\nif a[-1] != 1:\n    dp[1] = 1\nelse:\n    a.pop()\nfor i in range(2, n+1):\n    if i == a[-1]:\n        a.pop()\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n    dp[i] %= mod\nprint(dp[n])", "N,M = map(int,input().split())\nStlist = [1]*N\nfor i in range(M):\n    breakstair = int(input())\n    Stlist[breakstair-1] = 0\nComb = [1,2]\nif N == 1:\n    Comb = Stlist\nelse:\n    if Stlist[0] == 0:\n        Comb[0] = 0\n        Comb[1] = 1\n    if Stlist[1] == 0:\n       Comb[1] = 0\n    for i in range(2,N):\n        Comb.append((Comb[i-1] + Comb[i-2])%(10**9+7))\n        if Stlist[i] == 0:\n            Comb[i] = 0\nprint(Comb[-1])", "n,m=map(int,input().split())\na=set([int(input()) for i in range(m)])\ndp=[0]*(10**5+5)\ndp[0]=1\nfor i in range(1,n+1):\n  if i not in a:\n    dp[i]=dp[i-1]+dp[i-2]\n    dp[i]%=(10**9+7)\nprint(dp[n])", "n, m = map(int, input().split())\ndp = [0]*(n+2)\ndp[0] = 1\nfor i in range(m):\n  dp[int(input())] = -1\n\nfor i in range(n):\n  if dp[i] >= 0:\n    if dp[i+1] >= 0:\n      dp[i+1] += dp[i]\n    if dp[i+2] >= 0:\n      dp[i+2] += dp[i]\n\nprint(dp[n] % 1000000007)", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\n\nbroken = set([int(readline()) for i in range(M)])\n\ndp = [0] * (N + 1)\ndp[0] = 1\nif 1 not in broken:\n  dp[1] = 1\n  \nDIV = 10 ** 9 + 7\n\nfor i in range(2, N + 1):\n  if i in broken:\n    continue\n  dp[i] = dp[i - 2] + dp[i - 1]\n  dp[i] %= DIV\n  \nprint(dp[N])", "n, m = list(map(int, input().split()))\na = [int(input()) for _ in range(m)]\ndp = [0] * n\nfor i in a:\n    dp[i-1] = -1\nif n == 1:\n    if dp[0] == 0:\n        print((1))\n        return\n    elif dp[0] == -1:\n        print((0))\n        return\nif dp[1] >= 0 and dp[0] >= 0:\n    dp[0] = 1\n    dp[1] = 2\nelif dp[1] == -1 and dp[0] >= 0:\n    dp[0] = 1\nelif dp[1] >= 0 and dp[0] == -1:\n    dp[1] = 1\nelse:\n    print((0))\n    return\nfor j in range(2, n):\n    if dp[j] >= 0:\n        if dp[j-1] >= 0 and dp[j-2] >= 0:\n            dp[j] = dp[j-1] + dp[j-2]\n        elif dp[j-1] == -1 and dp[j-2] >= 0:\n            dp[j] = dp[j-2]\n        elif dp[j-1] >= 0 and dp[j-2] == -1:\n            dp[j] = dp[j-1]\n        else:\n            print((0))\n            return\nprint((dp[n-1] % (10**9+7)))\n", "n, m = list(map(int, input().split()))\nL = [False]*(n+1)\n\nfor _ in range(m):\n    a = int(input())\n    L[a] = True\n\ndp = [0]*(n+1)\ndp[0] = 1\nMOD = 1000000007\n\nfor i in range(1, n+1):\n    if L[i]:\n        continue\n    if i == 1:\n        dp[1] = 1\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint((dp[n] % MOD))\n", "#!/usr/bin/env python3\ndef main():\n    N, M = list(map(int, input().split()))\n    A = set([int(input()) for x in range(M)])\n\n    mod = 10 ** 9 + 7\n    dp = [0] * 10 ** 6\n    dp[0] = 1\n    for i in range(N + 1):\n        if i in A:\n            continue\n        dp[i + 1] += dp[i] % mod\n        dp[i + 2] += dp[i] % mod\n    print((dp[N] % mod))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int,input().split())\nlsS = [1,1]+[0]*(N-1)\nfor i in range(M):\n    lsS[int(input())] = -1\nfor i in range(2,N+1):\n    if lsS[i] == -1:\n        continue\n    else:\n        if lsS[i-2] != -1:\n            lsS[i] += lsS[i-2]\n        if lsS[i-1] != -1:\n            lsS[i] += lsS[i-1]\n        lsS[i] = lsS[i]%(10**9+7)\nprint(lsS[N])", "import sys\ninput = lambda: sys.stdin.readline().strip()\nn, m = [int(x) for x in input().split()]\ncan = [True for i in range(n + 1)]\nfor i in range(m):\n    ai = int(input())\n    can[ai] = False\nC = [0 for i in range(n + 1)]\nfor i in range(n + 1):\n    if i == 0:\n        C[i] = 1\n    else:\n        C[i] = sum(C[j] if j >= 0 and can[j] else 0 for j in (i - 1, i - 2)) % (10**9 + 7)\nprint(C[n])", "n, m = list(map(int, input().split()))\nbroken = [False] * (n + 1)\nfor _ in range(m):\n    broken[int(input())] = True\n\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = 1 if not broken[1] else 0\nMOD = 10 ** 9 + 7\n\nfor i in range(2, n + 1):\n    if not broken[i - 1]:\n        dp[i] += (dp[i - 1])\n    if not broken[i - 2]:\n        dp[i] += (dp[i - 2])\n    dp[i] %= MOD\n\nprint((dp[n]))\n", "N, M = list(map(int, input().split()))\na_s = set([int(input()) for _ in range(M)])\n\nmod = 10 ** 9 + 7\nans = [0] * (N + 1)\nans[0] = 1\n\nfor i in range(1, N + 1):\n    if i - 1 not in a_s:\n        ans[i] = ans[i - 1]\n    if i > 1:\n        if i - 2 not in a_s:\n            ans[i] += ans[i - 2]\n    if i - 1 in a_s and i - 2 in a_s:\n        break\n    else:\n        ans[i] = ans[i] % mod\n\nprint((ans[-1]))\n", "n,m=map(int,input().split())\ndp=[0]*(n+1)\nfor _ in range(m):\n  a=int(input())\n  dp[a]=-1\ndp[0]=1\nfor i in range(0,n):\n  if dp[i] < 0:\n    continue\n  dp[i]%=1000000007\n  if dp[i+1] >= 0:\n    dp[i+1] += dp[i]\n  if i!=(n-1):\n    if dp[i+2] >= 0:\n      dp[i+2] += dp[i]\nprint(dp[n]%1000000007)", "#!/usr/bin/env python3\n\n#import\n#import math\n#import numpy as np\nN, M = list(map(int, input().split()))\nA = [int(input()) for _ in range(M)]\n\ndp = [0] * (N + 1)\ndp[0] = 1\n\nsafe = []\nfor i in range(1, N + 1):\n    if len(A) != 0:\n        if A[0] == i:\n            A.pop(0)\n            continue\n\n    safe.append(i)\n\nfor s in safe:\n    for i in range(1, 3):\n        if s - i >= 0:\n            dp[s] += dp[s - i]\n    dp[s] %= 10 ** 9 + 7\n\nprint((dp[N]))\n", "MOD = 10**9 + 7\nN, M = map(int, input().split())\ndp = [0]*(N+1)\nfor _ in range(M):\n  dp[int(input())] = -1\ndp[0] = 1\n\nfor i in range(N+1):\n  if dp[i] == -1:\n    continue\n  if i+1 <= N and dp[i+1] != -1:\n    dp[i+1] = (dp[i+1] + dp[i]) % MOD\n  if i+2 <= N and dp[i+2] != -1:\n    dp[i+2] = (dp[i+2] + dp[i]) % MOD\nprint(dp[N])", "def main3():\n    N, M = map(int, input().split())\n    ng_step = set([int(input()) for _ in range(M)])\n\n    dp = [0 for i in range(N + 1)]\n    dp[0] = 1\n\n    if 1 in ng_step:\n        dp[1] = 0\n    else:\n        dp[1] = 1\n\n    for i in range(2, N + 1):\n        if i in ng_step:\n            dp[i] = 0\n        else:\n            dp[i] = dp[i - 1] + dp[i - 2] \n    \n    print(dp[N] % (10**9 + 7))\n\ndef __starting_point():\n    main3()\n__starting_point()", "n, m = map(int, input().split())\nal = [0]*(n+2)\nfor _ in range(m):\n    al[int(input())] += 1\ndp = [0]*(n+2)\ndp[0] = 1\nfor i in range(n):\n    if al[i] != 0:\n        continue\n    else:\n        dp[i+1] += dp[i]\n        dp[i+2] += dp[i]\n\n# print(dp)\nprint(dp[n]%(10**9+7))", "n, m = map(int, input().split())\nmod = pow(10, 9) + 7\ndp = [0] * (n + 5)\nfor _ in range(m):\n    a = int(input())\n    dp[a] = -1\ndp[0] = 1\nfor i in range(n):\n    if not dp[i] == -1:\n        dp[i] %= mod\n    else:\n        continue\n    if not dp[i + 1] == -1:\n        dp[i + 1] += dp[i]\n    if not dp[i + 2] == -1:\n        dp[i + 2] += dp[i]\nans = dp[n] % mod\nprint(ans)", "N,M=map(int,input().split())\na=[0]\nfor i in range(0,M):\n    a.append(int(input()))\na.append(N+1)\nb=[0]*(N+2)\nb[0]=0\nb[1]=1\nfor j in range(0,M+1):\n    for i in range(a[j]+2,a[j+1]+1):\n        b[i]=(b[i-1]+b[i-2])%1000000007\n\nprint(b[N+1])", "n, m = list(map(int, input().split()))\nA = []; broken = [True] * n\nfor i in range(m):\n    a = int(input())\n    A.append(a)\n    broken[a] = False \ndp = [0] * (n+1)\ndp[0] = 1\nmod = 10**9 + 7\nfor i in range(1, n+1):\n    if broken[i-1] :\n        dp[i] += dp[i-1]\n    if i >= 2 and broken[i-2] :\n        dp[i] += dp[i-2]\n    dp[i] %= mod\nprint((dp[n]))\n    \n\n", "n,m = map(int ,input().split())\na = set([int(input()) for _ in range(m)])\n\nmod = 10**9+7\nans = [0]*(n+1)\nans [0] = 1\nif 1 not in a: ans[1] = 1\n\nfor i in range(2,n+1):\n  if i in a: continue\n  ans[i] = ans[i-1] + ans[i-2]\nprint(ans[-1]%mod)", "n,m = map(int, input().split())\na = set()\nfor _ in range(m):\n  a.add(int(input()))\n\nDP = [None]*100001\nDP[0] = 1\nif 1 in a:\n  DP[1] = 0\nelse:\n  DP[1] = 1\n\ndef stairs(n):\n  for i in range(2, n+1):\n    DP[i] = DP[i-1] + DP[i-2]\n    if i in a:\n      DP[i] = 0\n    DP[i] %= 10**9+7\n  return DP[n]\n\nprint(stairs(n))", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 13 12:06:59 2020\n\n@author: liang\n\"\"\"\n\n\nkey = 10**9 + 7\nN, M = map(int, input().split())\n\nA = [int(input()) for _ in range(M)]\nA.sort()\nA += [-1]\n\ndef solve():\n    steps = list()\n    count = 0\n    index = 0\n    #\u6bb5\u5dee\u6570\u3048\n    for i in range(N+1):\n        if i == A[index]:\n            if count == 0:\n                return 0\n            else:\n                steps.append(count)\n                count = 0\n                if index < M:\n                    index += 1\n        else:\n            count += 1\n    else:\n         steps.append(count)\n         count = 0\n        \n    smax = max(steps)\n    fibs = [0] * smax\n    #fib\u30c6\u30fc\u30d6\u30eb\u751f\u6210 O(n)\n    for i in range(smax):\n        if i == 0 or i == 1:\n            fibs[i] = 1\n        else:\n            fibs[i] = fibs[i-1] + fibs[i-2]  \n    else:\n        ans = 1\n        for s in steps:\n            #print(s)\n            ans *= fibs[s-1]\n            #print(ans)\n            ans %= key\n    #print(A)\n    #print(steps)\n    #print(fibs)\n    return ans\n\nans = solve()        \nprint(ans)", "n,m=map(int,input().split())\na=[int(input()) for i in range(m)]\nd=[1]*(n+1)\nfor i in range(m):\n  d[a[i]]=0\nfor i in range(2,n+1):\n  if d[i]!=0:\n    d[i]=d[i-1]+d[i-2]\nprint(d[n]%(10**9+7))", "n, m = map(int,input().split())\nbroken = set()\nstairs = [0]*(n+2)\nstairs[n] = 1\n\nfor _ in range(m):\n    a = int(input())\n    broken.add(a)\n\nfor j in range(n):\n    if n-1-j in broken:\n        continue\n    stairs[n-1-j] = stairs[n-j]+stairs[n+1-j]\n\nprint(stairs[0]%1000000007)", "n,m = map(int,input().split())\ndp = [0]*(n+1)\ndp[0],dp[1] = 1,1\n\nfor _ in range(m):\n  a = int(input())\n  dp[a] = -1\n\nfor i in range(0,n-1):\n  if dp[i+2]==-1:\n    continue\n  if dp[i]==-1 and dp[i+1]==-1:\n    dp[i+2] = -1\n  elif dp[i]==-1:\n    dp[i+2] = dp[i+1]\n  elif dp[i+1]==-1:\n    dp[i+2] = dp[i]\n  else:\n    dp[i+2] = dp[i] + dp[i+1]\n\nprint(dp[n]%(10**9+7) if dp[n]!=-1 else 0)", "N, M = map(int, input().split())\na = set([int(input()) for _ in range(M)])\nINF = 1000000007\n\ndp = [0] * (N + 1)\ndp[0] = 1\nif 1 not in a:\n\tdp[1] = 1\nelse:\n\tdp[1] = 0\nfor i in range(2, N + 1):\n\tif i in a:\n\t\tcontinue\n\tdp[i] = dp[i - 1] + dp[i - 2]\n\tdp[i] %= INF\n\nprint(dp[N])", "n,m=map(int,input().split())\na=[int(input()) for i in range(m)]\nd=[1]*(n+1)\nfor i in range(m):\n  d[a[i]]=0\nfor i in range(2,n+1):\n  if d[i]!=0:\n    d[i]=d[i-1]+d[i-2]\nprint(d[n]%(10**9+7))", "n,m = list(map(int,input().split()))\nMOD=1000000007\n\ndp=[0]*(n+1)\ndp[0]=1\n\nfor _ in range(m):\n    dp[int(input())]=-1\n\nfor i in range(n+1):\n    if dp[i]==-1:\n        continue\n\n    if i+1<=n and dp[i+1]!=-1:\n        dp[i+1]=(dp[i+1]+dp[i])%MOD\n    if i+2<=n and dp[i+2]!=-1:\n        dp[i+2]=(dp[i+2]+dp[i])%MOD\n\nprint((dp[-1]))\n", "n, m = list(map(int, input().split()))\na = []\nfor i in range(m):\n    a.append(int(input()))\n\nmod = 1000000007\n\nmemo = [-1]*(n+1)\nmemo[0] = 0\n\nfor k in range(m):\n    memo[a[k]] = 0\n\nfor i in range(1, n+1):\n    if memo[i] != -1:\n        pass \n    elif i <= 2:\n        memo[i] = memo[i-1] + 1\n    else:\n        memo[i] = memo[i-1] + memo[i-2]\nprint(memo[-1]%mod)", "n,m=map(int,input().split())\na1=0\nans=1\nfor i in range(m+1):\n    if i==m:\n        a2=n+1\n    else:\n        a2=int(input())\n    l=a2-a1\n    if l==0:\n        print(0)\n        return\n    if l>2:\n        fst=1\n        snd=1\n        for _ in range(l-2):\n            nfst=snd\n            snd=fst+nfst\n            fst=nfst\n        ans*=snd\n    a1=a2+1\nprint(ans%(10**9+7))", "import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    N, M = MI()\n    L = set([I() for i in range(M)])\n    mod = 1000000007\n    D = [0]*(N+2)\n    D[1]=1\n    \n    for i in range(1, N+1):\n        if not i in L:\n            D[i+1] = (D[i]+D[i-1]) % mod\n\n    print(D[N+1]%mod)\n    \n    \ndef __starting_point():\n    main()\n__starting_point()", "N,M = map(int, input().split())\nA = [int(input()) for _ in range(M)]\n\nmod = 10**9 + 7\n\ndp = [1] * (N+1)\n\nfor i in A:\n    dp[i] = 0\n\nfor i in range(2, N+1):\n        dp[i] *= (dp[i-1] + dp[i-2]) % mod\n\nprint(dp[-1])", "N,M = list(map(int, input().split()))\n\nA = set([int(input()) for _ in range(M)])\n\nlis = [0]*(N+1)\nlis[0] = 1\n\n\nfor i in range(1,N+1):\n    lis[i] = (lis[i-1] + lis[i-2])%(10**9+7)\n    if i in A:\n        lis[i] = 0\n\nprint((lis[N]))\n", "n,m = map(int,input().split())\nl = set([int(input()) for i in range(m)])\nc = [0]*(n+1)\nc[0]=1\nc[1]=1\nif 1 in l:\n  c[1]=0\nfor i in range(2,n+1):  \n  if i in l:\n    c[i] = 0 \n  else:\n    c[i] = (c[i-1]+c[i-2])%1000000007\nprint(c[n])", "N, M = map(int, input().split())\nMOD = 10 ** 9 + 7\ns = 0\n\ndef comb(n, k):\n  if k > n - k:\n    k = n - k\n  de = 1\n  nu = 1\n  for i in range(k):\n    de *= (n - i)\n    de = de % MOD\n    nu *= (i + 1)\n    nu = nu % MOD\n  nu = pow(nu, -1, MOD)\n  return (de * nu) % MOD\n\ndef calc_from_step(step):\n  temp = 0\n  for i in range(1 + (step // 2)):\n    temp += comb(step-i, i)\n  return temp\n\n\narr = [1, 1]\nsteps = []\nstep = 0\ns = 0\nfor i in range(M):\n  l = int(input()) - 1\n  steps.append(l-s)\n  if s > l:\n    print(0)\n    return\n  if step < l - s:\n    step = l - s\n  s = l + 2\nl = N\nsteps.append(l-s)\nif step < l - s:\n  step = l - s\n\nfor i in range(step - 1):\n  arr.append((arr[i] + arr[i+1])%MOD)\nans = 1\n\nfor i in steps:\n  ans *= arr[i]\n  ans = ans % MOD\nprint(ans)", "def f():\n    n, m = map(int, input().split())\n    a = [int(input()) for _ in range(m)]\n    for i in range(m-1):\n        if a[i] + 1 == a[i+1]:\n            return 0\n    mod = 10**9 + 7\n    x = [1]*(n+1)\n    for j in a:\n        x[j] = 0\n    for k in range(2, n+1):\n        if x[k] == 1:\n            x[k] = (x[k-1] + x[k-2])%mod\n    return x[n]\nprint(f())", "n,m = map(int, input().split())\nans = [0] * (n + 1)\nans[0] = 1\np = 10 ** 9 + 7\nfor i in range(m):\n  ans[int(input())] = -1\n\nif ans[1] != -1:\n  ans[1] = 1\n\nfor i in range(2, n + 1):\n  if ans[i] == -1:\n    continue\n  ans[i] = max(ans[i - 1], 0) + max(ans[i - 2], 0)\n  ans[i] %= p\nprint(ans[n])", "#import math\n#import itertools\n#import numpy as np\n#from collections import deque\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\n#INF = 10 ** 9\n#PI = 3.14159265358979323846\n\nINT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\ndef do():\n    n,m=INTM()\n    b_sts=[False]*n\n    for i in range(m):\n        b=INT()\n        b-=1\n        b_sts[b]=True\n        \n    step=[0]*(n+2)\n    step[1]=1\n    for i in range(n):\n        if b_sts[i]:\n            continue\n        else:\n            step[i+2]=(step[i+1]+step[i])%MOD\n    print(step[-1]%MOD)\n\ndef __starting_point():\n    do()\n__starting_point()", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 13 12:37:37 2020\n\n@author: liang\n\"\"\"\n\n\"\"\"\n\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u751f\u6210\n\u3010DP(?)\u3011\u3000: \u914d\u5217\u3092\u4f7f\u7528\u3059\u308b\u3053\u3068\u3067\u8a08\u7b97\u91cf\u304c\u7206\u767a\u3059\u308b\u306e\u3092\u9632\u3050\n\u3010\u5c0f\u3055\u3044\u3082\u306e\u304b\u3089\u8a08\u7b97\u3059\u308b\u3011\u306e\u539f\u5247\n\n\u3010\u65b9\u91dd\u3011\n\u3000\u901a\u5e38\u306e\u914d\u5217\u3092\u7528\u3044\u305f\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u751f\u6210\u65b9\u6cd5\u306e\u5fdc\u7528\u7248\n \u58ca\u308c\u305f\u968e\u6bb5\u306e\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u5024\u3092\u30000 \u306b\u3059\u308b\u3053\u3068\u3067\u3001\u5b9f\u8cea\u9077\u79fb\u3092\u6b62\u3081\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u3002\n\"\"\"\nkey = 10**9 + 7\nN, M = map(int, input().split())\nA = [int(input()) for _ in range(M)]+[-1]\n\nfibs = [0]*(N+1)\nindex = 0\nfor i in range(N+1):\n    #\u58ca\u308c\u305f\u3068\u3053\u308d\u306e\u5024\u30920\u306b\u3059\u308c\u3070\u826f\u3044\n    if i == A[index]:\n        fibs[i] = 0\n        index += 1\n    elif i == 0 or i == 1:\n        fibs[i] = 1\n    else:\n        fibs[i] = (fibs[i-1] + fibs[i-2])%key\n        \n\nprint(fibs[N])", "n, m = list(map(int, input().split()))\na = set(list(int(input()) for _ in range(m)))\nmod = 1000000007\n\nmemo = [0]*(n+1)\nmemo[0] = 1\n\n\nfor i in range(1, n+1):\n    memo[i] = memo[i-1] + memo[i-2]\n    if i in a:\n        memo[i] = 0\n\nprint((memo[-1]%mod))\n", "N, M = map(int, input().split())\nA = [True]*N\nfor _ in range(M):\n  a = int(input())\n  A[a-1] = False # \u58ca\u308c\u3066\u308b\u3068\u3053\u308d\u306ffalse\n\nwaru = 10**9 + 7\ndp = [0]*(N+1)\n\ndp[0], dp[1] = 1, 1 # \u521d\u671f\u6761\u4ef6\nif not A[0]: # 1\u6bb5\u76ee\u304c\u58ca\u308c\u3066\u305f\u3089\n  dp[1] = 0\n\nfor i in range(2,N+1):\n  # \u58ca\u308c\u3066\u308b\u3068\u3053\u308d\u306fdp=0\u306b\u3059\u308b\n  if not A[i-1]:\n    dp[i] = 0\n  else:\n    dp[i] = (dp[i-1] + dp[i-2])%waru\nprint(dp[-1])", "n, m = list(map(int, input().split()))\na = list(int(input()) for _ in range(m))\n\nMOD = 10**9 + 7\nis_broken = [0] * (n+1)\ndp = [0] * (n+1)\ndp[0] = 1\n\nfor x in a:\n    is_broken[x] = 1\n\nfor i in range(n):\n    for j in range(i+1, min(n, i+2) + 1):\n        if not is_broken[j]:\n            dp[j] += dp[i]\n            dp[j] %= MOD\n\nprint((dp[n]))\n", "n, m = map(int, input().split())\nans = [0] * (n + 1)\np = 10 ** 9 + 7\nans[0] = 1\nfor i in range(m):\n  ans[int(input())] = -1\n\nif ans[1] != -1:\n  ans[1] = 1\n  \nfor i in range(2, n + 1):\n  if ans[i] == -1:\n    continue\n  ans[i] = max(ans[i - 1], 0) + max(ans[i - 2], 0)\n  ans[i] %= p\nprint(ans[n] % p)", "import sys\nmod=10**9+7 ; inf=float(\"inf\")\nfrom math import sqrt, ceil\nfrom collections import deque, Counter, defaultdict #\u3059\u3079\u3066\u306ekey\u304c\u7528\u610f\u3055\u308c\u3066\u308b defaultdict(int)\u3067\u521d\u671f\u5316\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright\n#\u30e1\u30e2\u5316\u518d\u5e30def\u306e\u5192\u982d\u306b\u6bce\u56de @lru_cache(maxsize=10**10)\n#\u5f15\u6570\u306blist\u306f\u3060\u3081\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\nn,m=list(map(int,input().split()))\nA=[int(input()) for i in range(m)]\nNG=[0]*(10**5+10)\nfor i in A:\n    NG[i]=1\n\n\n@lru_cache(maxsize=10**10)\ndef qwe(x):\n    if x==n:return 1\n    if x>n:return 0\n    if NG[x+1] and NG[x+2]: print((0));return\n    if NG[x+1]:return qwe(x+2)%mod\n    if NG[x+2]:return qwe(x+1)%mod\n    return (qwe(x+2)+qwe(x+1))%mod\nprint((qwe(0)))\n    \n", "n,m = map(int,input().split())\na = set([int(input()) for _ in range(m)])\nstep = [0] * (n+1)\nstep[0] = 1\nif 1 not in a:\n    step[1] = 1\nelse:\n    step[1] = 0\nfor i in range(2,n+1):\n    if i in a:\n        continue\n    step[i] = (step[i-1] + step[i-2]) % 1000000007\nprint(step[-1])", "n,m=map(int,input().split())\na=[int(input()) for i in range(m)]+[-1]\ndp=[0]*(10**5+5)\n\ndp[0],idx=1,0\n  \nfor i in range(1,n+1):\n  if a[idx]==i:\n    idx+=1\n    dp[i]=0\n    if dp[i-1]==0: # continuous case\n      print(0)\n      return\n  else:\n    dp[i]+=dp[i-1]+dp[i-2]\n    dp[i]%=(10**9+7)\n    \nprint(dp[n])", "N, M = map(int, input().split())\n \n# issafe => 0\u6bb5\u76ee\u304b\u3089N\u6bb5\u76ee\u307e\u3067, \u5b89\u5168\u306a\u3089True, \u58ca\u308c\u3066\u3044\u308b\u306a\u3089False\nissafe = [1] * (N+1)\nfor i in range(M):\n  a = int(input())\n  issafe[a] = 0\n\n# \u52d5\u7684\u8a08\u753b\u6cd5\uff08\u6f38\u5316\u5f0f\uff09\n# dp => 0\u6bb5\u76ee\u304b\u3089N\u6bb5\u76ee\u307e\u3067, \u305d\u306e\u79fb\u52d5\u65b9\u6cd5\u306e\u6570\ndp = [0] * (N+1)\ndp[0] = 1\nif issafe[1]: dp[1] = 1\nfor i in range(2, N+1):\n  if issafe[i-1]: dp[i] += dp[i-1]\n  if issafe[i-2]: dp[i] += dp[i-2]\n  dp[i] %= 10**9+7\n    \nprint(dp[N])", "n,m = map(int,input().split())\na = set([int(input()) for _ in range(m)])\nmod = 10**9+7\nfl = [0]*(n+1)\nfl[0] = 1\n\nfor i in range(1,n+1):\n    if i not in a:\n        fl[i] = (fl[i-1] + fl[i-2])%mod\n    else:\n        fl[i] = 0\nprint(fl[-1])", "N, M = map(int, input().split())\n# 0\u6bb5\u76ee\u304b\u3089N\u6bb5\u76ee\u307e\u3067\u3001\u58ca\u308c\u3066\u3044\u308b\u304b\u5426\u304b\u3092\u8868\u3059 flag\nissafe = [1] * (N+1)\nfor i in range(M):\n  a = int(input())\n  issafe[a] = 0\n\nmod = 10**9 + 7\n\n# 0\u6bb5\u76ee\u304b\u3089N\u6bb5\u76ee\u307e\u3067\u306e\u79fb\u52d5\u65b9\u6cd5\u306e\u6570\ndp = [0] * (N + 1)\ndp[0] = 1\nif issafe[1]: dp[1] = 1\n# \u6f38\u5316\u5f0f\u306b\u5f93\u3063\u3066\u8a08\u7b97\u3059\u308b\nfor i in range(2, N + 1):\n  if issafe[i-1]: dp[i] += dp[i-1]\n  if issafe[i-2]: dp[i] += dp[i-2]\n  dp[i] %= mod\n  \nprint(dp[N])", "#96 C - Typical Stairs\nN,M = map(int,input().split())\nA = [int(input()) for _ in range(M)]\nA = set(A)\nMOD = 1000000007\n\ndp = [0]*(N+1)\ndp[0] = 1\nfor i in range(1,N+1):\n    if i in A:\n        continue\n    dp[i] = (dp[i-1] + dp[i-2])%MOD\nprint(dp[N])", "n, m = map(int,input().split())\na = list(int(input()) for _ in range(m))\ndp = [[] for _ in range(n + 1)]\ndp[0] = 1\n# j = 0\nif m == 0:\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\n    print(dp[n])\n    return\nif a[0] == 1:\n    dp[1] = 0\n    j = 1\nelse:\n    dp[1] = 1\n    j = 0\nfor i in range(2, n + 1):\n    # print(i, dp)\n    if j < m:\n        if a[j]  == i:\n            dp[i] = 0\n            j += 1\n            continue\n    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\nprint(dp[n])", "MOD=1000000007\nN,M=list(map(int,input().split()))\ncnt=[0 for _ in range(N+1)]\ncnt[0]=1\nfor _ in range(M):\n    a=int(input())\n    cnt[a]=-1\nfor i in range(1,N+1):\n    if cnt[i]==-1:\n        cnt[i]=0\n        continue\n    if i==1:\n        cnt[i]=cnt[i-1]\n    else:\n        cnt[i]=(cnt[i-1]+cnt[i-2])%MOD\nprint((cnt[N]))\n", "N,M = map(int,input().split())\nA = [int(input()) for i in range(M)]\nn = 0\nif M != 0:\n    a = b = A[0]\nelse:\n    a = b = -2\nc = 0\nans = [0,1]\nfor i in range(1,N+1):\n    if  i == a:\n        c = 0\n        n += 1\n        b = a\n        if n <= M-1:\n            a = A[n]\n    elif i-2 == b:\n        c = ans[-1]\n    elif i-1 == b :\n        c = ans[-2]\n    else:\n        c  = ans[-1] + ans[-2]\n    c %= 10**9 + 7\n    ans.append(c)\nprint(ans[-1])", "import numpy as np\nN,M=map(int,input().split())\nA=set([int(input()) for _ in range(M)])\n\nmod=10**9+7\n\ndp=np.zeros(N+1)\ndp[0]=1\nif 1 not in A:\n    dp[1]=1\nelse:\n    dp[1]=0\n\nfor i in range(2,N+1):\n    if i in A:\n        continue\n    dp[i]=dp[i-1]+dp[i-2]\n    dp[i]%=mod\n\nprint(int(dp[N]))", "n,m = map(int,input().split())\ns = [0]*n\ndp = [0]*(n+1)\nfor i in range(m):\n    s[int(input())-1] = 1\ndp[0] = 1\nif s[0] == 1:\n    dp[1] = 0\nelse:\n    dp[1] = 1\nfor i in range(2,n+1):\n    if s[i-1] == 1:\n        dp[i] = 0\n    else:\n        dp[i] = dp[i-1]+dp[i-2]\nprint(dp[n]%1000000007)", "N, M = [int(i) for i in input().split()]\nAS = {int(input()) for _ in range(M)}\n\nt = [1, 1 if 1 not in AS else 0]\nfor i in range(2, N+1):\n#  print(t)\n  if i in AS:\n    t.append(0)\n    continue\n  t.append(t[i-2] + t[i-1])\n\n#print(t)\nprint((t[N] % 1000000007))\n", "def solve(N, a):\n    mod = 10**9 + 7\n    dp = [0] * (N+1)\n    step = [0] * (N+1)\n    for aa in a:\n        step[aa] = 1\n\n    dp[0] = 1\n    if step[1] == 0:\n        dp[1] = 1\n\n    for i in range(2, N+1):\n        if step[i] == 0:\n            dp[i] = dp[i-1] + dp[i-2]\n            dp[i] %= mod\n\n    return dp[N]\n\n\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    a = [int(input()) for _ in range(M)]\n\n    print((solve(N, a)))\n\n__starting_point()", "import sys\npin=sys.stdin.readline\nsys.setrecursionlimit(10000000)\n\ndef f(n):\n  if n==0:\n    return 1\n  if n==1:\n    if dp[n]==0:\n      return 0\n    return 1\n  if dp[n]==0:\n    return 0\n  if dp[n-1]==-1:\n    dp[n-1]=f(n-1)\n  if dp[n-2]==-1:\n    dp[n-2]=f(n-2)\n  return dp[n-1]+dp[n-2]\n\n\nN,M=map(int,pin().split())\nmod=1000000007\ndp=[-1]*(N+1)\ndp[0]=1\nfor i in range(M):\n  dp[int(pin())]=0\nprint(f(N)%mod)", "def main():\n    N,M = list(map(int,input().split()))\n    mod = 10**9 + 7\n    a = [0]*(N+1)\n    a[0] = 1\n    banned = [False]*(N+1)\n    for x in range(M):\n        n = int(input())\n        banned[n] = True\n    for i in range(1,N+1):\n        res = 0\n        if not banned[i-1]:\n            res += a[i-1]\n        if not banned[i-2]:\n            res += a[i-2]\n        a[i] = res\n    print((a[-1]%mod))\n    return\n\nmain()\n", "n, m = map(int, input().split())\nstep = [True] * n\nr = [0,1]\nMOD = 10**9 + 7\nfor _ in range(m):\n    broken = int(input())\n    step[broken - 1] = False\nfor i, tf in enumerate(step):\n    if tf:\n        r += [(r[i] + r[i+1]) % MOD]\n    else:\n        r += [0]\nprint(r[-1])", "n,m=list(map(int,input().split()))\na=[int(input()) for i in range(m)]\na=set(a)\nmod=10**9+7\ndp=[0]*(n+7)\ndp[0]=1\nfor i in range(n+1):\n    if i+2 not in a: #2\u6bb5\u5148\u304c\u58ca\u308c\u3066\u3044\u306a\u3044\n        dp[i+2]+=dp[i]\n    if i+1 not in a: #1\u6bb5\u5148\u304c\u58ca\u308c\u3066\u3044\u306a\u3044\n        dp[i+1]+=dp[i]\n    dp[i+2]%=mod\n    dp[i+1]%=mod\nprint((dp[n]%mod))\n", "n,m = map(int,input().split())\na = [0]*(m+2)\na[m]=n+10\na[m+1]=n+10\nfor i in range(m):\n  a[i]= int(input())\nanswer=[0]*(n+1)\nanswer[0]=1\nif(n==1):\n  if(a[0]==1):\n    print(0)\n  else:\n    print(1)\nelse:\n  answer[0] = 1\n  if(a[0]==1):\n    answer[1] = 0\n    a.pop(0)\n  else:\n    answer[1] = 1\n  for i in range(2,n+1):\n    if(a[0]==i or a[1]==i):\n      answer[i]=0\n    elif(a[0]==i-1):\n      answer[i]=answer[i-2]\n      a.pop(0)\n    else:\n      answer[i]=answer[i-1]+answer[i-2]\n    answer[i] = answer[i]%1000000007\n  print(answer[n])", "N,M=map(int,input().split())\nAset=set()\nfor _ in range(M):\n    Aset.add(int(input()))\nmod=10**9+7\nnum=[0]*(N+1)\nfor i in range(2):\n    if not i in Aset:\n        num[i]+=1\nfor i in range(2,N+1):\n    if i in Aset:\n        num[i]=0\n    else:\n        num[i]+=num[i-1]+num[i-2]\n        num[i]%=mod\nprint(num[-1]%mod)", "N, M = list(map(int, input().split()))\nA = set(list(int(input()) for _ in range(M)))\n\n\n\ndp = [0]* (N+1)\ndp[0] = 1\n\nfor i in range(1, N+1):\n    dp[i] = (dp[i-1] + dp[i-2])%(10**9+7)\n    if i in A:\n        dp[i] = 0\nprint((dp[-1]))\n", "n,m = map(int,input().split())\n\nmod = 10**9+7\ndp = [-1]*(n+1)\ndp[0]= 0\ndp[1] = 1\nfor i in range(m):\n    a = int(input())\n    dp[a] = 0\n\nfor i in range(2,n+1):\n    if dp[i] == -1:\n        if i <= 2:\n            dp[i] = dp[i-1]+1\n        elif i>=3 :\n            dp[i] = (dp[i-1]+ dp[i-2])%mod\n\nprint(dp[n])", "n, m = map(int, input().split())\na_l = [ int(input()) for _ in range(m) ]\n\ndp = [1] * (n+1)\ndp[0] = 1\nif 1 not in a_l:\n    dp[1] = 1\nelse:\n    dp[1] = 0\nif n > 1:\n    for i in a_l:\n        dp[i] = 0\n    if 2 not in a_l:\n        dp[2] = dp[0] + dp[1]\n    else:\n        dp[2] = 0\n    for i in range(2,n+1):\n        if dp[i] != 0:\n            dp[i] = (dp[i-1] + dp[i-2])%1000000007\nprint(dp[-1])", "N, M = list(map(int, input().split()))\nA = [int(input()) for _ in range(M)]\n\nstep = [0]*(N+1)\nlast = -1\nfor a in A:\n    if a == last + 1 or a == last - 1:\n        print((0))\n        return\n    step[a] = 1\n    last = a\n\nans = [0] + [1] + [0]*N\n\nchk = 0\nfor i in range(1, N+1):\n    if step[i] == 0 and chk <= 0:\n        ans[i+1] = ans[i] + ans[i-1]\n        chk = 0\n    elif step[i] == 1:\n        ans[i+1] = ans[i]\n        chk = 2\n    elif step[i] == 0 and chk > 0:\n        ans[i+1] = ans[i]\n        chk -= 1\n        \nprint((ans[-1]%(10**9 + 7)))\n", "p = 10**9+7\n\nN, M = map(int, input().split())\nstatus = [1]*(N+1)\nfor i in range(M):\n    status[int(input())] = 0\n\ndp = [0]*(N+1)\ndp[0] = 1\n\nfor i in range(N):\n    if i+1 <= N and status[i+1]:\n        dp[i+1] += dp[i] % p\n    if i+2 <= N and status[i+2]:\n        dp[i+2] += dp[i] % p\n\nprint(dp[N] % p)", "N,M = map(int,input().split())\nA = set([int(input()) for _ in range(M)])\nstep = [0] * (N+1)\nstep[0] = 1\nif 1 not in A:\n    step[1] = 1\nelse:\n    step[1] = 0\nfor i in range(2,N+1):\n    if i in A:\n        continue\n    step[i] = (step[i-1] + step[i-2]) % 1000000007\nprint(step[-1])", "n, m = list(map(int, input().split()))\nis_safe = [True] * (n+1)\nfor _ in range(m):\n    is_safe[int(input())] = False\n\nMOD = 10**9+7\ndp = [0] * (n+1)\ndp[0] = 1\nif is_safe[1]:\n    dp[1] = 1\n\nfor i in range(2, n+1):\n    if is_safe[i-1]:\n        dp[i] += dp[i-1]\n    if is_safe[i-2]:\n        dp[i] += dp[i-2]\n    dp[i] %= MOD\n\nprint((dp[n]))\n", "N,M=map(int,input().split())\nres = 0\nflag = True\n#\u4efb\u610f\u306e\u6570K\u306b\u5bfe\u3057\u3066\u305f\u3069\u308a\u7740\u304f\u901a\u308a\u6570\nINF = 100000000000\nstepList = [INF]*(N+1)\nstepList[0] = 1\nstepList[1] = 1\ndef stepF(K):\n  if K == 0:\n    return stepList[0]\n  else:\n    for i in range(1,K+1):\n      if i == 1:\n        pass\n      else:\n        if stepList[i]==INF:\n          stepList[i]= stepList[i-2] + stepList[i-1]\n    return stepList[K]\n  \nif M == 0:\n  res = stepF(N)\n  \nelse:\n  List = []\n  for i in range (M):\n    List.append(int(input()))\n  #\u4efb\u610f\u306e\u6570a\u304c\u58ca\u308c\u3066\u3044\u308b\u5834\u5408\n  \n  for i in range(M):\n    if i == 0:\n      res = stepF(List[i]-1)\n    else:\n      if List[i] - List[i-1] == 1:\n        flag = False\n        break\n      res = res * stepF(List[i]-List[i-1]-2)\n  res = res * stepF(N-List[M-1]-1)\nif flag:\n  print(res%1000000007)\nelse:\n  print(0)", "n,m=map(int,input().split())\na=[int(input()) for i in range(m)]\nmod=10**9+7\nans=1\n\ndp=[0]*(n+1)\ndp[0]=1\ndp[1]=1\nfor i in range(2,n+1):\n    dp[i]=dp[i-1]+dp[i-2]\n    dp[i]%=mod\nif m==0:\n    ans=dp[n]\nelse:\n    begin=0\n    end=a[0]-1\n    for i in range(m):\n        end=a[i]-1\n        ans*=dp[end-begin]\n        \n        if(i+1<m and a[i+1]==a[i]+1):\n            ans=0\n            break\n            \n        else:\n            begin=end+2\n\n    ans*=dp[n-a[m-1]-1]\n\nprint(ans%mod)", "#\u5165\u529b:N,M(int:\u6574\u6570)\ndef input2():\n\treturn map(int,input().split())\n\ndef Fib(n):\n\ta,b=0,1\n\tif n==1:\n\t\treturn a\n\telif n==2:\n\t\treturn b\n\telse:\n\t\tfor i in range(n-2):\n\t\t\ta,b=b,a+b\n\t\treturn b\n\nn,m=input2()\nA=[int(input()) for _ in range(m)]\nINF = 1000000007\n\nstart=0 #\u968e\u6bb5\u306e\u958b\u59cb\u70b9\nans=1 #\nfor a in A:\n\ttmp=a-start\n\tif tmp>1:\n\t\tfib=Fib(tmp+1)\n\t\tans*=fib\n\t\tans%=INF\n\telif tmp==0:\n\t\tans=0\n\t\tbreak\n\tstart=a+1\n\nif n-start>1:\n\tans*=Fib(n-start+2)\n\tans%=INF\nprint(ans)", "n,m = map(int, input().split())\na = set([int(input()) for _ in range(m)])\n\nnums = [0]*(n+1)\nnums[0] = 1\nif 1 not in a: nums[1] = 1\nfor i in range(2,n+1):\n  if i in a : continue\n  nums[i] = nums[i-1]+nums[i-2]\nprint(nums[n]%1000000007)", "n,m=map(int,input().split())\noks=[True]*(n+1)\nfor _ in range(m):\n  a=int(input())\n  oks[a]=False\nmod=1000000007\ndp=[0]*(n+1)\ndp[0]=1\nif oks[1]: dp[1]=1\nfor i in range(2,n+1):\n  if oks[i]:\n    dp[i]=dp[i-1]+dp[i-2]\n    dp[i]%=mod\nprint(dp[-1])", "n, m = map(int, input().split())\na_l = [ int(input()) for _ in range(m) ]\n\ndp = [1] * (n+1)\ndp[0] = 1\nif 1 not in a_l:\n    dp[1] = 1\nelse:\n    dp[1] = 0\nif n > 1:\n    for i in a_l:\n        dp[i] = 0\n    if 2 not in a_l:\n        dp[2] = dp[0] + dp[1]\n    else:\n        dp[2] = 0\n    for i in range(2,n+1):\n        if dp[i] != 0:\n            dp[i] = (dp[i-1] + dp[i-2])%1000000007\nprint(dp[-1])", "n,m = map(int, input().split())\nstep = []\n\nnow = 0\nfor i in range(m):\n  next = int(input()) - 1\n  step.append(next - now)\n  now = next + 2\n\nstep.append(n-now)  \nstep.sort()\n\ndef fibo():\n  s = []\n  a = 1\n  b = 1\n  s.append(a)\n  s.append(b)\n  for i in range(n):\n    c = a+b\n    a = b\n    b = c\n    s.append(c)\n  return s\n\nans = 1\n\nif step[0] < 0:\n  ans = 0\n\nelse:\n  f = fibo()\n  for i in step:\n    ans *= f[i]\n\nprint(ans % 1000000007)", "N,M=map(int,input().split())\nAset=set()\nfor _ in range(M):\n    Aset.add(int(input()))\nmod=10**9+7\nnum=[0]*(N+1)\nfor i in range(2):\n    if not i in Aset:\n        num[i]+=1\nfor i in range(2,N+1):\n    if i in Aset:\n        num[i]=0\n    else:\n        num[i]+=num[i-1]+num[i-2]\nprint(num[-1]%mod)", "n, m = list(map(int,input().split()))\nlst = [-1 for i in range(n + 1)]\nfor i in range(m):\n    x = int(input())\n    lst[x] = 0\n\nlst[0] = 1\nfor i in range(1, n + 1):\n    if (i == 1):\n        if(lst[1] == -1):\n            lst[1] = 1\n    elif (lst[i] == 0):\n        pass\n    else:\n        lst[i] = (lst[i - 1] + lst[i - 2])%(1000000007)\n\nprint((lst[n]))\n", "n,m = map(int, input().split())\nA = [1]*(n+1)\ndp = [0]*(n+1)\ndp[0]=1\nfor i in range(m):\n    A[int(input())]=0\n\nif A[1]:\n    dp[1] = 1\n\nfor i in range(2, n+1):\n    if A[i]:\n        dp[i] = dp[i-1]+dp[i-2]\nmod = 7+10**9\nprint(dp[-1]%mod)", "import sys\n\ninput = sys.stdin.readline\n\nMOD = pow(10,9)+7\ndef MODINV(n:int, MOD=MOD):\n    return pow(n, MOD-2, MOD)\n\ndef main():\n    N, M = list(map(int, input().split()))\n    DP = [0] * (N+1)\n    ngset = set()\n    for _ in range(M):\n        a = int(input())\n        ngset.add(a)\n    \n    DP[0] = 1\n    if 1 not in ngset:\n        DP[1] = DP[0]\n    for i in range(2, N+1):\n        if i in ngset:\n            continue\n        DP[i] = DP[i-1] + DP[i-2]\n        DP[i] %= MOD\n    \n    print((DP[N]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int, input().split())\na=[False]*(n+1)\nfor i in range(m):\n    A=int(input())\n    a[A]=True\nmod=10**9+7\ndp=[0]*(n+1)\n\nif not a[1]:\n    dp[1]=1\n\nif n>1:\n    if not a[2]:\n        dp[2]=dp[1]+1\n\nfor i in range(3,n+1):\n    if not a[i-2]:\n        dp[i]+=dp[i-2]\n        dp[i]%=mod\n    if not a[i-1]:\n        dp[i]+=dp[i-1]\n        dp[i]%=mod\n    if a[i]:\n        dp[i]=0\n\nprint(dp[n]%mod)", "def main():\n    N, M = [int(i) for i in input().split()]\n\n    pos = 0\n    ans = 1\n\n    fib = [1 for _ in range(100002)]\n    for i in range(2, 100002):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    for _ in range(M):\n\n        a = int(input())\n        if a == pos:\n            ans = 0\n            pos = N\n            break\n        elif a == pos + 1:\n            pos = a + 1\n        else:\n            ans *= fib[(a - 1 - pos)]\n            pos = a + 1\n\n    if pos + 1 < N:\n        ans *= fib[(N - pos)]\n\n    print((ans % 1_000_000_007))\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "3\nimport sys\ninput = lambda: sys.stdin.readline().strip()\nn, m = [int(x) for x in input().split()]\ncan = [True for i in range(n + 1)]\nfor i in range(m):\n    ai = int(input())\n    can[ai] = False\nC = [0 for i in range(n + 1)]\nfor i in range(n + 1):\n    if i == 0:\n        C[i] = 1\n    else:\n        C[i] = sum(C[j] if j >= 0 and can[j] else 0 for j in (i - 1, i - 2)) % (10**9 + 7)\nprint(C[n])", "n, m = list(map(int, input().split()))\nbroken = [False] * (n + 1)\nfor _ in range(m):\n    broken[int(input())] = True\n\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = 1 if not broken[1] else 0\nMOD = 10 ** 9 + 7\n\nfor i in range(2, n + 1):\n    if broken[i]:\n        continue\n    dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\nprint((dp[n]))\n"]