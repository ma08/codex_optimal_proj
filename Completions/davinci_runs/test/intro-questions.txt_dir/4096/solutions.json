["n, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\na.sort(reverse=True)\n\ndef check(d):\n    s=0\n    for i in range(len(a)):\n        s+=max(0,a[i]-i//d)\n    return s>=m\nif sum(a)<m:\n    print(-1)\nelse:\n    l, r = 1,n\n    mid = l+r>>1\n    while l<r:\n        if check(mid):\n            r=mid\n        else:\n            l=mid+1\n        mid=l+r>>1\n    print(l)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\ndef main():\n    n, m = get_tuple()\n    li = get_list()\n    li.sort(reverse=True)\n    for i in range(1,n+1):\n        curr = sum(li[:i]) #Replce with prefix sum\n        c = -1\n        for j in range(i,n):\n            if li[j]-j//i>0:\n                curr+=li[j]-j//i\n        if curr>=m:\n            print(i)\n            return\n    print(-1)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n,m=list(map(int,input().split()))\narr=list(map(int,input().split()))\nans=0\narr.sort(reverse=True)\nflag=0\nfor i in range(1,101):\n\tdays=i\n\tinterval=n//i\n\ttemp=n%i\n\ttempans=0\n\tj=0\n\tcount=0\n\twhile(j<=n):\n\t\tk=j\n\t\twhile(k<min(j+i,n)):\n\t\t\ttempans+=max(arr[k]-count,0)\n\t\t\tk+=1\n\t\tj+=i\n\t\tcount+=1\n\tif(tempans>=m):\n\t\t\tprint(i)\n\t\t\tflag=1\n\t\t\treturn\nif(flag==0):\n\tprint(-1)\n\n\n", "n, m = map(int, input().split())\ncoffees = sorted(map(int, input().split()), reverse=True)\ntotal = sum(coffees)\n\nif total < m:\n    print(-1)\n    return\n\nfor div in range(1, n):\n    a = [0] * div\n    index = 0\n    for pena in range(n):\n        for d in range(div):\n            if coffees[index] <= pena:\n                break\n            a[d] += coffees[index] - pena\n            index += 1\n\n            if index >= n or coffees[index] <= pena:\n                break\n        if index >= n or coffees[index] <= pena:\n            break\n\n    if sum(a) >= m:\n        print(div)\n        return\n\nprint(n)", "n, m = map(int, input().split())\na = input().split()\na = [int(i) for i in a]\n\ns = sum(a)\nif s < m:\n    print(-1)\nelif s == m:\n    print(n)\nelse:\n    a.sort(reverse=True)\n    # print(a)\n    for day in range(1, n + 1):\n        coffee = [0 for _ in range(day)]\n        paper = [0 for _ in range(day)]\n        i = 0\n        while i < n:\n            if a[i] - coffee[i % day] > 0:\n                paper[i % day] += a[i] - coffee[i % day]\n                coffee[i % day] += 1\n            i += 1\n        # print(coffee, paper)\n        if sum(paper) >= m:\n            print(day)\n            return", "n, m = map(int, input().split())\naa = list(map(int, input().split()))\naa.sort()\n# n^3\u3067\u3067\u304d\u308b(\u4e00\u5fdc)\n# i\u65e5\u3067\u3067\u304d\u308b\u304b\u3069\u3046\u304b\n# \u3067\u304d\u308b\u3060\u3051\u5747\u4e00\u306b\u4e26\u3079\u305f\u307b\u3046\u304c\u826f\u3044\n# j\u500b\u4f7f\u3063\u3066\u3067\u304d\u308b\u304b\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        ans = 0\n        cnt = 0\n        for k in range(j):\n            now = aa[n-j+k]\n            ans += max(0, now - cnt//i)\n            cnt += 1\n        # m\u30da\u30fc\u30b8\u3092\u8d85\u3048\u305f\u3068\u304d\n        if ans >= m:\n            print(i)\n            return\nprint(-1)", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n\ndef proc(n, m, a):\n    # if m > sum(a):\n    #     return -1\n    a = list(sorted(a, reverse=True))\n    for i in range(1, n + 1):  # check if i is valid days\n\n        sub_m = [0] * i\n        sub_c = [0] * i\n        # sub_l = [list() for _ in range(i)]\n        for j in range(n):\n            pos = j % i\n            sub_m[pos] += max(0, a[j] - sub_c[pos])\n            # sub_l[pos].append(max(0, a[j] - sub_c[pos]))\n            sub_c[pos] += 1\n\n        if sum(sub_m) >= m:\n            return i\n    return -1\n\n\nprint(proc(n, m, a))\n", "n, m = [int(n) for n in input().split()]\na = sorted([int(n) for n in input().split()])\n\nans = 0\nif m > sum(a):\n        ans = -1\nelse:\n        for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                        fold = j // i\n                        amari = j % i\n                        suma = sum(a[-1*j:]) - ((fold - 1) * fold // 2) * i - amari * fold\n                        if suma >= m:\n                                ans = i\n                                break\n                if ans > 0:\n                        break\n\nprint(ans)\n\n\n\n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/2/20 0:12\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : D1. Coffee and Coursework (Easy version).py\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    c = a.copy()\n    for i in range(1, n):\n        c[i] = c[i] + c[i - 1]\n    # print(c)\n\n    dp = [[0] * n for _ in range(n)]\n    # print('1st:')\n    for i in range(n):\n        dp[0][i] = max(0, c[i] - (1 + i) * i // 2)\n        if dp[0][i] >= m:\n            print(1)\n            return\n    # print(*dp[0])\n\n    for i in range(1, n):\n        for j in range(i, n):\n            for k in range(i - 1, j):\n                num = j - k - 1\n                dp[i][j] = max(dp[i][j], dp[i - 1][k] + c[j] - c[k] - (1 + num) * num // 2)\n            if dp[i][j] >= m:\n                print(i + 1)\n                return\n\n    print(-1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\na.reverse()\na = a + [0] * 100\nif sum(a) < m:\n    print(-1)\nelse:\n    for ans in range(1, n + 1):\n        p = 0\n        for i in range((n+ans-1)//ans):\n            for j in range(ans):\n                p += max(0, a[i * ans + j] - i)\n        if p >= m:\n            print(ans)\n            break", "n,m = list(map(int,input().split()))\na = list(map(int,input().split()))\nans=1\nsu = sum(a)\na.sort(reverse=True)\ns = [0]*n\ns[0] = a[0]\nfor i in range(1,n):\n    s[i] = s[i-1]+a[i]\n\ndef pos(d):\n    i=d\n    while i<=n:\n        k = i//d\n        neg = k*i-((k*(k+1))//2)*d\n        if(s[i-1]-neg >= m):\n            return True\n        i+=1\n    return False\n\n\n\nif(su < m):\n    ans = -1\n    print(ans)\n\nelse:\n    first = 0\n    last = n\n\n    while first<last-1:\n        midpoint = (first + last)//2\n        if pos(midpoint):\n            last = midpoint\n        else:\n            first = midpoint\n\n    print(last)\n", "n, m=(int(i) for i in input().split())\nL=[int(i) for i in input().split()]\np=0\nt=1\nL.sort()\nfor i in L:\n   p+=i\nif p<m:\n    print(-1)\n    t=0\nelse:\n    for i in range(n):\n        s=0\n        for j in range(n//(i+1)):\n            s+=j\n            g=j\n        s=s*(i+1)+(g+1)*(n%(i+1))\n        if s+m<=p:\n            mm=i+1\n            break\nfor u in range(len(L)):\n    L=L[1:]\n    n=n-1\n    p=0\n    #print(L)\n    for i in L:\n        p+=i\n    if p>=m:\n        for i in range(n):\n            s=0\n            for j in range(n//(i+1)):\n                s+=j\n                g=j\n            s=s*(i+1)+(g+1)*(n%(i+1))\n            if s+m<=p:\n                if i+1<mm:\n                    mm=i+1\n                break\nif t:\n    print(mm)\n\n\n        \n    \n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nasum = sum(a)\nif m > asum:\n    print(-1)\nelse:\n    a.sort(reverse = True)\n    for i in range(1, 101):\n        task = 0\n        for j in range(n):\n            task += max(0, a[j] - j//i)\n        if task >= m:\n            print(i)\n            break\n", "def check(arr,d,mm):\n\tss=0\n\tk=-1\n\tfor i in range(n):\n\t\tif (i)%d==0:\n\t\t\t# print(\"i is \",i)\n\t\t\tk+=1\n\t\t# print(\"k is \",k)\n\t\tss+=max(0,arr[i]-k)\n\tif ss>=mm:\n\t\treturn True\n\telse:\n\t\treturn False\nn,m=map(int,input().split())\narr=list(map(int,input().split()))\narr.sort(reverse=True)\ns=1 \ne=n \nans=1000000000000000000000\nwhile s<=e:\n\tmid=(s+e)//2\n\tif check(arr,mid,m):\n\t\tans=min(ans,mid)\n\t\te=mid-1\n\telse:\n\t\ts=mid+1\nif ans==1000000000000000000000:\n\tans=-1\nprint(ans)", "import io, sys, atexit, os\n\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li ():\n\treturn list (map (int, input ().split ()))\n\n\ndef num ():\n\treturn map (int, input ().split ())\n\n\ndef nu ():\n\treturn int (input ())\n\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\n\ndef solve ():\n\tt = 1\n\tfor it in range (t):\n\t\tn,m = num ()\n\t\ta = li ()\n\t\ta.sort(reverse = True)\n\t\tlo=1\n\t\thi=n\n\t\tans=-1\n\t\twhile(lo<=hi):\n\t\t\tmid=(lo+hi)//2\n\t\t\tpp=0\n\t\t\tss=0\n\t\t\tfor i in range(n):\n\t\t\t\tif (i % mid == 0 and i != 0):\n\t\t\t\t\tpp += 1\n\t\t\t\tss+=max(a[i]-pp,0)\n\t\t\tif(ss>=m):\n\t\t\t\thi=mid-1\n\t\t\telse:\n\t\t\t\tlo=mid+1\n\t\tif(lo==n+1):\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(lo)\n\n\ndef __starting_point():\n\tsolve ()\n__starting_point()", "\nn,m = list(map(int,input().strip().split()))\n\narr = list(map(int,input().strip().split()))\n\narr = sorted(arr,reverse=True)\n\nlow = 1\nhigh = n\n#print(arr)\ndef check(k,m):\n    #print(m)\n    #print(m)\n    if m>0:\n        l = 0\n        z = 0\n        for i in range(n):\n            m-=max(0,arr[i]-(l))\n            z+=1\n            if z==k:\n                z = 0\n                l+=1\n            \n    #print(m)\n    if m<=0:\n        return 1\n    else:\n        return 0\nans = []\nwhile high >= low:\n    \n    mid = low+(high-low)//2\n    #print(low,high,mid)\n    if check(mid,m):\n        ans.append(mid)\n        high = mid-1\n    else:\n        low = mid+1\n#print(ans)\nif len(ans)>0:\n    print(min(ans))\nelse:\n    print(-1)\n", "import sys\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nif sum(A)<m:\n    print(-1)\n    return\n\nA.sort(reverse=True)\n\nMIN=1\nMAX=n\n\nwhile MIN!=MAX:\n    d=(MIN+MAX)//2\n\n\n    ANS=0\n    j=0\n    count=0\n    for a in A:\n        if a<=j:\n            continue\n        \n        ANS+=(a-j)\n        count+=1\n\n        if count==d:\n            j+=1\n            count=0\n\n    #print(d,ANS)\n\n    if ANS>=m:\n        MAX=d\n    else:\n        MIN=d+1\nprint(MIN)\n            \n", "nb_cups, nb_task = [int(x) for x in input().split()]\ncaffines = sorted([int(x) for x in input().split()], reverse=True)\nif nb_task > sum(caffines):\n    print(-1)\nelse:    \n    for days in range(1, 101):\n        task_done = 0\n        for curr in range(nb_cups):\n            task_done += max(0, caffines[curr] - curr // days)\n        if task_done >= nb_task:\n            print(days)\n            break\n", "n,m = [int(x) for x in input().split()]\n\nl = [int(x) for x in input().split()]\nsumm = sum(l)\nresult = 0\n\ndef find(x) :\n    # x\u00e9t n\u1ebfu u\u1ed1ng trong x ng\u00e0y k\u1ecbp l\u00e0m\n    # th\u1ee9 t\u1ef1 u\u1ed1ng trong m\u1ed7i ng\u00e0y \u01b0u ti\u00ean c\u1ed1c l\u1edbn tr\u01b0\u1edbc . ex : v\u1edbi x = 2 : a1x1 > a1x2 > a2x1 >a2x2 >...\n    s = 0\n    pos_count = 0\n    day_count = 0\n\n    for i in l :\n        s += max(0,i-pos_count)\n        day_count+=1\n        if day_count == x :\n            day_count = 0\n            pos_count+=1\n\n    if s < m :\n        return 0\n    else :\n        return x\n\ndef binary_search(lf,r) :\n    nonlocal result\n    mid = int((lf+r)/2)\n\n    rs = find(mid)\n\n    if lf==r :\n        result = rs\n    elif lf == r-1 :\n        if rs :\n            result = rs\n        else :\n            binary_search(r,r)\n    else :\n        if rs :\n            binary_search(lf,mid)\n        else :\n            binary_search(mid,r)\n\n\nif summ<m:\n    print('-1')\nelif summ == m :\n    print(n)\n# elif summ - sum(range(n)) == m:\n#     print('1')\nelse :\n    l= sorted(l,reverse=True)\n    binary_search(1,n)\n    print(result)\n", "def check_possibility(days, m, coffee):\n    sum_coffee = 0\n    for i, cup in enumerate(coffee):\n        tax = i // days\n        if sum_coffee >= m or tax >= cup:\n            break\n        sum_coffee += cup - tax\n    return sum_coffee >= m\n\n\nn, m = list(map(int, input().split()))\ncoffee = sorted(map(int, input().split()), reverse=True)\n\nbad = 0\ngood = len(coffee)\n\nwhile good - bad > 1:\n    days = (bad + good) // 2\n    if check_possibility(days, m, coffee):\n        good = days\n    else:\n        bad = days\n\npossible = check_possibility(good, m, coffee)\nprint(good if possible else -1)\n", "import sys\nn , m = map(int,input().split())\nl = list(map(int,input().split()))\nl.sort(reverse = True)\n\nleft = 1\nright = n+1\n\nans = 10**18 + 1\nwhile left != right:\n    mid = (left+right)//2\n    #print(mid,left,right)\n    din = 0\n    kaam = 0\n    c = 0\n    for i in l:\n        if i - din <=0:\n            break\n        kaam += i - din\n        c += 1\n        if c == mid:\n            c = 0\n            din += 1\n    if kaam >= m:\n        ans = min(ans,mid)\n        right = mid\n    else:\n        left = mid+1\n\nif ans == 10**18+1:\n    print(-1)\nelse:\n    print(ans)", "n, m = list(map(int, input().split()))\n\nl = list(map(int,input().split()))\n\nl.sort(reverse = True)\n\nleft = 1\nright = n\n\ndef check(k,m):\n  if m > 0:\n    lef = 0\n    z = 0\n    for i in range(n):\n      m -= max(0, l[i]-lef)\n      z += 1\n      if z == k:\n        z = 0\n        lef += 1\n  if m <= 0:\n    return 1\n  else:\n    return 0\n\nres = []\n\nwhile left <= right:\n  mid = int((left+right)/2)\n  if check(mid, m):\n    res.append(mid)\n    right = mid - 1\n  else:\n    left = mid + 1\nif len(res) > 0:\n  print(min(res))\nelse:\n  print(\"-1\")\n\n\"\"\"\nn, m = map(int, input().split())\n\nl = list(map(int,input().split()))\n\ns = sum(l)\nans = 0\n\ndef find(x):\n  su = 0\n  days = 0\n  z = 0\n\n  for i in l:\n    su += max(0, i-z)\n    days += 1\n    if days == x:\n      days = 0\n      z += 1\n  if su < m:\n    return 0\n  return x\n\ndef binary(left, right):\n  nonlocal ans\n  mid = int((left+right)/2)\n  r = find(mid)\n  if right == left:\n    ans = r\n  elif left == right - 1:\n    if r:\n      ans = r\n    else:\n      binary(r, r)\n  else:\n    if r:\n      binary(left, mid)\n    else:\n      binary(mid, right)\n\nif s < m:\n  print(\"-1\")\nelif s == m:\n  print(n)\nelse:\n  l.sort(reverse = True)\n  binary(1,n)\n  print(ans)\nprint(ans)\n\"\"\"\n", "from math import ceil\ndef check(p):\n    sm = 0\n    k = 0\n    d = 0\n    for i in range(ceil(len(a)/p)):\n        for j in range(p):\n            if k < len(a):\n                sm += max(0, a[k]-d)\n                k+=1\n        d += 1\n    return sm >= m\n\nn,m=list(map(int,input().split()))\na=[int(x) for x in input().split()]\na.sort(reverse=True)\n\nl=1\nr=len(a)\nif sum(a) < m:\n    print(-1)\nelse:\n    while(l < r):\n        mid = (l + r) // 2\n\n        if check(mid):\n            r = mid\n        else:\n            l = mid+1\n    print(l)\n", "n, m = list(map(int, input().split()))\nl = list(map(int, input().split()))\nl.sort(reverse=True)\nans = []\ndef bin(s):\n    tmp = [[] for k in range(s)]\n    cur = s\n    tr = 0\n    for i in range(n):\n        if (cur == s):\n            cur = 0\n        tmp[cur].append(l[i])\n        cur += 1\n    for i in range(s):\n        for k in range(len(tmp[i])):\n            tr += max(tmp[i][k] - k, 0)\n    if tr >= m:\n        return 1\n    else:\n        return 0\nuk2 = n\nuk1 = 1\nwhile (uk2 - uk1 > 1):\n    if bin((uk2 + uk1) // 2):\n        uk2 = (uk2 + uk1) // 2\n    else:\n        uk1 = (uk2 + uk1) // 2\nif bin(uk1):\n    print(uk1)\nelif bin(uk2):\n    print(uk2)\nelse:\n    print(-1)"]