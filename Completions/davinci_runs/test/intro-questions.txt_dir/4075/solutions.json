["n,m = map(int,input().split())\ns = [list(map(int,input().split())) for i in range(m)]\np = list(map(int,input().split()))\nans = 0\nfor i in range(2 ** n):\n    t = ['off'] * n\n    x = i\n    j = 0\n    while x > 0:\n        if x % 2 != 0:\n            t[j] = 'on'\n        x = x // 2\n        j += 1\n    flg = True\n    for j in range(m):\n        z = 0\n        for k in range(1,s[j][0]+1):\n            if t[s[j][k]-1] == 'on':\n                z += 1\n        if z % 2 != p[j]:\n            flg = False\n            break\n    if flg:\n        ans += 1\nprint(ans)", "n,m = map(int,input().split())\nf = [list(map(int,input().split())) for i in range(m)]\np = list(map(int,input().split()))\ncount = 0\nfor i in range(2**n):\n  Bit = [0]*n\n  for j in range(n):\n    if (i>>j)&1:\n      Bit[j]=1\n  same = 0\n  for k in range(m):\n    sum = 0\n    for l in range(f[k][0]):\n      if Bit[f[k][l+1]-1] == 1:\n        sum += 1\n    if sum % 2 !=p[k]:\n      break\n  else:\n    count += 1\nprint(count)", "n,m=map(int,input().split())\nks=[[] for i in range(m)]\nfor i in range(m):\n  ks[i]=list(map(lambda x:int(x)-1,input().split()))\np=list(map(int,input().split()))\n\nans=0\nfor i in range(1<<n):\n  l=[0]*n\n  for j in range(n):\n    l[j]=1 if i&1 else 0\n    i>>=1\n  \n  # light check\n  for j in range(m):\n    s=sum([l[k] for k in ks[j][1:]])\n    if s%2!=p[j]:\n      break\n  else:\n    ans+=1\n\nprint(ans) ", "N, M = map(int,input().split())\nK = []\nS = []\nfor i in range(M):\n    k = 0\n    s = []\n    k, *s = map(int,input().split())\n    K.append(k)\n    S.append(s)\nP = list(map(int,input().split()))\nres = 0\nfor bit in range(1 << N):\n    judge = True\n    for i in range(M):\n        cnt = 0\n        for s in S[i]:\n            cnt += (bit >> s-1) & 1\n        if cnt % 2 != P[i]:\n            judge = False\n            break\n    if judge:\n        res += 1\nprint(res)", "from itertools import product\n\n\nN, M = list(map(int, input().split()))\nbulbs = [list([int(x) - 1 for x in input().split()]) for _ in range(M)]\nP = list(map(int, input().split()))\n\nans = 0\nfor x in product([0, 1], repeat=N):\n    is_on = [0] * M\n    for i in range(M):\n        k, *switches = bulbs[i]\n        cnt = sum(x[s] for s in switches)\n        if cnt % 2 == P[i]:\n            is_on[i] = 1\n    if all(is_on):\n        ans += 1\nprint(ans)\n", "N, M = map(int, input().split())\nswitch = []\nfor _ in range(M):\n  tmp = list(map(int, input().split()))\n  switch.append(tmp[1:])\np = list(map(int, input().split()))\n\nfrom itertools import product\ncandidate = list(product([0,1], repeat=N))\n\nans = 0\nfor cand in candidate:\n  flag = True\n  for idx, snum in enumerate(switch):\n    tmp = 0\n    for s in snum:\n      tmp += cand[s-1]\n    if p[idx] != tmp%2:\n      flag = False\n      break\n  if flag:\n    ans += 1\nprint(ans)", "n,m = map(int,input().split())\ns = [list(map(int,input().split()))[1:] for i in range(m)]\np = list(map(int,input().split()))\nans = 0\nfor i in range(1<<n):\n    for j in range(m):\n        c = 0\n        for k in range(n):\n            if(i>>k)&1 and k+1 in s[j]:\n                c+=1\n        if c%2!=p[j]:\n            break\n    else:\n        ans+=1\nprint(ans)", "n,m=map(int,input().split())\nks=[]\nfor i in range(m):\n  t=list(map(int,input().split()))\n  ks.append(t)\np=list(map(int,input().split()))\n\nans=0\nfor i in range(1<<n):\n  on=0\n  for j in range(m):\n    cnt=0\n    for k in range(ks[j][0]):\n      if 1<<(ks[j][k+1]-1) & i:\n        cnt+=1\n    if cnt%2==p[j]:\n      on+=1\n    if on==m:\n      ans+=1\nprint(ans)", "N,M = map(int,input().split())\nks = [list(map(int,input().split())) for i in range(M)]\np = list(map(int,input().split()))\nans = 0\nfor i in range(2**N):\n    s = i\n    b = [0]*N\n    for j in range(N):\n        if s >= (2**(N-j-1)):\n            s -= 2**(N-j-1)\n            b[j] = 1\n    for j in range(M):\n        on = 0\n        for k in range(ks[j][0]):\n            if b[ks[j][k+1]-1] == 1:\n                on += 1\n        if on%2 != p[j]:\n            break\n    else:\n        ans += 1\nprint(ans)", "n,m = map(int,input().split())\nbulbbit = [0]*m # \u96fb\u7403\u3068\u3064\u306a\u304c\u3063\u3066\u3044\u308bSW\u3092bit\u8868\u73fe\nfor i in range(m):\n    tmp = list(map(int,input().split()))\n    for j in range(1,tmp[0]+1):\n        bulbbit[i] |= 1<<(tmp[j]-1)\np = list(map(int,input().split()))\n\nans = 0\nfor s in range(1<<n):\n    cnt = 0\n    for i in range(m):\n        swon = 0\n        for j in range(n):\n            if s>>j&1 and bulbbit[i]>>j&1:\n                swon += 1\n        if swon%2 == p[i]:\n            cnt += 1\n    if cnt == m:\n        ans += 1\nprint(ans)", "N,M = map(int,input().split())\nmat = [[int(i) for i in input().split()] for k in range(M)]\np = [int(i) for i in input().split()]\nswitch = [0]*N\nO = [0]*M\nL = [False]*M\nans = 0\n\nfor i in range(2 ** (N)):\n    switchsub = list(format(i,'b'))\n    for j in range(len(switchsub)):\n        switch[-j-1] = switchsub[-j-1]\n    for j in range(N):\n        if(switch[j] == \"1\"):\n            for k in range(M):\n                for l in range(1,len(mat[k])):\n                    if(mat[k][l] == j+1):\n                        O[k] += 1\n    for j in range(M):\n        if(O[j] % 2 == p[j]):\n            L[j] = True\n    if(False not in L):\n        ans += 1\n        switch = [0]*N\n        O = [0]*M\n        L = [False]*M\n    if(False in L):\n        switch = [0]*N\n        O = [0]*M\n        L = [False]*M\n\nprint(ans)", "N, M = list(map(int, input().split()))\n\nK = []\nfor i in range(M):\n    K.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(1 << N):\n    flg = True\n    for j in range(M):\n        n = 0\n        for k in K[j][1:]:\n            n += i >> (k - 1) & 1\n        if n % 2 != p[j]:\n            flg = False\n            break\n    if flg:\n        ans += 1\n\nprint(ans)\n", "n,m = map(int,input().split())\nswithes = [list(map(int,input().split())) for i in range(m)]\np = list(map(int,input().split()))\ntotal = 0\n\nfor i in range(2**n):\n    bag = []\n    ans = 0\n    for j in range(n):\n        if i >> j & 1:\n            bag.append(j+1)\n    for k in range(m):\n        a = 0\n        for l in range(swithes[k][0]):\n            if swithes[k][l+1] in bag:\n                a += 1\n        if a % 2 == p[k]:\n            ans += 1\n    \n    if ans == m:\n        total += 1\n\nprint(total)", "num_of_switch, light = list(map(int, input().split()))\nligth_list = [list(map(int,input().split())) for _ in range(light)]\non_list = list(map(int, input().split()))\n\nnum_of_patern = 2 ** num_of_switch\npatern = 0\n\nfor i in range(num_of_patern):\n\ton = []\n\tlight_counter = 0\n\tfor j in range(num_of_switch):  #\u30b9\u30a4\u30c3\u30c1\u306e\u30aa\u30f3\u306e\u5834\u6240\n\t\tif ((i >> j) & 1):\n\t\t\ton.append(j + 1)\n\tfor j in range(light):   #\u3069\u306e\u96fb\u7403\u304c\u4ed8\u3044\u3066\u3044\u308b\u304b\u306e\u5224\u5b9a\n\t\tcount = 0\n\t\tnum_connect = ligth_list[j][0]\n\t\t#print(on)\n\t\tif on_list[j] == 1:\n\t\t\tfor n in range(len(on)):\n\t\t\t\tif on[n] in ligth_list[j][1:]:\n\t\t\t\t\tcount += 1\n\t\t\tif count % 2 == 1:\n\t\t\t\tlight_counter += 1\n\t\telse:\n\t\t\tfor m in range(len(on)):\n\t\t\t\tif on[m] in ligth_list[j][1:]:\n\t\t\t\t\tcount += 1\n\t\t\tif count % 2 == 0:\n\t\t\t\tlight_counter += 1\n\tif light_counter == light:\n\t\t#print(i)\n\t\tpatern += 1\n\tdel on[:]\nprint(patern)\n\n\n", "# cs: c nnected switches\nn, m = list(map(int, input().split()))\n\n# cs: connected switches\ncs = [list(map(int, input().split())) for _ in range(m)]\nps = list(map(int, input().split()))\n\n# bit\u5168\u63a2\u7d22(0: \u3059\u3079\u3066off\u306f\u4e0d\u8981)\nans = 0\n# on: 0:\u6d88\u3048\u3066\u308b\u30011:\u70b9\u3044\u3066\u308b\n# 10: 1 2  3   4 \n# 0b: 1 10 11, 100..\nfor on in range(2**n):\n    # bin: \u30d0\u30a4\u30ca\u30ea\u6587\u5b57\u5217\u306b\u5909\u63db\n    # 3 -> '0b11'\n    # rust \u3067\u53f30\u57cb\u3081\n    patern = bin(on)[2:].rjust(n, '0')\n    ok = True\n\n    for i in range(m):\n        ct = 0\n        for j in range(cs[i][0]):\n            if patern[cs[i][j+1] - 1] == '1':\n                ct += 1\n        if ct%2 != ps[i]:\n            ok = False\n    if ok:\n        ans += 1\nprint(ans)\n", "3\n#coding: utf-8\n\nN, M = (int(x) for x in input().split())\n\nS = []\nfor i in range(M):\n    items = [int(x)-1 for x in input().split()]\n    S.append(items[1:])\n\nP = [int(x) for x in input().split()]\n\nret = 0\nfor bit in range(2**N):\n    on = [i for i in range(N) if bit & (1 << i)]\n    ok = True\n    for i in range(M):\n        s = S[i]\n        p = P[i]\n        if sum(1 for switch in s if switch in on) % 2 != p:\n            ok = False\n            break\n    if ok:\n        ret += 1\nprint(ret)\n", "# -*- coding: utf-8 -*-\n\ndef func(sw, p, bit):\n    sum_on = 0\n    for k in range(sw[0]):\n        idx = sw[k+1]-1\n        if bit[idx] == 1:\n            sum_on += 1\n    if sum_on % 2 == p:\n        res = 1\n    else:\n        res = 0\n    return res\n\n\nN,M = list(map(int, input().split()))\nSW = [list(map(int, input().split())) for _ in range(M)]\nP = list(map(int, input().split()))\n\nans = 0\nfor i in range(1<<N):\n    bit = [0] * N\n    for j in range(N):\n        div = 1 << j\n        bit[j] = (i // div) % 2\n\n    cnt = 0\n    for m in range(M):\n        res = func(SW[m], P[m], bit)\n        if res == 1:\n            cnt += 1\n    \n    if cnt == M:\n        ans += 1\n\nprint(ans)\n", "def abc128c_switches():\n    import itertools\n    n, m = map(int, input().split())\n    s = []\n    for _ in range(m):\n        v = list(map(int, input().split()))\n        v = v[1:]\n        s.append(v)\n    p = list(map(int, input().split()))\n    pattern = itertools.product([0,1], repeat=n)\n    result = 0\n    for pat in pattern:\n        cnt = 0\n        for i in range(m):\n            total = 0\n            for j in s[i]:\n                if pat[j-1] == 1:\n                    total += 1\n            if total %2==p[i]:\n                cnt +=1\n        if cnt == m:\n            result += 1\n    print(result)\n\nabc128c_switches()", "import sys\nsys.setrecursionlimit(10**9)\ninput=sys.stdin.readline\n\nN,M=map(int,input().split())\nlamps=[list(map(lambda x:int(x)-1,input().split()))[1:] for _ in range(M)]\np=list(map(int,input().split()))\n\nans=0\n\n#bit\u5168\u63a2\u7d22\nfor i in range(1<<N):\n  for lamp in range(M):\n    on_sum=0\n    for j in range(N):\n      if i>>j&1 and j in lamps[lamp]:\n        on_sum+=1\n    if on_sum%2 !=p[lamp]:\n      break\n  else:\n    ans+=1\nprint(ans)", "# author:  Taichicchi\n# created: 16.09.2020 23:07:07\n\nimport sys\n\nN, M = list(map(int, input().split()))\n\nk = []\ns = []\n\nfor i in range(M):\n    _k, *_s = list(map(int, input().split()))\n    k.append(_k)\n    s.append(_s)\n\np = list(map(int, input().split()))\nans = 0\n\n\nfor i in range(2 ** N):\n    sw = [0 for _ in range(N)]\n    for j in range(N):\n        if i >> j & 1:\n            sw[j] = 1\n\n    for m in range(M):\n        mod = 0\n        for switch in s[m]:\n            mod += sw[switch - 1]\n        if mod % 2 != p[m]:\n            break\n    else:\n        ans += 1\n\nprint(ans)\n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n  N,M = i_map()\n  K = []\n  for i in range(M):\n    l = i_list()\n    l.pop(0)\n    K.append(l)\n  P = i_list()\n  cnt = 0\n\n  for i in range(2**N):\n    trial = []\n    for j in range(N):\n      if i >> j & 1:\n        trial.append(1)\n      else:\n        trial.append(0)\n    flg = True\n    for h,g in enumerate(K):\n      num = 0\n      for r in g:\n        if trial[r-1] == 1:\n          num += 1\n      if num%2 != P[h]:\n        flg = False\n    if flg == True:\n      cnt += 1\n\n  print(cnt)\n\n\n\n\n\n \n \n\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import product\n\nN, M = list(map(int, input().split()))\nk = []\nS = []\nfor _ in range(M):\n    ks = list(map(int, input().split()))\n    k.append(ks[0])\n    S.append(ks[1:])\np = list(map(int, input().split()))\n\nonoff = list(product([0, 1], repeat = N))\n\nans = 0\nfor i in onoff:\n    cnt = 0\n    for ind, s in enumerate(S):\n        state = 0\n        for o in s:\n            state += i[o-1]\n        if state % 2 == p[ind]:\n            cnt += 1\n    if cnt == M:\n        ans += 1\n\nprint(ans)\n", "n,m = list(map(int, input().split()))\nK = [list(map(int, input().split()))[1:] for _ in range(m)]\np = list(map(int, input().split()))\nans = 0\nfor i in range(2**n):\n    bit = [i>>j&1 for j in range(n)]\n    for j,k in enumerate(K):\n        if p[j] != sum([bit[l-1] for l in k])%2:\n            break\n    else:\n        ans += 1\nprint(ans)\n", "def abc128_c():\n    # n\u500b\u306e\u30b9\u30a4\u30c3\u30c1\u3001m\u500b\u306e\u96fb\u7403\n    N, M = list(map(int, input().split()))\n\n    connected_switches = []\n    for i in range(M):\n        # [k, s1, s2, ...sn][1:]\n        tmp = list(map(int, input().split()))[1:]\n        connected_switches.append(tmp)\n\n    p = list(map(int, input().split()))\n\n    ans = 0\n\n    # \u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614b(ON/OFF)\u3092bit\u3067\u3059\u3079\u3066\u5217\u6319\u3059\u308b\n    for i in range(2 ** N):\n        # \u5404\u96fb\u7403\u304c\u70b9\u706f\u3057\u3066\u3044\u308b\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\n        for j in range(M):\n            on_switch_count = 0\n            # \u30b9\u30a4\u30c3\u30c1\u304c\u3064\u306a\u304c\u3063\u3066\u3044\u3066\u3001\u304b\u3064\u3001on\u306b\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u30ab\u30a6\u30f3\u30c8\n            for k in range(N):\n                # connected_switches[j]\u306b\u306f[s1, s2, ...]\u304c\u5165\u3063\u3066\u3044\u308b\u305f\u3081+1\u304c\u5fc5\u8981\n                if k + 1 in connected_switches[j] and ((i >> k) & 1):\n                    on_switch_count += 1\n\n            # \u96fb\u706f\u3092\u30c1\u30a7\u30c3\u30af\u3057\u3066\u4e00\u3064\u3067\u3082\u3064\u3044\u3066\u3044\u306a\u3044\u3082\u306e\u304c\u3042\u308c\u3070\u305d\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614b\u3067\u306f\u3059\u3079\u3066\u306e\u96fb\u706f\u304c\u4ed8\u304f\u3068\u3044\u3046\u6761\u4ef6\u3092\u6e80\u305f\u305b\u306a\u3044\n            if on_switch_count % 2 != p[j]:\n                break\n            \n            if j == (M - 1):\n                ans += 1\n\n    print(ans)\n\ndef __starting_point():\n    abc128_c()\n\n__starting_point()", "import re\nimport sys\nimport math\nimport itertools\nimport bisect\nimport heapq#.heapify:Priority Queue\u306b\u5909\u63db \n#.heappop:\u6700\u5c0f\u5024\u53d6\u5f97, .heappush:\u8981\u7d20\u633f\u5165\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef get_primenumber(number):#\u7d20\u6570\u5217\u6319\n    prime_list = []\n    search_list = list(range(2,number+1))\n    #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n    while search_list[0] <= math.sqrt(number):\n      #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n      #search_list\u306e\u5148\u982d\u3092prime_list\u306b\u5165\u308c\u3066\u3001\u5148\u982d\u3092\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3057\u3066\u524a\u9664\n        head_num = search_list.pop(0)\n        prime_list.append(head_num)\n        #head_num\u306e\u500d\u6570\u3092\u9664\u53bb\n        search_list = [num for num in search_list if num % head_num != 0]\n    #prime_list\u306bsearch_list\u3092\u7d50\u5408\n    prime_list.extend(search_list)\n    return prime_list\ndef factrization_prime(number):#\u7d20\u56e0\u6570\u5206\u89e3\n    factor = {}\n    div = 2\n    s = math.sqrt(number)\n    while div < s:\n        div_cnt = 0\n        while number % div == 0:\n            div_cnt += 1\n            number //= div\n        if div_cnt != 0:\n            factor[div] = div_cnt\n        div += 1\n    if number > 1:\n        factor[number] = 1\n    return factor\ndef v(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 6)\nmod = 10**9+7\ncnt = 0\nans = 0\nnum = []\ninf = float(\"inf\")\nal = \"abcdefghijklmnopqrstuvwxyz\"\nAL = al.upper()\n\nn,m = I()\nswitch = [l() for _ in range(m)]\np = l()\n\nfor bit in range(2**n):\n    poi = [0]*n\n    for i in range(n):\n        if (bit>>i)&1:\n            poi[i] = 1\n    for j in range(m):\n        ans = 0\n        for k in range(switch[j][0]):\n            if poi[switch[j][k+1]-1] == 1:\n                ans += 1\n        if ans % 2 != p[j]:\n            break\n    else:\n        cnt += 1\nprint(cnt)", "# /usr/bin/python3\n# -*- coding: utf-8 -*-\nfrom queue import Queue\nfrom queue import LifoQueue as Stack\nfrom math import sqrt, floor, ceil, log2, log10, pi\nfrom fractions import gcd\nfrom itertools import permutations, combinations\nfrom operator import itemgetter\nfrom functools import cmp_to_key\nfrom bisect import bisect_left\n\n\nINF=1001001001\n__MOD__=(10**9)+7\nyn = 'YNeos'\njudge = False\ncnt = 0\nans = None\n\n\ndef lcm(a, b):\n    return (a*b) // gcd(a,b)\n\ndef intinput():\n    return int(input())\n\ndef mulinputs():\n    return list(map(int,input().split()))\n\ndef lineinputs(func=intinput):\n    datas = []\n    while True:\n        try:\n            datas.append(func())\n        except EOFError:\n            break\n    return datas\n\ndef bindex(a,x):\n    i = bisect_left(a,x)\n    if i != len(a) and a[i] == x:\n        return i\n    return None\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.r = [-1]*(n+1)\n\n    def root(self, x):\n        if self.r[x] < 0:\n            return x\n        self.r[x] = self.root(self.r[x])\n        return self.r[x]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.r[x] > self.r[y]:\n            x,y = y,x\n        self.r[x] += self.r[y]\n        self.r[y] = x\n        return True\n\n    def size(self, x):\n        return -1 * self.r[self.root(x)]\n\n\nclass ModInt():\n    def __init__(self, x):\n        self.__x = (x % __MOD__)\n    def __add__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((self.__x + other.__x)%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((self.__x + other.__x)%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n    def __radd__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((other.__x + self.__x)%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((other.__x + self.__x)%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n\n    def __sub__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((self.__x - other.__x)%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((self.__x - other.__x)%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n    def __rsub__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((other.__x - self.__x)%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((other.__x - self.__x)%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n\n    def __mul__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((self.__x * other.__x)%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((self.__x * other.__x)%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n    def __rmul__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((other.__x * self.__x)%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((other.__x * self.__x)%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n\n    def __truediv__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((self.__x * other.__modinv())%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((self.__x * other.__modinv())%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n    def __rtruediv__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__((other.__x * self.__modinv())%__MOD__))\n        elif type(other) == ModInt:\n            return self.__class__((other.__x * self.__modinv())%__MOD__)\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n\n    def __pow__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__(pow(self.__x, other.__x, __MOD__)))\n        elif type(other) == ModInt:\n            return self.__class__(pow(self.__x, other.__x, __MOD__))\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n    def __rpow__(self, other):\n        if type(other) == int:\n            other = self.__class__(other)\n            return int(self.__class__(pow(other.__x, self.__x, __MOD__)))\n        elif type(other) == ModInt:\n            return self.__class__(pow(other.__x, self.__x, __MOD__))\n        else:\n            raise Exception(\"Not Int or Not ModInt\")\n\n    def __modinv(self, m=__MOD__):\n        a = self.__x\n        if a == 0:\n            raise ZeroDivisionError()\n        if gcd(a, m) != 1:\n            raise Exception(\"%s\u306e\u9006\u6570\u306f\u6c42\u307e\u308a\u307e\u305b\u3093\u3002\" % a)\n        b, u, v = m, 1, 0\n        while b != 0:\n            t = a//b;\n            a -= t*b\n            a, b = b, a\n            u -= t * v\n            u, v = v, u\n        u %= m\n        if u < 0:\n            u += m\n        return u\n    def __int__(self):\n        return self.__x\n    def __str__(self):\n        return str(self.__x)\n\n\n\ndef __starting_point():\n    N, M = mulinputs()\n    ks, ss, ps = [], [], []\n    for _ in range(M):\n        k, *s = list(mulinputs())\n        ks.append(k)\n        ss.append(s)\n    ps = list(mulinputs())\n\n    cnt = 0\n    for n in range((1<<N)):\n        state = [0] * N\n        for j in range(N):\n            state[j] = (n&(1<<j))>>j\n        is_light = True\n        for j in range(M):\n            icnt = 0\n            for s in ss[j]:\n                icnt += state[s-1]\n            if icnt%2 != ps[j]:\n                is_light = False\n                break\n        if is_light:\n            cnt+=1\n\n    # \u51fa\u529b\n    print(cnt)\n\n\n__starting_point()", "n, m = map(int, input().split())\nks = [list(map(int, input().split())) for i in range(m)]\np = list(map(int, input().split()))\nans = 0\n\nfor i in range(2**n):\n    judge = True\n    switch = [('off') for _ in range(n)]\n    for j in range(len(switch)):\n        if (i >> j) & 1:\n            switch[j] = 'on'\n    for k in range(m):\n        count = 0\n        for l in range(ks[k][0]):\n            if switch[ks[k][l+1]-1] == 'on':\n                count += 1\n        if count % 2 != p[k]:\n            judge = False\n            break\n    if judge == True:\n        ans += 1\n\nprint(ans)", "N, M = list(map(int, input().split()))\nSwitch = [list([int(a) - 1 for a in input().split()])[1:] for i in range(M)]\nP = list(map(int, input().split()))\nfrom itertools import product\n\nTarget = product([0, 1], repeat=N)\nans = 0\nfor T in Target:\n    akari = []\n    for i, S in enumerate(Switch):\n        temp = 0\n        for s in S:\n            a = T[s]\n            if a == 1:\n                temp += 1\n        akari.append(temp)\n    isOK = True\n    for j, ak in enumerate(akari):\n        if ak % 2 != P[j]: isOK = False\n    if isOK:\n        ans += 1\nprint(ans)\n", "from itertools import product\nn,m = list(map(int, input().split()))\nS = []\nfor _ in range(m):\n    k, *s = list(map(int, input().split()))\n    S.append(s)\np = list(map(int, input().split()))\n\nans = 0\nfor pattern in product(range(2), repeat=n):\n    # \u96fb\u7403\u304c\u3064\u304f\u304b\u30c1\u30a7\u30c3\u30af\n    for x,y in zip(S, p):\n        on_cnt = sum([pattern[s-1] == 1 for s in x])\n        if on_cnt % 2 != y:\n            break\n    else:\n        ans += 1\n\nprint(ans)", "import copy\n\ndef dfs(i,lst):\n    nonlocal ans\n    if i==n:\n        ans.append(lst)\n        return\n    tmp1 = copy.copy(lst)\n    tmp1.append(0)\n    dfs(i+1,tmp1)\n    tmp2 = copy.copy(lst)\n    tmp2.append(1)\n    dfs(i+1,tmp2)\n\nn,m = map(int,input().split())\nans = []\ntmp = [0]\ndfs(0,tmp)\n#print(ans)\ns = []\nk = []\nfor i in range(m):\n    tmp = list(map(int,input().split()))\n    k.append(tmp[0])\n    s.append(tmp[1:])\np = list(map(int,input().split()))\n#print(k)\n#print(s)\n#print(p)\ncnt = 0\nfor i in range(len(ans)):\n    cnt_i = 0\n    for mi in range(m):\n        sum_s = 0\n        for ki in range(len(s[mi])):\n            sum_s += ans[i][s[mi][ki]]\n        if sum_s%2==p[mi]:\n            cnt_i += 1\n    if cnt_i==m:\n        cnt += 1\nprint(cnt)", "n,m = map(int,input().split())\na = [list(map(int,input().split())) for _ in range(m)]\np = list(map(int,input().split()))\nans = 0\nfor i in range(2**n):\n    onoffs = [int(j) for j in list(bin(i)[2:].zfill(n))]\n    Flag = True\n    for lamp in range(m):\n        k = a[lamp][0]\n        info = [l - 1 for l in  a[lamp][1:]]\n        tmp = 0\n        for index in info:\n            if onoffs[index]:\n                tmp += 1\n        if tmp % 2 != p[lamp]:\n            Flag = False\n            break\n    if Flag:\n        ans += 1\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int,input().split())\nks = list(list(map(int,input().split())) for _ in range(m))\np = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(2 ** n):\n  c = [False] * n\n  for j in range(n):\n    if (i >> j) & 1: c[j] = True\n  for j in range(m):\n    count, l = 0, ks[j][0]\n    for k in range(l):\n      if c[ks[j][k+1]-1]: count += 1\n    if count % 2 != p[j]: break\n  else: ans += 1\n\nprint(ans)", "3\n#coding: utf-8\n\nN, M = (int(x) for x in input().split())\n\nS = []\nfor i in range(M):\n    S.append([int(x)-1 for x in input().split()][1:])\nP = [int(x) for x in input().split()]\n\nret = 0\nfor bit in range(2**N):\n    on = [i for i in range(N) if bit & (1 << i)]\n    if all(sum(1 for switch in S[i] if switch in on) % 2 == P[i] for i in range(M)):\n        ret += 1\nprint(ret)\n", "import itertools\n\nN,M = list(map(int, input().split()))\nA = []\n\nfor m in range(M):\n    a = list(map(int, input().split()))\n    A.append(a[1:])\n\nP = list(map(int, input().split()))\n\nS = itertools.product([0,1],repeat=N)\nans = 0\n\nfor s in S:\n    flag = True\n    for i in range(M):\n        temp = 0\n        for a in A[i]:\n            temp += s[a-1]\n        if temp % 2 != P[i]:\n            flag = False\n    if flag == True:\n        ans += 1\n\nprint(ans)\n", "import copy\n\nn, m = list(map(int, input().split()))\ns = []\n\nfor i in range(m):\n    st = list(map(int, input().split()))\n    s.append([0]+st)\n\n\np = list(map(int, input().split()))\nans = 0\n\n# \u5168bit\u63a2\u7d22\nfor i in range(2**(n)):\n    lst = copy.deepcopy(s) # list \u306e\u30b3\u30d4\u30fc\u306b\u306fcopy.copy()\u3092\u7528\u3044\u308b(2\u91cd\u914d\u5217\u4ee5\u4e0a\u306fdeepcopy()\u3092\u7528\u3044\u308b)\n    flag = True\n    for j in range(n):\n        if i >> j & 1 == 1:\n            for k in lst:\n                for l in range(2, k[1]+2):\n                    if k[l]-1 == j:\n                        k[0] += 1\n    # \u5076\u6570\u5947\u6570\u304c\u5408\u3048\u3070 ans+=1\n    for b in range(len(p)):\n        if p[b] != lst[b][0]%2:\n            flag = False\n    if flag == True:\n        ans +=1\n\nprint(ans)", "n,m=map(int,input().split())\ns=[[x for x in map(int,input().split())]for _ in range(m)]\np=list(map(int,input().split()))\nans=0\nfor i in range(1<<n):\n  c=1\n  for j in range(m):\n    t=0\n    for k in range(1,s[j][0]+1):\n      if (i>>(s[j][k]-1))&1==1:\n        t+=1\n    if t%2!=p[j]:\n      c=0\n      break\n  if c:\n    ans+=1\nprint(ans)", "n,m=map(int, input().split())\ns=[]\nfor i in range(m):\n    tmp=list(map(int, input().split()))\n    s.append(tmp[1:])\np=list(map(int, input().split()))\nans=0\nfor i in range(2**n):\n    tmp=[0]*m\n    for j in range(n):\n        if ((i>>j) & 1):\n            for k in range(m):\n                if j+1 in s[k]:\n                    tmp[k]+=1\n    for t in range(m):\n        if p[t]!=tmp[t]%2:\n            break\n    else:\n        ans+=1\nprint(ans)", "n,m = map(int,input().split())\nline = []\nfor i in range(m):\n  k,*s = map(int,input().split())\n  line.append(list(s))\np = list(map(int,input().split()))\n\nans = 0\nfor bit in range(1<<n):\n  switch = [0]*(n+1)\n  tf = 1\n  for i in range(n):\n    if (bit>>i)&1:\n      switch[i+1] = 1\n  for i in range(m):\n    cnt = 0\n    for v in line[i]:\n      if switch[v]:\n        cnt += 1\n    if cnt%2!=p[i]:\n      tf = 0\n  if tf:\n    ans += 1\nprint(ans) ", "n, m = map(int, input().split(' '))\nK = []\nS = []\nfor i in range(m):\n    l = list(map(int, input().split(' ')))\n    K.append(l[0])\n    S.append(l[1:])\np = list(map(int, input().split(' ')))\nans = 0\nfor i in range(2**n):\n    light = 0\n    for j in range(m):\n        sw = 0\n        for s in S[j]:\n            if (i>>(s-1))&1:\n                sw += 1\n        if sw%2 == p[j]:\n            light+=1\n    if light == m:\n        ans += 1\nprint(ans)", "from itertools import combinations\nn, m = map(int, input().split())\nksm = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nonoff = [0]*n\ntotal = 0\ndef dfs(i, onoff):\n    nonlocal total\n    if i == n:\n        flag = True\n        for idx, j in enumerate(ksm):\n            count = 0\n            for k in j[1:]:\n                count += onoff[k-1]\n            if count%2 != p[idx]:\n                flag = False\n        if flag:\n            total += 1\n        return\n    dfs(i+1, onoff[:])\n    dfs(i+1, onoff[:i]+[1]+onoff[i+1:])\n\ndfs(0, onoff)\nprint(total)", "n,m = map(int, input().split(\" \"))\nks = [list(map(int, input().split(\" \"))) for i in range(m)]\np = list(map(int, input().split(\" \")))\ntotal = 0\nfor i in range(2 ** n):\n  count = 0\n  den = [0 for i in range(m+1)]\n  for j in range(n):\n    if i >> j & 1:\n      for k in range(m):\n        #print(i, j+1, ks[k][1:])\n        if j+1 in ks[k][1:]:\n          den[k+1] += 1\n  #print(i, den)\n  for j in range(m):\n    if den[j+1] % 2 == p[j]:\n      count += 1\n  if count == m:\n    total += 1\nprint(total)", "N, M = map(int, input().split())\ns = [list(map(lambda x:int(x)-1, input().split()[1:])) for _ in range(M)]\np = list(map(int, input().split()))\n \nans = 0\nfor i in range(2**N): # \u5168\u3066\u306e\u30b9\u30a4\u30c3\u30c1\u306e (on, off) \u306e\u7d44\u307f\u5408\u308f\u305b\n  # \u96fb\u7403j\u304c\u70b9\u706f\u3059\u308b\u6761\u4ef6\uff1a\u7e4b\u304c\u3063\u3066\u3044\u308bk_j\u500b\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u3046\u3061\u3001on\u306e\u500b\u6570\u30922\u3067\u5272\u3063\u305f\u4f59\u308a\u304cp_j\u306b\u7b49\u3057\u3044\n  bulb_num = 0 # \u70b9\u706f\u3059\u308b\u96fb\u7403\u306e\u500b\u6570\n  for j in range(M): # \u3042\u308b (on, off) \u306e\u7d44\u306b\u304a\u3044\u3066\u3001\u70b9\u706f\u3059\u308b\u96fb\u7403\u306e\u500b\u6570\u3092\u6c42\u3081\u308b\n    on_num = 0 # \u96fb\u7403j\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u3046\u3061\u3001on\u306e\u500b\u6570\n    for k in range(N):\n      # \u30b9\u30a4\u30c3\u30c1k\u304con \u304b\u3064\u3001\u96fb\u7403j\u3068\u30b9\u30a4\u30c3\u30c1k\u304c\u7e4b\u304c\u3063\u3066\u3044\u308b\u306a\u3089\u3070\uff1a\n      if i >> k & 1 and k in s[j]: on_num += 1\n    if (on_num - p[j]) % 2 == 0: bulb_num += 1\n  if bulb_num == M: ans += 1\n    \nprint(ans)", "n,m = list(map(int,input().split()))\nks = [list(map(int,input().split())) for i in range(m)]\np = list(map(int,input().split()))\n\n\nans = 0\nfor i in range(2**n):\n    s = 0\n    for j in range(m):\n        c = 0\n        for k in range(len(ks[j])-1) :\n            if ((i >> (ks[j][k+1]-1)) & 1) :\n                c += 1\n        if c % 2 == p[j]:\n            s += 1\n    if s == m :\n        ans += 1\n\nprint(ans)\n", "from itertools import product\n\nn, m = map(int, input().split())\nswitches = []\nfor _ in range(m):\n    x = list(map(int, input().split()))[1:]\n    temp = []\n    for i in range(n):\n        if i + 1 in x:\n            temp.append(1)\n        else:\n            temp.append(0)\n    switches.append(temp)\np = list(map(int, input().split()))\n\nans = 0\nfor on_off in product([1, 0], repeat=n):\n    flag = 1\n    for i, switch in enumerate(switches):\n        cnt = 0\n        for x, y in zip(on_off, switch):\n            if x == 1 and y == 1:\n                cnt += 1\n        if cnt % 2 != p[i]:\n            flag = 0\n    if flag:\n        ans += 1\n\nprint(ans)", "N = None\nM = None\nS = []\nP = []\n\ndef __starting_point():\n    N, M = map(int, input().split())\n    for _ in range(M):\n        row = list(map(int, input().split()))[1:]\n        S.append(row)\n    P = list(map(int, input().split()))\n    ans = 0\n    for bit in range(1<<N):\n        on_switches = []\n        light = 0\n        for i in range(N):\n            if bit>>i&1:\n                on_switches.append(i)\n        for i in range(M):\n            cnt = 0\n            for s in S[i]:\n                for on_switch in on_switches:\n                    if s==on_switch+1:\n                        cnt += 1\n            if cnt%2==P[i]:\n                light += 1\n        if light==M:\n            ans += 1\n    print(ans)\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef slove():\n    N, M = map(int,input().split())\n    light = []\n    for i in range(M):\n        connecting_sw = list(map(int,input().split()))\n        light.append(connecting_sw[1:])\n    on = list(map(int,input().split()))\n    #print(light)\n    #print(on)\n\n    ans = 0\n    for i in range(1 << N):\n        light_on = [0]*M\n        for j in range(N):\n            if i >> j & 1:\n                a = 0\n                for item in light:\n                    if j+1 in item:\n                        light_on[a] = (light_on[a]+1)%2\n                    a += 1\n        #print(light_on)\n        a = 0\n        for i in range(M):\n            if on[i] == light_on[i]:\n                a += 1\n                continue\n            break\n        if a == M:\n            ans += 1\n\n    print(ans)\n    \ndef __starting_point():\n    slove()\n__starting_point()", "n, m = map(int,input().split())\nk, s = [], []\nfor i in range(m):\n  inp = list(map(int, input().split()))\n  k_, s_ = inp[0], inp[1:]\n  k.append(k_)\n  s.append(s_)\np = list(map(int, input().split()))\nans = 0\nfor bit in range(1<<n):\n  flg = True\n  for i in range(m):\n    cnt = 0\n    for e in s[i]:\n      e -= 1\n      if bit & 1<<e: cnt += 1\n    if cnt%2 != p[i]: flg = False\n  if flg: ans += 1\nprint(ans)", "n,m=map(int,input().split())\np=2\n\nfrom itertools import product\niterator=product(range(p),repeat=n)\n\ns=[0 for i in range(m)]    \nfor i in range(m):\n    S=list(map(int,input().split()))\n    k=S[0]\n    s[i]=S[1:]\n\np=list(map(int,input().split()))\n\nans=0\nfor idxs in iterator:\n    tmp1=0\n    for i in range(m):\n        tmp2=0\n        for j in s[i]:\n            tmp2+=idxs[j-1]\n        if tmp2%2==p[i]:\n            tmp1+=1\n    if tmp1==m:\n        ans+=1\nprint(ans)", "n, m = map(int, input().split())\ns_lis = []\n\n#ON/OFF\u306e\u30d1\u30bf\u30fc\u30f3\nfor i in range(2 ** n) :\n    lis = []\n    for j in range(len(bin(2 ** n)) - 3) :\n        if (i >> j) & 1 :\n            lis.append(1)\n        else:\n            lis.append(0)\n    \n    s_lis.append(lis)\n\n#\u5404\u96fb\u7403\u306e\u63a5\u7d9a\nb_lis = []\nfor k in range(m) :\n    b_lis.append(list(map(int, input().split())))\n\n#\u70b9\u706f\u6761\u4ef6\nlight = list(map(int, input().split()))\n\n#\u5404\u96fb\u7403\u306e\u5408\u8a08\ncnt = 0\nfor s in s_lis :\n    c_lis = []\n    for b in b_lis :\n        c = 0\n        for x in range(b[0]) :\n            c += s[b[x + 1] - 1]\n        c_lis.append(c)\n    \n    c_lis = list(map(lambda y : y % 2, c_lis))\n    if c_lis == light :\n        cnt += 1\n\nprint(cnt)", "from itertools import product, repeat\nimport numpy as np\n\ninput_row = lambda : [int(_) for _ in input().split(' ')]\n\nN, M = input_row()\nC = np.zeros((M, N), dtype=np.int32)\n\nfor i in range(M):\n    s = np.array(input_row()[1:]) # ignore k\n    C[i, s-1] = 1 # s_ to zero index.\n\np = input_row()\n\nall_on_num = 0\nfor S_ in product(*(repeat([1, 0], N))):\n    S = np.array(S_)\n\n    L = C.dot(S)%2 == p\n\n    if len(L[L == True]) == M:\n        all_on_num += 1\nprint(all_on_num)\n\n", "\nall_input=[] #append\u306e\u305f\u3081\u306b\u5ba3\u8a00\u304c\u5fc5\u8981\nwhile True:\n    try:\n        all_input.append(list(map(int,input().split())))\n    except:\n        break;\n        #\u307e\u305f\u306f\u3001return,os.return\u3092\u3057\u3066\u6b62\u3081\u308b\u3002\n\nN, M = all_input[0][0], all_input[0][1]\np = all_input[-1]\nall_input.pop(0), all_input.pop(-1)\nswitch = [all_input[i][1:] for i in range(M)]\nnum_switch = [all_input[i][0] for i in range(M)]\n\nall_on = 0\nfor i in range(2**N):\n    num_light_on = 0 # M\u500b\u306e\u96fb\u7403\u306e\u3046\u3061\uff0c\u70b9\u706f\u3059\u308b\u3082\u306e\u306e\u500b\u6570\u3092increment\u3059\u308b\n    for m in range(M):\n        switch_on = 0\n        for j in range(N):\n            if (i >> j) & 1:\n                if j+1 in switch[m]:\n                    switch_on += 1\n        if switch_on % 2 == p[m]:\n            num_light_on += 1\n    if num_light_on == M:\n        all_on += 1\nprint(all_on)\n\n", "from itertools import combinations\n\ndef getval():\n    n,m = map(int,input().split())\n    s = [list(map(int,input().split())) for i in range(m)]\n    for i in range(m):\n        for j in range(1,s[i][0]+1):\n            s[i][j] -= 1\n    p = list(map(int,input().split()))\n    return n,m,s,p \n\ndef main(n,m,s,p):\n    l = [[] for i in range(n)]\n    for i in range(m):\n        for j in range(1,s[i][0]+1):\n            l[s[i][j]].append(i)\n    ans = 0\n    for i in range(n+1):\n        for c in combinations(range(n),i):\n            temp = [0 for i in range(m)]\n            for j in c:\n                for k in l[j]:\n                    temp[k] += 1\n                    temp[k] %= 2\n            if temp==p:\n                ans += 1\n    print(ans)\n\ndef __starting_point():\n    n,m,s,p = getval()\n    main(n,m,s,p)\n__starting_point()", "n,m = list(map(int,input().split()))\nlight = [list(map(int,input().split())) for _ in range(m)]\nlighton = list(map(int,input().split()))\nswicth = []\n\nfor i in range(2**n):\n    a = [0]*n\n    for j in range(n):\n        if (i>>j)&1:\n            a[j] = 1\n    swicth.append(a)\n\nans = 0\n\nfor x in swicth:\n    for y in range(m):\n        b = light[y][1:]\n        total = 0\n        for z in b:\n            total += x[z-1]\n        if total%2 != lighton[y]:\n            break\n    else:\n        ans += 1\n\nprint(ans)\n\n", "# cs: c nnected switches\nn, m = list(map(int, input().split()))\n\ndef get_connected_switches():\n    # k s1 s2 .. sn\n    lst = list(map(int, input().split()))\n    lst.pop(0) # k is not use\n    return list([1<<(d-1) for d in lst])\n\n# cs: connected switches\ncs = [get_connected_switches() for _ in range(m)]\nps = list(map(int, input().split()))\n\n# bit\u5168\u63a2\u7d22(0: \u3059\u3079\u3066off\u306f\u4e0d\u8981)\nans = 0\n# on: 0:\u6d88\u3048\u3066\u308b\u30011:\u70b9\u3044\u3066\u308b\n# 10: 1 2  3   4 \n# 0b: 1 10 11, 100..\nfor on in range(2**n):\n    ok = True\n    for i in range(m):\n        ct = 0\n        for s in cs[i]:\n            if s&on: ct += 1\n        if ct%2 != ps[i]:\n            ok = False\n    if ok:\n        ans += 1\nprint(ans)\n", "N, M = list(map(int, input().split()))\nk = []\ns = []\nfor i in range(M):\n    a = list(map(int, input().split()))\n    k.append(a[0])\n    s.append(a[1:])\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(1<<N):\n    ri_count = 0\n    for j in range(M):\n        sw_count = 0\n        for l in range(k[j]):\n            if i>>(s[j][l]-1) & 1:\n                sw_count += 1\n        if sw_count%2 == p[j]:\n            ri_count += 1\n    if ri_count == M:\n        ans += 1\nprint(ans)\n", "\nn, m = list(map(int, input().split(' ')))\nk = []\ns = []\nfor i in range(m):\n    a = list(map(int, input().split(' ')))\n    k.append(a[0])\n    s.append(a[1:])\np = list(map(int, input().split(' ')))\nans = 0\nfor i in range(2**n):\n    ri_cnt = 0\n    for j in range(m):\n        sw_cnt = 0\n        for l in range(k[j]):\n            if (i >> (s[j][l]-1)) & 1:\n                sw_cnt += 1\n        if sw_cnt % 2 == p[j]:\n            ri_cnt += 1\n    if ri_cnt == m:\n        ans += 1\nprint(ans)\n", "N,M=map(int,input().split())\nk=[]\ns=[]\nfor i in range(M):\n    ks=list(map(int,input().split()))\n    k.append(ks[0])\n    s.append(list(map(lambda x:x-1,ks[1:])))\np=list(map(int,input().split()))\n\nans=0\nfor i in range(2**N):\n    isOK=True\n\n    for j in range(M):\n        sum=0\n        for x in s[j]:\n            sum+=(i>>x)&1\n        \n        if sum%2!=p[j]:\n            isOK=False\n    \n    if isOK:\n        ans+=1\n\nprint(ans)", "def light(l,i):\n    k=1<<(i-1)\n    if l&k:\n        return 1\n    else:\n        return 0\n\nN, M = map(int,input().split())\ns=list()\nfor j in range(0,M):\n    s.append(0)\nfor j in range(0,M):\n    s[j]=list(map(int,input().split()))\np=list(map(int,input().split()))\n\na=0\nfor l in range(0,1<<N):\n    b=0\n    for j in range(0,M):\n        c=0\n        for i in range(1,s[j][0]+1):\n            c+=light(l,s[j][i])\n        if c%2==p[j]:\n            b+=1\n    if b==M:\n        a+=1\nprint(a)", "n, m = map(int, input().split())\nbulbs = []\nans = 0\nfor i in range(m):\n    c = tuple(map(int, input().split()))\n    bulbs.append(c[1:])\np = list(map(int, input().split()))\nfor i in range(2 ** n):\n    cnt = 0\n    for j, bulbs_sub in enumerate(bulbs):\n        switch_on = 0\n        for l in bulbs_sub:\n            if i >> (l-1) & 1:\n                switch_on += 1\n        if switch_on % 2 == p[j]:\n                cnt += 1\n    if cnt == m:\n        ans += 1\nprint(ans)", "N, M = list(map(int, input().split()))\n\ns_lst = [[False] * N for _ in range(M)]\nfor i in range(M):\n    ks = list(map(int, input().split()))\n    for j, value in enumerate(ks):\n        if j != 0:\n            s_lst[i][value-1] = True\np = list(map(int, input().split()))\n# print(s_lst)\n\nans = 0\nfor bit in range(2**N):\n    cnt = [0] * M\n    for i in range(N):\n        if (bit>>i) & 1 == 1:\n            for j in range(M):\n                if s_lst[j][i]:\n                    cnt[j] += 1\n    flug = True\n    for i in range(M):\n        if cnt[i] % 2 != p[i]:\n            flug = False\n    if flug:\n        ans += 1\nprint(ans)\n", "n,m = map(int, input().split())\nks = []\nss = []\nfor _ in range(m):\n    row = list(map(lambda x: int(x)-1, input().split()))\n    ks.append(row[0]+1)\n    ss.append(row[1:])\nps = list(map(int, input().split()))\n\ndef is_bulb_on(bits, i):\n    cnt = 0\n    for s in ss[i]:\n        if bits[s]:\n            cnt += 1\n    return cnt % 2 == ps[i]\n\ndef are_all_bulb_on(bits):\n    good = True\n    i = 0\n    while good and i < m:\n        good &= is_bulb_on(bits, i)\n        i += 1\n    return good\n\ndef rec(bits, i):\n    if i == n:\n        return 1 if are_all_bulb_on(bits) else 0\n    cnt = 0\n    cnt += rec(bits, i+1)\n    bits[i] = 1\n    cnt += rec(bits, i+1)\n    bits[i] = 0\n    return cnt\n\nbits = [0]*n\nprint(rec(bits, 0))", "from itertools import product\n\n\nn,m = map(int, input().split())\n\nswitch = []\n\nfor i in range(m):\n  k, *s = map(int, input().split())\n  s = list(s)\n  switch.append(s)\n\np = list(map(int, input().split()))\nans = 0\n\nfor i in product(range(2), repeat=n):\n  flag = True\n  for s in range(m):\n    cnt = 0\n    for t in switch[s]:\n      if i[t-1] == 1:\n        cnt += 1\n    if cnt % 2 != p[s]:\n      flag = False\n      break\n  if flag == True:\n    ans += 1\n\nprint(ans)", "N,M=map(int, input().split())\nks=[list(map(int, input().split()))[1:] for _ in range(M)]\nP=list(map(int, input().split()))\ntemp=[0]*M\n\nans=0\n\nfor i in range(2**N):\n\ttemp=[0]*M\n\tfor h in range(N):\n\t\tif i>>h & 1:\n\t\t\tfor g in range(M):\n\t\t\t\tif h+1 in ks[g]:\n\t\t\t\t\ttemp[g]+=1\n\tfor k in range(M):\n\t\ttemp[k]=temp[k]%2\n\tif temp==P:\n\t\tans+=1\n\t\n\t#print(temp)\n\nprint(ans)", "n,m = map(int, input().split(\" \"))\nks = [list(map(int, input().split(\" \"))) for i in range(m)]\np = list(map(int, input().split(\" \")))\ntotal = 0\nfor i in range(2 ** n):\n  count = 0\n  den = [0 for i in range(m+1)]\n  for j in range(n):\n    if i >> j & 1:\n      for k in range(m):\n        #print(i, j+1, ks[k][1:])\n        if j+1 in ks[k][1:]:\n          den[k+1] += 1\n  #print(i, den)\n  for j in range(m):\n    if den[j+1] % 2 == p[j]:\n      count += 1\n  if count == m:\n    total += 1\nprint(total)", "N, M = list(map(int, input().split()))\nS = [0]*M\nanswer = 0\n\nfor i in range(M):\n    S[i] = list(map(int, input().split()))\n\nP = list(map(int, input().split()))\n\nfor i in range(2**N):\n    mb = '0' + str(N) + 'b'\n    bi = format(i, mb)\n    count = 0\n    for j in range(M):\n        on = 0\n        for k in range(S[j][0]):\n            on += int(bi[-S[j][k+1]])\n        if on%2 == P[j]:\n            count += 1\n    if count == M:\n        answer += 1\n\nprint(answer)", "from itertools import product, repeat\nimport numpy as np\n\ninput_row = lambda : [int(_) for _ in input().split(' ')]\n\nN, M = input_row()\nC = np.zeros((M, N), dtype=np.int32)\n\nfor i in range(M):\n    s = input_row()[1:]\n    for s_ in s:\n        C[i, s_-1] = 1\n\np = input_row()\n\nall_on_num = 0\n\nfor S_ in product(*(repeat([1, 0], N))):\n    S = np.array(S_)\n\n    L = C.dot(S)%2 == p\n    L_on = L[L == True]\n    all_on = len(L_on) == M\n\n    if all_on:\n        all_on_num += 1\nprint(all_on_num)\n\n", "import math\nN, M = list(map(int, input().split()))\nswitch = [0] * N\npattern = 2 ** N\nans = 0\nfor i in range(M):\n  temp = input().split()[1:]\n  for j in temp:\n    switch[int(j) - 1] += (1 << i )\n  \np = list(map(int, input().split()))\npbin = 0\ntemp = 1\nfor i in p:\n  pbin += i * temp\n  temp *= 2\n\nfor i in range(pattern):\n  temp = 0\n  j = 0\n  while i > 0:\n    if i & 1 == 1 :\n      temp = temp ^ switch[j]\n    j += 1\n    i = i >> 1\n  if pbin == temp:\n    ans += 1\nprint(ans)\n", "n, m = list(map(int, input().split()))\nk = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**n):\n    light = 0\n    for ki, j in enumerate(k):\n        switch = 0\n        for s in j[1:]:\n            if i >> (s-1) & 1:\n                switch += 1\n        if switch % 2 == p[ki]:\n            light += 1\n    if light == m:\n        ans += 1\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\n\nn,m=MI()\nsws=[]\nfor i in range(m):\n    sws.append(list(map(int,input().split())))\n#print(sws)\nps=LI()\nans=0\nfor i in range(2**n):\n    count=0\n    for j in range(m):\n        sm=0\n        for k in range(1,len(sws[j])):\n            sm+= (i>>(sws[j][k]-1)) %2\n        #print(sm)\n        if sm%2==ps[j]:\n            count+=1\n    if count==m:\n        ans+=1\nprint(ans)\n", "n,m = list(map(int,input().split()))\nl = []\nfor i in range(1 << n):\n    tmp = str(bin(i))[2:]\n    l.append(tmp.zfill(n))\nK = [list(map(int,input().split())) for _ in range(m)]\nP = list(map(int,input().split()))\n#print(P)\nans = 0\n#print(\"----\")\nfor i in range(len(l)):\n    #\u30b9\u30a4\u30c3\u30c1\u306e\u72b6\u614bl[i]\n    #\u4ed8\u3044\u3066\u3044\u308b\u96fb\u7403\u306e\u30ea\u30b9\u30c8O\n    O = []\n    for j in range(m):\n        #\u96fb\u7403\u306e\u304d\u306b\u306a\u308b\u3059\u3044\u3063\u3061\u306e\u6570K[j][0]\n        ON = 0\n        for ii in range(K[j][0]): #\u30b9\u30a4\u30c3\u30c1\u306e\u30ea\u30b9\u30c8\n            if l[i][K[j][ii+1] - 1] == \"1\":\n                ON += 1\n        if ON % 2 == P[j]:\n            O.append(1)\n        else:\n            O.append(0)\n    if sum(O) == m:\n        #print(l[i])\n        ans += 1\nprint(ans)\n\n", "def f(i):\n    if i == n:\n        on = [0] * m\n        for j in range(m):\n            for k in range(1, s[j][0] + 1):\n                if t[s[j][k] - 1]:\n                    on[j] += 1\n        for j in range(m):\n            if not on[j] % 2 == p[j]:\n                return\n        nonlocal ans\n        ans += 1\n        return\n    t[i] = 1\n    f(i + 1)\n    t[i] = 0\n    f(i + 1)\n    return\n\nn, m = map(int, input().split())\ns = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\nans = 0\nt = [0] * n\nf(0)\nprint(ans)", "n,m = map(int, input().split())\ns = [list(map(lambda x: int(x)-1, input().split()))[1:] for _ in range(m)]\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**n):\n  for x,y in zip(s,p):\n    flag = False\n    for a in x:\n      if i>>a&1: flag = not flag\n    if int(flag) != y: break\n  else: ans += 1\nprint(ans)", "import sys\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n#bit\u5168\u90e8\u4f5c\u3063\u3066\u308b\n#bit = [i>>j&1 for j in range(N)]\n\nn,m=MI()\nlights=[LI() for _ in range(m)]\np_list=LI()\n\nbit_list=[]\ncount=0\nfor i in range(2**n):\n    bit = [i>>j&1 for j in range(n)]\n    flag=0\n    for j in range(m):\n        ki=lights[j][0]\n        onswitch=0\n        for k in range(1,ki+1):\n            si=lights[j][k]\n            onswitch+=bit[si-1]\n        if onswitch%2!=p_list[j]:\n            flag+=1\n    if flag==0:\n        count+=1\nprint(count)", "N,M = map(int,input().split())\nconditions = []\nfor i in range(M):\n    conditions.append(list(map(int,input().split()))[1:])\ncompair = list(map(int, input().split()))\n\nmaster_list = []\nfor i in range(2 ** N):\n    target = list(map(int,'{:010b}'.format(i)))[-N:]\n    master_list.append(target)\n    \nresult_list = []\nfor i in master_list:\n    prepair_line = []\n    for j in conditions:\n        total = 0\n        for k in j:\n            total += i[k-1]\n        prepair_line.append(total % 2)\n    result_list.append(prepair_line)\n\ncnt = 0\nfor i in result_list:\n    if compair == i:\n        cnt += 1\n\nprint(cnt)", "import itertools\nN,M = map(int,input().split())\nSwitch = []\nfor i in range(M):\n    Swi = list(map(int,input().split()))\n    S = Swi[0]\n    Switch.append(Swi[1:S+1])\nPlist = list(map(int,input().split()))\nAns = 0\nL = [0,1]\nc_list = list(itertools.product(L, repeat=N))\nfor comb in c_list:\n    for i in range(M):\n        Jud = 0\n        Swi = Switch[i]\n        for j in Swi:\n            Jud += comb[j-1]\n        if Jud%2 != Plist[i]:\n            break\n        elif i == M-1:\n            Ans += 1\nprint(Ans)", "#!/usr/bin/env python3\n\n#import\n#import math\n#import numpy as np\nN, M = list(map(int, input().split()))\n\nK = {i: [] for i in range(M)}\nfor i in range(M):\n    t = list(map(int, input().split()))\n    for j in range(1, len(t)):\n        K[i].append(t[j] - 1)\n\nP = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(2 ** N):\n    switch = [False] * N\n    for j in range(N):\n        if (i >> j) & 1:\n            switch[j] = True\n\n    isok = True\n    for m in range(M):\n        t = 0\n        for k in K[m]:\n            if switch[k]:\n                t += 1\n\n        if (t % 2) != P[m]:\n            isok = False\n\n    if isok:\n        ans += 1\n\nprint(ans)\n\n\n", "N, M = map(int, input().split())\nA = [[0 for _ in range(N)] for _ in range(M)]\nfor i in range(M):\n    S = list(map(int, input().split()))\n    for j in S[1:]: \n        A[i][j-1] = 1\n\nP = list(map(int, input().split()))\n\nans = 0\nfor bit in range(2**N):\n    b = bin(bit)[2:].zfill(N)\n    X = [0] * M\n    for i in range(M):\n        for j in range(N):\n            if A[i][j] == 1 and b[j] == '1':\n                X[i] = (X[i] + 1) % 2\n\n    tmp = 0\n    for i in range(M):\n        if P[i] == X[i]:\n            tmp += 1\n    \n    if tmp == M: \n        ans += 1\n\nprint(ans)", "n,m = list(map(int,input().split()))\nks = [[int(i) for i in input().split()] for _ in range(m)]\np = list(map(int,input().split()))\n\nans=0\nfor i in range(2**n):\n    sw=[]\n    on=0\n    for j in range(n):\n        sw.append(i>>j & 1)\n    for k in range(m):\n        if (sum( [sw[ks[k][j+1]-1] for j in range(ks[k][0])] ))%2 == p[k]:\n            on +=1\n    if on==m:\n        ans +=1\nprint(ans)\n", "n, m = map(int, input().split())\nks = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**n):\n    bnt = 0\n    for j in range(m):\n        cnt = 0\n        for l in range(1, len(ks[j])):\n            if (i>>(ks[j][l]-1))&1 == 1:\n                cnt += 1\n        if cnt%2 == p[j]:\n            bnt += 1\n    if bnt == m:\n        ans += 1\nprint(ans)", "N, M = map(int, input().split())\ns = [list(map(lambda x:int(x)-1, input().split()[1:])) for _ in range(M)]\np = list(map(int, input().split()))\n \nans = 0\nfor i in range(2**N): # \u5168\u3066\u306e\u30b9\u30a4\u30c3\u30c1\u306e (on, off) \u306e\u7d44\u307f\u5408\u308f\u305b\n  # \u96fb\u7403j\u304c\u70b9\u706f\u3059\u308b\u6761\u4ef6\uff1a\u7e4b\u304c\u3063\u3066\u3044\u308bk_j\u500b\u306e\u30b9\u30a4\u30c3\u30c1\u306e\u3046\u3061\u3001on\u306e\u500b\u6570\u30922\u3067\u5272\u3063\u305f\u4f59\u308a\u304cp_j\u306b\u7b49\u3057\u3044\n  bulb_num = 0 # \u70b9\u706f\u3059\u308b\u96fb\u7403\u306e\u500b\u6570\n  for j in range(M): # \u3042\u308b (on, off) \u306e\u7d44\u306b\u304a\u3044\u3066\u3001\u70b9\u706f\u3059\u308b\u96fb\u7403\u306e\u500b\u6570\u3092\u6c42\u3081\u308b\n    on_num = 0 # \u96fb\u7403j\u306b\u7e4b\u304c\u3063\u3066\u3044\u308b\u30b9\u30a4\u30c3\u30c1\u306e\u3046\u3061\u3001on\u306e\u500b\u6570\n    for k in range(N):\n      # \u30b9\u30a4\u30c3\u30c1k\u304con \u304b\u3064\u3001\u96fb\u7403j\u3068\u30b9\u30a4\u30c3\u30c1k\u304c\u7e4b\u304c\u3063\u3066\u3044\u308b\u306a\u3089\u3070\uff1a\n      if i >> k & 1 and k in s[j]: on_num += 1\n    if (on_num - p[j]) % 2 == 0: bulb_num += 1\n  if bulb_num == M: ans += 1\n    \nprint(ans)", "#import math\nimport itertools\n#import numpy as np\n#from collections import deque\n\n\nINT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\ndef do():\n    n,m=INTM()\n    cnct=[]\n    for i in range(m):\n        temp=LIST()\n        temp=temp[1:]\n        cnct.append(temp)\n    ps=LIST()\n    ans=0\n    \n    for bit in range(2**n):\n        check=[0]*m\n        for i in range(n):\n            if (bit>>i)&1:\n                for k in range(m):\n                    if i+1 in cnct[k]:\n                        check[k]+=1\n        \n        flg=True\n        for k in range(m):\n            if check[k]%2!=ps[k]:\n                flg=False\n        \n        if flg:\n            ans+=1\n    \n    print(ans)\n\n\ndef __starting_point():\n    do()\n__starting_point()", "#!/usr/bin/env python3\n\ndef II(): return int(input())\ndef MII(): return list(map(int, input().split()))\ndef LII(): return list(map(int, input().split()))\n\ndef main():\n    N, M = MII()\n    s = []\n    for _ in range(M):\n        s.append(list(map(int, input().split()))[1:])\n    p = LII()\n\n    ans = 0\n    for i in range(2**N, 2**(N+1)):\n        b = bin(i)[3:]\n        t = [0] * M\n        for j, sj in enumerate(s):\n            for k, bi in enumerate(list(b)):\n                if bi == '1' and k+1 in sj:\n                    t[j] += 1\n            if t[j] % 2 != p[j]:\n                ans -= 1\n                break\n        ans += 1\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\nk = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n \nans = 0\nfor i in range(2**n):\n    light = 0\n    for ki, j in enumerate(k):\n        switch = 0\n        for s in j[1:]:\n            if i & (1 << s-1):\n                switch += 1\n        if switch % 2 == p[ki]:\n            light += 1\n    if light == m:\n        ans += 1\nprint(ans)", "N,M=map(int,input().split())\nlamps=[list(map(lambda x:int(x)-1,input().split()))[1:] for _ in range(M)]\np=list(map(int,input().split()))\n\nans=0\n\n#bit\u5168\u63a2\u7d22\nfor i in range(1<<N):\n  for lamp in range(M):\n    on_sum=0\n    for j in range(N):\n      if i>>j&1 and j in lamps[lamp]:\n        on_sum+=1\n    if on_sum%2 !=p[lamp]:\n      break\n  else:\n    ans+=1\nprint(ans)", "#m = int(input())\nn, m = list(map(int, input().split()))\n#al = list(map(int, input().split()))\n#al=[list(input()) for i in range(n)]\nswitch = []\nkl = []\nfor i in range(m):\n    temp = list(map(int, input().split()))\n    kl.append(temp[0])\n    switch.append(temp[1:])\npl = list(map(int, input().split()))\n# print(switch)\n\npattern = [[0 for _ in range(n)] for _1 in range(2**n)]\nfor i in range(2**n):\n    for j in range(n):\n        if ((i >> j) & 1):  # \u4e8c\u9032\u6570i\u306e\u4e0b\u304b\u3089\u6570\u3048\u3066j\u6841\u76ee\u304c1\u304b\u5426\u304b\n            pattern[i][j] = 1\n\nans = 0\nfor ptnum, spt in enumerate(pattern):\n    islit = True\n    for lightnum in range(m):\n        count = 0\n        for s in switch[lightnum]:\n            if spt[s-1] == 1:\n                count += 1\n        if count % 2 != pl[lightnum]:\n            islit = False\n            break\n    if islit:\n        ans += 1\nprint(ans)\n", "N, M = map(int,input().split())\nK = []\nS = []\nfor i in range(M):\n    k = 0\n    s = []\n    k, *s = map(int,input().split())\n    K.append(k)\n    S.append(s)\nP = list(map(int,input().split()))\nres = 0\nfor bit in range(1 << N):\n    judge = True\n    for i in range(M):\n        cnt = 0\n        for s in S[i]:\n            cnt += (bit >> s-1) & 1\n        if cnt % 2 != P[i]:\n            judge = False\n    if judge:\n        res += 1\nprint(res)", "n,m=map(int,input().split())\ns=[list(map(int,input().split()))[1:] for _ in range(m)]\np=list(map(int,input().split()))\nans=0\n\nfor i in range(2**n):\n    tmp=[]\n    cnt=[0]*n\n    for j in range(n):\n        if (i>>j)&1:\n            tmp.append(j+1)\n    for k in range(m):\n        if len(set(tmp)&set(s[k]))%2!=p[k]:\n            break\n    else:\n        ans+=1\nprint(ans)", "n, m = map(int, input().split())\n\nswl = [list(map(int, input().split())) for _ in range(m)]\npl = list(map(int, input().split()))\nans = 0\nfor i in range(2**n):\n    sw = [0]*n\n    light_cnt = 0\n    for j in range(n):\n        if (i>>j)&1:\n            sw[j] += 1\n    for j in range(m):\n        wl = swl[j][1:]\n        sw_cnt = 0\n        for wi in wl:\n            if sw[wi-1] == 1:\n                sw_cnt += 1\n        if sw_cnt%2 == pl[j]:\n            light_cnt += 1\n    if light_cnt == m:\n        ans += 1\n\nprint(ans)", "n,m = map(int,input().split())\ns = []\nfor _ in range(m):\n    tmp = list(map(int,input().split()))\n    s.append(tmp[1:])\np = list(map(int,input().split()))\n\nans = 0\nfor i in range(2**n):\n    for j in range(m):\n        count = 0\n        check = True\n        for k in s[j]:\n            if (i >> (k-1)) & 1:\n                count += 1\n        if count % 2 != p[j]:\n            check = False\n            break\n    if check:\n        ans += 1\nprint(ans)", "3\nimport sys\ninput = lambda: sys.stdin.readline().strip()\nn, m = [int(x) for x in input().split()]\ns = [[int(x) - 1 for x in input().split()][1:] for i in range(m)]\np = [int(x) for x in input().split()]\nprint(sum(1 for mask in range(1 << n) if all(sum((mask >> bulb) & 1 for bulb in s[i]) % 2 == p[i] for i in range(m))))", "n,m=map(int,input().split())\nks=[[] for i in range(m)]\nfor i in range(m):\n  ks[i]=list(map(lambda x:int(x)-1,input().split()))\np=list(map(int,input().split()))\n\nans=0\nfor i in range(1<<n):\n  l=[0]*n\n  for j in range(n):\n    l[j]=1 if i>>j&1 else 0\n  \n  # light check\n  for j in range(m):\n    s=sum([l[k] for k in ks[j][1:]])\n    if s%2!=p[j]: break;\n  else: ans+=1;\n\nprint(ans) ", "N, M = list(map(int, input().split()))\n\nswiches = []\n\nfor _ in range(M):\n    swiches.append(list(map(int,input().split()))[1:])\n\np = list(map(int,input().split()))\n\ntemp = \"0\" + str(N) + \"b\"\ncase = []\nfor i in range(2 ** N):\n    case.append(format(i, temp))\n\nfor a in range(len(swiches)):\n    for b in range(len(swiches[a])):\n        swiches[a][b] -= 1\n\nans = 0\nfor x in case:\n    flag = 0\n    for i in range(M):\n        temp = 0\n        for j in swiches[i]:\n            temp += int(x[j])\n        if temp % 2 == p[i]:\n            flag += 1\n    if flag == M:\n        ans += 1\n\nprint(ans)\n\n", "n, m = list(map(int, input().split()))\nk = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**n):\n    light = 0\n    for ki, j in enumerate(k):\n        switch = 0\n        for s in j[1:]:\n            if i & (1 << s-1):\n                switch += 1\n        if switch % 2 == p[ki]:\n            light += 1\n    if light == m:\n        ans += 1\nprint(ans)\n", "\nn,m = map(int, input().split())\nli = []\n\nfor i in range(m):\n    a = list(map(int, input().split()))\n    li.append(a[1:])\n\np = list(map(int, input().split()))\nans = 0\nfor i in range(1<<n):\n    ok = 1\n    s = []\n    for j in range(n):\n        if (i>>j)&1:\n            s.append(j)\n    for j in range(m):\n        tmp = 0\n        for k in li[j]:\n            if  k-1 in s:\n                tmp += 1\n        if tmp%2!=p[j]:\n            ok=0\n    if ok:\n        ans += 1\nprint(ans)", "n, m = map(int, input().split())\nks = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**n):\n    flag = True\n    for j in range(m):\n        on = 0\n        a = False\n        for l in ks[j]:\n            if a and (i>>(l-1)) & 1:\n                on += 1\n            a = True\n        if on % 2 != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\nprint(ans)", "n,m=list(map(int,input().split()))\ns=[[0]*10 for _ in range(m)]\nfor i in range(m):\n    k=list(map(int,input().split()))\n    for j in range(1,k[0]+1):\n        s[i][10-k[j]]=1\nimport numpy as np\ns=np.asarray(s)\np=list(map(int,input().split()))\nans=0\nfor i in range(2**n):\n    binst=format(i,'010b')\n    l=list(map(int,list(binst)))\n    l=np.asarray(l)\n    on=s&l\n    onsum=np.sum(on,axis=1)%2\n    err=0\n    for j in range(m):\n        if onsum[j]!=p[j]:\n            err=1\n            break\n    if err==0:\n        ans+=1\nprint(ans)\n", "N,M=list(map(int,input().split()))\nli=[]\nans=0\nfor i in range(M):\n    s=list(map(int,input().split()))\n    li.append(s)\np=list(map(int,input().split()))\n\nfor j in range(2**N):\n    j=bin(j)\n    j=str(j)\n    j=j[2:]\n    while len(j)!=N:\n        j=\"0\"+j\n    flash=0\n    for k in range(M):\n        temp=0\n        for l in range(li[k][0]):\n            if j[li[k][l+1]-1]==\"1\":\n                temp+=1\n        if temp%2==p[k]:\n            flash+=1\n    if flash==M:\n        ans+=1\nprint(ans)\n        \n            \n", "n, m = map(int, input().split())\ns = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\ncount = 0\nfor i in range(2 ** n):\n    on_number = [0] * m\n    for j in range(n):\n        if i >> j & 1:\n            for k in range(m):\n                if (j + 1) in s[k][1:]:\n                    on_number[k] += 1\n    flag = 0\n    for k in range(m):\n        if on_number[k] % 2 == p[k]:\n            flag += 1\n        if flag == m:\n            count += 1\nprint(count)"]