["\n\n#Solution:\n\nn,k=map(int,input().split())\ns=input()\nl=[]\nfor i in range(n):\n    for j in range(i+1,n+1):\n        l.append(s[i:j])\nl.sort(key=len)\ns=set()\nc=0\nfor i in l:\n    if len(s)==k:\n        break\n    if i not in s:\n        s.add(i)\n        c+=n-len(i)\nif len(s)==k:\n    print(c)\nelse:\n    print(-1)", "\n\nn, k = map(int, input().split())\ns = input()\n\nif k > n*(n+1)//2:\n    print(-1)\nelse:\n    sm = 0\n    p = 0\n    for i in range(1, n+1):\n        sm += i\n        if sm >= k:\n            p = i\n            break\n    print(n*(n+1)//2 - (p*(p+1)//2))", "\n\ndef main():\n    \"\"\"\n    The idea is to use dynamic programming to calculate subproblems.\n    For each character in the string, find the minimum cost to create a set of size k.\n    \"\"\"\n    n, k = map(int, input().split())\n    s = input()\n    dp = [0] * (k + 1)\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if j == 1:\n                dp[j] = dp[j] + 1\n            else:\n                dp[j] = min(dp[j], dp[j - 1])\n    result = dp[k]\n    print(result if result <= n else -1)\n\nif __name__ == '__main__':\n    main()"]