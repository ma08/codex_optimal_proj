2022-04-21 00:18:50.476124 num operations 2
2022-04-21 00:18:50.476134 size on input set 1
2022-04-21 00:18:50.476280 using api key derek
2022-04-21 00:18:50.607834 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-21 00:18:55.613220 using api key sourya
2022-04-21 00:18:55.655319 in retry 5 10 <class 'Exception'>, Retrying in 10 seconds...
2022-04-21 00:19:05.656116 using api key soukgp
2022-04-21 00:19:10.850897 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros((N+1), dtype=np.int)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros((N+1), dtype=np.int64)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650500345,
  "object": "edit"
}
2022-04-21 00:19:10.851150 fix spelling mistakes 2 ['\n\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros((N+1), dtype=np.int)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == "__main__":\n    main()\n', '\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros((N+1), dtype=np.int64)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-21 00:19:10.851182 size on output set 2
2022-04-21 00:19:10.851190 size on input set 2
2022-04-21 00:19:10.851384 using api key sunu
2022-04-21 00:19:15.296464 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros(N+1, dtype=np.int64)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros((N+1), dtype=np.int64)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650500350,
  "object": "edit"
}
2022-04-21 00:19:15.296678 fix syntax errors 2 ['import numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros(N+1, dtype=np.int64)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == "__main__":\n    main()\n', 'import numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros((N+1), dtype=np.int64)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-21 00:19:15.296902 using api key gabby
2022-04-21 00:19:15.337812 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-21 00:19:20.343190 using api key gabby
2022-04-21 00:19:20.384796 in retry 5 10 <class 'Exception'>, Retrying in 10 seconds...
2022-04-21 00:19:30.395218 using api key kouti
2022-04-21 00:19:36.985647 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros(N+1, dtype=np.int)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N + 1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros(N+1, dtype=np.int)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650500370,
  "object": "edit"
}
2022-04-21 00:19:36.985879 fix syntax errors 2 ['\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros(N+1, dtype=np.int)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N + 1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == "__main__":\n    main()\n', '\nimport numpy as np\n\ndef main():\n    N, M = map(int, input().split())\n    broken_steps = [int(input()) for _ in range(M)]\n    broken_steps.sort()\n    dp = np.zeros(N+1, dtype=np.int)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        if i in broken_steps:\n            dp[i] = 0\n        else:\n            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007\n    print(dp[N])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-21 00:19:36.985911 size on output set 4
2022-04-21 00:19:36.985924 num operations 2
2022-04-21 00:19:36.985931 size on input set 1
2022-04-21 00:19:36.986102 using api key soukgp
2022-04-21 00:20:01.688759 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, m = map(int, input().split())\nbroken = set(map(int, [input() for _ in range(m)]))\n\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, n+1):\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[n] % 1000000007)\n"
    },
    {
      "index": 1,
      "text": "\n\nn, m = map(int, input().split()) # n\uc740 \uc0c1\uadfc\uc774\uac00 \uc774\ub3d9\ud574\uc57c \ud560 \uac70\ub9ac, m\uc740 \ubc84\ud2bc\uc774 \uace0\uc7a5\ub09c \uac70\ub9ac\nbroken = set(map(int, [input() for _ in range(m)]))\n\ndp = [0] * (n+1) # dp\uc758 \ucd08\uae30\uac12\uc744 0\uc73c\ub85c \uc124\uc815\ud574\uc900\ub2e4.\ndp[0] = 1 # 0\ubc88\uc9f8 \ubc84\ud2bc\uc740 \uc774\ub3d9\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\uae30 \ub54c\ubb38\uc5d0 1\ub85c \uc124\uc815\ud574\uc900\ub2e4.\ndp[1] = 1 # 1\ubc88\uc9f8 \ubc84\ud2bc\uc740 \uc774\ub3d9\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\uae30 \ub54c\ubb38\uc5d0 1\ub85c \uc124\uc815\ud574\uc900\ub2e4.\n\nfor i in range(2, n+1): # 2\ubc88\uc9f8 \ubc84\ud2bc\ubd80\ud130 n\ubc88\uc9f8 \ubc84\ud2bc\uae4c\uc9c0 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uacbd\uc6b0\uc758 \uc218\ub97c \uad6c\ud55c\ub2e4.\n    if i in broken: # i\ubc88\uc9f8 \ubc84\ud2bc\uc774 \uace0\uc7a5\ub09c \uacbd\uc6b0\n        continue # \ub2e4\uc74c \ubc84\ud2bc\uc73c\ub85c \ub118\uc5b4\uac04\ub2e4.\n    dp[i] = dp[i-1] + dp[i-2] # i\ubc88\uc9f8 \ubc84\ud2bc\uc774 \uc815\uc0c1\uc778 \uacbd\uc6b0, i\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\ub294 i-1\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\uc640 i-2\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\uc758 \ud569\uc774\ub2e4.\n\nprint(dp[n] % 1000000007)\n"
    }
  ],
  "created": 1650500377,
  "object": "edit"
}
2022-04-21 00:20:01.689092 fix spelling mistakes 2 ['\n\nn, m = map(int, input().split())\nbroken = set(map(int, [input() for _ in range(m)]))\n\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, n+1):\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[n] % 1000000007)\n', '\n\nn, m = map(int, input().split()) # n은 상근이가 이동해야 할 거리, m은 버튼이 고장난 거리\nbroken = set(map(int, [input() for _ in range(m)]))\n\ndp = [0] * (n+1) # dp의 초기값을 0으로 설정해준다.\ndp[0] = 1 # 0번째 버튼은 이동하지 않아도 되기 때문에 1로 설정해준다.\ndp[1] = 1 # 1번째 버튼은 이동하지 않아도 되기 때문에 1로 설정해준다.\n\nfor i in range(2, n+1): # 2번째 버튼부터 n번째 버튼까지 이동할 수 있는 경우의 수를 구한다.\n    if i in broken: # i번째 버튼이 고장난 경우\n        continue # 다음 버튼으로 넘어간다.\n    dp[i] = dp[i-1] + dp[i-2] # i번째 버튼이 정상인 경우, i번째 버튼에 도착하는 경우의 수는 i-1번째 버튼에 도착하는 경우의 수와 i-2번째 버튼에 도착하는 경우의 수의 합이다.\n\nprint(dp[n] % 1000000007)\n']
2022-04-21 00:20:01.689147 size on output set 2
2022-04-21 00:20:01.689158 size on input set 2
2022-04-21 00:20:01.689391 using api key jaanu
2022-04-21 00:20:19.461086 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, m = map(int, input().split())\nbroken = set(map(int, [input() for _ in range(m)]))\n\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, n+1):\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[n] % 1000000007)\n"
    },
    {
      "index": 1,
      "text": "import sys\nsys.setrecursionlimit(10**6)\n\nn, m = map(int, input().split())\nbroken = set(map(int, [input() for _ in range(m)]))\ndef dfs(i):\n    if i == 0:\n        return 1\n    if i < 0:\n        return 0\n    if dp[i] != -1:\n        return dp[i]\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        return 0\n    dp[i] = dfs(i-1) + dfs(i-2)\n    return dp[i]\n\n\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, n+1):\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[n] % 1000000007)\n"
    }
  ],
  "created": 1650500401,
  "object": "edit"
}
2022-04-21 00:20:19.461302 fix syntax errors 2 ['\nn, m = map(int, input().split())\nbroken = set(map(int, [input() for _ in range(m)]))\n\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, n+1):\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[n] % 1000000007)\n', 'import sys\nsys.setrecursionlimit(10**6)\n\nn, m = map(int, input().split())\nbroken = set(map(int, [input() for _ in range(m)]))\ndef dfs(i):\n    if i == 0:\n        return 1\n    if i < 0:\n        return 0\n    if dp[i] != -1:\n        return dp[i]\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        return 0\n    dp[i] = dfs(i-1) + dfs(i-2)\n    return dp[i]\n\n\ndp = [0] * (n+1)\ndp[0] = 1\ndp[1] = 1\n\nfor i in range(2, n+1):\n    if i in broken or (i-1) in broken and (i-2) in broken:\n        continue\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[n] % 1000000007)\n']
2022-04-21 00:20:19.461601 using api key jaanu
2022-04-21 00:20:26.785122 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, m = map(int, input().split()) # n\uc740 \uc0c1\uadfc\uc774\uac00 \uc774\ub3d9\ud574\uc57c \ud560 \uac70\ub9ac, m\uc740 \ubc84\ud2bc\uc774 \uace0\uc7a5\ub09c \uac70\ub9ac\nbroken = set(map(int, [input() for _ in range(m)])) # broken\uc740 \uace0\uc7a5\ub09c \ubc84\ud2bc\uc758 \ubc88\ud638\ub97c \uc800\uc7a5\ud558\ub294 \uc9d1\ud569\uc774\ub2e4.\n\ndp = [0] * (n+1) # dp\uc758 \ucd08\uae30\uac12\uc744 0\uc73c\ub85c \uc124\uc815\ud574\uc900\ub2e4.\ndp[0] = 1 # 0\ubc88\uc9f8 \ubc84\ud2bc\uc740 \uc774\ub3d9\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\uae30 \ub54c\ubb38\uc5d0 1\ub85c \uc124\uc815\ud574\uc900\ub2e4.\ndp[1] = 1 # 1\ubc88\uc9f8 \ubc84\ud2bc\uc740 \uc774\ub3d9\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\uae30 \ub54c\ubb38\uc5d0 1\ub85c \uc124\uc815\ud574\uc900\ub2e4.\n\nfor i in range(2, n+1): # 2\ubc88\uc9f8 \ubc84\ud2bc\ubd80\ud130 n\ubc88\uc9f8 \ubc84\ud2bc\uae4c\uc9c0 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uacbd\uc6b0\uc758 \uc218\ub97c \uad6c\ud55c\ub2e4.\n    if i in broken: # i\ubc88\uc9f8 \ubc84\ud2bc\uc774 \uace0\uc7a5\ub09c \uacbd\uc6b0\n        continue # \ub2e4\uc74c \ubc84\ud2bc\uc73c\ub85c \ub118\uc5b4\uac04\ub2e4.\n    dp[i] = dp[i-1] + dp[i-2] # i\ubc88\uc9f8 \ubc84\ud2bc\uc774 \uc815\uc0c1\uc778 \uacbd\uc6b0, i\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\ub294 i-1\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\uc640 i-2\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\uc758 \ud569\uc774\ub2e4.\n\nprint(dp[n] % 1000000007) # dp[n]\uc744 \ucd9c\ub825\ud55c\ub2e4.\n"
    },
    {
      "index": 1,
      "text": "\nn, m = map(int, input().split()) # n\uc740 \uc0c1\uadfc\uc774\uac00 \uc774\ub3d9\ud574\uc57c \ud560 \uac70\ub9ac, m\uc740 \ubc84\ud2bc\uc774 \uace0\uc7a5\ub09c \uac70\ub9ac\nbroken = set(map(int, [input() for _ in range(m)])) # \uc774\ub3d9\ud560 \uc218 \uc5c6\ub294 \ubc84\ud2bc\uc758 \ubc88\ud638\ub97c \uc800\uc7a5\ud55c\ub2e4.\n\ndp = [0] * (n+1) # dp\uc758 \ucd08\uae30\uac12\uc744 0\uc73c\ub85c \uc124\uc815\ud574\uc900\ub2e4.\ndp[0] = 1 # 0\ubc88\uc9f8 \ubc84\ud2bc\uc740 \uc774\ub3d9\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\uae30 \ub54c\ubb38\uc5d0 1\ub85c \uc124\uc815\ud574\uc900\ub2e4.\ndp[1] = 1 # 1\ubc88\uc9f8 \ubc84\ud2bc\uc740 \uc774\ub3d9\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\uae30 \ub54c\ubb38\uc5d0 1\ub85c \uc124\uc815\ud574\uc900\ub2e4.\n\nfor i in range(2, n+1): # 2\ubc88\uc9f8 \ubc84\ud2bc\ubd80\ud130 n\ubc88\uc9f8 \ubc84\ud2bc\uae4c\uc9c0 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uacbd\uc6b0\uc758 \uc218\ub97c \uad6c\ud55c\ub2e4.\n    if i in broken: # i\ubc88\uc9f8 \ubc84\ud2bc\uc774 \uace0\uc7a5\ub09c \uacbd\uc6b0\n        continue # \ub2e4\uc74c \ubc84\ud2bc\uc73c\ub85c \ub118\uc5b4\uac04\ub2e4.\n    dp[i] = dp[i-1] + dp[i-2] # i\ubc88\uc9f8 \ubc84\ud2bc\uc774 \uc815\uc0c1\uc778 \uacbd\uc6b0, i\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\ub294 i-1\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\uc640 i-2\ubc88\uc9f8 \ubc84\ud2bc\uc5d0 \ub3c4\ucc29\ud558\ub294 \uacbd\uc6b0\uc758 \uc218\uc758 \ud569\uc774\ub2e4.\n\nprint(dp[n] % 1000000007) # \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uacbd\uc6b0\uc758 \uc218\ub97c \ucd9c\ub825\ud55c\ub2e4.\n"
    }
  ],
  "created": 1650500419,
  "object": "edit"
}
2022-04-21 00:20:26.785411 fix syntax errors 2 ['\nn, m = map(int, input().split()) # n은 상근이가 이동해야 할 거리, m은 버튼이 고장난 거리\nbroken = set(map(int, [input() for _ in range(m)])) # broken은 고장난 버튼의 번호를 저장하는 집합이다.\n\ndp = [0] * (n+1) # dp의 초기값을 0으로 설정해준다.\ndp[0] = 1 # 0번째 버튼은 이동하지 않아도 되기 때문에 1로 설정해준다.\ndp[1] = 1 # 1번째 버튼은 이동하지 않아도 되기 때문에 1로 설정해준다.\n\nfor i in range(2, n+1): # 2번째 버튼부터 n번째 버튼까지 이동할 수 있는 경우의 수를 구한다.\n    if i in broken: # i번째 버튼이 고장난 경우\n        continue # 다음 버튼으로 넘어간다.\n    dp[i] = dp[i-1] + dp[i-2] # i번째 버튼이 정상인 경우, i번째 버튼에 도착하는 경우의 수는 i-1번째 버튼에 도착하는 경우의 수와 i-2번째 버튼에 도착하는 경우의 수의 합이다.\n\nprint(dp[n] % 1000000007) # dp[n]을 출력한다.\n', '\nn, m = map(int, input().split()) # n은 상근이가 이동해야 할 거리, m은 버튼이 고장난 거리\nbroken = set(map(int, [input() for _ in range(m)])) # 이동할 수 없는 버튼의 번호를 저장한다.\n\ndp = [0] * (n+1) # dp의 초기값을 0으로 설정해준다.\ndp[0] = 1 # 0번째 버튼은 이동하지 않아도 되기 때문에 1로 설정해준다.\ndp[1] = 1 # 1번째 버튼은 이동하지 않아도 되기 때문에 1로 설정해준다.\n\nfor i in range(2, n+1): # 2번째 버튼부터 n번째 버튼까지 이동할 수 있는 경우의 수를 구한다.\n    if i in broken: # i번째 버튼이 고장난 경우\n        continue # 다음 버튼으로 넘어간다.\n    dp[i] = dp[i-1] + dp[i-2] # i번째 버튼이 정상인 경우, i번째 버튼에 도착하는 경우의 수는 i-1번째 버튼에 도착하는 경우의 수와 i-2번째 버튼에 도착하는 경우의 수의 합이다.\n\nprint(dp[n] % 1000000007) # 이동할 수 있는 경우의 수를 출력한다.\n']
2022-04-21 00:20:26.785536 size on output set 4
