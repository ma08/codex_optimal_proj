["\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print 'yes'\n    print '0' * n\nelse:\n    print 'yes'\n    print solve(s)\n\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print 'yes'\n    print '0' * n\nelse:\n    print 'yes'\n    print solve(s)\n", "#!/bin/bash\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n\n\n#\n#\n#\n", "\nimport sys\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\n\ndef solve(s):\n    answer = []\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "#!/usr/bin/env python\n\nimport os\n\ndef get_dirlist(path):\n    \"\"\"\n      Return a sorted list of all entries in path.\n      This returns just the names, not the full path to the names.\n    \"\"\"\n    dirlist = os.listdir(path)\n    dirlist.sort()\n    return dirlist\n\ndef print_files(path, prefix = \"\"):\n    \"\"\" Print recursive listing of contents of path \"\"\"\n    if prefix == \"\":  # Detect outermost call, print a heading\n        print(\"Folder listing for\", path)\n        prefix = \"| \"\n\n    dirlist = get_dirlist(path)\n    for f in dirlist:\n        print(prefix+f)                    # Print the line\n        fullname = os.path.join(path, f)   # Turn name into full pathname\n        if os.path.isdir(fullname):        # If a directory, recurse.\n            print_files(fullname, prefix + \"| \")\n\n\ndef main():\n    print_files(\"/home/joe/Downloads/\")\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph: Dict[str, List[int]]) -> Set[str]:\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r: Set[str], p: Set[str], x: Set[str]):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph: Dict[str, List[int]]) -> int:\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph: Dict[str, List[int]]) -> Set[int]:\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s: str) -> List[str]:\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s: str) -> bool:\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s: str) -> bool:\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\n\ndef solve(s):\n    answer = []\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "\nfrom collections import defaultdict\nfrom typing import List, Dict, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\n\ndef get_max_clique(graph: Dict[str, List[int]]) -> Set[str]:\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\n\ndef get_max_clique_size(graph: Dict[str, List[int]]) -> int:\n    return len(get_max_clique(graph))\n\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('yes')\n    print('0' * n)\nelse:\n    print('yes')\n    print(solve(s))\n"]