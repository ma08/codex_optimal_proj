2022-04-21 01:46:29.724886 num operations 2
2022-04-21 01:46:29.724908 size on input set 1
2022-04-21 01:46:29.725064 using api key sunu
2022-04-21 01:46:36.904833 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight.\n# If the current weight is the same as the previous one,\n# we can increase it by one and then we are sure that it will be different from the previous weight.\n# If the current weight is bigger than the previous one by more than one,\n# we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the current weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650505589,
  "object": "edit"
}
2022-04-21 01:46:36.905089 fix spelling mistakes 2 ["\n\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them,\n# keeping track of the previous weight.\n# If the current weight is the same as the previous one,\n# we can increase it by one and then we are sure that it will be different from the previous weight.\n# If the current weight is bigger than the previous one by more than one,\n# we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the current weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-21 01:46:36.905132 size on output set 2
2022-04-21 01:46:36.905140 size on input set 2
2022-04-21 01:46:36.905300 using api key kouti
2022-04-21 01:46:43.939247 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n"
    },
    {
      "index": 1,
      "text": "\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650505596,
  "object": "edit"
}
2022-04-21 01:46:43.939477 fix syntax errors 2 ['\n', "\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-21 01:46:43.939744 using api key jaanu
2022-04-21 01:46:51.448480 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them, keeping track of the previous weight.\n# If the current weight is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If the current weight is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the current weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650505603,
  "object": "edit"
}
2022-04-21 01:46:51.448726 fix syntax errors 2 ["\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them, keeping track of the previous weight.\n# If the current weight is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight.\n# If the current weight is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight.\n# Otherwise, we can't change the current weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-21 01:46:51.448873 size on output set 4
2022-04-21 01:46:51.448888 num operations 2
2022-04-21 01:46:51.448894 size on input set 1
2022-04-21 01:46:51.449062 using api key sunu
2022-04-21 01:46:53.855494 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650505611,
  "object": "edit"
}
2022-04-21 01:46:53.855695 fix spelling mistakes 2 ['\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-21 01:46:53.855735 size on output set 1
2022-04-21 01:46:53.855743 size on input set 1
2022-04-21 01:46:53.855912 using api key kouti
2022-04-21 01:46:56.974722 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "n = int(input())\na = sorted(list(map(int, input().split())))\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650505613,
  "object": "edit"
}
2022-04-21 01:46:56.974925 fix syntax errors 2 ['n = int(input())\na = sorted(list(map(int, input().split())))\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-21 01:46:56.974946 size on output set 2
