2022-04-21 03:59:54.460547 num operations 2
2022-04-21 03:59:54.460560 size on input set 1
2022-04-21 03:59:54.460734 using api key gabby
2022-04-21 03:59:54.626640 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-21 03:59:59.632034 using api key jaanu
2022-04-21 04:00:04.208776 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\n    return(list(map(int,f.readline().split())))\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\n\ndef ins():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650513599,
  "object": "edit"
}
2022-04-21 04:00:04.209116 fix spelling mistakes 2 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\n    return(list(map(int,f.readline().split())))\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\n\ndef ins():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-21 04:00:04.209307 size on output set 2
2022-04-21 04:00:04.209326 size on input set 2
2022-04-21 04:00:04.209615 using api key gabby
2022-04-21 04:00:04.247510 in retry 6 5 <class 'Exception'>, Retrying in 5 seconds...
2022-04-21 04:00:09.252981 using api key sunu
2022-04-21 04:00:14.144578 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\nsys.stdin = open('input.txt','r')\nsys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline().strip())\n\ndef inlt():\n    return list(map(int,f.readline().strip().split()))\n\ndef insr():\n    return input()\n\ndef invr():\n    return map(int,f.readline().strip().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650513609,
  "object": "edit"
}
2022-04-21 04:00:14.144836 fix syntax errors 2 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\nsys.stdin = open('input.txt','r')\nsys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline().strip()))\n\ndef inlt():\n    return(list(map(int,f.readline().strip().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().strip().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline().strip())\n\ndef inlt():\n    return list(map(int,f.readline().strip().split()))\n\ndef insr():\n    return input()\n\ndef invr():\n    return map(int,f.readline().strip().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-21 04:00:14.145132 using api key sunu
2022-04-21 04:00:20.101676 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\nf = sys.stdin\no = sys.stdout\ndef inp():\n    return(int(f.readline()))\n    return(list(map(int,f.readline().split())))\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\ndef ins():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return list(map(int,f.readline().split()))\n\ndef inlr():\n    return list(map(int,f.readline().split()))\n\ndef ins():\n    return input()\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650513614,
  "object": "edit"
}
2022-04-21 04:00:20.101924 fix syntax errors 2 ["\nimport sys\nimport os\nimport heapq\nimport math\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\nf = sys.stdin\no = sys.stdout\ndef inp():\n    return(int(f.readline()))\n    return(list(map(int,f.readline().split())))\n\ndef inlr():\n    return(list(map(int,f.readline().split())))\ndef ins():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\n    return list(map(int,f.readline().split()))\n\ndef inlr():\n    return list(map(int,f.readline().split()))\n\ndef ins():\n    return input()\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-21 04:00:20.102051 size on output set 4
2022-04-21 04:00:20.102066 num operations 2
2022-04-21 04:00:20.102072 size on input set 1
2022-04-21 04:00:20.102231 using api key soukgp
2022-04-21 04:00:24.034008 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (topological sort)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (Kruskal's theorem)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic by checking if graph is bipartite\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650513620,
  "object": "edit"
}
2022-04-21 04:00:24.034250 fix spelling mistakes 2 ['\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (topological sort)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (Kruskal\'s theorem)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic by checking if graph is bipartite\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-21 04:00:24.034302 size on output set 2
2022-04-21 04:00:24.034311 size on input set 2
2022-04-21 04:00:24.034471 using api key sunu
2022-04-21 04:00:27.538944 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (topological sort)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            print(\"NO\")\n            return \n            return\n\n    # if graph is acyclic and connected, then it is a tree (Kruskal's theorem)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (topological sort)\n    visited = [False] * (n + 1)\n    bfs(graph, 1, visited) \n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            print(\"NO\")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (Kruskal's theorem)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650513624,
  "object": "edit"
}
2022-04-21 04:00:27.539257 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (topological sort)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            print("NO")\n            return \n            return\n\n    # if graph is acyclic and connected, then it is a tree (Kruskal\'s theorem)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (topological sort)\n    visited = [False] * (n + 1)\n    bfs(graph, 1, visited) \n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            print("NO")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (Kruskal\'s theorem)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-21 04:00:27.539515 using api key soukgp
2022-04-21 04:00:33.528371 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for nxt in graph[start]:\n        if not visited[nxt]:\n            dfs(graph, nxt, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic by checking if graph is bipartite\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic by checking if graph is bipartite\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1): # for each vertex\n        for j in graph[i]: # for each edge\n            if i < j: # if the edge is not oriented\n                print(\"0\", end=\"\") # orient it\n    for i in range(1, n + 1): # for each vertex\n        for j in graph[i]: # for each edge\n            if i > j: # if the edge is not oriented\n                print(\"1\", end=\"\") # orient it\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650513627,
  "object": "edit"
}
2022-04-21 04:00:33.528616 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for nxt in graph[start]:\n        if not visited[nxt]:\n            dfs(graph, nxt, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic by checking if graph is bipartite\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic by checking if graph is bipartite\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1): # for each vertex\n        for j in graph[i]: # for each edge\n            if i < j: # if the edge is not oriented\n                print("0", end="") # orient it\n    for i in range(1, n + 1): # for each vertex\n        for j in graph[i]: # for each edge\n            if i > j: # if the edge is not oriented\n                print("1", end="") # orient it\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-21 04:00:33.528766 size on output set 4
