["var fs = require('fs');\n\nfs.readFile('file.txt', 'utf8', function (err, data) {\n    if (err) throw err;\n    console.log(data);\n});\n", "\n\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    #print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    #print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    #print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    #print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end=\"\")\n        else:\n            print(1, end=\"\")\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "const fs = require('fs');\n\nconst file = './file.txt';\n\nfs.readFile(file, 'utf-8', (err, data) => {\n    if (err) {\n        console.log(err);\n    }\n    console.log(data);\n});\n", "from sys import argv\nfrom os.path import exists\n\nscript, from_file, to_file = argv\n\nprint \"Copying from %s to %s\" % (from_file, to_file)\n\n# we could do these two on one line too, how?\nin_file = open(from_file)\nindata = in_file.read()\n\nprint \"The input file is %d bytes long\" % len(indata)\n\nprint \"Does the output file exist? %r\" % exists(to_file)\nprint \"Ready, hit RETURN to continue, CTRL-C to abort.\"\nraw_input()\n\nout_file = open(to_file, 'w')\nout_file.write(indata)\n\nprint \"Alright, all done.\"\n\nout_file.close()\nin_file.close()\n", "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "\nimport sys\n\n\ndef dfs(graph, v, parent, used, colors):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - colors[v]):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    colors = [None] * n\n    for i in range(n):\n        if colors[i] is None:\n            colors[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if colors[u] is None:\n                        colors[u] = 1 - colors[v]\n                        stack.append(u)\n    for u, v in edges:\n        if colors[u - 1] == colors[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if colors[u - 1] < colors[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport time\nimport json\nimport urllib\nimport urllib2\nimport requests\nfrom lxml import etree\n\nreload(sys)\nsys.setdefaultencoding('utf-8')\n\n\n# \u83b7\u53d6\u6587\u4ef6\u5217\u8868\ndef get_file_list(path):\n    file_list = []\n    for root, dirs, files in os.walk(path):\n        for file in files:\n            file_list.append(os.path.join(root, file))\n    return file_list\n\n\n# \u83b7\u53d6\u6587\u4ef6\u5185\u5bb9\ndef get_file_content(file_path):\n    with open(file_path, 'r') as f:\n        return f.read()\n\n\n# \u5199\u5165\u6587\u4ef6\u5185\u5bb9\ndef write_file_content(file_path, content):\n    with open(file_path, 'w') as f:\n        f.write(content)\n\n\n# \u83b7\u53d6\u6587\u4ef6\u540d\ndef get_file_name(file_path):\n    return os.path.basename(file_path)\n\n\n# \u83b7\u53d6\u6587\u4ef6\u540e\u7f00\u540d\ndef get_file_type(file_path):\n    return os.path.splitext(file_path)[1]\n\n\n# \u83b7\u53d6\u6587\u4ef6\u5927\u5c0f\ndef get_file_size(file_path):\n    return os.path.getsize(file_path)\n\n\n# \u83b7\u53d6\u6587\u4ef6\u4fee\u6539\u65f6\u95f4\ndef get_file_mtime(file_path):\n    return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(file_path)))\n\n\n# \u83b7\u53d6\u6587\u4ef6\u521b\u5efa\u65f6\u95f4\ndef get_file_ctime(file_path):\n    return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getctime(file_path)))\n\n\n# \u83b7\u53d6\u6587\u4ef6\u8bbf\u95ee\u65f6\u95f4\ndef get_file_atime(file_path):\n    return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getatime(file_path)))\n\n\n# \u83b7\u53d6\u6587\u4ef6\u7edd\u5bf9\u8def\u5f84\ndef get_file_absolute_path(file_path):\n    return os.path.abspath(file_path)\n\n\n# \u83b7\u53d6\u6587\u4ef6\u76f8\u5bf9\u8def\u5f84\ndef get_file_relative_path(file_path):\n    return os.path.relpath(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728\ndef is_file_exists(file_path):\n    return os.path.exists(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u53ef\u8bfb\ndef is_file_readable(file_path):\n    return os.access(file_path, os.R_OK)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u53ef\u5199\ndef is_file_writable(file_path):\n    return os.access(file_path, os.W_OK)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u53ef\u6267\u884c\ndef is_file_executable(file_path):\n    return os.access(file_path, os.X_OK)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7edd\u5bf9\u8def\u5f84\ndef is_file_absolute_path(file_path):\n    return os.path.isabs(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u76ee\u5f55\ndef is_file_directory(file_path):\n    return os.path.isdir(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u6587\u4ef6\ndef is_file_file(file_path):\n    return os.path.isfile(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u94fe\u63a5\u6587\u4ef6\ndef is_file_link(file_path):\n    return os.path.islink(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n\n\n# \u5224\u65ad\u6587\u4ef6\u662f\u5426\u662f\u7ec4\u5408\u6587\u4ef6\ndef is_file_mount(file_path):\n    return os.path.ismount(file_path)\n", "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 0)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())  # noqa\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef dfs(graph, v, parent, used):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "var fs = require('fs');\nvar path = require('path');\n\nvar dir = process.argv[2];\nvar ext = process.argv[3];\n\nfs.readdir(dir, function(err, list) {\n\tif (err) {\n\t\tconsole.log(err);\n\t}\n\tfor (var i = 0; i < list.length; i++) {\n\t\tif (path.extname(list[i]) == '.' + ext) {\n\t\t\tconsole.log(list[i]);\n\t\t}\n\t}\n});\n", "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\nimport os\n\n\ndef main():\n    if len(sys.argv) < 2:\n        print(\"Usage: python file.py <filename>\")\n        sys.exit(1)\n\n    filename = sys.argv[1]\n    if not os.path.exists(filename):\n        print(\"%s does not exist\" % filename)\n        sys.exit(2)\n\n    if os.path.isfile(filename):\n        print(\"%s is a file\" % filename)\n    else:\n        print(\"%s is not a file\" % filename)\n\n    if os.path.isdir(filename):\n        print(\"%s is a directory\" % filename)\n    else:\n        print(\"%s is not a directory\" % filename)\n\n    if os.path.islink(filename):\n        print(\"%s is a link\" % filename)\n    else:\n        print(\"%s is not a link\" % filename)\n\n    if os.path.ismount(filename):\n        print(\"%s is a mount point\" % filename)\n    else:\n        print(\"%s is not a mount point\" % filename)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(source, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(v, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(u, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n        dfs(graph, 1)\n\n        if not all(seen):\n            return False\n\n    # find a cycle\n        cycle = [False for _ in range(m)]\n        seen = [False for _ in range(n + 1)]\n        seen[1] = True\n        for i in range(m):\n            u, v = edges[i]\n            if seen[u] and seen[v]:\n                cycle[i] = True\n            seen[u] = True\n            seen[v] = True\n\n        # print(cycle)\n\n    # find a cycle that has at least one even degree node\n        def dfs2(graph, source, cycle, even_degree_count):\n            seen[source] = True\n            if len(graph[source]) % 2 == 0:\n                even_degree_count += 1\n            if len(graph[source]) > 1 and even_degree_count > 1:\n                return True\n            if len(graph[source]) == 1 and even_degree_count > 0:\n                return True\n            if len(graph[source]) == 0:\n                return even_degree_count > 0\n            for v in graph[source]:\n                if not seen[v]:\n                    if dfs2(graph, v, cycle, even_degree_count):\n                        for u, v in edges:\n                            if u == source:\n                                cycle[u - 1] = False\n                        return True\n            return False\n\n    # print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n", "var fs = require('fs');\n\nfs.readFile('file.txt', 'utf8', function(err, data) {\n    if (err) throw err;\n    console.log(data);\n});\n", "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [list(next(reader) for _ in range(2)) for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Sep  4 12:08:06 2018\n\n@author: luolei\n\n\u6587\u4ef6\u8bfb\u5199\n\"\"\"\nimport os\nimport shutil\n\n\ndef file_read(file_path):\n    \"\"\"\n    \u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\n    :param file_path: \u6587\u4ef6\u8def\u5f84\n    :return: \u6587\u4ef6\u5185\u5bb9\n    \"\"\"\n    with open(file_path, 'r') as f:\n        content = f.read()\n    return content\n\n\ndef file_write(file_path, content):\n    \"\"\"\n    \u5199\u5165\u6587\u4ef6\u5185\u5bb9\n    :param file_path: \u6587\u4ef6\u8def\u5f84\n    :param content: \u6587\u4ef6\u5185\u5bb9\n    :return:\n    \"\"\"\n    with open(file_path, 'w') as f:\n        f.write(content)\n\n\ndef file_append(file_path, content):\n    \"\"\"\n    \u8ffd\u52a0\u6587\u4ef6\u5185\u5bb9\n    :param file_path: \u6587\u4ef6\u8def\u5f84\n    :param content: \u6587\u4ef6\u5185\u5bb9\n    :return:\n    \"\"\"\n    with open(file_path, 'a') as f:\n        f.write(content)\n\n\ndef file_copy(src_file_path, dst_file_path):\n    \"\"\"\n    \u590d\u5236\u6587\u4ef6\n    :param src_file_path: \u6e90\u6587\u4ef6\u8def\u5f84\n    :param dst_file_path: \u76ee\u6807\u6587\u4ef6\u8def\u5f84\n    :return:\n    \"\"\"\n    shutil.copyfile(src_file_path, dst_file_path)\n\n\ndef file_move(src_file_path, dst_file_path):\n    \"\"\"\n    \u79fb\u52a8\u6587\u4ef6\n    :param src_file_path: \u6e90\u6587\u4ef6\u8def\u5f84\n    :param dst_file_path: \u76ee\u6807\u6587\u4ef6\u8def\u5f84\n    :return:\n    \"\"\"\n    shutil.move(src_file_path, dst_file_path)\n\n\ndef file_delete(file_path):\n    \"\"\"\n    \u5220\u9664\u6587\u4ef6\n    :param file_path: \u6587\u4ef6\u8def\u5f84\n    :return:\n    \"\"\"\n    os.remove(file_path)\n\n\ndef file_rename(src_file_path, dst_file_path):\n    \"\"\"\n    \u91cd\u547d\u540d\u6587\u4ef6\n    :param src_file_path: \u6e90\u6587\u4ef6\u8def\u5f84\n    :param dst_file_path: \u76ee\u6807\u6587\u4ef6\u8def\u5f84\n    :return:\n    \"\"\"\n    os.rename(src_file_path, dst_file_path)\n\n\ndef file_create(file_path):\n    \"\"\"\n    \u521b\u5efa\u6587\u4ef6\n    :param file_path: \u6587\u4ef6\u8def\u5f84\n    :return:\n    \"\"\"\n    with open(file_path, 'w') as f:\n        pass\n\n\ndef file_create_dir(dir_path):\n    \"\"\"\n    \u521b\u5efa\u6587\u4ef6\u5939\n    :param dir_path: \u6587\u4ef6\u5939\u8def\u5f84\n    :return:\n    \"\"\"\n    os.makedirs(dir_path)\n\n\ndef file_delete_dir(dir_path):\n    \"\"\"\n    \u5220\u9664\u6587\u4ef6\u5939\n    :param dir_path: \u6587\u4ef6\u5939\u8def\u5f84\n    :return:\n    \"\"\"\n    shutil.rmtree(dir_path)\n\n\ndef file_rename_dir(src_dir_path, dst_dir_path):\n    \"\"\"\n    \u91cd\u547d\u540d\u6587\u4ef6\u5939\n    :param src_dir_path: \u6e90\u6587\u4ef6\u5939\u8def\u5f84\n    :param dst_dir_path: \u76ee\u6807\u6587\u4ef6\u5939\u8def\u5f84\n    :return:\n    \"\"\"\n    os.rename(src_dir_path, dst_dir_path)\n\n\ndef file_list_dir(dir_path):\n    \"\"\"\n    \u83b7\u53d6\u6587\u4ef6\u5939\u4e0b\u6240\u6709\u6587\u4ef6\n    :param dir_path: \u6587\u4ef6\u5939\u8def\u5f84\n    :return:\n    \"\"\"\n    file_list = os.listdir(dir_path)\n    return file_list\n\n\ndef file_is_exist(file_path):\n    \"\"\"\n    \u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728\n    :param file_path: \u6587\u4ef6\u8def\u5f84\n    :return:\n    \"\"\"\n    return os.path.exists(file_path)\n\n\nif __name__ == '__main__':\n    pass\n", "\nimport sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]: \n        if u == parent: \n            continue \n        if used[u]: \n            continue \n        if dfs(graph, u, v, used, 1 - color): \n            return True \n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges: \n        graph[u - 1].append(v - 1) \n        graph[v - 1].append(u - 1) \n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0): \n        print('NO') \n        return \n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    print(cycle)\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n"]