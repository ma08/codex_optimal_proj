2022-04-18 02:12:56.324491 """
The only difference between problems C1 and C2 is that all values in input of problem C1 are distinct (this condition may be false for problem C2).

You are given a sequence $a$ consisting of $n$ integers. All these integers are distinct, each value from $1$ to $n$ appears in the sequence exactly once.

You are making a sequence of moves. During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence, write it down and remove it from the sequence. Your task is to write down a strictly increasing sequence, and among all such sequences you should take the longest (the length of the sequence is the number of elements in it).

For example, for the sequence $[2, 1, 5, 4, 3]$ the answer is $4$ (you take $2$ and the sequence becomes $[1, 5, 4, 3]$, then you take the rightmost element $3$ and the sequence becomes $[1, 5, 4]$, then you take $4$ and the sequence becomes $[1, 5]$ and then you take $5$ and the sequence becomes $[1]$, the obtained increasing sequence is $[2, 3, 4, 5]$).


-----Input-----

The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of elements in $a$.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le n$), where $a_i$ is the $i$-th element of $a$. All these integers are pairwise distinct.


-----Output-----

In the first line of the output print $k$ — the maximum number of elements in a strictly increasing sequence you can obtain.

In the second line print a string $s$ of length $k$, where the $j$-th character of this string $s_j$ should be 'L' if you take the leftmost element during the $j$-th move and 'R' otherwise. If there are multiple answers, you can print any.


-----Examples-----
Input
5
2 1 5 4 3

Output
4
LRRR

Input
7
1 3 5 6 7 4 2

Output
7
LRLRLLL

Input
3
1 2 3

Output
3
LLL

Input
4
1 2 4 3

Output
4
LLRL



-----Note-----

The first example is described in the problem statement.
"""
2022-04-18 02:12:56.324526 --------------------------
2022-04-18 02:13:35.580221 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ans = [0] * n\n    stack = []\n    for i in range(n):\n        while stack and nums[stack[-1]] < nums[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    for i in range(n - 1, -1, -1):\n        while stack and nums[stack[-1]] < nums[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    max_ans = 0\n    for i in range(n):\n        max_ans = max(max_ans, ans[i] - i + 1)\n    print(max_ans)\n    for i in range(n):\n        if i == n - 1 or ans[i] < ans[i + 1]:\n            print('L', end='')\n        else:\n            print('R', end='')\n    print()\n\nmain()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\n# In the optimal solution the sequence must be strictly increasing.\n# We can find the longest strictly increasing subsequence in linear time.\n# (See https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms)\n#\n# The optimal solution then consists of the longest strictly increasing subsequence\n# followed by the remaining elements from the original sequence.\n\n# Find the longest increasing subsequence.\n# We use a list to store the indices of the sequence.\n# The indices are sorted according to the corresponding elements in the sequence.\n# The last element of the list is the smallest element of the longest increasing subsequence.\n# If a new element is larger than the last element in the list, we append it to the list.\n# Otherwise, we replace the smallest element that is larger than the new element with the new element.\n# This way the list always represents the longest increasing subsequence.\nlis = []\nfor i in range(n):\n    if lis == []:\n        lis.append(i)\n    elif a[i] > a[lis[-1]]:\n        lis.append(i)\n    else:\n        for j in range(len(lis)):\n            if a[lis[j]] > a[i]:\n                lis[j] = i\n                break\n\n# Construct the solution from the longest increasing subsequence.\ns = ['L' for _ in range(len(lis))]\nleft = [0] * n\nfor i in range(len(lis)):\n    left[lis[i]] = 1\n    if i > 0:\n        left[lis[i]] += left[lis[i-1]]\n\nfor i in range(len(lis)):\n    if i == len(lis) - 1 or left[lis[i]] < left[lis[i+1]]:\n        s[i] = 'R'\n\n# Print the answer.\nprint(len(lis))\nprint(''.join(s))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Get the reverse sorted indices for the array\n    r_sorted_idx = sorted(range(len(a)), key=lambda k: a[k])\n    r_sorted_idx.reverse()\n\n    # For each index, find the longest increasing subsequence starting at that index\n    # Keep track of the best subsequence and the corresponding indexes\n    longest_sequence = 0\n    best_idx = 0\n\n    for i in range(n):\n        # keep track of the last index visited in the sequence\n        last_visited_idx = 0\n        # keep track of the current length of the subsequence\n        curr_len = 0\n        # keep track of the current index\n        curr_idx = i\n\n        while curr_idx < n:\n            # If the current index is greater than the last visited index, then\n            # this index can be added to the increasing subsequence\n            if r_sorted_idx[curr_idx] > last_visited_idx:\n                last_visited_idx = r_sorted_idx[curr_idx]\n                curr_len += 1\n            curr_idx += 1\n\n        # If the current subsequence is longer than the previous best, then\n        # update the best subsequence and the corresponding indexes\n        if curr_len > longest_sequence:\n            longest_sequence = curr_len\n            best_idx = i\n\n    # Print out the length of the longest subsequence\n    print(longest_sequence)\n\n    curr_idx = best_idx\n    while curr_idx < n:\n        # If the current index is greater than the last visited index, then\n        # this index can be added to the increasing subsequence\n        if r_sorted_idx[curr_idx] > last_visited_idx:\n            last_visited_idx = r_sorted_idx[curr_idx]\n            # if the index is the leftmost element, print L, else print R\n            if last_visited_idx == 0:\n                print('L', end='')\n            else:\n                print('R', end='')\n        curr_idx += 1\n\n\nmain()"
    }
  ],
  "created": 1650247976,
  "id": "cmpl-4yBAmU9wilLqtpY2ov3vqdN61ZRG4",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 02:13:35.580464 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ans = [0] * n\n    stack = []\n    for i in range(n):\n        while stack and nums[stack[-1]] < nums[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    for i in range(n - 1, -1, -1):\n        while stack and nums[stack[-1]] < nums[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    max_ans = 0\n    for i in range(n):\n        max_ans = max(max_ans, ans[i] - i + 1)\n    print(max_ans)\n    for i in range(n):\n        if i == n - 1 or ans[i] < ans[i + 1]:\n            print('L', end='')\n        else:\n            print('R', end='')\n    print()\n\nmain()"
}
2022-04-18 02:13:35.580500 REASON stop
2022-04-18 02:13:35.602048 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn = int(input())\na = [int(x) for x in input().split()]\n\n# In the optimal solution the sequence must be strictly increasing.\n# We can find the longest strictly increasing subsequence in linear time.\n# (See https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms)\n#\n# The optimal solution then consists of the longest strictly increasing subsequence\n# followed by the remaining elements from the original sequence.\n\n# Find the longest increasing subsequence.\n# We use a list to store the indices of the sequence.\n# The indices are sorted according to the corresponding elements in the sequence.\n# The last element of the list is the smallest element of the longest increasing subsequence.\n# If a new element is larger than the last element in the list, we append it to the list.\n# Otherwise, we replace the smallest element that is larger than the new element with the new element.\n# This way the list always represents the longest increasing subsequence.\nlis = []\nfor i in range(n):\n    if lis == []:\n        lis.append(i)\n    elif a[i] > a[lis[-1]]:\n        lis.append(i)\n    else:\n        for j in range(len(lis)):\n            if a[lis[j]] > a[i]:\n                lis[j] = i\n                break\n\n# Construct the solution from the longest increasing subsequence.\ns = ['L' for _ in range(len(lis))]\nleft = [0] * n\nfor i in range(len(lis)):\n    left[lis[i]] = 1\n    if i > 0:\n        left[lis[i]] += left[lis[i-1]]\n\nfor i in range(len(lis)):\n    if i == len(lis) - 1 or left[lis[i]] < left[lis[i+1]]:\n        s[i] = 'R'\n\n# Print the answer.\nprint(len(lis))\nprint(''.join(s))"
}
2022-04-18 02:13:35.602165 REASON stop
2022-04-18 02:13:35.602619 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Get the reverse sorted indices for the array\n    r_sorted_idx = sorted(range(len(a)), key=lambda k: a[k])\n    r_sorted_idx.reverse()\n\n    # For each index, find the longest increasing subsequence starting at that index\n    # Keep track of the best subsequence and the corresponding indexes\n    longest_sequence = 0\n    best_idx = 0\n\n    for i in range(n):\n        # keep track of the last index visited in the sequence\n        last_visited_idx = 0\n        # keep track of the current length of the subsequence\n        curr_len = 0\n        # keep track of the current index\n        curr_idx = i\n\n        while curr_idx < n:\n            # If the current index is greater than the last visited index, then\n            # this index can be added to the increasing subsequence\n            if r_sorted_idx[curr_idx] > last_visited_idx:\n                last_visited_idx = r_sorted_idx[curr_idx]\n                curr_len += 1\n            curr_idx += 1\n\n        # If the current subsequence is longer than the previous best, then\n        # update the best subsequence and the corresponding indexes\n        if curr_len > longest_sequence:\n            longest_sequence = curr_len\n            best_idx = i\n\n    # Print out the length of the longest subsequence\n    print(longest_sequence)\n\n    curr_idx = best_idx\n    while curr_idx < n:\n        # If the current index is greater than the last visited index, then\n        # this index can be added to the increasing subsequence\n        if r_sorted_idx[curr_idx] > last_visited_idx:\n            last_visited_idx = r_sorted_idx[curr_idx]\n            # if the index is the leftmost element, print L, else print R\n            if last_visited_idx == 0:\n                print('L', end='')\n            else:\n                print('R', end='')\n        curr_idx += 1\n\n\nmain()"
}
2022-04-18 02:13:35.602673 REASON stop
