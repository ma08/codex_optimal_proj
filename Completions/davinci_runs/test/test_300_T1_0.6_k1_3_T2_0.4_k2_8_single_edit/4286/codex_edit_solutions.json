["\n\n#!/usr/bin/env python3\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(1, 2, 5), (1, 3, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i + 1] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] += tree[v_idx]\n            del tree[v_idx]\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "import heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = sum(a)\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\n\nimport heapq\n\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# @Author: Shuailong\n# @Email: liangshuailong@gmail.com\n# @Date: 2019-05-11 22:50:34\n# @Last Modified by: Shuailong\n# @Last Modified time: 2019-05-11 22:50:34\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = set()\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.add(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs) if self.costs else 0\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i + 1] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(len(tree)):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(len(tree)):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\nimport heapq\n\nclass Graph:\n    def __init__(self, n, m):\n        self.n = n + 1\n        self.edges = [[] for _ in range(self.n)]\n        self.cost = [[float('inf') for _ in range(self.n)] for _ in range(self.n)]\n        self.costs = [float('inf')]\n        self.is_edge = [[False for _ in range(self.n)] for _ in range(self.n)]\n        self.m = m\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        if self.is_edge[u][v]:\n            self.costs[u] = min(self.costs[u], w)\n            self.costs[v] = min(self.costs[v], w)\n        else:\n            self.costs[u] = w\n            self.costs[v] = w\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0.0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 2) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n, m)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n\n# https://atcoder.jp/contests/abc172/tasks/abc172_e\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i + 1] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] += tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(a)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "import os\n\n\ndef main():\n    path = os.getcwd()\n    print(path)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    print(\"hello\")\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i + 1] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i] and v in tree[i]:\n                u_idx, v_idx = i, i\n            elif u in tree[i]:\n                u_idx = i\n            elif v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx].extend(tree[v_idx])\n            del tree[v_idx]\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\n\n\ndef read_file(filename):\n    pass\n\n\ndef write_file(filename, data):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"]