["\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print(\"NO\")\n        sys.exit(0)\n\n    print(\"YES\")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\n# Created by: Teddy Sannan\n# Created on: October 2019\n# This program shows the area and perimeter of a rectangle\n#    with user input\n\n\ndef main():\n    # this function shows the area and perimeter of a rectangle\n    # input\n    length = int(input(\"Enter length of the rectangle (mm): \"))\n    width = int(input(\"Enter width of the rectangle (mm): \"))\n    # process\n    area = length*width\n    perimeter = 2*(length+width)\n    # output\n    print(\"\")\n    print(\"Area is {}mm^2\".format(area))\n    print(\"Perimeter is {}mm\".format(perimeter))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print \"NO\"\n        sys.exit(0)\n\n    print \"YES\"\n    for i in range(1, n):\n        print i, graph[i - 1]\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print(\"NO\")\n        sys.exit(0)\n\n    print(\"YES\")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1 and k == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print(\"NO\")\n        sys.exit(0)\n\n    print(\"YES\")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n", "var http = require('http');\nvar fs = require('fs');\n\nhttp.createServer(function (req, res) {\n  fs.readFile('demofile1.html', function(err, data) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.write(data);\n    res.end();\n  });\n}).listen(8080);\n", "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    FILE *fptr;\n    int i, n, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10;\n    int sum = 0;\n    float avg = 0;\n    char ch;\n    char *filename = \"file.txt\";\n\n    fptr = fopen(filename, \"w\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    printf(\"Enter the number of integers to be written to the file: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter %d integers: \", n);\n\n    for (i = 0; i < n; ++i) {\n        scanf(\"%d\", &n1);\n        fprintf(fptr, \"%d\\n\", n1);\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    while ((ch = fgetc(fptr)) != EOF) {\n        printf(\"%c\", ch);\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n2);\n        sum += n2;\n    }\n\n    avg = (float)sum / n;\n\n    printf(\"\\nSum of all integers = %d\\n\", sum);\n    printf(\"Average of all integers = %.2f\", avg);\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n3);\n        if (n3 % 2 == 0) {\n            printf(\"\\n%d is an even integer\", n3);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n4);\n        if (n4 % 2 != 0) {\n            printf(\"\\n%d is an odd integer\", n4);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n5);\n        if (n5 > 0) {\n            printf(\"\\n%d is a positive integer\", n5);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n6);\n        if (n6 < 0) {\n            printf(\"\\n%d is a negative integer\", n6);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n7);\n        if (n7 % 2 == 0 && n7 > 0) {\n            printf(\"\\n%d is an even positive integer\", n7);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n8);\n        if (n8 % 2 == 0 && n8 < 0) {\n            printf(\"\\n%d is an even negative integer\", n8);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n9);\n        if (n9 % 2 != 0 && n9 > 0) {\n            printf(\"\\n%d is an odd positive integer\", n9);\n        }\n    }\n\n    fclose(fptr);\n\n    fptr = fopen(filename, \"r\");\n\n    if (fptr == NULL) {\n        printf(\"Error!\");\n        exit(1);\n    }\n\n    for (i = 0; i < n; ++i) {\n        fscanf(fptr, \"%d\", &n10);\n        if (n10 % 2 != 0 && n10 < 0) {\n            printf(\"\\n%d is an odd negative integer\", n10);\n        }\n    }\n\n    fclose(fptr);\n\n    return 0;\n}\n", "var fs = require('fs');\n\nfs.readFile(process.argv[2], function(err, data) {\n  if (err) {\n    console.log(err);\n  } else {\n    var lines = data.toString().split('\\n').length - 1;\n    console.log(lines);\n  }\n});\n", "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n\tFILE *fp;\n\tchar c;\n\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Usage: %s <file>\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tfp = fopen(argv[1], \"r\");\n\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Cannot open %s\\n\", argv[1]);\n\t\treturn 1;\n\t}\n\n\twhile ((c = fgetc(fp)) != EOF)\n\t\tputchar(c);\n\n\tfclose(fp);\n\n\treturn 0;\n}\n", "import os\nimport sys\nimport time\nimport shutil\nimport zipfile\n\ndef main():\n    if len(sys.argv) > 1:\n        if sys.argv[1] == '-h' or sys.argv[1] == '--help':\n            print('Usage: python3 file.py [OPTION] [PATH]')\n            print('Create a new file or directory')\n            print('  -h, --help       display this help and exit')\n            print('  -f, --file       create a new file')\n            print('  -d, --dir        create a new directory')\n            print('  -z, --zip        create a new zip file')\n            print('  -u, --unzip      unzip a zip file')\n            print('  -r, --remove     remove a file or directory')\n            print('  -c, --copy       copy a file or directory')\n            print('  -m, --move       move a file or directory')\n            print('  -s, --search     search a file or directory')\n            print('  -l, --list       list all files and directories')\n            print('  -a, --all        list all files and directories with details')\n            print('  -p, --path       list the current path')\n            print('  -e, --edit       edit a file')\n            print('  -o, --open       open a file')\n            print('  -v, --version    display version info and exit')\n            print('  -i, --info       display file or directory info')\n            print('  -b, --back       back to the previous directory')\n            print('  -g, --goto       go to the specified directory')\n            print('  -t, --tree       display directory tree')\n        elif sys.argv[1] == '-v' or sys.argv[1] == '--version':\n            print('file.py version 1.0.0')\n        elif sys.argv[1] == '-f' or sys.argv[1] == '--file':\n            if len(sys.argv) > 2:\n                with open(sys.argv[2], 'w'):\n                    pass\n            else:\n                print('file.py: missing file operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-d' or sys.argv[1] == '--dir':\n            if len(sys.argv) > 2:\n                os.mkdir(sys.argv[2])\n            else:\n                print('file.py: missing directory operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-z' or sys.argv[1] == '--zip':\n            if len(sys.argv) > 2:\n                zip = zipfile.ZipFile(sys.argv[2] + '.zip', 'w', zipfile.ZIP_DEFLATED)\n                zip.close()\n            else:\n                print('file.py: missing zip file operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-u' or sys.argv[1] == '--unzip':\n            if len(sys.argv) > 2:\n                zip = zipfile.ZipFile(sys.argv[2], 'r')\n                zip.extractall(sys.argv[2][:-4])\n                zip.close()\n            else:\n                print('file.py: missing zip file operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-r' or sys.argv[1] == '--remove':\n            if len(sys.argv) > 2:\n                if os.path.isdir(sys.argv[2]):\n                    shutil.rmtree(sys.argv[2])\n                else:\n                    os.remove(sys.argv[2])\n            else:\n                print('file.py: missing file or directory operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-c' or sys.argv[1] == '--copy':\n            if len(sys.argv) > 3:\n                if os.path.isdir(sys.argv[2]):\n                    shutil.copytree(sys.argv[2], sys.argv[3])\n                else:\n                    shutil.copyfile(sys.argv[2], sys.argv[3])\n            else:\n                print('file.py: missing file or directory operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-m' or sys.argv[1] == '--move':\n            if len(sys.argv) > 3:\n                if os.path.isdir(sys.argv[2]):\n                    shutil.move(sys.argv[2], sys.argv[3])\n                else:\n                    shutil.move(sys.argv[2], sys.argv[3])\n            else:\n                print('file.py: missing file or directory operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-s' or sys.argv[1] == '--search':\n            if len(sys.argv) > 2:\n                for root, dirs, files in os.walk(os.getcwd()):\n                    if sys.argv[2] in dirs or sys.argv[2] in files:\n                        print(os.path.join(root, sys.argv[2]))\n            else:\n                print('file.py: missing file or directory operand')\n                print('Try \\'file.py --help\\' for more information.')\n        elif sys.argv[1] == '-l' or sys.argv[1] == '--list':\n            if len(sys.argv) > 2:\n                for file in os.listdir(sys.argv[2]):\n                    print(file)\n            else:\n                for file in os.listdir(os.getcwd()):\n                    print(file)\n        elif sys.argv[1] == '-a' or sys.argv[1] == '--all':\n            if len(sys.argv) > 2:\n                for file in os.listdir(sys.argv[2]):\n                    info = os.stat(sys.argv[2] + '/' + file)\n                    print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(info.st_mtime)), end=' ')\n                    if os.path.isdir(sys.argv[2] + '/' + file):\n                        print('<DIR>', end=' ')\n                    else:\n                        print(info.st_size, end=' ')\n                    print(file)\n            else:\n                for file in os.listdir(os.getcwd()):\n                    info = os.stat(file)\n                    print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(info.st_mtime)), end=' ')\n                    if os.path.isdir(file):\n                        print('<DIR>', end=' ')\n                    else:\n                        print(info.st_size, end=' ')\n                    print(file)\n        elif sys.argv[1] == '-p' or sys.argv[1] == '--path':\n            print(os.getcwd())\n        elif sys.argv[1] == '-e' or sys.argv[1] == '--edit':\n            if len(sys.argv) > 2:\n", "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport re\n\n\n\nclass File(object):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n        \"\"\"\n        self.path = path\n        self.name = os.path.basename(path)\n        self.size = os.path.getsize(path)\n        self.extension = os.path.splitext(path)[1]\n        self.mime = self.get_mime(self.extension)\n\n    def get_mime(self, extension):\n        \"\"\"\n        \"\"\"\n        mimes = {\n            '.txt': 'text/plain',\n            '.pdf': 'application/pdf',\n            '.doc': 'application/msword',\n            '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            '.xls': 'application/vnd.ms-excel',\n            '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            '.png': 'image/png',\n            '.jpg': 'image/jpeg',\n            '.jpeg': 'image/jpeg',\n            '.gif': 'image/gif',\n            '.zip': 'application/zip',\n            '.rar': 'application/x-rar-compressed',\n            '.tar': 'application/x-tar',\n            '.7z': 'application/x-7z-compressed',\n            '.gz': 'application/gzip',\n            '.bz2': 'application/x-bzip2'\n        }\n        return mimes.get(extension, 'application/octet-stream')\n\n\nclass Directory(object):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n        \"\"\"\n        self.path = path\n        self.name = os.path.basename(path)\n        self.size = self.get_size(path)\n        self.files = self.get_files(path)\n\n    def get_size(self, path):\n        \"\"\"\n        \"\"\"\n        size = 0\n        for root, dirs, files in os.walk(path):\n            size += sum([os.path.getsize(os.path.join(root, name)) for name in files])\n        return size\n\n    def get_files(self, path):\n        \"\"\"\n        \"\"\"\n        files = []\n        for root, dirs, files in os.walk(path):\n            for name in files:\n                files.append(File(os.path.join(root, name)))\n        return files\n\n\nclass FileManager(object):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, path):\n        \"\"\"\n        \"\"\"\n        self.path = path\n        self.name = os.path.basename(path)\n        self.size = self.get_size(path)\n        self.directories = self.get_directories(path)\n        self.files = self.get_files(path)\n\n    def get_size(self, path):\n        \"\"\"\n        \"\"\"\n        size = 0\n        for root, dirs, files in os.walk(path):\n            size += sum([os.path.getsize(os.path.join(root, name)) for name in files])\n        return size\n\n    def get_directories(self, path):\n        \"\"\"\n        \"\"\"\n        directories = []\n        for root, dirs, files in os.walk(path):\n            for name in dirs:\n                directories.append(Directory(os.path.join(root, name)))\n        return directories\n\n    def get_files(self, path):\n        \"\"\"\n        \"\"\"\n        files = []\n        for root, dirs, files in os.walk(path):\n            for name in files:\n                files.append(File(os.path.join(root, name)))\n        return files\n\n\ndef main():\n    \"\"\"\n    \"\"\"\n    print(FileManager('/home/lucas/Documents/'))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print (\"NO\")\n        sys.exit(0)\n\n    print (\"YES\")\n    for i in range(1, n):\n        print (i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n", "\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "var fs = require('fs');\nvar path = require('path');\n\nmodule.exports = function(dir, ext, callback) {\n  var extension = \".\" + ext;\n\n  fs.readdir(dir, function (err, list) {\n    if (err) {\n      return callback(err);\n    }\n\n    list = list.filter(function (file) {\n      return path.extname(file) === extension;\n    });\n\n    callback(null, list);\n  });\n};\n"]