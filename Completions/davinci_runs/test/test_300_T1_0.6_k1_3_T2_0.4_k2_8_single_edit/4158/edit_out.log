2022-04-20 18:00:10.604079 num operations 1
2022-04-20 18:00:10.604097 size on input set 1
2022-04-20 18:00:10.604250 using api key soukgp
2022-04-20 18:00:23.385734 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = []  # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9)) + 1):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "import math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2.\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order.\n    max_points = [] # List of points that satisfy the given condition.\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point.\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points,\n            # then we set the current points as the maximum points.\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order.\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650477610,
  "object": "edit"
}
2022-04-20 18:00:23.386201 fix syntax errors 8 ['import math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = []  # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9)) + 1):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', 'import math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2.\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order.\n    max_points = [] # List of points that satisfy the given condition.\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point.\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points,\n            # then we set the current points as the maximum points.\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order.\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 18:00:23.386351 size on output set 5
2022-04-20 18:00:23.386364 num operations 1
2022-04-20 18:00:23.386370 size on input set 1
2022-04-20 18:00:23.386563 using api key kouti
2022-04-20 18:00:43.230042 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # n = int(input())\n    # x = [int(i) for i in input().split()]\n\n    # d = {}\n    # for i in x:\n    #     if i not in d:\n    #         d[i] = 1\n    #     else:\n    #         d[i] += 1\n\n    # nums = sorted(d.keys())\n\n    # def helper(nums, d, i):\n    #     if i == len(nums):\n    #         return d\n\n    #     cur = nums[i]\n\n    #     if cur - 1 in d:\n    #         d[cur] += d[cur - 1]\n    #     if cur + 1 in d:\n    #         d[cur] += d[cur + 1]\n\n    #     return helper(nums, d, i + 1)\n\n    # d = helper(nums, d, 0)\n\n    # res = max(d.values())\n    # print(res)\n    # print(' '.join([str(i) for i in nums if d[i] == res]))\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()][:n]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res])[:n])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(res, d[cur]))\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()][:n]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, n):\n        if i == n:\n            return\n\n        cur = nums[i]\n\n        if cur - 1 in d and cur + 1 in d:\n            d[cur] += d[cur - 1] + d[cur + 1]\n        elif cur - 1 in d:\n            d[cur] += d[cur - 1]\n        elif cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, n)\n\n    helper(nums, d, 0, len(nums))\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join(str(i) for i in nums if d[i] == res))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()][:n]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, res)\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res])) \n\nif __name__ == '__main__':\n    main() \n"
    },
    {
      "index": 7,
      "text": "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]  # x = [int(i) for i in input().split()]\n\n    d = {}  # d = {}\n    for i in x:  # for i in x:\n        if i not in d:  # if i not in d:\n            d[i] = 1  # d[i] = 1\n        else:  # else:\n            d[i] += 1  # d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650477623,
  "object": "edit"
}
2022-04-20 18:00:43.230355 fix syntax errors 8 ["\n\ndef main():\n    # n = int(input())\n    # x = [int(i) for i in input().split()]\n\n    # d = {}\n    # for i in x:\n    #     if i not in d:\n    #         d[i] = 1\n    #     else:\n    #         d[i] += 1\n\n    # nums = sorted(d.keys())\n\n    # def helper(nums, d, i):\n    #     if i == len(nums):\n    #         return d\n\n    #     cur = nums[i]\n\n    #     if cur - 1 in d:\n    #         d[cur] += d[cur - 1]\n    #     if cur + 1 in d:\n    #         d[cur] += d[cur + 1]\n\n    #     return helper(nums, d, i + 1)\n\n    # d = helper(nums, d, 0)\n\n    # res = max(d.values())\n    # print(res)\n    # print(' '.join([str(i) for i in nums if d[i] == res]))\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()][:n]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res])[:n])\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(res, d[cur]))\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()][:n]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, n):\n        if i == n:\n            return\n\n        cur = nums[i]\n\n        if cur - 1 in d and cur + 1 in d:\n            d[cur] += d[cur - 1] + d[cur + 1]\n        elif cur - 1 in d:\n            d[cur] += d[cur - 1]\n        elif cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, n)\n\n    helper(nums, d, 0, len(nums))\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join(str(i) for i in nums if d[i] == res))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()][:n]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, res)\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res])) \n\nif __name__ == '__main__':\n    main() \n", "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]  # x = [int(i) for i in input().split()]\n\n    d = {}  # d = {}\n    for i in x:  # for i in x:\n        if i not in d:  # if i not in d:\n            d[i] = 1  # d[i] = 1\n        else:  # else:\n            d[i] += 1  # d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 18:00:43.230532 size on output set 8
2022-04-20 18:00:43.230547 num operations 1
2022-04-20 18:00:43.230553 size on input set 1
2022-04-20 18:00:43.230724 using api key jaanu
2022-04-20 18:00:50.258525 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0 and points[i] not in largest_subset:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 1,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 2,
      "text": "\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points.\n    :param points: list of points.\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset.\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list).\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 3,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 4,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 5,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = set()\n    largest_subset.add(points[0])\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.add(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*sorted(largest_subset))\n"
    },
    {
      "index": 6,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n        if points[i] not in largest_subset:\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i]) \n                break\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 7,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    }
  ],
  "created": 1650477643,
  "object": "edit"
}
2022-04-20 18:00:50.258840 fix syntax errors 8 ['\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0 and points[i] not in largest_subset:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points.\n    :param points: list of points.\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset.\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list).\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = set()\n    largest_subset.add(points[0])\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.add(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*sorted(largest_subset))\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n        if points[i] not in largest_subset:\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i]) \n                break\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n']
2022-04-20 18:00:50.259029 size on output set 6
