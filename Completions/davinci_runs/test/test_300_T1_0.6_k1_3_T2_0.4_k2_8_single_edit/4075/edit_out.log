2022-04-20 17:14:03.585903 num operations 1
2022-04-20 17:14:03.585930 size on input set 1
2022-04-20 17:14:03.586151 using api key jaanu
2022-04-20 17:14:19.425049 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# -*- coding: utf-8 -*-\n\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n"
    },
    {
      "index": 1,
      "text": "import sys\n\n\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(M)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(1, k+1):\n        switches[line[i]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons, cnt):\n    if n == M:\n        for i in range(M):\n            if light_states[i] != ons[i]:\n                return 0\n        return 1\n    if cnt == N:\n        return 0\n    return f(n, ons+[0], cnt+1) + f(n, ons+[1], cnt+1)\n\nprint(f(0, []))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(M)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(1, k+1):\n        switches[line[i]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons, M):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0], M) + f(n+1, ons+[1], M)\n\nprint(f(0, []))\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n"
    },
    {
      "index": 4,
      "text": "\nimport numpy as np\na = np.zeros(3)\na[1] = 1\nprint(a)\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons + [0]) + f(n+1, ons + [1])\n\nprint(f(0, []))\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 1:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input().split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in input().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in input().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n"
    }
  ],
  "created": 1650474843,
  "object": "edit"
}
2022-04-20 17:14:19.425394 fix syntax errors 8 ['# -*- coding: utf-8 -*-\n\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n', 'import sys\n\n\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(M)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(1, k+1):\n        switches[line[i]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons, cnt):\n    if n == M:\n        for i in range(M):\n            if light_states[i] != ons[i]:\n                return 0\n        return 1\n    if cnt == N:\n        return 0\n    return f(n, ons+[0], cnt+1) + f(n, ons+[1], cnt+1)\n\nprint(f(0, []))\n', '\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(M)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(1, k+1):\n        switches[line[i]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons, M):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0], M) + f(n+1, ons+[1], M)\n\nprint(f(0, []))\n', '\nimport sys\ninput = sys.stdin.readline\n\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n', '\nimport numpy as np\na = np.zeros(3)\na[1] = 1\nprint(a)\n', '\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons + [0]) + f(n+1, ons + [1])\n\nprint(f(0, []))\n', '\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input.split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in sys.stdin.readline().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in sys.stdin.readline().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 1:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n', '\nimport sys\ninput = sys.stdin.readline()\nN, M = [int(i) for i in input().split()]\n\nswitches = [[] for _ in range(N)]\nfor _ in range(M):\n    line = [int(i) for i in input().split()]\n    k = line[0]\n    for i in range(k):\n        switches[line[i+1]-1].append(_)\n\nlight_states = [int(i) for i in input().split()]\n\ndef f(n, ons):\n    if n == N:\n        for i in range(M):\n            if light_states[i] == 1 and sum([1 for j in switches[i] if ons[j] == 1]) % 2 == 0:\n                return 0\n        return 1\n    return f(n+1, ons+[0]) + f(n+1, ons+[1])\n\nprint(f(0, []))\n']
2022-04-20 17:14:19.425538 size on output set 8
2022-04-20 17:14:19.425552 num operations 1
2022-04-20 17:14:19.425558 size on input set 1
2022-04-20 17:14:19.425719 using api key sunu
2022-04-20 17:14:29.643971 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j + 1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k + 1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 3,
      "text": "\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 4,
      "text": "import sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\nbulbs = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 5,
      "text": "\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = set()\n    for j in range(N):\n        if (i >> j) & 1:\n            on.add(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:  # if on[bulbs[j][k+1]]:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 6,
      "text": "\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 7,
      "text": "import sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(1<<N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n"
    }
  ],
  "created": 1650474859,
  "object": "edit"
}
2022-04-20 17:14:29.644296 fix syntax errors 8 ['\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', '\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j + 1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k + 1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', '\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', '\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', 'import sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\nbulbs = [list(map(int, input().split())) for _ in range(m)]\np = list(map(int, input().split()))\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', '\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = set()\n    for j in range(N):\n        if (i >> j) & 1:\n            on.add(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:  # if on[bulbs[j][k+1]]:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', '\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(2**N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n', 'import sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\nbulbs = []\nfor i in range(M):\n    bulbs.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(1<<N):\n    on = []\n    for j in range(N):\n        if (i >> j) & 1:\n            on.append(j+1)\n    flag = True\n    for j in range(M):\n        cnt = 0\n        for k in range(bulbs[j][0]):\n            if bulbs[j][k+1] in on:\n                cnt += 1\n        if (cnt % 2) != p[j]:\n            flag = False\n            break\n    if flag:\n        ans += 1\n\nprint(ans)\n']
2022-04-20 17:14:29.644454 size on output set 5
2022-04-20 17:14:29.644473 num operations 1
2022-04-20 17:14:29.644479 size on input set 1
2022-04-20 17:14:29.644645 using api key sunu
2022-04-20 17:14:55.633790 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Sep 26 16:12:51 2019\n@author: mert\n\"\"\"\nimport sys, math\ndef main(argv):\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split() \n    n = int(n)\n    m = int(m) \n    # Get the connected switches and p for each bulb\n    bulbs = [] \n    for i in range(m):\n        # Get the number of switches that are connected to the bulb \n        k = int(sys.stdin.readline().split()[0]) \n        # Get the connected switches \n        switches = [int(s) for s in sys.stdin.readline().split()] \n        # Get p \n        p = int(sys.stdin.readline().split()[0]) \n        bulbs.append({'switches': switches, 'p': p}) \n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs \n    count = 0 \n    switches = [0] * n \n    while True: \n        if is_all_bulbs_lighted(bulbs, switches): \n            # print_switch_status(bulbs, switches) \n            count += 1 \n        # Increase the switch count \n        switches[0] += 1 \n        for i in range(n - 1): \n            if switches[i] == 2: \n                switches[i] = 0 \n                switches[i + 1] += 1 \n        if switches[n - 1] == 2: \n            break \n    print(count) \ndef is_all_bulbs_lighted(bulbs, switches): \n    for bulb in bulbs: \n        bulb_switch_count = 0 \n        # On/Off state of switches that are connected to the bulb \n        for switch in bulb['switches']: \n            bulb_switch_count += switches[switch - 1] \n        # If the count is not congruent to p mod 2, the bulb is not lit \n        if bulb_switch_count % 2 != bulb['p']: \n            return False \n    return True \ndef print_switch_status(bulbs, switches): \n    switch_status = [] \n    for i in range(len(switches)): \n        switch_status.append('on' if switches[i] == 1 else 'off') \n    print(switch_status) \nif __name__ == \"__main__\": \n    main(sys.argv)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = [int(x) for x in sys.stdin.readline().split()]\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb['switches']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb['p']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append('on' if switches[i] == 1 else 'off')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = [int(s) for s in sys.stdin.readline().split()]\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({'switches': switches, 'p': p})\n    # Calculate the number of combinations of \"on\" and \"off\" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650474869,
  "object": "edit"
}
2022-04-20 17:14:55.634290 fix syntax errors 8 ['\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\nCreated on Thu Sep 26 16:12:51 2019\n@author: mert\n"""\nimport sys, math\ndef main(argv):\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split() \n    n = int(n)\n    m = int(m) \n    # Get the connected switches and p for each bulb\n    bulbs = [] \n    for i in range(m):\n        # Get the number of switches that are connected to the bulb \n        k = int(sys.stdin.readline().split()[0]) \n        # Get the connected switches \n        switches = [int(s) for s in sys.stdin.readline().split()] \n        # Get p \n        p = int(sys.stdin.readline().split()[0]) \n        bulbs.append({\'switches\': switches, \'p\': p}) \n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs \n    count = 0 \n    switches = [0] * n \n    while True: \n        if is_all_bulbs_lighted(bulbs, switches): \n            # print_switch_status(bulbs, switches) \n            count += 1 \n        # Increase the switch count \n        switches[0] += 1 \n        for i in range(n - 1): \n            if switches[i] == 2: \n                switches[i] = 0 \n                switches[i + 1] += 1 \n        if switches[n - 1] == 2: \n            break \n    print(count) \ndef is_all_bulbs_lighted(bulbs, switches): \n    for bulb in bulbs: \n        bulb_switch_count = 0 \n        # On/Off state of switches that are connected to the bulb \n        for switch in bulb[\'switches\']: \n            bulb_switch_count += switches[switch - 1] \n        # If the count is not congruent to p mod 2, the bulb is not lit \n        if bulb_switch_count % 2 != bulb[\'p\']: \n            return False \n    return True \ndef print_switch_status(bulbs, switches): \n    switch_status = [] \n    for i in range(len(switches)): \n        switch_status.append(\'on\' if switches[i] == 1 else \'off\') \n    print(switch_status) \nif __name__ == "__main__": \n    main(sys.argv)\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = sys.stdin.readline().split()\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = [int(x) for x in sys.stdin.readline().split()]\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\ndef is_all_bulbs_lighted(bulbs, switches):\n    for bulb in bulbs:\n        bulb_switch_count = 0\n        # On/Off state of switches that are connected to the bulb\n        for switch in bulb[\'switches\']:\n            bulb_switch_count += switches[switch - 1]\n        # If the count is not congruent to p mod 2, the bulb is not lit\n        if bulb_switch_count % 2 != bulb[\'p\']:\n            return False\n    return True\n\ndef print_switch_status(bulbs, switches):\n    switch_status = []\n    for i in range(len(switches)):\n        switch_status.append(\'on\' if switches[i] == 1 else \'off\')\n    print(switch_status)\n\ndef main():\n    # Get the number of switches and bulbs\n    [n, m] = [int(s) for s in sys.stdin.readline().split()]\n    n = int(n)\n    m = int(m)\n    # Get the connected switches and p for each bulb\n    bulbs = []\n    for i in range(m):\n        # Get the number of switches that are connected to the bulb\n        k = int(sys.stdin.readline().split()[0])\n        # Get the connected switches\n        switches = [int(s) for s in sys.stdin.readline().split()]\n        # Get p\n        p = int(sys.stdin.readline().split()[0])\n        bulbs.append({\'switches\': switches, \'p\': p})\n    # Calculate the number of combinations of "on" and "off" states of the switches that light all the bulbs\n    count = 0\n    switches = [0] * n\n    while True:\n        if is_all_bulbs_lighted(bulbs, switches):\n            # print_switch_status(bulbs, switches)\n            count += 1\n        # Increase the switch count\n        switches[0] += 1\n        for i in range(n - 1):\n            if switches[i] == 2:\n                switches[i] = 0\n                switches[i + 1] += 1\n        if switches[n - 1] == 2:\n            break\n    print(count)\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-20 17:14:55.634509 size on output set 4
