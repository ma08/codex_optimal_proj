["\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2], end='')\n    else:\n        print(0, end='')\n\nmain()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(int(find_max_intersection_length(n, segments)))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)  # TODO: Uncomment.\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]  # TODO: Uncomment.\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by ending point\n    segments = sorted(segments, key = lambda x: x[1])\n\n    # Find the intersection of all segments, starting with the last segment\n    intersection = segments[-1]\n    for segment in reversed(segments):\n        if segment[0] > intersection[0]:\n            # The segment intersects the intersection, so add it to the intersection\n            intersection[0] = segment[0]\n\n    # Check each segment for the max length, starting with the last segment\n    max_length = intersection[1] - intersection[0]\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[0] > temp_intersection[0]:\n            # The segment intersects the intersection, so add it to the intersection\n            temp_intersection[0] = segment[0]\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n", "\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n", "\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by ending point\n    segments = sorted(segments, key = lambda x: x[1])\n\n    # Find the union of all segments\n    union = [segments[0][0], segments[0][1]]\n    for i in range(1, n):\n        if segments[i][0] > union[1]:\n            # The segment does not intersect the union\n            union[0] = segments[i][0]\n            union[1] = segments[i][1]\n        elif segments[i][1] > union[1]:\n            # The segment intersects the union\n            union[1] = segments[i][1]\n    union_length = union[1] - union[0]\n\n    # Check each segment for the max length\n    max_length = union_length\n    for i in range(n):\n        # Find the union of all segments except the current one\n        temp_union = union\n        if segments[i][0] > temp_union[1]:\n            # The segment does not intersect the union\n            temp_union[0] = segments[i][0]\n            temp_union[1] = segments[i][1]\n        elif segments[i][1] > temp_union[1]:\n            # The segment intersects the union\n            temp_union[1] = segments[i][1]\n        temp_union_length = temp_union[1] - temp_union[0]\n        if temp_union_length > max_length:\n            max_length = temp_union_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    # reader = (map(int, line.split()) for line in sys.stdin)\n    # n, segments = next(reader), list(reader)\n    n, segments = test_data()\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    segments = [[random.randint(0, 10 ** 9), random.randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments, solution(n, segments)\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n    intersection = min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        return 0\n\n    # Find the middle and the highest segment, and the intersection of the middle two segments.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            intersection\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            intersection\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin) # Reads in the input.\n    n, segments = next(reader), list(reader) # Separates the number of segments and the segments.\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(solution(n - 1, segments[:middle] + segments[middle + 1:]), min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0]))\n    else:\n        return max(solution(n - 1, segments[:middle + 1] + segments[middle + 2:]), min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0]))\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in xrange(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin.readlines())\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader)\n    segments = list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = segments[0]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection = [max(intersection[0], segment[0]), min(intersection[1], segment[1])]\n    intersection_length = intersection[1] - intersection[0] + 1\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection = [max(temp_intersection[0], segment[0]), min(temp_intersection[1], segment[1])]\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0] + 1\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"]