2022-04-20 16:30:26.182431 num operations 1
2022-04-20 16:30:26.182442 size on input set 1
2022-04-20 16:30:26.182587 using api key sourya
2022-04-20 16:31:09.346345 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    pass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 4,
      "text": "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 5,
      "text": "import sys\n\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent=-1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef dfs(v, parent=-1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    }
  ],
  "created": 1650472227,
  "object": "edit"
}
2022-04-20 16:31:09.346813 fix syntax errors 8 ['# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', '\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', '\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    pass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', 'import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', 'import sys\n\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent=-1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', '\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', '\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef dfs(v, parent=-1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n']
2022-04-20 16:31:09.346900 size on output set 7
2022-04-20 16:31:09.346915 num operations 1
2022-04-20 16:31:09.346921 size on input set 1
2022-04-20 16:31:09.347087 using api key derek
2022-04-20 16:31:10.318829 in retry 6 1.5 <class 'Exception'>, Retrying in 1 seconds...
2022-04-20 16:31:11.820754 using api key gabby
2022-04-20 16:31:20.851518 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res, a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "# https://codeforces.com/contest/1325/problem/A\n\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    x = i\n                    y = j\n                    z = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            z = k\n                            break\n    print(res)\n    print(x, y, z)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650472272,
  "object": "edit"
}
2022-04-20 16:31:20.851963 fix syntax errors 8 ['\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res, a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '# https://codeforces.com/contest/1325/problem/A\n\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        x, y = map(int, sys.stdin.readline().split())\n        graph[x].append(y)\n        graph[y].append(x)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    x = i\n                    y = j\n                    z = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            z = k\n                            break\n    print(res)\n    print(x, y, z)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 16:31:20.852136 size on output set 4
2022-04-20 16:31:20.852150 num operations 1
2022-04-20 16:31:20.852156 size on input set 1
2022-04-20 16:31:20.852311 using api key sunu
2022-04-20 16:31:40.031842 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    print(\"Hello, World!\")\n\n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b) \n        adj[b].append(a) \n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n\n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650472281,
  "object": "edit"
}
2022-04-20 16:31:40.032254 fix syntax errors 8 ['\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    print("Hello, World!")\n\n    \nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b) \n        adj[b].append(a) \n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n\n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    adj = [ [] for _ in range(n+1) ]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 16:31:40.032377 size on output set 7
