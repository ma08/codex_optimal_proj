2022-04-20 18:02:09.748463 num operations 1
2022-04-20 18:02:09.748489 size on input set 1
2022-04-20 18:02:09.748646 using api key soukgp
2022-04-20 18:02:26.301867 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N.\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 1,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 2,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 3,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 4,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 5,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 6,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 7,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    }
  ],
  "created": 1650477729,
  "object": "edit"
}
2022-04-20 18:02:26.302304 fix syntax errors 8 ['\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N.\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n']
2022-04-20 18:02:26.302459 size on output set 2
2022-04-20 18:02:26.302472 num operations 1
2022-04-20 18:02:26.302479 size on input set 1
2022-04-20 18:02:26.302657 using api key sunu
2022-04-20 18:02:31.430236 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 1,
      "text": "from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 2,
      "text": "\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 3,
      "text": "\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 4,
      "text": "from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 5,
      "text": "\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 6,
      "text": "\nfrom math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 7,
      "text": "from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    }
  ],
  "created": 1650477746,
  "object": "edit"
}
2022-04-20 18:02:31.430578 fix syntax errors 8 ['from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', 'from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', '\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', '\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', 'from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', '\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', '\nfrom math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', 'from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n']
2022-04-20 18:02:31.430627 size on output set 4
2022-04-20 18:02:31.430639 num operations 1
2022-04-20 18:02:31.430646 size on input set 1
2022-04-20 18:02:31.430814 using api key gabby
2022-04-20 18:02:31.466143 in retry 6 1.5 <class 'Exception'>, Retrying in 1 seconds...
2022-04-20 18:02:32.968049 using api key gabby
2022-04-20 18:02:33.003305 in retry 5 3.0 <class 'Exception'>, Retrying in 3 seconds...
2022-04-20 18:02:36.006723 using api key jaanu
2022-04-20 18:02:42.157983 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\n\ndef main():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * (N + 1)\n    for i in range(N):\n        for j in range(N):\n            B[j + 1] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650477756,
  "object": "edit"
}
2022-04-20 18:02:42.158486 fix syntax errors 8 ["\nimport sys\n\n\ndef main():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * (N + 1)\n    for i in range(N):\n        for j in range(N):\n            B[j + 1] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = [0] * N\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 18:02:42.158544 size on output set 5
