2022-04-20 17:55:28.491976 num operations 1
2022-04-20 17:55:28.491998 size on input set 1
2022-04-20 17:55:28.492167 using api key jaanu
2022-04-20 17:55:35.302454 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"
    },
    {
      "index": 3,
      "text": "\nfrom sys import stdin\n\ns = stdin.readline()\n"
    },
    {
      "index": 4,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"
    },
    {
      "index": 5,
      "text": "\n\nfrom sys import stdin\ns = s[:-1]\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"
    },
    {
      "index": 6,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0s and 1s\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint min(count.values()) * 2\n"
    },
    {
      "index": 7,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"
    }
  ],
  "created": 1650477328,
  "object": "edit"
}
2022-04-20 17:55:35.302769 fix syntax errors 8 ["\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n", '\n\nfrom sys import stdin\n\ns = stdin.readline()\n\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n', "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n", '\nfrom sys import stdin\n\ns = stdin.readline()\n', "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n", "\n\nfrom sys import stdin\ns = s[:-1]\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n", '\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0s and 1s\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint min(count.values()) * 2\n', "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint(min(count.values()) * 2)\n"]
2022-04-20 17:55:35.302810 size on output set 5
2022-04-20 17:55:35.302822 num operations 1
2022-04-20 17:55:35.302828 size on input set 1
2022-04-20 17:55:35.302991 using api key sourya
2022-04-20 17:55:43.503660 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "\n\ndef f(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n - 1) + f(n - 2)\n\nprint(f(10))\n"
    },
    {
      "index": 3,
      "text": "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    },
    {
      "index": 4,
      "text": "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    },
    {
      "index": 5,
      "text": "\n\n\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    },
    {
      "index": 6,
      "text": "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    },
    {
      "index": 7,
      "text": "\nfrom collections import deque\n\nn = int(input())\ns = deque(input().strip())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"
    }
  ],
  "created": 1650477335,
  "object": "edit"
}
2022-04-20 17:55:43.503982 fix syntax errors 8 ["\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n", "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n", '\n\ndef f(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n - 1) + f(n - 2)\n\nprint(f(10))\n', "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n", "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n", "\n\n\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n", "\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n", "\nfrom collections import deque\n\nn = int(input())\ns = deque(input().strip())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)\n"]
2022-04-20 17:55:43.504131 size on output set 5
2022-04-20 17:55:43.504147 num operations 1
2022-04-20 17:55:43.504154 size on input set 1
2022-04-20 17:55:43.504370 using api key sunu
2022-04-20 17:55:51.942857 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s, representing red and blue cubes\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s.\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    },
    {
      "index": 2,
      "text": "\n\ndef find_max_removal(s, n):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s (length n)\n    :param n: length of string\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for i in range(n):\n        # If the digit is the same as the previous digit, increment the counter\n        if s[i] == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = s[i]\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    n = len(s)\n    max_removal = find_max_removal(s, n)\n    print(max_removal)\n"
    },
    {
      "index": 3,
      "text": "\n\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input(\"\")\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    },
    {
      "index": 4,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input(\"Enter a string of 1s and 0s: \")\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    },
    {
      "index": 5,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables.\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter.\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal.\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop.\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    },
    {
      "index": 6,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)  # noqa\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    },
    {
      "index": 7,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop.\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n"
    }
  ],
  "created": 1650477343,
  "object": "edit"
}
2022-04-20 17:55:51.943274 fix syntax errors 8 ['\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s, representing red and blue cubes\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n', '\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s.\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n', '\n\ndef find_max_removal(s, n):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s (length n)\n    :param n: length of string\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for i in range(n):\n        # If the digit is the same as the previous digit, increment the counter\n        if s[i] == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = s[i]\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input()\n    n = len(s)\n    max_removal = find_max_removal(s, n)\n    print(max_removal)\n', '\n\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input("")\n    max_removal = find_max_removal(s)\n    print(max_removal)\n', '\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input("Enter a string of 1s and 0s: ")\n    max_removal = find_max_removal(s)\n    print(max_removal)\n', '\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables.\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter.\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal.\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop.\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n', '\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)  # noqa\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n', '\n\ndef find_max_removal(s):\n    """\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    """\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop.\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == "__main__":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)\n']
2022-04-20 17:55:51.943385 size on output set 8
