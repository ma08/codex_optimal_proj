["H, n = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nt = 0\nmiPt = H\nfor a in d:\n  t += 1\n  H += a\n  miPt = min(miPt, H)\n  if H <= 0:\n    print(t)\n    return\n\nif sum(d) >= 0:\n  print(-1)\n  return\n\njump = max(0, miPt // -sum(d) - 2)\nH -= jump * -sum(d)\nt += n * jump\nfor i in range(100000000000000000):\n  t += 1\n  H += d[i % n]\n  if H <= 0:\n    print(t)\n    return\n", "from itertools import accumulate\nimport math\n\nH, n = map(int, input().split())\n\nd = list(map(int, input().split()))\n\nacc = list(accumulate(d))\nper_round = acc[-1]\n\nm = min(acc)\n\nif m >= 0:\n\tprint(-1)\n\treturn\n\ntarget = -m\n\nif H <= target:\n\trounds = 0\nelif per_round >= 0:\n\tprint(-1)\n\treturn\nelse:\n\trounds = math.ceil((H - target) / -per_round)\n\nhealth = H - rounds * -per_round\n\nfor i, diff in enumerate(acc):\n\tcur = health + diff\n\tif cur <= 0:\n\t\tbreak\n\nminutes = rounds * n + i+1\nprint(minutes)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/19 23:03\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : E. Superhero Battle.py\n\n\ndef main():\n    total_hp, n = map(int, input().split())\n    d = list(map(int, input().split()))\n\n    c = d.copy()\n    for i in range(1, n):\n        c[i] += c[i - 1]\n\n    for i in range(n):\n        if total_hp + c[i] <= 0:\n            print(i + 1)\n            return\n\n    if c[-1] >= 0:\n        print(-1)\n        return\n\n    min_val, round_dmg = -min(c), -c[-1]\n    # print(min_val, round_dmg)\n    temp_round = (total_hp - min_val + (round_dmg - 1)) // round_dmg\n    ret = temp_round * n\n    total_hp -= temp_round * round_dmg\n    for i in range(n):\n        if total_hp + c[i] <= 0:\n            ret += i + 1\n            break\n    print(ret)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\n\ndef test(k):\n    nonlocal sm, mn, h\n    return h + k * sm + mn <= 0\n\n\nh, n = map(int, input().split())\na = list(map(int, input().split()))\nmn = math.inf\nsm = 0\nfor e in a:\n    sm += e\n    mn = min(mn, sm)\nif mn >= 0:\n    print(-1)\n    return\nl = -1\nr = h + 1\nwhile r - l > 1:\n    m = (r + l) // 2\n    if test(m):\n        r = m\n    else:\n        l = m\nh += sm * r\nif h <= 0:\n    print(n * r)\n    return\nfor i in range(n):\n    h += a[i]\n    if h <= 0:\n        print(r * n + i + 1)\n        return\nprint(-1)", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nH, n = mints()\nd = list(mints())\ns = [0]*(n+1)\nfor i in range(n):\n\ts[i+1] = s[i]+d[i]\nfor i in range(n+1):\n\tif s[i] + H <= 0:\n\t\tprint(i)\n\t\treturn\n#print(s)\nif s[n] >= 0:\n\tprint(-1)\nelse:\n\tl = -1\n\tr = H//(-s[n]) + 2\n\twhile r-l > 1:\n\t\tc = (l+r)//2\n\t\th = -c*s[n]-H\n\t\tz = -1\n\t\tfor i in range(n+1):\n\t\t\tif s[i] <= h:\n\t\t\t\tz = i\n\t\t\t\tbreak\n\t\tif z == -1:\n\t\t\tl = c\n\t\telse:\n\t\t\tr = c\n\th = -r*s[n]-H\n\tz = -1\n\tfor i in range(n+1):\n\t\tif s[i] <= h:\n\t\t\tprint(r*n+i)\n\t\t\tbreak\n", "[H, n] = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nH_old = H\nmH = H\n\nfor i in range(n):\n  H += d[i]\n  mH = min(mH, H)\n  if H <= 0:\n    print(i+1)\n    break;\nelse:\n  if H_old <= H:\n    print(-1)\n  else:\n    df = H_old - H\n    mD = H_old - mH\n    rnds = (mH+df-1) // df\n    H = H_old - rnds * df\n    for i in range(n):\n      H += d[i]\n      if H <= 0:\n        print(rnds*n + i+1)\n        break;\n", "H, n = list(map(int, input().split()))\nds = [int(x) for x in input().split()]\n\nh = H\nmn = 0\nfor i, d in enumerate(ds):\n    h += d\n    mn = min(mn, h - H)\n    if h <= 0:\n        print(i + 1)\n        break\nelse:\n    sd = sum(ds)\n    if sd >= 0:\n        print(-1)\n    else:\n        sd = -sd\n        # print(mn, sd)\n        repeat = (H + mn) // sd\n        h = H - repeat * sd\n        # print(repeat, h)\n        for i, d in enumerate(ds):\n            h += d\n            if h <= 0:\n                print(repeat * n + i + 1)\n                break\n        else:\n            for i, d in enumerate(ds):\n                h += d\n                if h <= 0:\n                    print(repeat * n + i + 1 + n)\n                    break\n", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 100_000_000\n# from heapq import heappush, heappop\n# from collections import defaultdict\nt = 1#int(input())\n# from math import sqrt\n\n\nfor test in range(t):\n    # n = int(input())\n    H, n = (list(map(int, input().split())))\n    # a = []\n    # for i in range(n):\n    # l = input()\n    # r = input()\n    d = (list((list(map(int, input().split())))))\n    pre = [0 for i in range(n+1)]\n\n    minVal = pre[0]\n    minInd = 0\n    for i in range(n):\n        pre[i+1] = pre[i]+d[i]\n        if pre[i+1]<minVal:\n            minInd = i+1\n            minVal = pre[i+1]\n\n    h = H\n    ans = 0\n    for i in d:\n        ans+=1\n        h+=i\n        if h<=0:\n            print(ans)\n            return\n    if pre[-1] >= 0:\n        print(-1)\n    else:\n        h=H\n        h+=minVal\n        tmp = (h-pre[-1]-1)//(-pre[-1])\n        # print(tmp, minVal, pre[-1])\n        ans = tmp*(n)\n        h=H\n        h+= pre[-1]*tmp\n        for i in d:\n            ans+=1\n            h+=i\n            if h<=0:\n                print(ans)\n                break\n\n\n\n\n    \n\n            \n", "from math import floor\n\n(H, n) = (int(x) for x in input().split())\nd = [int(x) for x in input().split()]\n\nsum_d = sum(d)\n\nmax_damage_per_round = 0\ndamage_sofar = 0\nfor attack in d:\n\tdamage_sofar += attack\n\tmax_damage_per_round = min(max_damage_per_round, damage_sofar)\n\nmax_damage_per_round = abs(max_damage_per_round)\n\nanswer = 0\n\nfor attack in d:\n\tanswer += 1\n\tH += attack\n\tif H <= 0:\n\t\tprint(answer)\n\t\treturn\n\nif sum_d >= 0:\n\tprint(-1)\n\treturn\n\nif H > max_damage_per_round:\n\tcan_attack_rounds_count = floor((H - max_damage_per_round - 1) / abs(sum_d))\n\tanswer += n * can_attack_rounds_count\n\tH += sum_d * can_attack_rounds_count\n\nif H <= 0:\n\tprint(answer)\n\treturn\n\nwhile True:\n\tfor attack in d:\n\t\tanswer += 1\n\t\tH += attack\n\t\tif H <= 0:\n\t\t\tprint(answer)\n\t\t\treturn", "import math\nh,n = map(int, input().strip().split())\nl = list(map(int, input().strip().split()))\nmn = 0\nsm = 0\ncounter = 0\ndone = False\nfor i in l:\n    counter += 1\n    sm += i\n    mn = min(mn,sm)\n    if h + mn <= 0 and done == False:\n        print(counter)\n        done = True\nif sm >= 0:\n    if done == False:\n        print (-1)\nelse:\n    nh = h + mn\n    it = nh//-sm\n    if nh %-sm:\n        it += 1\n    ans = it*n\n    h = h + it*sm\n    for i in range(n):\n        h = h + l[i]\n        ans += 1\n        if h <= 0 and done == False:\n            print (ans)\n            break", "import sys\ninput = sys.stdin.readline\n\nH,n=list(map(int,input().split()))\nD=list(map(int,input().split()))\n\nfrom itertools import accumulate\nONETURN=list(accumulate(D))\n\nMIN=min(ONETURN)\nONE=ONETURN[-1]\n\nif ONE>=0:\n    if H+MIN>0:\n        print(-1)\n        return\n\n    DAMAGED=[H+o for o in ONETURN]\n    for i in range(n):\n        if DAMAGED[i]<=0:\n            print(i+1)\n            return\n\nANS=0\n\nR=max(0,(H+MIN)//(-ONE))\nANS+=R*n\nH+=R*ONE\n\nwhile H+MIN>0:\n    H+=ONE\n    ANS+=n\n\nDAMAGED=[H+o for o in ONETURN]\nfor i in range(n):\n    if DAMAGED[i]<=0:\n        print(ANS+i+1)\n        break\n", "H, n = map(int, input().split())\nD = list(map(int, input().split()))\nfor i in range(1, n):\n    D[i] += D[i - 1]\nw = -min(D)\nif D[-1] >= 0 and w < H:\n    print(-1)\n    return\nif D[-1] >= 0 or w >= H:\n    for q in range(n):\n        i = D[q]\n        if -i >= H:\n            print(q + 1)\n            return\ncnt = 0\ncnt += n * ((H - w - D[-1] - 1) // (-D[-1]))\nsas = H - cnt // n * (-D[-1])\nfor q in range(n):\n    i = D[q]\n    if -i >= sas:\n        print(cnt + q + 1)\n        break", "H, n = (int(t) for t in input().split(' '))\nd = [int(t) for t in input().split(' ')]\n\nhp_diff = sum(d)\n\ncurrent_hp = 0\nrip_hp_max = 0\nfor di in d:\n    current_hp += di\n    rip_hp_max = max(rip_hp_max, -current_hp)\n\nif hp_diff < 0 and rip_hp_max < H:\n    required_full_rounds = (H - rip_hp_max) // -hp_diff\nelse:\n    required_full_rounds = 0\n\nhp_after_full_rounds = H + required_full_rounds * hp_diff\ncurrent_hp = hp_after_full_rounds\nfor i in range(2*n):\n    current_hp += d[i % n]\n    if current_hp <= 0:\n        print(i+1+required_full_rounds*n)\n        return\n\nprint(-1)\n", "h, n = list(map(int, input().split()))\nfo = [int(x) for x in input().split()]\nac = [0]*n\nmiac = [0]*n\nfor i in range(n):\n\tac[i] = ac[i-1]+fo[i]\n\tmiac[i] = min(ac[i], miac[i-1])\n# print(ac)\n# print(miac)\nm = min(ac)\nif h + miac[-1] > 0 and ac[-1] >= 0:\n\tprint(-1)\nelse:\n\tif h + miac[-1] <= 0:\n\t\thi, lo = n-1, 0\n\t\twhile hi > lo:\n\t\t\tmid = (hi+lo)//2\n\t\t\tif miac[mid]+h > 0:\n\t\t\t\tlo = mid+1\n\t\t\telse:\n\t\t\t\thi = mid\n\t\tprint(hi+1)\n\telse:\n\t\tbajo = (h+miac[-1]-1)//(-ac[-1]) +1\n\t\t# print(h)\n\t\th += (bajo*ac[-1])\n\t\t# print(h)\n\t\thi, lo = n-1, 0\n\t\twhile hi > lo:\n\t\t\tmid = (hi+lo)//2\n\t\t\tif miac[mid]+h > 0:\n\t\t\t\tlo = mid+1\n\t\t\telse:\n\t\t\t\thi = mid\n\t\tprint(hi+1+ bajo*n)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\nfrom math import factorial\n\ndef main():\n    hp,n = get_tuple()\n    li = get_list()\n    sm = prefix_sum(li)\n    mn = min(sm) if min(sm)<0 else 0\n    j = hp+mn\n    if j>0 and sm[-1]>=0:\n        print(-1)\n        return\n    #print(sm)\n    tries = n*math.ceil(j//abs(sm[-1])) if j>0 else 0\n    hp += sm[-1]*math.ceil(j//abs(sm[-1])) if j>0 else 0\n    #print(tries,hp,j)\n    while hp>0:\n        hp+=li[tries%n]\n        tries+=1\n    print(tries)\n    \n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "H, n = list(map(int,input().split()))\nhp = list(map(int,input().split()))\nsum = H\nmini = H\nimport sys\nfor i in range(n):\n\tsum = sum + hp[i]\n\tmini = min(mini, sum)\n\tif sum <= 0:\n\t\tprint(i+1)\n\t\treturn\nif sum>=H:\n\tprint(-1)\n\treturn\nx =1 + (mini-1) // (H-sum)\n\nH = H - (H-sum)*x\nwyn = n*x\nfor i in hp:\n\twyn += 1\n\tH = H + i\n\tif H<=0:\n\t\tprint(wyn)\n\t\tbreak\n", "H,n=list(map(int,input().split()))\narr=list(map(int,input().split()))\narr1=[]\nmostmin=10**9\nval=0\nmostminindex=-1\nfor i in range(n):\n\tval+=arr[i]\n\tarr1.append(val)\n\tif(mostmin>val):\n\t\tmostmin=val\n\t\tmostminindex=i\nif(mostmin>=0):\n\tprint(-1)\nelif(abs(mostmin)<H and val>=0):\n\tprint(-1)\nelse:\n\tturns=-1\n\tif(H+mostmin<=0):\n\t\tturns=0\n\telse:\n\t\tif(val!=0):\n\t\t\tturns=(H-abs(mostmin))//abs(val)\n\t\telse:\n\t\t\tturns=0\n\t\t#print(turns)\n\tH-=(abs(val)*turns)\n\tminutes=n*turns\n\tfor i in range(n):\n\t\tif(H+arr1[i]<=0):\n\t\t\tprint(minutes+1)\n\t\t\treturn\n\t\telse:\n\t\t\tminutes+=1\n\tH-=abs(val)\n\tfor i in range(n):\n\t\tif(arr1[i]+H<=0):\n\t\t\tprint(minutes+1)\n\t\t\treturn\n\t\telse:\n\t\t\tminutes+=1\n\tprint(-1)\n\n", "from sys import stdin\n\nH,n=list(map(int,stdin.readline().split()))\narr=list(map(int,stdin.readline().split()))\nk=H\nd={}\npre=0\ncond=False\nfor i in range(n):\n    k+=arr[i]\n    pre+=arr[i]\n    if pre in d:\n        d[pre].append(i+1)\n    else:\n        d[pre]=[i+1]\n    if k<=0:\n        ans=i+1\n        cond=True\n        break\n    else:\n        pass\nif cond==True:\n    print(ans)\nelse:\n    s=sum(arr)\n    if s<0:\n        a=min(list(d.keys()))\n        m=(H+a)//abs(s)\n        H+=(s*m)\n        ans=n*m\n        while(H>0):\n            l=list([x for x in list(d.keys()) if x+H<=0])\n            if len(l)>0:\n                case=[]\n                for ele in l:\n                    case.extend(d[ele])\n                ans+=min(case)\n                print(ans)\n                break\n            else:\n                H+=s\n                ans+=n\n    else:\n        print(-1)\n", "import math\nH, n = [int(i) for i in input().split(' ')]\nd = [int(i) for i in input().split(' ')]\nH_cur = H\ndead = False\nd_acc = [0]\nfor i in range(n):\n    d_acc.append(d_acc[-1]+d[i])\n    H_cur += d[i]\n    if H_cur <= 0:\n        print(i+1)\n        dead = True\n        break\nif not dead:\n    if d_acc[-1] >= 0:\n        print(-1)\n    else:\n        d_acc_min = min(d_acc)\n        r = int(math.ceil((H+d_acc_min)/-d_acc[-1]))\n        H_cur = H+r*d_acc[-1]\n        for i in range(n):\n            H_cur += d[i]\n            if H_cur <= 0:\n                print(r*n+i+1)\n                break", "from itertools import accumulate\nH, n = list(map( int, input().split()))\nD = list( map( int, input().split()))\naccD = list( accumulate(D))\nd = sum(D)\nm = min(accD)\nans = 0\nnow = H\nif H + m <= 0:\n    for i in range(n):\n        ans += 1\n        now += D[i]\n        if now <= 0:\n            break\nelif d >= 0:\n    ans = -1\nelse:\n    ans = ((H+m)//(-d))*n\n    now = H + (H+m)//(-d)*d\n    while now > 0:\n        for i in range(n):\n            ans += 1\n            now += D[i]\n            if now <= 0:\n                break\nprint(ans)\n", "s1=list(map(int,input().split()))\ns=list(map(int,input().split()))\nh,n=s1[0],s1[1]\nhp=h\ntime=0\nmins=0\nsums=0\nfor i in range(n):\n    sums+=s[i]\n    mins=min(mins,sums)\nwhile time!=n:\n    hp=hp+s[time]\n    time+=1\n    if hp<=0:\n        break\nif hp<=0:\n    print(time)\nelse:\n    t=sum(s)\n    #print(t)\n    if t>=0:\n        print(-1)\n    else:\n        hp1=h+mins\n        #print(hp1) \n        cycle=hp1//abs(t)\n        #print(cycle) \n        time=n*(hp1//abs(t))\n        #print(time) \n        timemod=0\n        hp=h-abs(t)*cycle\n        #print(hp)\n        while hp>0:\n            hp+=s[timemod]\n            timemod=(timemod+1)%n\n            time+=1\n        print(time)\n            \n        \n    \n    \n", "import sys\nfrom math import ceil\n\nfin = sys.stdin.readline\nH, n = [int(elem) for elem in fin().split()]\nd_list = [int(elem) for elem in fin().split()]\nprefix_sum_d = [0] * n\ncur_sum = 0\nfor i, d in enumerate(d_list):\n    cur_sum += d\n    prefix_sum_d[i] = cur_sum\n\n# no point of death during the first round and the hp does not increase\nmax_damage_in_round = -min(prefix_sum_d)\nif H - max_damage_in_round > 0 and prefix_sum_d[-1] >= 0:\n    print(-1)\n    return\n\ndamage_per_round = -prefix_sum_d[-1]\nif H <= max_damage_in_round:\n    num_rounds_before_death = 0\nelse:\n    num_rounds_before_death = ceil((H - max_damage_in_round) / damage_per_round)\n\nrest_H = H - damage_per_round * num_rounds_before_death\npast_minutes = num_rounds_before_death * n\n\nfor additional_minutes, gain in enumerate(prefix_sum_d, start=1):\n    if rest_H + gain <= 0:\n        print(additional_minutes + past_minutes)\n        break\n", "h,n=map(int,input().split())\nl=list(map(int,input().split()))\npref=[0]*(n+1)\nans=-1\nfor i in range(n):\n         pref[i+1]=pref[i]+l[i]\n         if(h+pref[i+1]<=0):\n                  ans=i+1\n                  break\nif(ans!=-1 or pref[n]>=0):\n         print(ans)\nelse:\n         m=min(pref)\n         x=abs((h+m)//pref[n])\n         ans=n*x\n         h+=x*pref[n]\n    #     print(m,x,ans,h)\n         for i in range(10*n):\n                  h+=l[i%n]\n                  ans+=1\n                  if(h<=0):\n                           print(ans)\n                           break", "h,n=map(int,input().split())\na=list(map(int,input().split()))\nb=a[:]\nH=h\nfor i in range(1,n):\n    a[i]+=a[i-1]\nt=0\nfor i in b:\n    if H>0:\n        H+=i\n        t+=1\n    else:\n        print(t);return\nif a[-1]>=0:\n    print(-1);return()\nelse:\n    r=min(a)\n    m=(h+r)//abs(a[-1])\n    h+=(m)*(a[-1])\n    t=n*(m)\n    while h>0:\n        for i in b:\n            if h>0:\n                h+=i\n                t+=1\n            else:\n                break\n    print(t)"]