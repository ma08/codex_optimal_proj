2022-04-17 20:26:12.736150 num operations 1
2022-04-17 20:26:12.736166 size on input set 1
2022-04-17 20:26:16.832870 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\ndef inlt():\n    return list(map(int,f.readline().split()))\n\ndef insr():\n    return input()\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1650227172,
  "object": "edit"
}
2022-04-17 20:26:16.833120 fix syntax errors 2 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\ndef inlt():\n    return list(map(int,f.readline().split()))\n\ndef insr():\n    return input()\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef insr():\n    return(input())\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-17 20:26:16.833242 size on output set 2
2022-04-17 20:26:16.833256 num operations 1
2022-04-17 20:26:16.833261 size on input set 1
2022-04-17 20:26:20.935063 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n+1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n+1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n+1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n+1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1650227176,
  "object": "edit"
}
2022-04-17 20:26:20.935246 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n+1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n+1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n+1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n+1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-17 20:26:20.935360 size on output set 2
