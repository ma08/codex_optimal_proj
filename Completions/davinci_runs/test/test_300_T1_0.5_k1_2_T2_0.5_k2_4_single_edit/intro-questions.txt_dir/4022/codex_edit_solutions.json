["\n\n\n# Time complexity: O(n log n)\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n# Time complexity: O(n^2)\n\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n", "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n\n\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n", "\n\n#!/usr/bin/env python3\n\n# COMPUTING THE MINIMUM INTERVAL LENGTH\n\n# Given n segments on the x-axis of length 1, find the minimum length\n# of an interval that contains all the segments.\n\ndef min_interval(segments):\n    # SOLUTION\n    # The problem is to find the segment with the least intersection length.\n    # If we sort the segments by their left endpoints, we can consider the\n    # problem as finding the segment with the least intersection length with\n    # the segment before it.\n\n    # To do this, we can keep track of the right endpoint of the previous\n    # segment.  For the first segment, we just set the right endpoint to\n    # -infinity.  For the next segment, we compute the intersection length\n    # and update the right endpoint to the right endpoint of the current\n    # segment.  We can then keep track of the minimum intersection length\n    # and return at the end.\n\n    # We can use a heap to keep track of the right endpoint of the previous\n    # segment and then just pop the first element, which will be the\n    # minimum.\n\n    import heapq\n\n    segments.sort()\n\n    heap = [float('-inf')]\n    min_intersection = float('inf')\n\n    for l, r in segments:\n        min_intersection = min(min_intersection, heap[0] - l)\n        heapq.heappush(heap, r)\n\n    return min_intersection\n\n\ndef main():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    print(min_interval(segments))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution 1\nn = int(input())\n\nx = []\ny = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\nx.sort()\ny.sort()\na = 0\nb = 0\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\nn = int(input())\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\nx.sort()\nans = 0\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\nprint(ans)\n", "\nn, m = map(int, input().split())\n\nx = []\ny = []\n\nfor _ in range(n):\n    x_i, y_i = map(int, input().split())\n    x.append(x_i)\n    y.append(y_i)\n\nx = sorted(x)\ny = sorted(y)\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        x[i] = 0\n    if y[i] == y[i + 1]:\n        y[i] = 0\n\nx = list(set(x))\ny = list(set(y))\n\nif len(x) == 1:\n    print(0)\nelse:\n    print(max(y) - min(x))\n\n"]