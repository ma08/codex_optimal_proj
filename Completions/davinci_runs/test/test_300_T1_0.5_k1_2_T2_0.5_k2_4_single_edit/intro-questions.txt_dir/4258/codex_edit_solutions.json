["#!/bin/bash\n#This script will create a new user on the local system\n#You will be prompted to enter the username (login), the person name, and a password.\n#The username, password, and host for the account will be display\n\n#Make sure the script is being executed with superuser privileges\nif [[ \"${UID}\" -ne 0 ]]\nthen\n\techo 'Please run with sudo or as root.'\n\texit 1\nfi\n\n#Get the username (login)\nread -p 'Enter the username to create: ' USER_NAME\n\n#Get the real name (contents for the description field)\nread -p 'Enter the name of the person or application that will be using this account: ' COMMENT\n\n#Get the password\nread -p 'Enter the password to use for the account: ' PASSWORD\n\n#Create the user with the password\nuseradd -c \"${COMMENT}\" -m ${USER_NAME}\n\n#Check to see if the useradd command succeeded\n#We don't want to tell the user that an account was created when it hasn't been\nif [[ \"${?}\" -ne 0 ]]\nthen\n\techo 'The account could not be created.'\n\texit 1\nfi\n\n#Set the password\necho ${PASSWORD} | passwd --stdin ${USER_NAME}\n\n#Check to see if the passwd command succeeded\nif [[ \"${?}\" -ne 0 ]]\nthen\n\techo 'The password for the account could not be set.'\n\texit 1\nfi\n\n#Force password change on first login\npasswd -e ${USER_NAME}\n\n#Display the username, password, and host where the user was created\necho\necho 'username:'\necho \"${USER_NAME}\"\necho\necho 'password:'\necho \"${PASSWORD}\"\necho\necho 'host:'\necho \"${HOSTNAME}\"\nexit 0\n", "#!/bin/bash\n\n#This script takes a file as an argument and displays it on the standard output\n\nif [ -z $1 ] || [ ! -e $1 ]\nthen\n  echo \"Usage: $0 file\"\n  exit 1\nfi\n\ncat $1\n", "\ndef main():\n    A, B, T = map(int, input().split())\n    print(B * (T // A + 1))\n\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    A, B, T = map(int, input().split())\n    print(B * (T // A + 1))\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\ndef main():\n    A, B, T = map(int, input().split())\n    sys.stdout.write(str(B * (T // A + 1)))\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\nsys.setrecursionlimit(1000000)\n\n\ndef main():\n    N, K = map(int, input().split())\n    print(K - 1 if K != 1 else 0)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python\n\nimport os\nimport sys\nimport argparse\nfrom argparse import RawTextHelpFormatter\n\n\nclass File:\n    def __init__(self, file_name, file_path, file_extension):\n        self.file_name = file_name\n        self.file_path = file_path\n        self.file_extension = file_extension\n        self.file_full_path = os.path.join(file_path, file_name)\n        self.file_size = os.stat(self.file_full_path).st_size\n\n    def __str__(self):\n        return '{} {} {} {}'.format(self.file_name, self.file_path, self.file_size, self.file_extension)\n\n    def __repr__(self):\n        return '{} {} {} {}'.format(self.file_name, self.file_path, self.file_size, self.file_extension)\n\n\ndef get_file_list(path, extension):\n    file_list = []\n    for root, dirs, files in os.walk(path):\n        for file in files:\n            if file.endswith(extension):\n                file_list.append(File(file, root, extension))\n    return file_list\n\n\ndef print_files(file_list):\n    for file in file_list:\n        print(file)\n\n\ndef print_files_size(file_list):\n    for file in file_list:\n        print(file.file_size)\n\n\ndef print_files_size_sum(file_list):\n    size_sum = 0\n    for file in file_list:\n        size_sum += file.file_size\n    print(size_sum)\n\n\ndef print_files_size_avg(file_list):\n    size_sum = 0\n    for file in file_list:\n        size_sum += file.file_size\n    print(size_sum / len(file_list))\n\n\ndef print_files_size_max(file_list):\n    size_max = 0\n    for file in file_list:\n        if file.file_size > size_max:\n            size_max = file.file_size\n    print(size_max)\n\n\ndef print_files_size_min(file_list):\n    size_min = sys.maxsize\n    for file in file_list:\n        if file.file_size < size_min:\n            size_min = file.file_size\n    print(size_min)\n\n\ndef print_files_size_max_file(file_list):\n    size_max = 0\n    max_file = None\n    for file in file_list:\n        if file.file_size > size_max:\n            max_file = file\n            size_max = file.file_size\n    print(max_file)\n\n\ndef print_files_size_min_file(file_list):\n    size_min = sys.maxsize\n    min_file = None\n    for file in file_list:\n        if file.file_size < size_min:\n            min_file = file\n            size_min = file.file_size\n    print(min_file)\n\n\ndef print_files_size_median(file_list):\n    file_list.sort(key=lambda x: x.file_size)\n    print(file_list[int(len(file_list) / 2)])\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Prints files in the specified path and extension',\n                                     formatter_class=RawTextHelpFormatter)\n    parser.add_argument('-p', '--path', type=str, help='Path to search for files in')\n    parser.add_argument('-e', '--extension', type=str, help='File extension to search for')\n    parser.add_argument('-m', '--mode', type=str, help='Print mode',\n                        choices=['all', 'size', 'size_sum', 'size_avg', 'size_max', 'size_min', 'size_max_file',\n                                 'size_min_file', 'size_median'])\n\n    args = parser.parse_args()\n\n    if not args.path or not args.extension or not args.mode:\n        parser.print_help()\n        sys.exit(1)\n\n    file_list = get_file_list(args.path, args.extension)\n\n    if args.mode == 'all':\n        print_files(file_list)\n    elif args.mode == 'size':\n        print_files_size(file_list)\n    elif args.mode == 'size_sum':\n        print_files_size_sum(file_list)\n    elif args.mode == 'size_avg':\n        print_files_size_avg(file_list)\n    elif args.mode == 'size_max':\n        print_files_size_max(file_list)\n    elif args.mode == 'size_min':\n        print_files_size_min(file_list)\n    elif args.mode == 'size_max_file':\n        print_files_size_max_file(file_list)\n    elif args.mode == 'size_min_file':\n        print_files_size_min_file(file_list)\n    elif args.mode == 'size_median':\n        print_files_size_median(file_list)\n\n\nif __name__ == '__main__':\n    main()\n"]