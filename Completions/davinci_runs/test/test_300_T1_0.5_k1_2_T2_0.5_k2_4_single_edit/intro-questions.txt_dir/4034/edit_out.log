2022-04-17 23:48:36.177891 num operations 1
2022-04-17 23:48:36.177909 size on input set 1
2022-04-17 23:48:41.685621 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique, graph\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    },
    {
      "index": 3,
      "text": "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n"
    }
  ],
  "created": 1650239316,
  "object": "edit"
}
2022-04-17 23:48:41.685827 fix syntax errors 4 ['\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique, graph\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n', '\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append(\'0\' if i in get_max_clique_indices(get_graph(s)) else \'1\')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print("YES")\n    print(\'\'.join(colors))\nelse:\n    print("NO")\n']
2022-04-17 23:48:41.685966 size on output set 3
2022-04-17 23:48:41.685979 num operations 1
2022-04-17 23:48:41.685984 size on input set 1
2022-04-17 23:48:46.431793 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print 'YES'\n    print '0' * n\nelse:\n    print 'YES'\n    print solve(s)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n"
    }
  ],
  "created": 1650239321,
  "object": "edit"
}
2022-04-17 23:48:46.432001 fix syntax errors 4 ["\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print 'YES'\n    print '0' * n\nelse:\n    print 'YES'\n    print solve(s)\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n"]
2022-04-17 23:48:46.432048 size on output set 2
