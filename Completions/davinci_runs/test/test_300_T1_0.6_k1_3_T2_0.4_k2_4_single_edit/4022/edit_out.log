2022-04-20 13:40:56.671388 num operations 1
2022-04-20 13:40:56.671408 size on input set 1
2022-04-20 13:40:56.671608 using api key kouti
2022-04-20 13:41:06.417615 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments[1:]:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments[1:]:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # TODO\n    pass\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650462056,
  "object": "edit"
}
2022-04-20 13:41:06.417910 fix syntax errors 4 ["\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments[1:]:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments[1:]:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # TODO\n    pass\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\n\n\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 13:41:06.418070 size on output set 4
2022-04-20 13:41:06.418084 num operations 1
2022-04-20 13:41:06.418090 size on input set 1
2022-04-20 13:41:06.418245 using api key sunu
2022-04-20 13:41:10.387564 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n"
    }
  ],
  "created": 1650462066,
  "object": "edit"
}
2022-04-20 13:41:10.387813 fix syntax errors 4 ['import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n']
2022-04-20 13:41:10.387869 size on output set 3
2022-04-20 13:41:10.387883 num operations 1
2022-04-20 13:41:10.387890 size on input set 1
2022-04-20 13:41:10.388045 using api key kouti
2022-04-20 13:41:15.361167 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)[:n]\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return segments\n\ndef solution(segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n\n    n = len(segments)\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    segments = list(reader)\n    segments.sort()\n    print(solution(segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650462070,
  "object": "edit"
}
2022-04-20 13:41:15.361548 fix syntax errors 4 ['\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)[:n]\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n', '\nfrom random import randint\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return segments\n\ndef solution(segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n\n    n = len(segments)\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    segments = list(reader)\n    segments.sort()\n    print(solution(segments))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 13:41:15.361642 size on output set 3
