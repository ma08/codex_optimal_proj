["\nn = int(input())\narray = list(map(int, input().split()))\ndef min_instability(n, array):\n    array.sort()\n    min_instability = array[-1] - array[0]\n\n    for i in range(1, n-1):\n        if array[i] - array[i-1] < min_instability:\n            min_instability = array[i] - array[i-1]\n        if array[i+1] - array[i] < min_instability:\n            min_instability = array[i+1] - array[i]\n    return min_instability\nprint(min_instability(n, array))\n", "from collections import defaultdict\n\n\ndef max_overlap(n, start_times, end_times):\n    # create a dictionary of start times\n    start_times_dict = defaultdict(int)\n    for time in start_times:\n        start_times_dict[time] += 1\n    # create a dictionary of end times\n    end_times_dict = defaultdict(int)\n    for time in end_times:\n        end_times_dict[time] += 1\n    # create a dictionary of times\n    times_dict = defaultdict(int)\n    for time in start_times + end_times:\n        times_dict[time] += 1\n    # create a list of times\n    times = list(times_dict.keys())\n    times.sort()\n    # create a list of overlap counts\n    overlap_counts = [0]\n    for time in times:\n        overlap_counts.append(overlap_counts[-1] + start_times_dict[time] - end_times_dict[time])\n    # return the max overlap count\n    return max(overlap_counts)\n\nn = int(input()) # number of meetings\nstart_times = []\nend_times = []\nfor i in range(n):\n    start_time, end_time = map(int, input().split()) # start and end times of the ith meeting\n    start_times.append(start_time)\n    end_times.append(end_time)\n\nprint(max_overlap(n, start_times, end_times))\n", "\nn = int(input())\narray = list(map(int, input().split()))\n\ndef min_instability(n, array):\n    array.sort()\n    min_instability = array[-1] - array[0]\n\n    for i in range(1, n-1):\n        if array[i] - array[i-1] < min_instability:\n            min_instability = array[i] - array[i-1]\n        if array[i+1] - array[i] < min_instability:\n            min_instability = array[i+1] - array[i]\n    return min_instability\n\nprint(min_instability(n, array))\n", "\n\n\n#\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nif n == 2:\n    print(0)\nelse:\n    print(min(a[n - 2] - a[0], a[n - 1] - a[1]))\n", "\n\nn = int(input())\narray = list(map(int, input().split()))\n\ndef min_instability(array):\n    array.sort()\n    min_instability = array[-1] - array[0]\n\n    for i in range(1, n-1):\n        if array[i] - array[i-1] < min_instability:\n            min_instability = array[i] - array[i-1]\n        if array[i+1] - array[i] < min_instability:\n            min_instability = array[i+1] - array[i]\n    return min_instability\n\nprint(min_instability(array))\n", "\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(min(a[-1] - a[1], a[-2] - a[0]))\n", "\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nif n == 2:\n    print(0)\nelse:\n    print(min(a[n - 2] - a[0], a[n - 1] - a[1]))\n", "\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\nprint(min(a[-1] - a[1], a[-2] - a[0]))\n", "\nfrom collections import deque\nfrom itertools import combinations\n\nn = int(input())\na = deque(map(int, input().split()))\n\na = sorted(a)\na = deque(a)\n\nprint(min(a[-1] - a[1], a[-2] - a[0]))\n", "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nprint(min(a[-1] - a[1], a[-2] - a[0]))\n"]