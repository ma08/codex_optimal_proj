["\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(3):\n    if a[i] == n or b[i] == n:\n        continue\n    else:\n        if (i - i)%3 == 0:\n            ans += min(a[i],b[i])\n        elif (i - i)%3 == 2:\n            ans += min(a[i],b[i])\n\nprint(ans,n-ans)\n", "#!/usr/bin/env python\n\n#\n# Example of one object under gravity with one contactor and a ground\n# using the Siconos proposed mechanics API\n#\n\nfrom siconos.mechanics.collision.tools import Contactor\nfrom siconos.io.mechanics_run import MechanicsHdf5Runner\nimport siconos.numerics as Numerics\nimport siconos.kernel as Kernel\nimport siconos.mechanics as Mechanics\n\nimport numpy as np\n\n# Creation of the hdf5 file for input/output\nwith MechanicsHdf5Runner() as io:\n\n    # Definition of a cube as a convex shape\n    io.add_convex_shape('Cube', [\n        (-1.0, 1.0, -1.0),\n        (-1.0, -1.0, -1.0),\n        (-1.0, -1.0, 1.0),\n        (-1.0, 1.0, 1.0),\n        (1.0, 1.0, 1.0),\n        (1.0, 1.0, -1.0),\n        (1.0, -1.0, -1.0),\n        (1.0, -1.0, 1.0)])\n\n    # Alternative to the previous convex shape definition.\n    # io.add_primitive_shape('Cube1', 'Box', (2, 2, 2))\n\n    # Definition of the ground shape\n    io.add_primitive_shape('Ground', 'Box', (100, 100, .5))\n\n    # Definition of a non smooth law. As no group ids are specified it\n    # is between contactors of group id 0.\n    io.add_Newton_impact_friction_nsl('contact', mu=0.3)\n\n    # The cube object made with an unique Contactor : the cube shape.\n    # As a mass is given, it is a dynamic system involved in contact\n    # detection and in the simulation.  With no group id specified the\n    # Contactor belongs to group 0\n    io.add_object('cube', [Contactor('Cube')], translation=[0, 0, 2],\n                  velocity=[10, 0, 0, 1, 1, 1],\n                  mass=1)\n\n    # the ground object made with the ground shape. As the mass is\n    # not given, it is a static object only involved in contact\n    # detection.\n    io.add_object('ground', [Contactor('Ground')],\n                  translation=[0, 0, 0])\n\n# Run the simulation from the inputs previously defined and add\n# results to the hdf5 file. The visualisation of the output may be done\n# with the vview command.\nwith MechanicsHdf5Runner(mode='r+') as io:\n\n    # By default earth gravity is applied and the units are those\n    # of the International System of Units.\n    # Because of fixed collision margins used in the collision detection,\n    # sizes of small objects may need to be expressed in cm or mm.\n    io.run(with_timer=False,\n           gravity_scale=1,\n           t0=0,\n           T=20,\n           h=0.005,\n           multipoints_iterations=True,\n           theta=0.50001,\n           Newton_max_iter=1,\n           set_external_forces=None,\n           solver=Numerics.SICONOS_FRICTION_3D_NSGS,\n           itermax=100000,\n           tolerance=1e-8,\n           numerics_verbose=False,\n           output_frequency=None)\n", "\n#\n# n = int(input())\n# a = [int(x) for x in input().split()]\n# b = [int(x) for x in input().split()]\n#\n# if a[0] > b[1]:\n#     a[0] -= b[1]\n#     b[1] = 0\n# else:\n#     b[1] -= a[0]\n#     a[0] = 0\n# if a[2] > b[0]:\n#     a[2] -= b[0]\n#     b[0] = 0\n# else:\n#     b[0] -= a[2]\n#     a[2] = 0\n# if a[1] > b[2]:\n#     a[1] -= b[2]\n#     b[2] = 0\n# else:\n#     b[2] -= a[1]\n#     a[1] = 0\n#\n# print(min(a), max(a))\n", "#!/usr/bin/env ruby\n\nclass File\n  def self.open_and_process(*args)\n    f = File.open(*args)\n    yield f\n    f.close\n  end\nend\n\nFile.open_and_process(\"testfile\", \"r\") do |file|\n  while line = file.gets\n    puts line\n  end\nend\n", "\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n\nn = int(input())\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# ans = 0\n#\n# for i in range(3):\n#     if a[i] == n or b[i] == n:\n#         continue\n#     else:\n#         if (i - i)%3 == 1:\n#             ans += min(a[i],b[i])\n#         elif (i - i)%3 == 2:\n#             ans += min(a[i],b[i])\n#\n# print(ans,n-ans)\n\nprint(n)\n", "\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n", "\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nif a[0] > b[1]:\n    a[0] -= b[1]\n    b[1] = 0\nelse:\n    b[1] -= a[0]\n    a[0] = 0\nif a[2] > b[0]:\n    a[2] -= b[0]\n    b[0] = 0\nelse:\n    b[0] -= a[2]\n    a[2] = 0\nif a[1] > b[2]:\n    a[1] -= b[2]\n    b[2] = 0\nelse:\n    b[2] -= a[1]\n    a[1] = 0\nprint(min(a), max(a))\n", "\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\ndef solve(a, b):\n    if a[0] > b[1]:\n        a[0] -= b[1]\n        b[1] = 0\n    else:\n        b[1] -= a[0]\n        a[0] = 0\n    if a[2] > b[0]:\n        a[2] -= b[0]\n        b[0] = 0\n    else:\n        b[0] -= a[2]\n        a[2] = 0\n    if a[1] > b[2]:\n        a[1] -= b[2]\n        b[2] = 0\n    else:\n        b[2] -= a[1]\n        a[1] = 0\n    return a, b\n\na, b = solve(a, b)\na, b = solve(b, a)\nprint(min(a), max(a))\n", "\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\na[0] = max(0, a[0] - b[1])\nb[1] = max(0, b[1] - a[0])\na[2] = max(0, a[2] - b[0])\nb[0] = max(0, b[0] - a[2])\na[1] = max(0, a[1] - b[2])\nb[2] = max(0, b[2] - a[1])\n\nprint(min(a), max(a))\n", "#!/bin/bash\n\n# This script is used to fix the syntax error in the .sh file\n\nfor file in `ls *.sh`; do\n\techo $file\n\tsed -i 's/\\r//g' $file\ndone\n", "\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    if a[i] == 0 or b[i] == 0:\n        continue\n    else:\n        if (i - i)%3 == 1:\n            min_win += min(a[i],b[i])\n        elif (i - i)%3 == 2:\n            max_win += min(a[i],b[i])\n\nprint(min_win,max_win)\n", "var fs = require('fs');\n\nvar read = fs.readFileSync('read.txt', 'utf8');\n\nvar write = fs.writeFileSync('write.txt', read);\n"]