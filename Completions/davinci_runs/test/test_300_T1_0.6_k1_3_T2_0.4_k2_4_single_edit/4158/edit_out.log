2022-04-20 14:24:33.066454 num operations 1
2022-04-20 14:24:33.066474 size on input set 1
2022-04-20 14:24:33.066672 using api key kouti
2022-04-20 14:24:54.542923 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n#\n# import math\n#\n# def main():\n#     \"\"\"\n#     We start with the first point and move towards the last point.\n#     For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n#     \"\"\"\n#     n = int(input())\n#     points = list(map(int, input().split()))\n#\n#     def is_pow_of_2(x):\n#         \"\"\"\n#         Check that the given number is a power of 2\n#         \"\"\"\n#         return int(math.log2(x)) == math.log2(x)\n#\n#     points.sort() # Sort points to make sure that points are in ascending order\n#     max_points = [] # List of points that satisfy the given condition\n#     for point_idx in range(n):\n#         point = points[point_idx]\n#         temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n#         for pow_idx in range(1, int(math.log2(10**9))):\n#             # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n#             if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n#                 temp_max_points.append(point + 2**pow_idx)\n#                 temp_max_points.append(point - 2**pow_idx)\n#             else:\n#                 break\n#         if len(temp_max_points) > len(max_points):\n#             # If there are more points that satisfy the given condition for the current point than for the previous points\n#             # then we set the current points as the maximum points\n#             max_points = temp_max_points\n#\n#     max_points.sort() # Sort points to make sure that points are in ascending order\n#\n#     print(len(max_points))\n#     print(*max_points)\n#\n# if __name__ == \"__main__\":\n#     main()\n"
    },
    {
      "index": 2,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(sys.stdin.readline())\n    points = list(map(int, sys.stdin.readline().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points, sep = \" \")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650464673,
  "object": "edit"
}
2022-04-20 14:24:54.543224 fix syntax errors 4 ['import math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\n#\n# import math\n#\n# def main():\n#     """\n#     We start with the first point and move towards the last point.\n#     For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n#     """\n#     n = int(input())\n#     points = list(map(int, input().split()))\n#\n#     def is_pow_of_2(x):\n#         """\n#         Check that the given number is a power of 2\n#         """\n#         return int(math.log2(x)) == math.log2(x)\n#\n#     points.sort() # Sort points to make sure that points are in ascending order\n#     max_points = [] # List of points that satisfy the given condition\n#     for point_idx in range(n):\n#         point = points[point_idx]\n#         temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n#         for pow_idx in range(1, int(math.log2(10**9))):\n#             # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n#             if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n#                 temp_max_points.append(point + 2**pow_idx)\n#                 temp_max_points.append(point - 2**pow_idx)\n#             else:\n#                 break\n#         if len(temp_max_points) > len(max_points):\n#             # If there are more points that satisfy the given condition for the current point than for the previous points\n#             # then we set the current points as the maximum points\n#             max_points = temp_max_points\n#\n#     max_points.sort() # Sort points to make sure that points are in ascending order\n#\n#     print(len(max_points))\n#     print(*max_points)\n#\n# if __name__ == "__main__":\n#     main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(sys.stdin.readline())\n    points = list(map(int, sys.stdin.readline().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points, sep = " ")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 14:24:54.543431 size on output set 4
2022-04-20 14:24:54.543447 num operations 1
2022-04-20 14:24:54.543453 size on input set 1
2022-04-20 14:24:54.543622 using api key sourya
2022-04-20 14:25:02.060621 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split(' ')]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]), end='')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, j):\n        if j == len(nums):\n            return d\n\n        cur = nums[j]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, j + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        d[i] = d.get(i, 0) + 1\n\n    nums = sorted(d.keys())\n\n    def helper(d, i):\n        if i == len(nums) - 1:\n            return\n\n        cur = nums[i]\n\n        if cur - 1 in d and cur + 1 in d:\n            d[cur] += d[cur - 1] + d[cur + 1]\n        elif cur - 1 in d:\n            d[cur] += d[cur - 1]\n        elif cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(d, i + 1)\n\n    helper(d, 0)\n\n    res = max(d.values())\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650464694,
  "object": "edit"
}
2022-04-20 14:25:02.060909 fix syntax errors 4 ["\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split(' ')]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]), end='')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, j):\n        if j == len(nums):\n            return d\n\n        cur = nums[j]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, j + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        d[i] = d.get(i, 0) + 1\n\n    nums = sorted(d.keys())\n\n    def helper(d, i):\n        if i == len(nums) - 1:\n            return\n\n        cur = nums[i]\n\n        if cur - 1 in d and cur + 1 in d:\n            d[cur] += d[cur - 1] + d[cur + 1]\n        elif cur - 1 in d:\n            d[cur] += d[cur - 1]\n        elif cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(d, i + 1)\n\n    helper(d, 0)\n\n    res = max(d.values())\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 14:25:02.060979 size on output set 4
2022-04-20 14:25:02.060995 num operations 1
2022-04-20 14:25:02.061006 size on input set 1
2022-04-20 14:25:02.061244 using api key gabby
2022-04-20 14:25:05.879284 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 1,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 2,
      "text": "import math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list of ints)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 3,
      "text": "\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = []\n    for i in range(1, n):\n                for j in range(i):\n                    if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                        largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    }
  ],
  "created": 1650464702,
  "object": "edit"
}
2022-04-20 14:25:05.879623 fix syntax errors 4 ['\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', 'import math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list of ints)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = []\n    for i in range(1, n):\n                for j in range(i):\n                    if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                        largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n']
2022-04-20 14:25:05.879677 size on output set 3
