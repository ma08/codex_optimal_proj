2022-04-20 15:03:53.177944 num operations 1
2022-04-20 15:03:53.177964 size on input set 1
2022-04-20 15:03:53.178160 using api key soukgp
2022-04-20 15:03:59.485130 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    print(\"Hello World\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n\ndef read_file(file_name):\n    pass\n\n\ndef write_file(file_name):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "import os\n\n\ndef main():\n    os.chdir(\"Lyrics\")\n    for directory_name, subdirectories, filenames in os.walk('.'):\n        print(\"Directory:\", directory_name)\n        print(\"\\tcontains subdirectories:\", subdirectories)\n        print(\"\\tand files:\", filenames)\n        print(\"(Current working directory is: {})\".format(os.getcwd()))\n\n        for filename in filenames:\n            new_name = get_fixed_filename(filename)\n            print(\"Renaming {} to {}\".format(filename, new_name))\n\n            full_name = os.path.join(directory_name, filename)\n            new_name = os.path.join(directory_name, new_name)\n            os.rename(full_name, new_name)\n\n\ndef get_fixed_filename(filename):\n    new_name = filename.replace(\" \", \"_\").replace(\".TXT\", \".txt\")\n    return new_name\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "import sys\n\n\ndef main():\n    print(sys.argv)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650467033,
  "object": "edit"
}
2022-04-20 15:03:59.485451 fix syntax errors 4 ['\ndef main():\n    print("Hello World")\n\n\nif __name__ == "__main__":\n    main()\n', '\n\n\ndef read_file(file_name):\n    pass\n\n\ndef write_file(file_name):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == "__main__":\n    main()\n', 'import os\n\n\ndef main():\n    os.chdir("Lyrics")\n    for directory_name, subdirectories, filenames in os.walk(\'.\'):\n        print("Directory:", directory_name)\n        print("\\tcontains subdirectories:", subdirectories)\n        print("\\tand files:", filenames)\n        print("(Current working directory is: {})".format(os.getcwd()))\n\n        for filename in filenames:\n            new_name = get_fixed_filename(filename)\n            print("Renaming {} to {}".format(filename, new_name))\n\n            full_name = os.path.join(directory_name, filename)\n            new_name = os.path.join(directory_name, new_name)\n            os.rename(full_name, new_name)\n\n\ndef get_fixed_filename(filename):\n    new_name = filename.replace(" ", "_").replace(".TXT", ".txt")\n    return new_name\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\n\ndef main():\n    print(sys.argv)\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 15:03:59.485493 size on output set 4
2022-04-20 15:03:59.485506 num operations 1
2022-04-20 15:03:59.485513 size on input set 1
2022-04-20 15:03:59.485671 using api key gabby
2022-04-20 15:04:11.090849 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)]) # doctest: +NORMALIZE_WHITESPACE\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)]) # doctest: +NORMALIZE_WHITESPACE\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(1, n+1)]\n    res = 0\n        if len(tree) > 1:\n            for u, v, w in offers:\n                for i in range(len(tree)):\n                    if u in tree[i]:\n                        u_idx = i\n                    if v in tree[i]:\n                        v_idx = i\n                if u_idx != v_idx:\n                    res += w\n                    tree[u_idx] = tree[u_idx] + tree[v_idx]\n                    tree.remove(tree[v_idx])\n        else:\n            break\n    for i in range(len(tree)):\n        for j in tree[i]:\n            res += a[j-1]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n"
    },
    {
      "index": 2,
      "text": "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [i for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if tree[i] == u:\n                u_idx = i\n            if tree[i] == v:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[v_idx]\n    for i in range(n):\n        if tree[i] == i:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n"
    },
    {
      "index": 3,
      "text": "\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n"
    }
  ],
  "created": 1650467039,
  "object": "edit"
}
2022-04-20 15:04:11.091124 fix syntax errors 4 ['\ndef min_cost(n, m, a, offers):\n    """\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    """\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == \'__main__\':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n', '\n\ndef min_cost(n, m, a, offers):\n    """\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)]) # doctest: +NORMALIZE_WHITESPACE\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)]) # doctest: +NORMALIZE_WHITESPACE\n    18\n    """\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(1, n+1)]\n    res = 0\n        if len(tree) > 1:\n            for u, v, w in offers:\n                for i in range(len(tree)):\n                    if u in tree[i]:\n                        u_idx = i\n                    if v in tree[i]:\n                        v_idx = i\n                if u_idx != v_idx:\n                    res += w\n                    tree[u_idx] = tree[u_idx] + tree[v_idx]\n                    tree.remove(tree[v_idx])\n        else:\n            break\n    for i in range(len(tree)):\n        for j in tree[i]:\n            res += a[j-1]\n    return res\n\nif __name__ == \'__main__\':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n', '\n\ndef min_cost(n, m, a, offers):\n    """\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    """\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [i for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if tree[i] == u:\n                u_idx = i\n            if tree[i] == v:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[v_idx]\n    for i in range(n):\n        if tree[i] == i:\n            res += a[i]\n    return res\n\nif __name__ == \'__main__\':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n', '\ndef min_cost(n, m, a, offers):\n    """\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    """\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == \'__main__\':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n']
2022-04-20 15:04:11.091286 size on output set 3
2022-04-20 15:04:11.091302 num operations 1
2022-04-20 15:04:11.091307 size on input set 1
2022-04-20 15:04:11.091512 using api key kouti
2022-04-20 15:04:23.211537 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))  # a[i] is the cost of the edge between i and i\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "import heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650467051,
  "object": "edit"
}
2022-04-20 15:04:23.211882 fix syntax errors 4 ["\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))  # a[i] is the cost of the edge between i and i\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "import heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 15:04:23.212028 size on output set 4
