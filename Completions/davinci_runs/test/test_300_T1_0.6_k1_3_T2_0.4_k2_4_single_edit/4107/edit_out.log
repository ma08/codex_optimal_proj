2022-04-20 14:07:18.514635 num operations 1
2022-04-20 14:07:18.514655 size on input set 1
2022-04-20 14:07:18.514857 using api key sunu
2022-04-20 14:07:20.204449 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, k = map(int, input().split())\ns = input()\nans = 0\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += i + 1\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\nn, k = map(int, input().split())\ns = input()\n\nans = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += i + 1\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\nn, k = map(int, input().split())\ns = input()\n\nans = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += 1\n\nprint(ans)\n"
    },
    {
      "index": 3,
      "text": "\nn, k = map(int, input().split())\ns = input()\n\nans = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += i + 1\n\nprint(ans)\n"
    }
  ],
  "created": 1650463638,
  "object": "edit"
}
2022-04-20 14:07:20.204747 fix syntax errors 4 ["\n\nn, k = map(int, input().split())\ns = input()\nans = 0\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += i + 1\n\nprint(ans)\n", "\nn, k = map(int, input().split())\ns = input()\n\nans = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += i + 1\n\nprint(ans)\n", "\n\nn, k = map(int, input().split())\ns = input()\n\nans = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += 1\n\nprint(ans)\n", "\nn, k = map(int, input().split())\ns = input()\n\nans = 0\n\nfor i in range(n):\n    if s[i] == '1':\n        continue\n    if i - k >= 0 and s[i - k] == '1':\n        continue\n    if i + k < n and s[i + k] == '1':\n        continue\n    ans += i + 1\n\nprint(ans)\n"]
2022-04-20 14:07:20.204782 size on output set 3
2022-04-20 14:07:20.204795 num operations 1
2022-04-20 14:07:20.204801 size on input set 1
2022-04-20 14:07:20.204986 using api key sunu
2022-04-20 14:07:27.217023 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import bisect\n\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == '1' or room == '2']\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == '1' or room == '0']\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, '00100'))\nprint(solution(6, 1, '000000'))\nprint(solution(4, 1, '0011'))\nprint(solution(12, 6, '000010000100'))\n"
    },
    {
      "index": 1,
      "text": "import bisect\n\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == '1']\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == '1' or room == '0']\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += n\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += n\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += n\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, '00100'))\nprint(solution(6, 1, '000000'))\nprint(solution(4, 1, '0011'))\nprint(solution(12, 6, '000010000100'))\n"
    },
    {
      "index": 2,
      "text": "import bisect\n\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == 1]\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == 1 or room == 0]\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, [0, 0, 1, 0, 0]))\nprint(solution(6, 1, [0, 0, 0, 0, 0, 0]))\nprint(solution(4, 1, [0, 0, 1, 1]))\nprint(solution(12, 6, [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]))\n"
    },
    {
      "index": 3,
      "text": "\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == '1']\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == '1' or room == '0']\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, '00100'))\nprint(solution(6, 1, '000000'))\nprint(solution(4, 1, '0011'))\nprint(solution(12, 6, '000010000100'))\n"
    }
  ],
  "created": 1650463640,
  "object": "edit"
}
2022-04-20 14:07:27.217391 fix syntax errors 4 ["import bisect\n\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == '1' or room == '2']\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == '1' or room == '0']\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, '00100'))\nprint(solution(6, 1, '000000'))\nprint(solution(4, 1, '0011'))\nprint(solution(12, 6, '000010000100'))\n", "import bisect\n\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == '1']\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == '1' or room == '0']\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += n\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += n\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += n\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, '00100'))\nprint(solution(6, 1, '000000'))\nprint(solution(4, 1, '0011'))\nprint(solution(12, 6, '000010000100'))\n", 'import bisect\n\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == 1]\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == 1 or room == 0]\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, [0, 0, 1, 0, 0]))\nprint(solution(6, 1, [0, 0, 0, 0, 0, 0]))\nprint(solution(4, 1, [0, 0, 1, 1]))\nprint(solution(12, 6, [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]))\n', "\ndef solution(n, k, s):\n    # create a list of rooms which have router\n    rooms_with_router = [i + 1 for i, room in enumerate(s) if room == '1']\n\n    # rooms to check\n    rooms_to_check = [i + 1 for i, room in enumerate(s) if room == '1' or room == '0']\n\n    # total cost\n    cost = 0\n\n    # for each room to check\n    for room in rooms_to_check:\n\n        # if room has router, skip\n        if room in rooms_with_router:\n            continue\n\n        # if room is the first room\n        if room == 1:\n            # set the closest router to the right\n            closest_router = rooms_with_router[0]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is the last room\n        elif room == n:\n            # set the closest router to the left\n            closest_router = rooms_with_router[-1]\n\n            # if the closest router is out of range, the room needs to be connected directly\n            if closest_router < room - k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n        # if room is in between first and last room\n        else:\n            # set the closest router to the left\n            closest_router_left = rooms_with_router[bisect.bisect_right(rooms_with_router, room) - 1]\n\n            # set the closest router to the right\n            closest_router_right = rooms_with_router[bisect.bisect_left(rooms_with_router, room)]\n\n            # if both routers are out of range, the room needs to be connected directly\n            if closest_router_left < room - k and closest_router_right > room + k:\n                cost += room\n            # else, the room is connected to the internet\n            else:\n                pass\n\n    return cost\n\n\nprint(solution(5, 2, '00100'))\nprint(solution(6, 1, '000000'))\nprint(solution(4, 1, '0011'))\nprint(solution(12, 6, '000010000100'))\n"]
2022-04-20 14:07:27.217517 size on output set 4
2022-04-20 14:07:27.217531 num operations 1
2022-04-20 14:07:27.217538 size on input set 1
2022-04-20 14:07:27.217697 using api key soukgp
2022-04-20 14:07:34.007683 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef solve(n, k, s):\n    i = 1\n    routers = 0\n    cost = 0\n    while i <= n:\n        # print(\"i: {}\".format(i))\n        if s[i-1] == '1':\n            # print(\"router at {}\".format(i))\n            routers += 1\n            cost += i\n            i += k * 2 + 1\n        else:\n            # print(\"connection at {}\".format(i))\n            cost += i\n            i += 1\n    # print(\"routers: {}\".format(routers))\n    return cost\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef solve(n, m, l, r):\n    return 0\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    l = []\n    r = []\n    for i in range(m):\n        l_i, r_i = map(int, input().split())\n        l.append(l_i)\n        r.append(r_i)\n    print(solve(n, m, l, r))\n"
    },
    {
      "index": 2,
      "text": "\n\ndef solve(n, k, s):\n    pass\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n"
    },
    {
      "index": 3,
      "text": "\n\ndef solve(n, k, s):\n    i = 1\n    routers = 0\n    cost = 0\n    while i <= n:\n        # print(\"i: {}\".format(i))\n        if s[i - 1] == '1':\n            # print(\"router at {}\".format(i))\n            routers += 1\n            cost += i\n            i += k * 2 + 1\n        else:\n            # print(\"connection at {}\".format(i))\n            cost += i\n            i += 1\n    # print(\"routers: {}\".format(routers))\n    return cost\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n"
    }
  ],
  "created": 1650463647,
  "object": "edit"
}
2022-04-20 14:07:34.007924 fix syntax errors 4 ['\n\ndef solve(n, k, s):\n    i = 1\n    routers = 0\n    cost = 0\n    while i <= n:\n        # print("i: {}".format(i))\n        if s[i-1] == \'1\':\n            # print("router at {}".format(i))\n            routers += 1\n            cost += i\n            i += k * 2 + 1\n        else:\n            # print("connection at {}".format(i))\n            cost += i\n            i += 1\n    # print("routers: {}".format(routers))\n    return cost\n\nif __name__ == \'__main__\':\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n', "\n\ndef solve(n, m, l, r):\n    return 0\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    l = []\n    r = []\n    for i in range(m):\n        l_i, r_i = map(int, input().split())\n        l.append(l_i)\n        r.append(r_i)\n    print(solve(n, m, l, r))\n", "\n\ndef solve(n, k, s):\n    pass\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n", '\n\ndef solve(n, k, s):\n    i = 1\n    routers = 0\n    cost = 0\n    while i <= n:\n        # print("i: {}".format(i))\n        if s[i - 1] == \'1\':\n            # print("router at {}".format(i))\n            routers += 1\n            cost += i\n            i += k * 2 + 1\n        else:\n            # print("connection at {}".format(i))\n            cost += i\n            i += 1\n    # print("routers: {}".format(routers))\n    return cost\n\nif __name__ == \'__main__\':\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n']
2022-04-20 14:07:34.007963 size on output set 4
