["from collections import deque\nn = int(input())\ns = input()\ngraph = {}\nfor i in range(n):\n    graph[i] = set()\nrb = set()\nfor i in range(n):\n    for j in range(i + 1, n):\n        if s[i] > s[j]:\n            graph[i].add(j)\n            graph[j].add(i)\n            rb.add((i, j))\n            rb.add((j, i))\ngroup = [0] * n\nused = [0] * n\nfor p in range(n):\n    if not used[p]:\n        used[p] = 1\n        q = deque([p])\n        group[p] = 0\n        while q:\n            v = q.popleft()\n            for u in graph[v]:\n                if not used[u]:\n                    used[u] = 1\n                    q.append(u)\n                    group[u] = 1 - group[v]\ng1, g2 = set(), set()\nfor i in range(n):\n    if group[i] == 0:\n        g1.add(i)\n    else:\n        g2.add(i)\nfor p in g1:\n    for p2 in g1:\n        if (p, p2) in rb:\n            print('NO')\n            return\nfor p in g2:\n    for p2 in g2:\n        if (p, p2) in rb:\n            print('NO')\n            return\nprint('YES')\nfor i in range(n):\n    if i in g1:\n        print('0', end='')\n    else:\n        print('1', end='')", "n = int(input())\ns = input()\nnajm = [0] * n\nnajm[n-1] = s[n-1]\nfor i in range(n-1):\n    j = n - i - 2\n    najm[j] = min(najm[j+1], s[j+1])\ncan_sort = True\nfor i in range(n):\n    for j in range(i+1, n-1):\n        if s[i] > s[j] and s[j] > najm[j]:\n            can_sort = False\n            break\nif not can_sort:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    kol = [-1] * n\n    kol[0] = 0\n    ind = 0\n    while ind < n:\n        if kol[ind] == -1:\n            kol[ind] = 0\n        for i in range(ind+1,n):\n            if s[i] < s[ind]:\n                kol[i] = (kol[ind]+1)%2\n        ind += 1\n    print(\"\".join(map(str,kol)))", "import sys\nn = int(input())\ns = input()\nl1 = [1]*n\nl1[0] = 0\nprev = s[0]\nfor i in range(1, n):\n    if s[i] >= prev:\n        l1[i] = 0\n        prev = s[i]\ntemp = []\nfor i in range(n):\n    if l1[i] == 1:\n        temp.append(s[i])\nif len(temp) ==0:\n    print(\"YES\")\n    print(''.join(str(x) for x in l1))\n    return\n    \nprev = temp[0]\nfor i in range(1, len(temp)):\n    if temp[i] < prev:\n        print(\"NO\")\n        return\n    prev = temp[i]\nprint(\"YES\")\nprint(''.join(str(x) for x in l1))", "from math import *\nn = int(input())\ns = input()\npre = '0'\nprev = s[0]\nlst = -1\nfor i in range(1,n):\n\tif(s[i] >= prev):\n\t\tprev = s[i]\n\t\tpre += '0'\n\telse:\n\t\tpre += '1'\n\t\tif(lst != -1):\n\t\t\tif(s[i] < lst):\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\n\t\tlst = s[i]\nprint(\"YES\")\nprint(pre)\n", "def dfs(no,par=-1,c=0):\n    nonlocal adj,vis,col,st\n    col[no]=c\n    \n    for i in adj[no]:\n        if vis[i]==1:\n            \n            if col[i]==col[no]:\n                st=0\n                continue\n            else:\n                continue\n        \n        vis[i]=1\n        \n        dfs(i,no,1-c)\nn=int(input())\ns=list(input())\n\ns=[ord(i)-97 for i in s]\nif sorted(s)==s:\n    print(\"YES\")\n    print(\"0\"*n)\nelse:\n    st=1\n    adj=[[] for i in range(n)]\n    for i in range(n):\n        for j in range(i):\n            if s[i]<s[j]:\n                adj[i].append(j)\n                adj[j].append(i)\n    col=[-1 for i in range(n)]\n    vis=[0 for i in range(n)]\n    st=1\n    for i in range(n):\n        if vis[i]==0:\n            vis[i]=1\n            dfs(i)\n          #  print(vis)\n    if st:\n        col=[str(i) for i in col]\n        print(\"YES\")\n        print(''.join(col))\n    else:\n        print(\"NO\")\n                \n            \n", "\nalp = \"abcdefghijklmnopqrstuvwxyz\"\n\ndic = {}\nfor i,s in enumerate(alp):\n    dic[s] = i\n\nlis = [-1] * 27\n\nn = int(input())\nS = input()\nans = []\n\nfor i,s in enumerate(S):\n\n    ind = dic[s]\n\n    ans.append(max(lis[ind+1:]) + 1)\n\n    lis[ind] = ans[-1]\n\nif max(ans) <= 1:\n\n    print (\"YES\")\n    print(\"\".join(map(str,ans)))\n\nelse:\n    print (\"NO\")\n", "n = int(input())\ns = input()\nf = [0 for _ in range(26)]\nres = [1 for _ in range(n)]\nfor i in range(n):\n    c = ord(s[i]) - ord('a')\n    for j in range(c + 1, 26):\n        res[i] = max(res[i], f[j] + 1)\n    f[c] = max(f[c], res[i])\n    \nmaxres = max(res)\n\nif maxres <= 2:\n    print(\"YES\")\n    for i in res:\n        print(i - 1, end = '')\nelse:\n    print(\"NO\")", "n = int(input())\na = list(map(lambda c: ord(c)-97, input()))\ncolor = [0]*26\nans = [0]*n\nlast = -1\n\nfor i, c in enumerate(a):\n    col = 0\n    if last <= c:\n        last = c\n        if color[c] == 0 or color[c] == 3:\n            col = 1\n        else:\n            col = color[c]\n    else:\n        for j in range(last, c, -1):\n            if color[j] == 0:\n                continue\n            if color[j] == 3:\n                print('NO')\n                return\n            if col == 0:\n                col = color[j] ^ 3\n            elif col & color[j]:\n                print('NO')\n                return\n\n    color[c] |= col\n    ans[i] = col-1\n\nprint('YES')\nprint(*ans, sep='')\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().split()[0])\n    s = sys.stdin.readline().split()[0]\n    color = [None]*n\n    color[0] = 0\n    for i in range(n):\n        if color[i] == None:\n            color[i] = 0\n        for j in range(i+1, n):\n            if ord(s[j]) < ord(s[i]):\n                if color[j] == color[i]:\n                    print(\"NO\")\n                    return\n                if color[j] == None:\n                    color[j] = color[i]^1\n    print(\"YES\")\n    print(*color, sep = \"\")            \n                \nmain()", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nclass SegmentTree:\n    def __init__(self, a):\n        # Operator\n        self.op = lambda a, b : max(a, b)\n        # Identity element\n        self.e = 0 \n\n        self.n = len(a)\n        self.lv = (self.n - 1).bit_length()\n        self.size = 2**self.lv\n        self.data = [self.e] * (2*self.size - 1)\n        # Bisect checking function \n        self._check = lambda x, acc : acc >= x\n        self._acc = self.e\n\n        self.initialize(a)\n\n    # Initialize data\n    def initialize(self, a):\n        for i in range(self.n):\n            self.data[self.size + i - 1] = a[i]\n        for i in range(self.size-2, -1, -1):\n            self.data[i] = self.op(self.data[i*2 + 1], self.data[i*2 + 2])\n\n    # Update ak as x (0-indexed)\n    def update(self, k, x):\n        k += self.size - 1\n        self.data[k] = x\n        while k > 0:\n            k = (k - 1) // 2\n            self.data[k] = self.op(self.data[2*k+1], self.data[2*k+2])\n\n    # Min value in [l, r) (0-indexed)\n    def fold(self, l, r):\n        L = l + self.size; R = r + self.size\n        s = self.e\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.op(s, self.data[R-1])\n            if L & 1:\n                s = self.op(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\n    def _bisect_forward(self, x, start, k):\n        # When segment-k is at the bottom, accumulate and return.\n        if k >= self.size - 1:\n            self._acc = self.op(self._acc, self.data[k])\n            if self._check(x, self._acc):\n                return k - (self.size - 1)\n            else:\n                return -1\n        width = 2**(self.lv - (k+1).bit_length() + 1)\n        mid = (k+1) * width + width // 2 - self.size \n        # When left-child isn't in range, just look at right-child. \n        if mid <= start:\n            return self._bisect_forward(x, start, 2*k + 2)\n        # When segment-k is in range and has no answer in it, accumulate and return -1\n        tmp_acc = self.op(self._acc, self.data[k])\n        if start <= mid - width // 2 and not self._check(x, tmp_acc):\n            self._acc = tmp_acc\n            return -1\n        # Check left-child then right-child\n        vl = self._bisect_forward(x, start, 2*k + 1)\n        if vl != -1:\n            return vl\n        return self._bisect_forward(x, start, 2*k + 2)\n    \n    # Returns min index s.t. start <= index and satisfy check(data[start:idx)) = True\n    def bisect_forward(self, x, start=None):\n        if start:\n            ret = self._bisect_forward(x, start, 0)\n        else:\n            ret = self._bisect_forward(x, 0, 0)\n        self._acc = self.e\n        return ret\n\n    def _bisect_backward(self, x, start, k):\n        # When segment-k is at the bottom, accumulate and return.\n        if k >= self.size - 1:\n            self._acc = self.op(self._acc, self.data[k])\n            if self._check(x, self._acc):\n                return k - (self.size - 1)\n            else:\n                return -1\n        width = 2**(self.lv - (k+1).bit_length() + 1)\n        mid = (k+1) * width + width // 2 - self.size \n        # When right-child isn't in range, just look at right-child. \n        if mid >= start:\n            return self._bisect_backward(x, start, 2*k + 1)\n        # When segment-k is in range and has no answer in it, accumulate and return -1\n        tmp_acc = self.op(self._acc, self.data[k])\n        if start > mid + width // 2 and not self._check(x, tmp_acc):\n            self._acc = tmp_acc\n            return -1\n        # Check right-child then left-child\n        vl = self._bisect_backward(x, start, 2*k + 2)\n        if vl != -1:\n            return vl\n        return self._bisect_backward(x, start, 2*k + 1)\n    \n    # Returns max index s.t. index < start and satisfy check(data[idx:start)) = True\n    def bisect_backward(self, x, start=None):\n        if start:\n            ret = self._bisect_backward(x, start, 0)\n        else:\n            ret = self._bisect_backward(x, self.n, 0)\n        self._acc = self.e\n        return ret\n\n\nn = int(input())\ns = input().rstrip()\narray = [0] * n\nST = SegmentTree(array)\n\nevent = []\nfor i, ch in enumerate(s):\n    event.append((ch, i))\nevent.sort(reverse=True)\n\nans = [0] * n\nfor ch, index in event:\n    val = ST.fold(0, index) + 1\n    ans[index] = val\n    ST.update(index, val)\nif max(ans) >= 3:\n    print(\"NO\")\n    return\nprint(\"YES\")\nprint(\"\".join([str(item - 1) for item in ans]))"]