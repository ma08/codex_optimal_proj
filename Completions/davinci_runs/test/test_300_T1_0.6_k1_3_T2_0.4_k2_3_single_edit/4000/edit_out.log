2022-04-18 04:42:44.510112 num operations 1
2022-04-18 04:42:44.510132 size on input set 1
2022-04-18 04:43:22.409299 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 1,
      "text": "\nimport os\nimport time\nimport random\nimport math\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport itertools\nimport collections\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\nfrom torch.optim import lr_scheduler\nfrom torch.autograd import Variable\nfrom torch.utils.data import DataLoader\nfrom torchvision import datasets, models, transforms\nfrom PIL import Image\nfrom tqdm import tqdm\nimport cv2\nimport pickle\nimport glob\nimport json\nimport copy\nimport shutil\nimport argparse\nfrom collections import OrderedDict\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.metrics import average_precision_score\nfrom sklearn.metrics import precision_recall_curve\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import cohen_kappa_score\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import precision_score\nfrom sklearn.metrics import recall_score\nfrom sklearn.metrics import log_loss\nfrom sklearn.metrics import jaccard_score\nfrom sklearn.metrics import hinge_loss\nfrom sklearn.metrics import matthews_corrcoef\nfrom sklearn.metrics import zero_one_loss\nfrom sklearn.metrics import brier_score_loss\nfrom sklearn.preprocessing import label_binarize\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.preprocessing import FunctionTransformer\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.preprocessing import KBinsDiscretizer\nfrom sklearn.preprocessing import Binarizer\nfrom sklearn.preprocessing import Imputer\nfrom sklearn.preprocessing import Normalizer\nfrom sklearn.preprocessing import MaxAbsScaler\nfrom sklearn.preprocessing import add_dummy_feature\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.preprocessing import Normalizer\nfrom sklearn.preprocessing import FunctionTransformer\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.preprocessing import KBinsDiscretizer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.preprocessing import add_dummy_feature\nfrom sklearn.preprocessing import Binarizer\nfrom sklearn.preprocessing import Imputer\nfrom sklearn.preprocessing import MaxAbsScaler\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.decomposition import PCA\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.decomposition import IncrementalPCA\nfrom sklearn.decomposition import KernelPCA\nfrom sklearn.decomposition import SparsePCA\nfrom sklearn.decomposition import FastICA\nfrom sklearn.decomposition import FactorAnalysis\nfrom sklearn.decomposition import MiniBatchDictionaryLearning\nfrom sklearn.decomposition import DictionaryLearning\nfrom sklearn.decomposition import LatentDirichletAllocation\nfrom sklearn.decomposition import NMF\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.decomposition import PCA\nfrom sklearn.decomposition import KernelPCA\nfrom sklearn.decomposition import SparsePCA\nfrom sklearn.decomposition import IncrementalPCA\nfrom sklearn.decomposition import MiniBatchDictionaryLearning\nfrom sklearn.decomposition import DictionaryLearning\nfrom sklearn.decomposition import FactorAnalysis\nfrom sklearn.decomposition import FastICA\nfrom sklearn.decomposition import LatentDirichletAllocation\nfrom sklearn.decomposition import NMF\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.manifold import TSNE\nfrom sklearn.manifold import Isomap\nfrom sklearn.manifold import LocallyLinearEmbedding\nfrom sklearn.manifold import SpectralEmbedding\nfrom sklearn.manifold import MDS\nfrom sklearn.manifold import SpectralEmbedding\nfrom sklearn.manifold import LocallyLinearEmbedding\nfrom sklearn.manifold import Isomap\nfrom sklearn.manifold import TSNE\nfrom sklearn.manifold import MDS\nfrom sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import chi2\nfrom sklearn.feature_selection import f_classif\nfrom sklearn.feature_selection import mutual_info_classif\nfrom sklearn.feature_selection import SelectPercentile\nfrom sklearn.feature_selection import SelectFpr\nfrom sklearn.feature_selection import SelectFdr\nfrom sklearn.feature_selection import SelectFwe\nfrom sklearn.feature_selection import GenericUnivariateSelect\nfrom sklearn.feature_selection import VarianceThreshold\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.feature_selection import RFE\nfrom sklearn.feature_selection import RFECV\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.feature_selection import RFE\nfrom sklearn.feature_selection import RFECV\nfrom sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import chi2\nfrom sklearn.feature_selection import f_classif\nfrom sklearn.feature_selection import mutual_info_classif\nfrom sklearn.feature_selection import SelectPercentile\nfrom sklearn.feature_selection import SelectFpr\nfrom sklearn.feature_selection import SelectFdr\nfrom sklearn.feature_selection import SelectFwe\nfrom sklearn.feature_selection import GenericUnivariateSelect\nfrom sklearn.feature_selection import VarianceThreshold\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_extraction.text import HashingVectorizer\nfrom sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.feature_extraction.text import ENGLISH_STOP_WORDS\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.feature_extraction.text import HashingVectorizer\nfrom sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.feature_extraction.text import ENGLISH_STOP_WORDS\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.metrics import average_precision_score\nfrom sklearn.metrics import precision_recall_curve\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import cohen_kappa_score\nfrom sklearn.metrics import roc_auc_\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n"
    }
  ],
  "created": 1650256965,
  "object": "edit"
}
2022-04-18 04:43:22.409769 fix syntax errors 3 ['\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', '\nimport os\nimport time\nimport random\nimport math\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport itertools\nimport collections\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.nn.functional as F\nfrom torch.optim import lr_scheduler\nfrom torch.autograd import Variable\nfrom torch.utils.data import DataLoader\nfrom torchvision import datasets, models, transforms\nfrom PIL import Image\nfrom tqdm import tqdm\nimport cv2\nimport pickle\nimport glob\nimport json\nimport copy\nimport shutil\nimport argparse\nfrom collections import OrderedDict\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.metrics import average_precision_score\nfrom sklearn.metrics import precision_recall_curve\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import cohen_kappa_score\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.metrics import precision_score\nfrom sklearn.metrics import recall_score\nfrom sklearn.metrics import log_loss\nfrom sklearn.metrics import jaccard_score\nfrom sklearn.metrics import hinge_loss\nfrom sklearn.metrics import matthews_corrcoef\nfrom sklearn.metrics import zero_one_loss\nfrom sklearn.metrics import brier_score_loss\nfrom sklearn.preprocessing import label_binarize\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.preprocessing import FunctionTransformer\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.preprocessing import KBinsDiscretizer\nfrom sklearn.preprocessing import Binarizer\nfrom sklearn.preprocessing import Imputer\nfrom sklearn.preprocessing import Normalizer\nfrom sklearn.preprocessing import MaxAbsScaler\nfrom sklearn.preprocessing import add_dummy_feature\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.preprocessing import Normalizer\nfrom sklearn.preprocessing import FunctionTransformer\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.preprocessing import KBinsDiscretizer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn.preprocessing import QuantileTransformer\nfrom sklearn.preprocessing import add_dummy_feature\nfrom sklearn.preprocessing import Binarizer\nfrom sklearn.preprocessing import Imputer\nfrom sklearn.preprocessing import MaxAbsScaler\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.decomposition import PCA\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.decomposition import IncrementalPCA\nfrom sklearn.decomposition import KernelPCA\nfrom sklearn.decomposition import SparsePCA\nfrom sklearn.decomposition import FastICA\nfrom sklearn.decomposition import FactorAnalysis\nfrom sklearn.decomposition import MiniBatchDictionaryLearning\nfrom sklearn.decomposition import DictionaryLearning\nfrom sklearn.decomposition import LatentDirichletAllocation\nfrom sklearn.decomposition import NMF\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.decomposition import PCA\nfrom sklearn.decomposition import KernelPCA\nfrom sklearn.decomposition import SparsePCA\nfrom sklearn.decomposition import IncrementalPCA\nfrom sklearn.decomposition import MiniBatchDictionaryLearning\nfrom sklearn.decomposition import DictionaryLearning\nfrom sklearn.decomposition import FactorAnalysis\nfrom sklearn.decomposition import FastICA\nfrom sklearn.decomposition import LatentDirichletAllocation\nfrom sklearn.decomposition import NMF\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.manifold import TSNE\nfrom sklearn.manifold import Isomap\nfrom sklearn.manifold import LocallyLinearEmbedding\nfrom sklearn.manifold import SpectralEmbedding\nfrom sklearn.manifold import MDS\nfrom sklearn.manifold import SpectralEmbedding\nfrom sklearn.manifold import LocallyLinearEmbedding\nfrom sklearn.manifold import Isomap\nfrom sklearn.manifold import TSNE\nfrom sklearn.manifold import MDS\nfrom sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import chi2\nfrom sklearn.feature_selection import f_classif\nfrom sklearn.feature_selection import mutual_info_classif\nfrom sklearn.feature_selection import SelectPercentile\nfrom sklearn.feature_selection import SelectFpr\nfrom sklearn.feature_selection import SelectFdr\nfrom sklearn.feature_selection import SelectFwe\nfrom sklearn.feature_selection import GenericUnivariateSelect\nfrom sklearn.feature_selection import VarianceThreshold\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.feature_selection import RFE\nfrom sklearn.feature_selection import RFECV\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.feature_selection import RFE\nfrom sklearn.feature_selection import RFECV\nfrom sklearn.feature_selection import SelectKBest\nfrom sklearn.feature_selection import chi2\nfrom sklearn.feature_selection import f_classif\nfrom sklearn.feature_selection import mutual_info_classif\nfrom sklearn.feature_selection import SelectPercentile\nfrom sklearn.feature_selection import SelectFpr\nfrom sklearn.feature_selection import SelectFdr\nfrom sklearn.feature_selection import SelectFwe\nfrom sklearn.feature_selection import GenericUnivariateSelect\nfrom sklearn.feature_selection import VarianceThreshold\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_extraction.text import HashingVectorizer\nfrom sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.feature_extraction.text import ENGLISH_STOP_WORDS\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.feature_extraction.text import HashingVectorizer\nfrom sklearn.feature_extraction.text import TfidfTransformer\nfrom sklearn.feature_extraction.text import ENGLISH_STOP_WORDS\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn.metrics import average_precision_score\nfrom sklearn.metrics import precision_recall_curve\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import cohen_kappa_score\nfrom sklearn.metrics import roc_auc_\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n', '\nimport sys\nsys.setrecursionlimit(10 ** 6)\ndef dfs(v, parent = -1):\n    for u in g[v]:\n        if u != parent:\n            dfs(u, v)\n            dp1[v] += dp2[u]\n            dp2[v] += max(dp1[u], dp2[u])\n\n\nn = int(input())\ng = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    g[a].add(b)\n    g[b].add(a)\n\ndp1 = [0] * (n + 1)\ndp2 = [1] * (n + 1)\ndfs(1)\n\nprint(max(dp1[1], dp2[1]))\nfor v in range(1, n + 1):\n    if dp1[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(1, v)\n        break\nfor v in range(1, n + 1):\n    if dp2[v] == max(dp1[1], dp2[1]) and v != 1:\n        print(v)\n        break\n']
2022-04-18 04:43:22.409950 size on output set 3
2022-04-18 04:43:22.409977 num operations 1
2022-04-18 04:43:22.409989 size on input set 1
2022-04-18 04:43:35.707481 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue(maxsize = n)\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue(maxsize = n)\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]  # graph[i] = [j, k, l] means i is connected to j, k, l\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)  # a is connected to b\n        graph[b].append(a)  # b is connected to a\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0  # max_1 is the maximum distance from i to some node, max_2 is the second maximum distance\n        dist_1 = [0] * (n + 1)  # dist_1[j] is the distance from i to j\n        q = queue.Queue()\n        q.put(i)  # initialize the queue with i\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650257003,
  "object": "edit"
}
2022-04-18 04:43:35.707763 fix syntax errors 3 ['\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue(maxsize = n)\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue(maxsize = n)\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0\n        dist_1 = [0] * (n + 1)\n        q = queue.Queue()\n        q.put(i)\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\ndef main():\n    n = int(sys.stdin.readline())\n    graph = [[] for _ in range(n + 1)]  # graph[i] = [j, k, l] means i is connected to j, k, l\n    for _ in range(n - 1):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)  # a is connected to b\n        graph[b].append(a)  # b is connected to a\n    res = 0\n    for i in range(1, n + 1):\n        max_1, max_2 = 0, 0  # max_1 is the maximum distance from i to some node, max_2 is the second maximum distance\n        dist_1 = [0] * (n + 1)  # dist_1[j] is the distance from i to j\n        q = queue.Queue()\n        q.put(i)  # initialize the queue with i\n        while not q.empty():\n            u = q.get()\n            for v in graph[u]:\n                if dist_1[v] == 0:\n                    dist_1[v] = dist_1[u] + 1\n                    if dist_1[v] > max_1:\n                        max_2 = max_1\n                        max_1 = dist_1[v]\n                    elif dist_1[v] > max_2:\n                        max_2 = dist_1[v]\n                    q.put(v)\n        for j in range(1, n + 1):\n            if dist_1[j] == max_2:\n                max_3 = 0\n                dist_2 = [0] * (n + 1)\n                q = queue.Queue()\n                q.put(j)\n                while not q.empty():\n                    u = q.get()\n                    for v in graph[u]:\n                        if dist_2[v] == 0:\n                            dist_2[v] = dist_2[u] + 1\n                            if dist_2[v] > max_3:\n                                max_3 = dist_2[v]\n                            q.put(v)\n                if max_1 + max_2 + max_3 - 3 > res:\n                    res = max_1 + max_2 + max_3 - 3\n                    a = i\n                    b = j\n                    c = 0\n                    for k in range(1, n + 1):\n                        if dist_2[k] == max_3:\n                            c = k\n                            break\n    print(res)\n    print(a, b, c)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-18 04:43:35.707958 size on output set 3
2022-04-18 04:43:35.707983 num operations 1
2022-04-18 04:43:35.707994 size on input set 1
2022-04-18 04:43:44.670657 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n\n    dfs(1, 0, 0)\n\n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n\n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n\n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 2
    }
  ],
  "created": 1650257016,
  "object": "edit"
}
2022-04-18 04:43:44.670911 NO RESULT
2022-04-18 04:43:44.670926 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 2
}
2022-04-18 04:43:44.671001 fix syntax errors 2 ['\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n    \n    dfs(1, 0, 0)\n    \n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n    \n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n    \n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    parent = [0] * (n+1)\n    depth = [0] * (n+1)\n    def dfs(cur, par, dep):\n        parent[cur] = par\n        depth[cur] = dep\n        for child in adj[cur]:\n            if child != par:\n                dfs(child, cur, dep+1)\n\n    dfs(1, 0, 0)\n\n    def lca(a, b):\n        if depth[a] > depth[b]:\n            a, b = b, a\n        while depth[a] < depth[b]:\n            b = parent[b]\n        while a != b:\n            a = parent[a]\n            b = parent[b]\n        return a\n\n    def solve(x, y, z):\n        # x -> y -> z\n        p1 = lca(x, y)\n        p2 = lca(y, z)\n        p3 = lca(x, z)\n        d1 = depth[x] + depth[y] - 2 * depth[p1]\n        d2 = depth[y] + depth[z] - 2 * depth[p2]\n        d3 = depth[x] + depth[z] - 2 * depth[p3]\n        return max(d1, d2, d3)\n\n    ans = 0\n    x, y, z = 0, 0, 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                t = solve(i, j, k)\n                if t > ans:\n                    ans = t\n                    x, y, z = i, j, k\n    print(ans)\n    print(x, y, z)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-18 04:43:44.671074 size on output set 2
