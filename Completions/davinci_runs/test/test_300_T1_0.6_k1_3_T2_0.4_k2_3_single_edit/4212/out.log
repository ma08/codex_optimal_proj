2022-04-18 03:28:11.533100 """
Given are positive integers N, M, Q, and Q quadruples of integers ( a_i , b_i , c_i , d_i ).
Consider a sequence A satisfying the following conditions:
 - A is a sequence of N positive integers.
 - 1 \leq A_1 \leq A_2 \le \cdots \leq A_N \leq M.
Let us define a score of this sequence as follows:
 - The score is the sum of d_i over all indices i such that A_{b_i} - A_{a_i} = c_i. (If there is no such i, the score is 0.)
Find the maximum possible score of A.

-----Constraints-----
 - All values in input are integers.
 - 2 ≤ N ≤ 10
 - 1 \leq M \leq 10
 - 1 \leq Q \leq 50
 - 1 \leq a_i < b_i \leq N ( i = 1, 2, ..., Q )
 - 0 \leq c_i \leq M - 1 ( i = 1, 2, ..., Q )
 - (a_i, b_i, c_i) \neq (a_j, b_j, c_j) (where i \neq j)
 - 1 \leq d_i \leq 10^5 ( i = 1, 2, ..., Q )

-----Input-----
Input is given from Standard Input in the following format:
N M Q
a_1 b_1 c_1 d_1
:
a_Q b_Q c_Q d_Q

-----Output-----
Print the maximum possible score of A.

-----Sample Input-----
3 4 3
1 3 3 100
1 2 2 10
2 3 2 10

-----Sample Output-----
110

When A = \{1, 3, 4\}, its score is 110. Under these conditions, no sequence has a score greater than 110, so the answer is 110.
"""
2022-04-18 03:28:11.533132 --------------------------
2022-04-18 03:28:44.953921 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfrom collections import deque\n\nn, m, q = map(int, input().split())\n\n# a_i, b_i, c_i, d_i\nquads = [list(map(int, input().split())) for _ in range(q)]\n\n# dp[i][j] ... maximum score for first i numbers with last number equal j\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    # if we don't use the last number\n    dp[i][0] = dp[i-1][0]\n\n    # if we use the last number\n    for j in range(1, m+1):\n        dp[i][j] = dp[i-1][j-1]\n\n        # check if we can contribute with the last number\n        for a, b, c, d in quads:\n            if a == i and b == i+1 and c == j:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + d)\n\nprint(max(dp[n]))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn,m,q = map(int, input().split())\ns = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\nfor _ in range(q):\n    a,b,c,d = map(int, input().split())\n    s[a][c] += d\n\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        s[i][j] += s[i][j-1]\n\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        s[i][j] += s[i-1][j]\n\nans = 0\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        ans = max(ans, s[j][m] - s[i-1][m] - s[j][i-1] + s[i-1][i-1])\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n    N, M, Q = map(int, input().split())\n    a = [None] * Q\n    b = [None] * Q\n    c = [None] * Q\n    d = [None] * Q\n    for i in range(Q):\n        a[i], b[i], c[i], d[i] = map(int, input().split())\n    a = [a1 - 1 for a1 in a]\n    b = [b1 - 1 for b1 in b]\n    score = 0\n    for m in range(1, M + 1):\n        score_m = 0\n        for i in range(Q):\n            if m - c[i] == 0:\n                score_m += d[i]\n        score = max(score, score_m)\n        for j in range(Q):\n            if a[j] < b[j] and m - c[j] > 0:\n                score_m += d[j]\n                score = max(score, score_m)\n    print(score)\n    return\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1650252491,
  "id": "cmpl-4yCLbBuj5Mw6lITeBnjw26TOYkoRe",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 03:28:44.954141 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfrom collections import deque\n\nn, m, q = map(int, input().split())\n\n# a_i, b_i, c_i, d_i\nquads = [list(map(int, input().split())) for _ in range(q)]\n\n# dp[i][j] ... maximum score for first i numbers with last number equal j\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    # if we don't use the last number\n    dp[i][0] = dp[i-1][0]\n\n    # if we use the last number\n    for j in range(1, m+1):\n        dp[i][j] = dp[i-1][j-1]\n\n        # check if we can contribute with the last number\n        for a, b, c, d in quads:\n            if a == i and b == i+1 and c == j:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + d)\n\nprint(max(dp[n]))"
}
2022-04-18 03:28:44.954194 REASON stop
2022-04-18 03:28:44.982688 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn,m,q = map(int, input().split())\ns = [[0 for _ in range(m+1)] for _ in range(n+1)]\n\nfor _ in range(q):\n    a,b,c,d = map(int, input().split())\n    s[a][c] += d\n\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        s[i][j] += s[i][j-1]\n\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        s[i][j] += s[i-1][j]\n\nans = 0\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        ans = max(ans, s[j][m] - s[i-1][m] - s[j][i-1] + s[i-1][i-1])\n\nprint(ans)"
}
2022-04-18 03:28:44.982758 REASON stop
2022-04-18 03:28:44.983296 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n    N, M, Q = map(int, input().split())\n    a = [None] * Q\n    b = [None] * Q\n    c = [None] * Q\n    d = [None] * Q\n    for i in range(Q):\n        a[i], b[i], c[i], d[i] = map(int, input().split())\n    a = [a1 - 1 for a1 in a]\n    b = [b1 - 1 for b1 in b]\n    score = 0\n    for m in range(1, M + 1):\n        score_m = 0\n        for i in range(Q):\n            if m - c[i] == 0:\n                score_m += d[i]\n        score = max(score, score_m)\n        for j in range(Q):\n            if a[j] < b[j] and m - c[j] > 0:\n                score_m += d[j]\n                score = max(score, score_m)\n    print(score)\n    return\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 03:28:44.983371 REASON stop
