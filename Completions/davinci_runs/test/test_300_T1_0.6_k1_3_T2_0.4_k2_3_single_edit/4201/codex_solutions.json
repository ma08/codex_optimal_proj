["\n\ndef get_input():\n    \"\"\" Gets the input from the user. \"\"\"\n    H, W, K = input().split()\n    H, W, K = int(H), int(W), int(K)\n    return H, W, K\n\ndef get_grid(H, W):\n    \"\"\" Gets the grid from the user. \"\"\"\n    grid = []\n    for i in range(H):\n        grid.append(input())\n    return grid\n\ndef count_black(grid, H, W):\n    \"\"\" Counts the number of black squares in the grid. \"\"\"\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \"#\":\n                count += 1\n    return count\n\ndef paint_rows(grid, H, W, rows):\n    \"\"\" Paints the rows red. \"\"\"\n    for i in range(H):\n        if i in rows:\n            for j in range(W):\n                grid[i][j] = \"r\"\n    return grid\n\ndef paint_columns(grid, H, W, columns):\n    \"\"\" Paints the columns red. \"\"\"\n    for i in range(H):\n        for j in range(W):\n            if j in columns:\n                grid[i][j] = \"r\"\n    return grid\n\ndef count_red(grid, H, W):\n    \"\"\" Counts the number of red squares. \"\"\"\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \"r\":\n                count += 1\n    return count\n\ndef count_choices(grid, H, W, K):\n    \"\"\" Counts the number of choices that satisfy the condition. \"\"\"\n    count = 0\n    for i in range(1 << H):\n        for j in range(1 << W):\n            rows = []\n            for k in range(H):\n                if i >> k & 1:\n                    rows.append(k)\n            columns = []\n            for k in range(W):\n                if j >> k & 1:\n                    columns.append(k)\n            new_grid = paint_rows(grid, H, W, rows)\n            new_grid = paint_columns(new_grid, H, W, columns)\n            if count_black(new_grid, H, W) == K and count_red(new_grid, H, W) == H * W - K:\n                count += 1\n    return count\n\ndef main():\n    \"\"\" The main function. \"\"\"\n    H, W, K = get_input()\n    grid = get_grid(H, W)\n    choices = count_choices(grid, H, W, K)\n    print(choices)\n\nif __name__ == \"__main__\":\n    main()", "\n\n#-----main-----\n#read input\nH, W, K = map(int, input().split())\nc = [list(input()) for i in range(H)]\n\n#initialize variables\nans = 0\n\n#loop for all cases \nfor i in range(1, 2**H):\n    #get row index\n    row = []\n    for j in range(H):\n        if (i>>j) & 1:\n            row.append(j)\n    for j in range(1, 2**W):\n        #get column index\n        column = []\n        for k in range(W):\n            if (j>>k) & 1:\n                column.append(k)\n        #count black squares\n        tmp = 0\n        for k in row:\n            for l in column:\n                if c[k][l] == '#':\n                    tmp += 1\n        if tmp == K:\n            ans += 1\n\nprint(ans)", "\n\nimport numpy as np\n\ndef main():\n\tH, W, K = map(int, input().split())\n\tgrid = []\n\tfor i in range(H):\n\t\tgrid.append(input())\n\tgrid = np.array(grid)\n\tgrid = np.vectorize(lambda x: 1 if x == '.' else 0)(grid)\n\t# print(grid)\n\n\tcount = 0\n\tfor i in range(2**H):\n\t\tfor j in range(2**W):\n\t\t\trow = np.array(list(map(int, bin(i)[2:].zfill(H))))\n\t\t\tcol = np.array(list(map(int, bin(j)[2:].zfill(W))))\n\t\t\t# print(row, col)\n\t\t\t# print(row[:,np.newaxis])\n\t\t\t# print(np.dot(row[:,np.newaxis], col))\n\t\t\t# print(grid + np.dot(row[:,np.newaxis], col))\n\t\t\t# print(np.sum(grid + np.dot(row[:,np.newaxis], col)))\n\t\t\tif np.sum(grid + np.dot(row[:,np.newaxis], col)) == K:\n\t\t\t\tcount += 1\n\tprint(count)\n\nif __name__ == '__main__':\n\tmain()"]