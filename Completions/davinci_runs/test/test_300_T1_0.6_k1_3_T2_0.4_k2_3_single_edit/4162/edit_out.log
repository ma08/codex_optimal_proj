2022-04-18 05:28:25.485103 num operations 1
2022-04-18 05:28:25.485125 size on input set 1
2022-04-18 05:28:36.332436 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 1,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    },
    {
      "index": 2,
      "text": "\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    \"\"\"\n    Reads in the input and parses it\n    :return: N and a_i\n    \"\"\"\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    \"\"\"\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    \"\"\"\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n"
    }
  ],
  "created": 1650259705,
  "object": "edit"
}
2022-04-18 05:28:36.332711 fix syntax errors 3 ['\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n', '\n\n# N: The number of elements in a_i\n# a_i: The elements in a_i\n\nimport sys\n\ndef read_input():\n    """\n    Reads in the input and parses it\n    :return: N and a_i\n    """\n    N = int(sys.stdin.readline())\n    a_i = list(map(int, sys.stdin.readline().split()))\n    return N, a_i\n\ndef solve(N, a_i):\n    """\n    :param N: The number of elements in a_i\n    :param a_i: The elements in a_i\n    :return: The maximum value of f\n    """\n    # This is basically a greedy algorithm.\n    # We want to maximize f(m) by making m as large as possible.\n    # This is because f(m) = (m mod a_1) + (m mod a_2) + ... + (m mod a_N) is a linear function.\n    # We want to maximize f(m) by making (m mod a_i) as large as possible for all a_i.\n    # This is because (m mod a_i) = m - floor(m/a_i)*a_i.\n    # Thus, m = (m mod a_i) + floor(m/a_i)*a_i.\n    # To maximize m, we want to make floor(m/a_i) as large as possible, which is floor(m/a_i) = 1.\n    # Thus, m = (m mod a_i) + a_i.\n    # The largest value of (m mod a_i) is a_i - 1, so m = a_i - 1 + a_i = 2a_i - 1.\n    # The sum of all the a_i is a_1 + a_2 + ... + a_N.\n    # Thus, the maximum value of f(m) is f(m) = 2a_1 - 1 + 2a_2 - 1 + ... + 2a_N - 1 = 2(a_1 + a_2 + ... + a_N) - N = 2 * sum(a_i) - N\n    return 2 * sum(a_i) - N\n\nN, a_i = read_input()\nprint(solve(N, a_i))\n']
2022-04-18 05:28:36.332877 size on output set 1
2022-04-18 05:28:36.332901 num operations 1
2022-04-18 05:28:36.332913 size on input set 1
2022-04-18 05:28:40.769115 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 1,
      "text": "from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n"
    },
    {
      "index": 2,
      "text": "\nfrom math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = tuple(map(int, input().split()))\nprint(sum(lcmm % a for a in A))\n"
    }
  ],
  "created": 1650259716,
  "object": "edit"
}
2022-04-18 05:28:40.769341 fix syntax errors 3 ['\nfrom math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a == 0 for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', 'from math import gcd\nfrom functools import reduce\nfrom functools import lru_cache\n\nN = int(input())\nA = tuple(map(int, input().split()))\n\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\n\ndef lcmm(*args):\n    return reduce(lcm, args)\n\n\n@lru_cache(maxsize=None)\ndef f(m):\n    return sum(m % a for a in A)\n\n\nl = lcmm(*A)\nprint(f(l))\n', '\nfrom math import gcd\nfrom functools import reduce\n\nN = int(input())\nA = tuple(map(int, input().split()))\nprint(sum(lcmm % a for a in A))\n']
2022-04-18 05:28:40.769385 size on output set 3
2022-04-18 05:28:40.769403 num operations 1
2022-04-18 05:28:40.769413 size on input set 1
2022-04-18 05:28:47.079070 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\n\ndef main():\n    _ = int(input())\n    a = list(map(int, input().split()))\n    b = [0] * _\n    for i in range(_):\n        for j in range(a[i]):\n            b[i] += (j + 1) * (a[i] - j)\n    print(sum(b))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = [0] * N  # \u5404\u4eba\u306e\u8ca2\u732e\u5ea6\u306e\u5408\u8a08\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)  # \u8ca2\u732e\u5ea6\u3092\u8a08\u7b97\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "# -*- coding: utf-8 -*-\n\nimport sys\n\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(sum(A) * sum(B))\n\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650259720,
  "object": "edit"
}
2022-04-18 05:28:47.079317 fix syntax errors 3 ["import sys\n\n\ndef main():\n    _ = int(input())\n    a = list(map(int, input().split()))\n    b = [0] * _\n    for i in range(_):\n        for j in range(a[i]):\n            b[i] += (j + 1) * (a[i] - j)\n    print(sum(b))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = [0] * N  # 各人の貢献度の合計\n    for i in range(N):\n        for j in range(A[i]):\n            B[i] += (j + 1) * (A[i] - j)  # 貢献度を計算\n    print(sum(B))\n\n\nif __name__ == '__main__':\n    main()\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(sum(A) * sum(B))\n\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-18 05:28:47.079412 size on output set 3
