2022-04-18 05:48:13.133131 num operations 1
2022-04-18 05:48:13.133151 size on input set 1
2022-04-18 05:48:33.860206 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class File {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"/Users/mkyong/filename.txt\");\n\t\tFileReader fr = new FileReader(file);\n\t\tBufferedReader br = new BufferedReader(fr);\n\n\t\tString line;\n\t\ttry {\n\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n"
    },
    {
      "index": 1,
      "text": "const fs = require('fs');\n\nmodule.exports = {\n    readFile: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.readFile(path, 'utf8', function (err, data) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(data);\n                }\n            });\n        });\n    },\n    writeFile: function (path, data) {\n        return new Promise(function (resolve, reject) {\n            fs.writeFile(path, data, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    appendFile: function (path, data) {\n        return new Promise(function (resolve, reject) {\n            fs.appendFile(path, data, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    unlink: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.unlink(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    rename: function (oldPath, newPath) {\n        return new Promise(function (resolve, reject) {\n            fs.rename(oldPath, newPath, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    mkdir: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.mkdir(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    rmdir: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.rmdir(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    readdir: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.readdir(path, function (err, files) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(files);\n                }\n            });\n        });\n    },\n    stat: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.stat(path, function (err, stats) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(stats);\n                }\n            });\n        });\n    },\n    readlink: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.readlink(path, function (err, linkString) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(linkString);\n                }\n            });\n        });\n    },\n    symlink: function (target, path) {\n        return new Promise(function (resolve, reject) {\n            fs.symlink(target, path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    link: function (target, path) {\n        return new Promise(function (resolve, reject) {\n            fs.link(target, path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    unlink: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.unlink(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n};\n"
    },
    {
      "index": 2,
      "text": "#!/bin/sh\n\n#  file.sh\n#  \n#\n#  Created by HSP SI Viet Nam on 5/15/14.\n#\necho \"Nhap ten file: \"\nread file\nif [ -f $file ]\nthen\n    echo \"File $file ton tai\"\nelse\n    echo \"File $file khong ton tai\"\nfi\n"
    }
  ],
  "created": 1650260893,
  "object": "edit"
}
2022-04-18 05:48:33.860422 fix syntax errors 3 ['import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class File {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File("/Users/mkyong/filename.txt");\n\t\tFileReader fr = new FileReader(file);\n\t\tBufferedReader br = new BufferedReader(fr);\n\n\t\tString line;\n\t\ttry {\n\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t}\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n', "const fs = require('fs');\n\nmodule.exports = {\n    readFile: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.readFile(path, 'utf8', function (err, data) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(data);\n                }\n            });\n        });\n    },\n    writeFile: function (path, data) {\n        return new Promise(function (resolve, reject) {\n            fs.writeFile(path, data, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    appendFile: function (path, data) {\n        return new Promise(function (resolve, reject) {\n            fs.appendFile(path, data, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    unlink: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.unlink(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    rename: function (oldPath, newPath) {\n        return new Promise(function (resolve, reject) {\n            fs.rename(oldPath, newPath, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    mkdir: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.mkdir(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    rmdir: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.rmdir(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    readdir: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.readdir(path, function (err, files) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(files);\n                }\n            });\n        });\n    },\n    stat: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.stat(path, function (err, stats) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(stats);\n                }\n            });\n        });\n    },\n    readlink: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.readlink(path, function (err, linkString) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(linkString);\n                }\n            });\n        });\n    },\n    symlink: function (target, path) {\n        return new Promise(function (resolve, reject) {\n            fs.symlink(target, path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    link: function (target, path) {\n        return new Promise(function (resolve, reject) {\n            fs.link(target, path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    },\n    unlink: function (path) {\n        return new Promise(function (resolve, reject) {\n            fs.unlink(path, function (err) {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n};\n", '#!/bin/sh\n\n#  file.sh\n#  \n#\n#  Created by HSP SI Viet Nam on 5/15/14.\n#\necho "Nhap ten file: "\nread file\nif [ -f $file ]\nthen\n    echo "File $file ton tai"\nelse\n    echo "File $file khong ton tai"\nfi\n']
2022-04-18 05:48:33.860579 size on output set 3
2022-04-18 05:48:33.860594 num operations 1
2022-04-18 05:48:33.860599 size on input set 1
2022-04-18 05:48:47.225347 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\n\ndef dfs(graph, v, parent, used):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\n\n\ndef bfs(graph, n, s):\n    d = [-1] * n\n    d[s] = 0\n    q = deque()\n    q.append(s)\n    while q:\n        v = q.popleft()\n        for u in graph[v]:\n            if d[u] == -1:\n                d[u] = d[v] + 1\n                q.append(u)\n    return d\n\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges[1:]:\n        graph[u].append(v)\n        graph[v].append(u)\n    d = bfs(graph, n + 1, 1)\n    for i in range(1, n + 1):\n        print(d[i], end=' ')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [None] + [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650260913,
  "object": "edit"
}
2022-04-18 05:48:47.225536 fix syntax errors 3 ["\nimport sys\n\n\ndef dfs(graph, v, parent, used):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\n\n\ndef bfs(graph, n, s):\n    d = [-1] * n\n    d[s] = 0\n    q = deque()\n    q.append(s)\n    while q:\n        v = q.popleft()\n        for u in graph[v]:\n            if d[u] == -1:\n                d[u] = d[v] + 1\n                q.append(u)\n    return d\n\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges[1:]:\n        graph[u].append(v)\n        graph[v].append(u)\n    d = bfs(graph, n + 1, 1)\n    for i in range(1, n + 1):\n        print(d[i], end=' ')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [None] + [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-18 05:48:47.225611 size on output set 3
2022-04-18 05:48:47.225636 num operations 1
2022-04-18 05:48:47.225642 size on input set 1
2022-04-18 05:48:51.016284 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1) \n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n"
    }
  ],
  "created": 1650260927,
  "object": "edit"
}
2022-04-18 05:48:51.016602 fix syntax errors 3 ['\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == "__main__":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print("NO")\n    else:\n        print("YES")\n        print("".join(map(str, map(int, cycle))))\n', '\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == "__main__":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print("NO")\n    else:\n        print("YES")\n        print("".join(map(str, map(int, cycle))))\n', '\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1) \n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    for i in range(m):\n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    return cycle\n\n\nif __name__ == "__main__":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print("NO")\n    else:\n        print("YES")\n        print("".join(map(str, map(int, cycle))))\n']
2022-04-18 05:48:51.016717 size on output set 3
