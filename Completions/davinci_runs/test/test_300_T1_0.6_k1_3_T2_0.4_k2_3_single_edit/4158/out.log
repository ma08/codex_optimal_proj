2022-04-18 03:00:10.664399 """
There are $n$ distinct points on a coordinate line, the coordinate of $i$-th point equals to $x_i$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.

In other words, you have to choose the maximum possible number of points $x_{i_1}, x_{i_2}, \dots, x_{i_m}$ such that for each pair $x_{i_j}$, $x_{i_k}$ it is true that $|x_{i_j} - x_{i_k}| = 2^d$ where $d$ is some non-negative integer number (not necessarily the same for each pair of points).


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of points.

The second line contains $n$ pairwise distinct integers $x_1, x_2, \dots, x_n$ ($-10^9 \le x_i \le 10^9$) — the coordinates of points.


-----Output-----

In the first line print $m$ — the maximum possible number of points in a subset that satisfies the conditions described above.

In the second line print $m$ integers — the coordinates of points in the subset you have chosen.

If there are multiple answers, print any of them.


-----Examples-----
Input
6
3 5 4 7 10 12

Output
3
7 3 5
Input
5
-1 2 5 8 11

Output
1
8



-----Note-----

In the first example the answer is $[7, 3, 5]$. Note, that $|7-3|=4=2^2$, $|7-5|=2=2^1$ and $|3-5|=2=2^1$. You can't find a subset having more points satisfying the required property.
"""
2022-04-18 03:00:10.664421 --------------------------
2022-04-18 03:00:52.022732 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)"
    }
  ],
  "created": 1650250810,
  "id": "cmpl-4yBuUNFLrSLmYLAeU43nAiopAPVyP",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 03:00:52.022991 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-18 03:00:52.023036 REASON stop
2022-04-18 03:00:52.040922 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 03:00:52.041002 REASON stop
2022-04-18 03:00:52.041453 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)"
}
2022-04-18 03:00:52.041548 REASON stop
