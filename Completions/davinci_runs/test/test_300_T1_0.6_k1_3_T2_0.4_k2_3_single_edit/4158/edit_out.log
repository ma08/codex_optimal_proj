2022-04-18 05:27:10.312814 num operations 1
2022-04-18 05:27:10.312852 size on input set 1
2022-04-18 05:27:23.718147 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2.\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = []  # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points,\n            # then we set the current points as the maximum points.\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point in points:\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9)) + 1):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650259630,
  "object": "edit"
}
2022-04-18 05:27:23.718438 fix syntax errors 3 ['\n\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2.\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = []  # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9).\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points,\n            # then we set the current points as the maximum points.\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point in points:\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9)) + 1):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-18 05:27:23.718622 size on output set 3
2022-04-18 05:27:23.718647 num operations 1
2022-04-18 05:27:23.718660 size on input set 1
2022-04-18 05:27:36.707423 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]  # \u8f93\u5165\u6570\u7ec4\n\n    d = {}  # \u5b58\u653e\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())  # \u6570\u7ec4\u4e2d\u5143\u7d20\u6392\u5e8f\n\n    def helper(nums, d, i):  # \u9012\u5f52\n        if i == len(nums):\n            return d\n\n        cur = nums[i]  # \u5f53\u524d\u5143\u7d20\n\n        if cur - 1 in d:  # \u5982\u679c\u5f53\u524d\u5143\u7d20\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u5728\u5b57\u5178\u4e2d\uff0c\u5219\u5f53\u524d\u5143\u7d20\u7684\u51fa\u73b0\u6b21\u6570\u589e\u52a0\u524d\u4e00\u4e2a\u5143\u7d20\u7684\u51fa\u73b0\u6b21\u6570\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n            res = max(res, d[cur])\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n            res = max(res, d[cur])\n\n        return helper(nums, d, i + 1, res)\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(list(d.keys()))\n\n    def helper(nums, d, i=0):\n        if i == len(nums):\n            return d\n\n        if nums[i] - 1 in d:\n            d[nums[i]] += d[nums[i] - 1]\n        if nums[i] + 1 in d:\n            d[nums[i]] += d[nums[i] + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650259643,
  "object": "edit"
}
2022-04-18 05:27:36.707664 fix syntax errors 3 ["\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]  # 输入数组\n\n    d = {}  # 存放数组中每个元素出现的次数\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())  # 数组中元素排序\n\n    def helper(nums, d, i):  # 递归\n        if i == len(nums):\n            return d\n\n        cur = nums[i]  # 当前元素\n\n        if cur - 1 in d:  # 如果当前元素的前一个元素在字典中，则当前元素的出现次数增加前一个元素的出现次数\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n            res = max(res, d[cur])\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n            res = max(res, d[cur])\n\n        return helper(nums, d, i + 1, res)\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(list(d.keys()))\n\n    def helper(nums, d, i=0):\n        if i == len(nums):\n            return d\n\n        if nums[i] - 1 in d:\n            d[nums[i]] += d[nums[i] - 1]\n        if nums[i] + 1 in d:\n            d[nums[i]] += d[nums[i] + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-18 05:27:36.707742 size on output set 3
2022-04-18 05:27:36.707764 num operations 1
2022-04-18 05:27:36.707776 size on input set 1
2022-04-18 05:27:41.054551 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i + 1):\n            if math.log(abs(points[j] - points[i]), 2) % 1 == 0:\n                largest_subset.append(points[j])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 2,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0.0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    }
  ],
  "created": 1650259656,
  "object": "edit"
}
2022-04-18 05:27:41.054872 fix syntax errors 3 ['\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i + 1):\n            if math.log(abs(points[j] - points[i]), 2) % 1 == 0:\n                largest_subset.append(points[j])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = []\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0.0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n']
2022-04-18 05:27:41.054959 size on output set 3
