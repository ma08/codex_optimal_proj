["\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "import os\nimport sys\nimport shutil\n\ndef main():\n    if len(sys.argv) > 1:\n        path = sys.argv[1]\n        if os.path.isdir(path):\n            dir_list = os.listdir(path)\n            for file in dir_list:\n                if os.path.isfile(file):\n                    print(file)\n        else:\n            print(\"Not a directory\")\n    else:\n        print(\"No path specified\")\n\nif __name__ == \"__main__\":\n    main()\n", "function readFile(file) {\n\tvar fs = require('fs');\n\tfs.readFile(file, 'utf8', function(err, data) {\n\t\tif (err) {\n\t\t\treturn console.log(err);\n\t\t}\n\t\tconsole.log(data);\n\t});\n}\n\nfunction writeFile(file, data) {\n\tvar fs = require('fs');\n\tfs.writeFile(file, data, function(err) {\n\t\tif (err) {\n\t\t\treturn console.log(err);\n\t\t}\n\t\tconsole.log(\"The file was saved!\");\n\t});\n}\n\nfunction appendFile(file, data) {\n\tvar fs = require('fs');\n\tfs.appendFile(file, data, function(err) {\n\t\tif (err) {\n\t\t\treturn console.log(err);\n\t\t}\n\t\tconsole.log(\"The file was saved!\");\n\t});\n}\n\nfunction main() {\n\tvar file = process.argv[2];\n\tvar data = process.argv[3];\n\tvar action = process.argv[4];\n\n\tif (action == 'read') {\n\t\treadFile(file);\n\t}\n\telse if (action == 'write') {\n\t\twriteFile(file, data);\n\t}\n\telse if (action == 'append') {\n\t\tappendFile(file, data);\n\t}\n}\n\nmain();\n", "function readFile(file) {\n  var fs = require('fs');\n  var content;\n  fs.readFile(file, 'utf8', function(err, data) {\n    if (err) {\n      return console.log(err);\n    }\n    content = data;\n  });\n  return content;\n}\n\nfunction writeFile(file, data) {\n  var fs = require('fs');\n  fs.writeFile(file, data, function(err) {\n    if (err) {\n      return console.log(err);\n    }\n  });\n}\n\nmodule.exports = {\n  readFile: readFile,\n  writeFile: writeFile\n}\n", "\n\nfrom sys import stdin\n\ndef main():\n    n, d, k = map(int, stdin.readline().strip().split(\" \"))\n    if d == 1:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if k < d - 1:\n        print(\"NO\")\n        return\n    if n == 2:\n        print(\"YES\")\n        print(\"1 2\")\n        return\n    if d == 2:\n        print(\"YES\")\n        for i in range(1, n):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 3:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        for i in range(1, n - 1):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 4:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        for i in range(3, n - 2):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    if d == 5:\n        print(\"YES\")\n        print(\"{} {}\".format(1, n))\n        print(\"{} {}\".format(1, n - 1))\n        print(\"{} {}\".format(2, n - 1))\n        print(\"{} {}\".format(2, n - 2))\n        print(\"{} {}\".format(3, n - 2))\n        for i in range(4, n - 3):\n            print(\"{} {}\".format(i, i + 1))\n        return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print(\"NO\")\n        sys.exit(0)\n\n    print(\"YES\")\n    for i in range(1, n):\n        print(i, graph[i - 1])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\nfrom collections import defaultdict\nfrom heapq import *\n\ndef add_edge(graph, frm, to, cost=1):\n    if frm == to: raise ValueError('invalid edge {}:{} -> {}'.format(cost, frm, to))\n    graph[frm].append((to, cost))\n    graph[to].append((frm, cost))\n\ndef readl():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, end):\n    queue, enqueued = [(0, start, ())], set([start])\n    while queue:\n        (cost, v1, path) = heappop(queue)\n        if v1 not in enqueued:\n            enqueued.add(v1)\n            path = (v1, path)\n            if v1 == end:\n                return (cost, path)\n\n            for v2, c in graph[v1]:\n                if v2 not in enqueued:\n                    heappush(queue, (cost + c, v2, path))\n\n    return float(\"inf\")\n\ndef generate_graph(n, d, k):\n    if d > n:\n        return float(\"inf\")\n\n    if d == 1:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        else:\n            return float(\"inf\")\n\n    if d == 2:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 2:\n            return [1, 2]\n        else:\n            return float(\"inf\")\n\n    if d == 3:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 4:\n            return [1, 2, 3, 3, 4, 5]\n        else:\n            return float(\"inf\")\n\n    if d == 4:\n        if k >= n - 1:\n            return [1 for i in range(n - 1)]\n        elif k >= 3:\n            return [1, 2, 3, 4, 5, 6]\n        else:\n            return float(\"inf\")\n\n    if k >= 4:\n        return [1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11]\n\n    return float(\"inf\")\n\ndef main():\n    n, d, k = readl()\n    graph = generate_graph(n, d, k)\n    if graph == float(\"inf\"):\n        print \"NO\"\n        sys.exit(0)\n\n    print \"YES\"\n    for i in range(1, n):\n        print i, graph[i - 1]\n\nif __name__ == '__main__':\n    main()\n"]