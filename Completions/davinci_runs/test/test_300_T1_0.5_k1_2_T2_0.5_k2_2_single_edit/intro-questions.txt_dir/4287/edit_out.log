2022-04-17 21:44:18.107518 num operations 1
2022-04-17 21:44:18.107535 size on input set 1
2022-04-17 21:44:22.149029 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#-----Description-----\n# Given a non-empty array of integers, every element appears twice except for one. Find that single one.\n# Note:\n# Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n#-----Solution-----\ndef singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    return 2 * sum(set(nums)) - sum(nums)\n\n\nprint(singleNumber([2,2,1]))\nprint(singleNumber([4,1,2,1,2]))\n#-----Test-----\n"
    },
    {
      "index": 1,
      "text": "\ndef solution(A):\n    return 0\n#-----Solution-----\n\n#-----Test-----\n"
    }
  ],
  "created": 1650231858,
  "object": "edit"
}
2022-04-17 21:44:22.149309 fix syntax errors 2 ['#-----Description-----\n# Given a non-empty array of integers, every element appears twice except for one. Find that single one.\n# Note:\n# Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n#-----Solution-----\ndef singleNumber(nums):\n    """\n    :type nums: List[int]\n    :rtype: int\n    """\n    return 2 * sum(set(nums)) - sum(nums)\n\n\nprint(singleNumber([2,2,1]))\nprint(singleNumber([4,1,2,1,2]))\n#-----Test-----\n', '\ndef solution(A):\n    return 0\n#-----Solution-----\n\n#-----Test-----\n']
2022-04-17 21:44:22.149333 size on output set 2
2022-04-17 21:44:22.149343 num operations 1
2022-04-17 21:44:22.149349 size on input set 1
2022-04-17 21:44:27.394125 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    a, n, m = map(int, input().split())\n    rain = []\n    for _ in xrange(n):\n        rain.append(list(map(int, input().split())))\n    umbrellas = []\n    for _ in xrange(m):\n        umbrellas.append(list(map(int, input().split())))\n\n    # dp[i][j]: minimum fatigue at x=i, using umbrellas up to index j\n    dp = [[0] * (m+1) for _ in xrange(a+1)]\n    for i in xrange(1, a+1):\n        for j in xrange(m+1):\n            if any(map(lambda x: x[0] <= i-1 and i <= x[1], rain)): # raining at i-1\n                min_fatigue = float('inf')\n                for k in xrange(1, j+1):\n                    min_fatigue = min(min_fatigue, dp[i-1][k] + umbrellas[k-1][1])\n                dp[i][j] = min_fatigue\n            else:\n                dp[i][j] = dp[i-1][j]\n    print dp[-1][-1]\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n    import sys\n    sys.setrecursionlimit(10**6)\ndef main():\n    a, n, m = map(int, raw_input().split())\n    rain = []\n    for _ in range(n):\n        rain.append(map(int, raw_input().split()))\n    umbrellas = []\n    for _ in range(m):\n        umbrellas.append(map(int, raw_input().split()))\n\n    # dp[i][j]: minimum fatigue at x=i, using umbrellas up to index j\n    dp = [[0] * (m+1) for _ in range(a+1)]\n    for i in range(1, a+1):\n        for j in range(m+1):\n            if any(map(lambda x: x[0] <= i-1 and i <= x[1], rain)): # raining at i-1\n                min_fatigue = float('inf')\n                for k in range(1, j+1):\n                    min_fatigue = min(min_fatigue, dp[i-1][k] + umbrellas[k-1][1])\n                dp[i][j] = min_fatigue\n            else:\n                dp[i][j] = dp[i-1][j]\n    print dp[-1][-1]\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650231862,
  "object": "edit"
}
2022-04-17 21:44:27.394314 fix syntax errors 2 ["\n\ndef main():\n    a, n, m = map(int, input().split())\n    rain = []\n    for _ in xrange(n):\n        rain.append(list(map(int, input().split())))\n    umbrellas = []\n    for _ in xrange(m):\n        umbrellas.append(list(map(int, input().split())))\n\n    # dp[i][j]: minimum fatigue at x=i, using umbrellas up to index j\n    dp = [[0] * (m+1) for _ in xrange(a+1)]\n    for i in xrange(1, a+1):\n        for j in xrange(m+1):\n            if any(map(lambda x: x[0] <= i-1 and i <= x[1], rain)): # raining at i-1\n                min_fatigue = float('inf')\n                for k in xrange(1, j+1):\n                    min_fatigue = min(min_fatigue, dp[i-1][k] + umbrellas[k-1][1])\n                dp[i][j] = min_fatigue\n            else:\n                dp[i][j] = dp[i-1][j]\n    print dp[-1][-1]\n\nif __name__ == '__main__':\n    main()\n", "\n\n    import sys\n    sys.setrecursionlimit(10**6)\ndef main():\n    a, n, m = map(int, raw_input().split())\n    rain = []\n    for _ in range(n):\n        rain.append(map(int, raw_input().split()))\n    umbrellas = []\n    for _ in range(m):\n        umbrellas.append(map(int, raw_input().split()))\n\n    # dp[i][j]: minimum fatigue at x=i, using umbrellas up to index j\n    dp = [[0] * (m+1) for _ in range(a+1)]\n    for i in range(1, a+1):\n        for j in range(m+1):\n            if any(map(lambda x: x[0] <= i-1 and i <= x[1], rain)): # raining at i-1\n                min_fatigue = float('inf')\n                for k in range(1, j+1):\n                    min_fatigue = min(min_fatigue, dp[i-1][k] + umbrellas[k-1][1])\n                dp[i][j] = min_fatigue\n            else:\n                dp[i][j] = dp[i-1][j]\n    print dp[-1][-1]\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-17 21:44:27.394346 size on output set 2
