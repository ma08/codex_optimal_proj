2022-04-17 20:58:52.285771 num operations 1
2022-04-17 20:58:52.285786 size on input set 1
2022-04-17 20:58:55.834594 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\", end = \"\")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\"*len(l), end = \"\")\n    else:\n        print(len(r))\n        print(\"R\"*len(r), end = \"\")\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print(\"R\")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print(\"L\" * len(l))\n    else:\n        print(len(r))\n        print(\"R\" * len(r))\n"
    }
  ],
  "created": 1650229132,
  "object": "edit"
}
2022-04-17 20:58:55.834824 fix syntax errors 2 ['\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R", end = "")\nelse:\n    l = [a[0]]\n    r = [a[n-1]]\n    l_i = 1\n    r_i = n-2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L"*len(l), end = "")\n    else:\n        print(len(r))\n        print("R"*len(r), end = "")\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(1)\n    print("R")\nelse:\n    l = [a[0]]\n    r = [a[n - 1]]\n    l_i = 1\n    r_i = n - 2\n    while l_i < r_i:\n        if a[l_i] > l[-1]:\n            l.append(a[l_i])\n            l_i += 1\n        if a[r_i] > r[-1]:\n            r.append(a[r_i])\n            r_i -= 1\n        if a[l_i] <= l[-1] and a[r_i] <= r[-1]:\n            break\n    if len(l) > len(r):\n        print(len(l))\n        print("L" * len(l))\n    else:\n        print(len(r))\n        print("R" * len(r))\n']
2022-04-17 20:58:55.834857 size on output set 2
2022-04-17 20:58:55.834875 num operations 1
2022-04-17 20:58:55.834881 size on input set 1
2022-04-17 20:59:15.010406 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \tthe stack will be empty and we can add the new element to the stack.\n# If we take the last element from the left,\n# \tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n# If we take the last element from the left,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tprint(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    },
    {
      "index": 1,
      "text": "\n\n# -----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# we can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# the stack will be empty and we can add the new element to the stack.\n# If we take the last element from the left,\n# the stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# we can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# we can check if the element is in the stack.\n# If it is, we can remove it from the stack.\n# Otherwise, we can remove it from the dictionary and add it to the stack.\n# If we take the last element from the left,\n# we can check if the element is in the stack.\n# If it is, we can remove it from the stack.\n# Otherwise, we can remove it from the dictionary and add it to the stack.\n\n# -----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n    if (len(stack) == 0):\n        stack.append(a[i])\n        length += 1\n    elif (a[i] > stack[-1]):\n        stack.append(a[i])\n        length += 1\n    else:\n        while (len(stack) > 0 and a[i] <= stack[-1]):\n            stack.pop()\n        stack.append(a[i])\n        length += 1\n\nprint(length)\n\nfor i in range(length):\n    if (i < length / 2):\n        print(\"L\", end=\"\")\n    else:\n        print(\"R\", end=\"\")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint(\"L\", end=\"\")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint(\"R\", end=\"\")\n\nprint()\n"
    }
  ],
  "created": 1650229135,
  "object": "edit"
}
2022-04-17 20:59:15.010826 fix syntax errors 2 ['\n\n#-----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \tthe stack will be empty and we can add the new element to the stack.\n# If we take the last element from the left,\n# \tthe stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# \twe can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n# If we take the last element from the left,\n# \twe can check if the element is in the stack.\n# \tIf it is, we can remove it from the stack.\n# \tOtherwise, we can remove it from the dictionary and add it to the stack.\n\n#-----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tprint("L", end="")\n\telse:\n\t\tprint("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n', '\n\n# -----Solution-----\n\n# For C1:\n\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# we can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# the stack will be empty and we can add the new element to the stack.\n# If we take the last element from the left,\n# the stack will be empty and we can add the new element to the stack.\n\n# For C2:\n\n# The solution for C1 is not valid for C2 because the elements may not be distinct.\n# We can use a dictionary to store the number of occurences of each element.\n# We can use a stack to store the elements we have taken from the left.\n# The stack will always be sorted in ascending order.\n# If a new element is greater than the top element of the stack,\n# we can add it to the stack and increase the length of the sequence by one.\n# Otherwise, we pop elements from the stack until the top element is smaller than the new element.\n# After that, we add the new element to the stack.\n# This way, we can always maintain a stack with increasing elements.\n# If we take the last element from the right,\n# we can check if the element is in the stack.\n# If it is, we can remove it from the stack.\n# Otherwise, we can remove it from the dictionary and add it to the stack.\n# If we take the last element from the left,\n# we can check if the element is in the stack.\n# If it is, we can remove it from the stack.\n# Otherwise, we can remove it from the dictionary and add it to the stack.\n\n# -----Code-----\n\n# C1:\n\nn = int(input())\na = list(map(int, input().split()))\n\nstack = []\nlength = 0\n\nfor i in range(n):\n    if (len(stack) == 0):\n        stack.append(a[i])\n        length += 1\n    elif (a[i] > stack[-1]):\n        stack.append(a[i])\n        length += 1\n    else:\n        while (len(stack) > 0 and a[i] <= stack[-1]):\n            stack.pop()\n        stack.append(a[i])\n        length += 1\n\nprint(length)\n\nfor i in range(length):\n    if (i < length / 2):\n        print("L", end="")\n    else:\n        print("R", end="")\n\nprint()\n\n# C2:\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = {}\nstack = []\nlength = 0\n\nfor i in range(n):\n\tif (a[i] not in d):\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]] += 1\n\nfor i in range(n):\n\tif (len(stack) == 0):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telif (a[i] > stack[-1]):\n\t\tstack.append(a[i])\n\t\tlength += 1\n\telse:\n\t\twhile (len(stack) > 0 and a[i] <= stack[-1]):\n\t\t\tstack.pop()\n\t\tstack.append(a[i])\n\t\tlength += 1\n\nprint(length)\n\nfor i in range(length):\n\tif (i < length / 2):\n\t\tif (a[i] in stack):\n\t\t\tstack.remove(a[i])\n\t\telse:\n\t\t\td[a[i]] -= 1\n\t\t\tstack.append(a[i])\n\t\tprint("L", end="")\n\telse:\n\t\tif (a[n - i - 1] in stack):\n\t\t\tstack.remove(a[n - i - 1])\n\t\telse:\n\t\t\td[a[n - i - 1]] -= 1\n\t\t\tstack.append(a[n - i - 1])\n\t\tprint("R", end="")\n\nprint()\n']
2022-04-17 20:59:15.010890 size on output set 2
