2022-04-17 21:21:55.158427 num operations 1
2022-04-17 21:21:55.158442 size on input set 1
2022-04-17 21:22:03.750034 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for k in range(2, int(math.sqrt(n)) + 1):\n        if n % k == 0:\n            return False\n    return True\n"
    },
    {
      "index": 1,
      "text": "\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650230515,
  "object": "edit"
}
2022-04-17 21:22:03.750413 fix syntax errors 2 ['\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for k in range(2, int(math.sqrt(n)) + 1):\n        if n % k == 0:\n            return False\n    return True\n', "\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-17 21:22:03.750470 size on output set 2
2022-04-17 21:22:03.750490 num operations 1
2022-04-17 21:22:03.750502 size on input set 1
2022-04-17 21:22:05.217576 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650230523,
  "object": "edit"
}
2022-04-17 21:22:05.217739 fix syntax errors 2 ['\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-17 21:22:05.217774 size on output set 1
