["n, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\na.sort(reverse=True)\n\ndef check(d):\n    s=0\n    for i in range(len(a)):\n        s+=max(0,a[i]-i//d)\n    return s>=m\nif sum(a)<m:\n    print(-1)\nelse:\n    l, r = 1,n\n    mid = l+r>>1\n    while l<r:\n        if check(mid):\n            r=mid\n        else:\n            l=mid+1\n        mid=l+r>>1\n    print(l)\n", "[n, m] = list(map(int, input().split()))\narr = list(map(int, input().split()))\narr.sort(reverse=True)\ndef check (i):\n    mins = 0\n    cnt = 0\n    sums = 0\n    for x in arr:\n        sums += max(x-mins,0)\n        if sums >= m:\n            return True\n        cnt += 1\n        if cnt >= i:\n            cnt = 0\n            mins += 1\n    return False\n\nl = 1\nr = n+1\nwhile l!= r:\n    if check((l+r)//2) :\n        r = (l+r)//2\n    else:\n        l = (l+r)//2+1\n\nprint(l if l > 0 and l <= n else -1)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0:\n            x+=b\n        b=b//2\n    return x\n\n\ndef main():\n    n, m = get_tuple()\n    li = get_list()\n    li.sort(reverse=True)\n    prefix_sum = []\n    sm=0\n    for i in li:\n        prefix_sum.append(sm+i)\n        sm+=i\n    for i in range(1,n+1):\n        #curr = prefix_sum[i-1] #Replce with prefix sum\n        c = -1\n        index = binary_serach(i,li)\n        n = index//i # Kitna lagega\n        curr = prefix_sum[index] - (i*n*(n-1)//2 + (index-n*i+1)*n)\n        #print(\"III\",i,\"CURR\",curr,index,n)\n        if curr>=m:\n            print(i)\n            return\n    print(-1)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n,m = list(map(int,input().split()))\na = list(map(int,input().split()))\nans=1\nsu = sum(a)\na.sort(reverse=True)\ns = [0]*n\ns[0] = a[0]\nfor i in range(1,n):\n    s[i] = s[i-1]+a[i]\n\ndef pos(d):\n    i=d\n    while i<=n:\n        k = i//d\n        neg = k*i-((k*(k+1))//2)*d\n        if(s[i-1]-neg >= m):\n            return True\n        i+=1\n    return False\n\n\n\nif(su < m):\n    ans = -1\n    print(ans)\n\nelse:\n    first = 0\n    last = n\n\n    while first<last-1:\n        midpoint = (first + last)//2\n        if pos(midpoint):\n            last = midpoint\n        else:\n            first = midpoint\n\n    print(last)\n", "n, m = list(map(int, input().split()))\na = list(sorted(map(int, input().split()), reverse=True))\n\n\ndef proc(n, m, a):\n    possible_minimum = -1\n    l, r = 1, n\n    sub_c = [0] * n\n    while l <= r:\n        i = (l + r) // 2\n        # if i == 100:\n\n        current_m = m\n        for j in range(i):\n            sub_c[j] = 0\n\n        for j in range(0, n):\n            # a[j:j + i]\n            pos = j % i\n            if a[j] < sub_c[pos]:\n                break\n            current_m -= a[j] - sub_c[pos]\n            sub_c[pos] += 1\n            if current_m <= 0:\n                break\n        if current_m <= 0:\n            # print('[{}, {}] => {} SUCCESS'.format(l, r, i))\n            possible_minimum = i\n            r = i - 1\n        else:\n            # print('[{}, {}] => {} FAIL'.format(l, r, i))\n            l = i + 1\n    return possible_minimum\n\n\nprint(proc(n, m, a))\n", "def check(arr,d,mm):\n\tss=0\n\tk=-1\n\tfor i in range(n):\n\t\tif (i)%d==0:\n\t\t\t# print(\"i is \",i)\n\t\t\tk+=1\n\t\t# print(\"k is \",k)\n\t\tss+=max(0,arr[i]-k)\n\tif ss>=mm:\n\t\treturn True\n\telse:\n\t\treturn False\nn,m=map(int,input().split())\narr=list(map(int,input().split()))\narr.sort(reverse=True)\ns=1 \ne=n \nans=1000000000000000000000\nwhile s<=e:\n\tmid=(s+e)//2\n\tif check(arr,mid,m):\n\t\tans=min(ans,mid)\n\t\te=mid-1\n\telse:\n\t\ts=mid+1\nif ans==1000000000000000000000:\n\tans=-1\nprint(ans)", "import io, sys, atexit, os\n\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li ():\n\treturn list (map (int, input ().split ()))\n\n\ndef num ():\n\treturn map (int, input ().split ())\n\n\ndef nu ():\n\treturn int (input ())\n\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\n\ndef solve ():\n\tt = 1\n\tfor it in range (t):\n\t\tn,m = num ()\n\t\ta = li ()\n\t\ta.sort(reverse = True)\n\t\tlo=1\n\t\thi=n\n\t\tans=-1\n\t\twhile(lo<=hi):\n\t\t\tmid=(lo+hi)//2\n\t\t\tpp=0\n\t\t\tss=0\n\t\t\tfor i in range(n):\n\t\t\t\tif (i % mid == 0 and i != 0):\n\t\t\t\t\tpp += 1\n\t\t\t\tss+=max(a[i]-pp,0)\n\t\t\tif(ss>=m):\n\t\t\t\thi=mid-1\n\t\t\telse:\n\t\t\t\tlo=mid+1\n\t\tif(lo==n+1):\n\t\t\tprint(-1)\n\t\telse:\n\t\t\tprint(lo)\n\n\ndef __starting_point():\n\tsolve ()\n__starting_point()", "n, m = list(map(int, input().strip().split()))\ncups = list(map(int, input().strip().split()))\n\n\nfull_coffe = sum(cups)\n\nif full_coffe < m:\n    print(\"-1\")\n    return\nelif full_coffe == m:\n    print(len(cups))\n    return\n\ncups.sort(reverse=True)\n\ndef check_day(day):\n    if day == 0:\n        return False\n    done = 0\n    for idx, c in enumerate(cups):\n        done += max(0, c - idx//day)\n    return done >= m\n\nlower = 0\nupper = n\nwhile upper - lower > 1:\n    middle = lower + (upper - lower)//2\n    if check_day(middle):\n        upper = middle\n    else:\n        lower = middle\n\nprint(upper)\n", "\nn,m = list(map(int,input().strip().split()))\n\narr = list(map(int,input().strip().split()))\n\narr = sorted(arr,reverse=True)\n\nlow = 1\nhigh = n\n#print(arr)\ndef check(k,m):\n    #print(m)\n    #print(m)\n    if m>0:\n        l = 0\n        z = 0\n        for i in range(n):\n            m-=max(0,arr[i]-(l))\n            z+=1\n            if z==k:\n                z = 0\n                l+=1\n            \n    #print(m)\n    if m<=0:\n        return 1\n    else:\n        return 0\nans = []\nwhile high >= low:\n    \n    mid = low+(high-low)//2\n    #print(low,high,mid)\n    if check(mid,m):\n        ans.append(mid)\n        high = mid-1\n    else:\n        low = mid+1\n#print(ans)\nif len(ans)>0:\n    print(min(ans))\nelse:\n    print(-1)\n", "import sys\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nif sum(A)<m:\n    print(-1)\n    return\n\nA.sort(reverse=True)\n\nMIN=1\nMAX=n\n\nwhile MIN!=MAX:\n    d=(MIN+MAX)//2\n\n\n    ANS=0\n    j=0\n    count=0\n    for a in A:\n        if a<=j:\n            continue\n        \n        ANS+=(a-j)\n        count+=1\n\n        if count==d:\n            j+=1\n            count=0\n\n    #print(d,ANS)\n\n    if ANS>=m:\n        MAX=d\n    else:\n        MIN=d+1\nprint(MIN)\n            \n", "nb_cups, nb_task = [int(x) for x in input().split()]\ncaffines = sorted([int(x) for x in input().split()], reverse=True)\n\n\ndef check(d):\n    done = 0\n    for i, v in enumerate(caffines):\n        done += max(0, v - i // d)\n    return done >= nb_task\n\nif sum(caffines) < nb_task:\n    print(-1)\nelse:\n    left, rite = 1, nb_cups\n    mid = left + rite >> 1\n    while left < rite:\n        if check(mid):\n            rite = mid\n        else:\n            left = mid + 1\n        mid = left + rite >> 1\n    print(left)     \n", "n,m = [int(x) for x in input().split()]\n\nl = [int(x) for x in input().split()]\nsumm = sum(l)\nresult = 0\n\ndef find(x) :\n    # x\u00e9t n\u1ebfu u\u1ed1ng trong x ng\u00e0y k\u1ecbp l\u00e0m\n    # th\u1ee9 t\u1ef1 u\u1ed1ng trong m\u1ed7i ng\u00e0y \u01b0u ti\u00ean c\u1ed1c l\u1edbn tr\u01b0\u1edbc . ex : v\u1edbi x = 2 : a1x1 > a1x2 > a2x1 >a2x2 >...\n    s = 0\n    pos_count = 0\n    day_count = 0\n\n    for i in l :\n        s += max(0,i-pos_count)\n        day_count+=1\n        if day_count == x :\n            day_count = 0\n            pos_count+=1\n\n    if s < m :\n        return 0\n    else :\n        return x\n\ndef binary_search(lf,r) :\n    nonlocal result\n    mid = int((lf+r)/2)\n\n    rs = find(mid)\n\n    if lf==r :\n        result = rs\n    elif lf == r-1 :\n        if rs :\n            result = rs\n        else :\n            binary_search(r,r)\n    else :\n        if rs :\n            binary_search(lf,mid)\n        else :\n            binary_search(mid,r)\n\n\nif summ<m:\n    print('-1')\nelif summ == m :\n    print(n)\n# elif summ - sum(range(n)) == m:\n#     print('1')\nelse :\n    l= sorted(l,reverse=True)\n    binary_search(1,n)\n    print(result)\n", "def check_possibility(days, m, coffee):\n    sum_coffee = 0\n    for i, cup in enumerate(coffee):\n        tax = i // days\n        if sum_coffee >= m or tax >= cup:\n            break\n        sum_coffee += cup - tax\n    return sum_coffee >= m\n\n\nn, m = list(map(int, input().split()))\ncoffee = sorted(map(int, input().split()), reverse=True)\n\nbad = 0\ngood = len(coffee)\n\nwhile good - bad > 1:\n    days = (bad + good) // 2\n    if check_possibility(days, m, coffee):\n        good = days\n    else:\n        bad = days\n\npossible = check_possibility(good, m, coffee)\nprint(good if possible else -1)\n", "import sys\nn , m = list(map(int,input().split()))\nl = list(map(int,input().split()))\nl.sort(reverse = True)\n\nleft = 1\nright = n+1\n\nans = 10**18 + 1\nwhile left != right:\n    mid = (left+right)//2\n    #print(mid,left,right)\n    din = 0\n    kaam = 0\n    c = 0\n    for i in l:\n        if i - din <=0:\n            break\n        kaam += i - din\n        c += 1\n        if c == mid:\n            c = 0\n            din += 1\n    if kaam >= m:\n        ans = min(ans,mid)\n        right = mid\n    else:\n        left = mid+1\n\nif ans == 10**18+1:\n    print(-1)\nelse:\n    print(ans)\n'''\nimport sys\nn = int(input())\nl = list(map(int,input().split()))\n\nfreq = [0]*1001\n\nfor i in range(n*n):\n    freq[l[i]] += 1\n\nodd = oc = 0\ntwo = []\nprint(freq[:11])\nif n > 2:\n    mn = 4\n    \n    for i in range(1001):\n        if freq[i] != 0:\n            \n            if freq[i]%2 == 1:\n                odd = i\n                oc += 1\n                freq[i] -= 1\n            if freq[i]%2 == 0 and freq[i]%4 != 0:\n                two.append(i)\n                freq[i] -= freq[i]%4\n                continue\n                \n            if freq[i]%4 != 0:\n                print('NO')\n                return\n                \nans = [ [0]*n for i in range(n) ]\n\nif not n%2 and odd != 0:\n    print('NO')\n    return\n\n\nif oc > 1:\n    print('NO')\n    return\n    \nif n%2:\n    ans[n//2][n//2] = odd\n\nr = c = 0\n\nprint(two)\nprint(freq[:11])\nmid = 0\nfor i in range(n):\n    for j in range(n):\n        if ans[i][j] == 0:\n            for k in range(1,1001):\n                if freq[k] != 0:\n                    temp = k\n                    r = i\n                    c = j\n\n                    ans[r][c] = ans[n-1-r][c] = ans[r][n-1-c] = ans[n-1-r][n-1-c] = temp\n                    flag = False\n                    if n%2 and ( n//2 == i or n//2 == j):\n                        #print('are ye to odd hai')\n                        if len(two) != 0:\n                            ans[n//2][mid] = ans[n//2][n-mid-1] = two[-1]\n                            flag = True\n                            two.pop()\n                        else:\n                            ans[n//2][mid] = ans[n//2][n-mid-1] = temp\n                        mid+=1\n                    #print(freq[:7])\n                    if not flag:\n                        freq[k] =freq[k] - 4\n                    else:\n                        freq[k] = freq[k] - 2\n                    #print(freq[:7])\n                    break\nprint(\"YES\")\nfor i in range(n):\n    print(*ans[i])\n'''\n", "n, m = list(map(int, input().split()))\n\nl = list(map(int,input().split()))\n\nl.sort(reverse = True)\n\nleft = 1\nright = n\n\ndef check(k,m):\n  if m > 0:\n    lef = 0\n    z = 0\n    for i in range(n):\n      m -= max(0, l[i]-lef)\n      z += 1\n      if z == k:\n        z = 0\n        lef += 1\n  if m <= 0:\n    return 1\n  else:\n    return 0\n\nres = []\n\nwhile left <= right:\n  mid = int((left+right)/2)\n  if check(mid, m):\n    res.append(mid)\n    right = mid - 1\n  else:\n    left = mid + 1\nif len(res) > 0:\n  print(min(res))\nelse:\n  print(\"-1\")\n\n\"\"\"\nn, m = map(int, input().split())\n\nl = list(map(int,input().split()))\n\ns = sum(l)\nans = 0\n\ndef find(x):\n  su = 0\n  days = 0\n  z = 0\n\n  for i in l:\n    su += max(0, i-z)\n    days += 1\n    if days == x:\n      days = 0\n      z += 1\n  if su < m:\n    return 0\n  return x\n\ndef binary(left, right):\n  nonlocal ans\n  mid = int((left+right)/2)\n  r = find(mid)\n  if right == left:\n    ans = r\n  elif left == right - 1:\n    if r:\n      ans = r\n    else:\n      binary(r, r)\n  else:\n    if r:\n      binary(left, mid)\n    else:\n      binary(mid, right)\n\nif s < m:\n  print(\"-1\")\nelif s == m:\n  print(n)\nelse:\n  l.sort(reverse = True)\n  binary(1,n)\n  print(ans)\nprint(ans)\n\"\"\"\n", "from math import ceil\ndef check(p):\n    sm = 0\n    k = 0\n    d = 0\n    for i in range(ceil(len(a)/p)):\n        for j in range(p):\n            if k < len(a):\n                sm += max(0, a[k]-d)\n                k+=1\n        d += 1\n    return sm >= m\n\nn,m=list(map(int,input().split()))\na=[int(x) for x in input().split()]\na.sort(reverse=True)\n\nl=1\nr=len(a)\nif sum(a) < m:\n    print(-1)\nelse:\n    while(l < r):\n        mid = (l + r) // 2\n\n        if check(mid):\n            r = mid\n        else:\n            l = mid+1\n    print(l)\n", "n, m = list(map(int, input().split()))\nl = list(map(int, input().split()))\nl.sort(reverse=True)\nans = []\ndef bin(s):\n    tmp = [[] for k in range(s)]\n    cur = s\n    tr = 0\n    for i in range(n):\n        if (cur == s):\n            cur = 0\n        tmp[cur].append(l[i])\n        cur += 1\n    for i in range(s):\n        for k in range(len(tmp[i])):\n            tr += max(tmp[i][k] - k, 0)\n    if tr >= m:\n        return 1\n    else:\n        return 0\nuk2 = n\nuk1 = 1\nwhile (uk2 - uk1 > 1):\n    if bin((uk2 + uk1) // 2):\n        uk2 = (uk2 + uk1) // 2\n    else:\n        uk1 = (uk2 + uk1) // 2\nif bin(uk1):\n    print(uk1)\nelif bin(uk2):\n    print(uk2)\nelse:\n    print(-1)", "import math\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split())) + [-1]\na.sort(reverse=True)\ns = sum(a)\n\nif m > s + 1:\n    print(-1)\n    return\n\nleft, r = 0, n\nwhile r - left > 1:\n    mid = (left + r) // 2\n\n    minus = 0\n    i = 0\n    ans = 0\n    while a[i] > minus:\n        cur = i\n        while cur - i < mid:\n            if a[cur] <= minus:\n                minus = 999999999\n                break\n            ans += a[cur] - minus\n            cur += 1\n        i = cur\n        minus += 1\n    if ans >= m:\n        r = mid\n    else:\n        left = mid\nprint(r)\n", "def check(sz):\n        aa=0\n        for i in range(n):\n                aa+=max(0,a[i]-i//sz)\n                if aa>=M:\n                        return True\n        return False \nn,M=map(int,input().split())\na=list(map(int,input().split()))\nif sum(a)<M:print(-1);return\na.sort(reverse=True)\nl=1;r=n\nwhile l<r:\n        m=l+r\n        m>>=1\n        if check(m):\n                r=m\n        else:\n                l=m+1\nprint(l)", "import math\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split())) + [-1]\na.sort(reverse=True)\ns = sum(a)\n\nif m > s + 1:\n    print(-1)\n    return\n\nleft, r = 0, n\nwhile r - left > 1:\n    mid = (left + r) // 2\n\n    minus = 0\n    i = 0\n    ans = 0\n    while a[i] > minus:\n        cur = i\n        while cur - i < mid:\n            if a[cur] <= minus:\n                minus = 999999999\n                break\n            ans += a[cur] - minus\n            cur += 1\n        i = cur\n        minus += 1\n    if ans >= m:\n        r = mid\n    else:\n        left = mid\nprint(r)\n", "def check(d, a):\n    ans = 0\n    for q in range(len(a)):\n        ans += max(a[q]-q//d, 0)\n    return ans\n\n\nn, m = list(map(int, input().split()))\na = sorted(list(map(int, input().split())), reverse=True)\nif sum(a) < m:\n    print(-1)\nelse:\n    l, r = 0, n\n    while r-l > 1:\n        m1 = (l+r)//2\n        if check(m1, a) >= m:\n            r = m1\n        else:\n            l = m1\n    print(r)\n", "n, m = (int(t) for t in input().split(' '))\na = [int(t) for t in input().split(' ')]\n\na.sort(reverse=True)\n\ndef possible(d):\n    total = 0\n    for i in range(d):\n        step = 0\n        for j in range(i, n, d):\n            total += max(a[j] - step, 0)\n            step += 1\n\n    return total >= m\n\nl, r = 0, n+1\n\nwhile l < r:\n    mid = (l + r) // 2\n    if possible(mid):\n        r = mid\n    else:\n        l = mid + 1\n\nif possible(l):\n    print(l)\nelse:\n    print(-1)\n", "_ = input()\nn, m = _.split()\nn, m = int(n), int(m)\n_ = input()\n_a = _.split()\nb = []\nnum_list = []\n_counter = {}\n_sum = 0\nfor i in _a:\n    value = int(i)\n    _sum = _sum + value\n    b.append(value)\n    if value in _counter:\n        _counter[value] = _counter[value] + 1\n    else:\n        _counter[value] = 1\n        num_list.append(value)\nif m > _sum:\n    print(\"-1\")\nelse:\n    num_list.sort()\n    num_list.reverse()\n    counter = []\n    sum_list = []\n    whole_sum_list = []\n    _ = 0\n    __ = 0\n    for num in num_list:\n        num_count = _counter[num]\n        counter.append(num_count)\n        _ = _ + num_count\n        __ = __ + num_count *num\n        sum_list.append(_)\n        whole_sum_list.append(__)\n    def avail(k):\n        parse = len(num_list) - 1\n        for i in range(len(num_list)):\n            if sum_list[i]//k >= num_list[i]:\n                parse = i\n                break\n        parse = parse - 1 if parse > 0 else 0\n        floor = sum_list[parse]//k - 1\n        token = sum_list[parse]%k\n        # print(k, sum_list[parse], floor, token)\n        whole_sum = whole_sum_list[parse] - k * int(floor*(floor+1)//2) - token * (floor+1)\n        if whole_sum >= m:\n            return True\n        if len(num_list) == 1:\n            return False\n        floor = floor + 1\n        _value = num_list[parse+1]\n        for i in range(counter[parse+1]):\n            if _value <= floor:\n                break\n            if whole_sum >= m:\n                return True\n            whole_sum = whole_sum + _value - floor\n            # print(k, i, whole_sum)\n            token = token + 1\n            if token >= k:\n                floor, token = floor + 1, 0\n        if whole_sum >= m:\n            return True\n        return False\n\n    def _avail(k):\n        token = 0\n        floor = 0\n        cafe = 0\n        available = False\n        for value, count in zip(num_list, counter):\n            if cafe - floor * token >= m:\n                available = True\n            if floor >= value:\n                break\n            cafe = cafe + value * count\n            token = token + count\n            for i in range(0, token//k):\n                cafe = cafe - (floor + i) * k\n            floor = floor + token // k\n            token = token % k\n        if cafe - floor * token>= m:\n            available = True\n        return available\n\n    start = 1\n    end = n\n    while start != end:\n        k = (start + end) // 2\n        # print(start,end,avail(k))\n        if avail(k):\n            start, end = start, k\n        else:\n            start, end = k+1, end\n    if n == 1:\n        print(1)\n    else:\n        print(start)", "def calc(ans,k,n):\n    for i in range(1,len(ans)):\n        if ans[i]>=n + k*(((i-k)//k)*((i-k)//k  + 1))//2 + ((i-k)%k)*((i-k)//k  + 1):\n            #print(\"panne \",i,k,ans[i],(((i-k)//k)*((i-k)//k  + 1))//2 + ((i-k)%k)*((i-k)//k  + 1))\n            return True\n            \n    return False\n\ndef bins(ans,n,low,high):\n    if low==high and calc(ans,low,n):\n        #print(low,high)\n        return low\n    elif low==high :\n        return -1\n    if calc(ans,(low+high)//2,n):\n        return bins(ans,n,low,(low+high)//2)\n    else:\n        return bins(ans,n,(low+high)//2 + 1,high)\n\nn,k=list(map(int,input().split()))\na=list(map(int,input().split()))\na.sort(reverse=True)\nans=[0]*(n+1)\nfor i in range(1,n+1):\n    ans[i]=ans[i-1]+a[i-1]\n#print(ans)\nprint(bins(ans,k,1,n))\n#print(calc(ans,7,550))\n#print(ans[47])\n"]