["\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(list(range(arr)), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = [0] + (nia())\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in list(cf.items()):\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n", "\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(list(range(arr)), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = [0]\nh.extend(nia())\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in list(cf.items()):\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n", "\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(list(range(arr)), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in list(cf.items()):\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n", "\nfrom collections import Counter\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef sortId(arr):\n    return sorted(list(range(arr)), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = Counter(c)\ncf = Counter(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in list(cf.items()):\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)\n", "\nfrom collections import Counter\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef sortId(arr):\n    return sorted(list(range(arr)), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = Counter(c)\ncf = Counter(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n    # log(dp[ni])\n\n# log(n,k)\n# log(\"c\", cc)\n# log(\"f\", cf)\n# log(\"h\", h)\n# log(dp)\n\nres = 0\n\n\nfor fk,fv in list(cf.items()):\n    # log(fk, fv, cc.get(fk,0))\n    res += dp[fv][cc[fk]]\n\nprint(res)\n", "\nfrom collections import Counter\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\nsys.setrecursionlimit(10**9)\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\ndef ni():\n    return map(int, input().split())\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\ndef nia():\n    return list(map(int, input().split()))\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\ncc = Counter(c)\ncf = Counter(f)\nn1 = n+1\nk1 = k+1\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            # log(ni,ki, kii, dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\nres = 0\nfor fk,fv in cf.items():\n    res += dp[fv][cc[fk]]\nprint(res)", "\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\nsys.setrecursionlimit(10**9)\n\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef mapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\ndef countMap(arr):\n    m = {}\n    for x in arr:\n        m[x] = m.get(x,0) + 1\n    return m\n\ndef sortId(arr):\n    return sorted(range(arr), key=lambda k: arr[k])\n\n# MAIN\n\nn, k = ni()\nc = nia()\nf = nia()\nh = nia()\nh.insert(0,0)\n\ncc = countMap(c)\ncf = countMap(f)\n\nn1 = n+1\nk1 = k+1\n\nnk1 = n*k+1\ndp = [[0]*nk1 for _ in range(n1)]\n\n\nfor ni in range(1,n1):\n    for ki in range(1,nk1):\n        mficount = min(k,ki) + 1        \n        for kii in range(mficount):\n            dp[ni][ki] = max(dp[ni][ki], dp[ni-1][ki-kii] + h[kii])\n\n\nres = 0\n\n\nfor fk,fv in cf.items():\n    res += dp[fv][cc.get(fk,0)]\n\nprint(res)", "import math\nfrom collections import defaultdict\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    cards = list(map(int, input().split()))\n    fav = list(map(int, input().split()))\n\n    h = [0] + list(map(int, input().split()))\n\n    cards_cnt = defaultdict(int)\n    for val in cards:\n        cards_cnt[val] += 1\n\n    players_fav_cnt = defaultdict(int)\n    for val in fav:\n        players_fav_cnt[val] += 1\n\n    # dp[a][b] - a players, b favourite cards (in total)\n    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]\n    for p in range(n):\n        for c in range(k*n+1):\n            for hand in range(k+1):\n                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])\n\n    res = 0\n    for f in players_fav_cnt:\n        res += dp[players_fav_cnt[f]][cards_cnt[f]]\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def solve():\n    n, k = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    cnt = {}\n    for i in c:\n        cnt[i] = cnt.get(i, 0) + 1\n    likecolor = {}\n    for i in range(n):\n        likecolor.setdefault(f[i], []).append(i)\n        cnt[f[i]] = cnt.get(f[i], 0)\n    ans = 0\n    for key, v in list(likecolor.items()):\n        n1 = len(v)\n        if cnt[key] >= n1 * k:\n            ans += n1 * h[k - 1]\n            continue\n        dp = [[-float(\"INF\")] * (cnt[key]+1) for _ in range(n1 + 1)]\n        dp[0][0] = 0\n        for i in range(n1):\n            j = i + 1\n            for e in range(cnt[key] + 1):\n                dp[j][e] = max(dp[j][e], dp[i][e])\n                for w in range(e + 1, min(cnt[key] + 1, e + k + 1)):\n                    dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w])\n        ans += dp[n1][cnt[key]]\n    print(ans)\n\n\nsolve()\n"]