2022-04-16 07:20:52.792587 num operations 1
2022-04-16 07:20:52.792602 size on input set 1
2022-04-16 07:21:00.388283 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_input():\n    t = int(raw_input())\n    for i in range(t):\n        n = int(raw_input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_input():\n    t = int(raw_input())\n    for i in range(t):\n        n = int(raw_input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 2,
      "text": "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * (n - 1)\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 3,
      "text": "\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 4,
      "text": "\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        print(solve(n))\n"
    },
    {
      "index": 5,
      "text": "\n\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        yield int(input())\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 6,
      "text": "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * (n - 1)\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 7,
      "text": "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * n\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    },
    {
      "index": 8,
      "text": "\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"
    }
  ],
  "created": 1650093652,
  "object": "edit"
}
2022-04-16 07:21:00.388580 fix syntax errors 9 ["\n\ndef get_input():\n    t = int(raw_input())\n    for i in range(t):\n        n = int(raw_input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\ndef get_input():\n    t = int(raw_input())\n    for i in range(t):\n        n = int(raw_input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * (n - 1)\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        print(solve(n))\n", "\n\ndef get_input():\n    t = int(input())\n    for _ in range(t):\n        yield int(input())\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * (n - 1)\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\n\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1) * n\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n", "\ndef get_input():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        yield n\n\ndef solve(n):\n    if n == 1:\n        return 0\n    return (n - 1)**2\n\nif __name__ == '__main__':\n    for n in get_input():\n        print(solve(n))\n"]
2022-04-16 07:21:00.388624 size on output set 7
2022-04-16 07:21:00.388634 num operations 1
2022-04-16 07:21:00.388639 size on input set 1
2022-04-16 07:21:11.044245 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 2,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the adjacent cells.\n# If the center is not empty, we can move the figures in the center to the adjacent cells\n# and then move the figures in the adjacent cells to the center.\n# We can repeat the process until all the figures are in the adjacent cells.\n# Because we move the figures to the adjacent cells, the number of moves is minimized.\n# The time complexity is O(n), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 3,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm. The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center. Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 4,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells\n# If the center is not empty, we can move the figures in the center to the closest cells and then move the figures in the closest cells to the center\n# We can repeat the process until all the figures are in the center\n# Because we move the figures to the closest cells, the number of moves is minimized\n# The time complexity is O(n^2), which is the size of the board\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 5,
      "text": "\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 6,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input()) \n    print(n * (n // 2) ** 2) \n"
    },
    {
      "index": 7,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm. The idea is to start\n# from the center and move the figures to the closest cells. If the center\n# is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center. We can repeat\n# the process until all the figures are in the center. Because we move the\n# figures to the closest cells, the number of moves is minimized. The time\n# complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    },
    {
      "index": 8,
      "text": "\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figure to the closest cells.\n# If the center is not empty, we can move the figure in the center to the closest cells\n# and then move the figure in the closest cells to the center.\n# We can repeat the process until all the figures are in the center. Because we move the\n# figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n"
    }
  ],
  "created": 1650093660,
  "object": "edit"
}
2022-04-16 07:21:11.044593 fix syntax errors 9 ['\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the adjacent cells.\n# If the center is not empty, we can move the figures in the center to the adjacent cells\n# and then move the figures in the adjacent cells to the center.\n# We can repeat the process until all the figures are in the adjacent cells.\n# Because we move the figures to the adjacent cells, the number of moves is minimized.\n# The time complexity is O(n), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm. The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center. Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells\n# If the center is not empty, we can move the figures in the center to the closest cells and then move the figures in the closest cells to the center\n# We can repeat the process until all the figures are in the center\n# Because we move the figures to the closest cells, the number of moves is minimized\n# The time complexity is O(n^2), which is the size of the board\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figures to the closest cells.\n# If the center is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center.\n# We can repeat the process until all the figures are in the center.\n# Because we move the figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input()) \n    print(n * (n // 2) ** 2) \n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm. The idea is to start\n# from the center and move the figures to the closest cells. If the center\n# is not empty, we can move the figures in the center to the closest cells\n# and then move the figures in the closest cells to the center. We can repeat\n# the process until all the figures are in the center. Because we move the\n# figures to the closest cells, the number of moves is minimized. The time\n# complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n', '\n\n# SOLUTION\n# The problem can be solved with a greedy algorithm.\n# The idea is to start from the center and move the figure to the closest cells.\n# If the center is not empty, we can move the figure in the center to the closest cells\n# and then move the figure in the closest cells to the center.\n# We can repeat the process until all the figures are in the center. Because we move the\n# figures to the closest cells, the number of moves is minimized.\n# The time complexity is O(n^2), which is the size of the board.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    print(n * (n // 2) ** 2)\n']
2022-04-16 07:21:11.044662 size on output set 9
