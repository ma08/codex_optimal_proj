2022-04-16 07:57:22.010702 num operations 1
2022-04-16 07:57:22.010723 size on input set 1
2022-04-16 07:57:43.409802 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n + 1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_input():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        adj[u].append(v)\n    return n, adj\n\n\ndef toposort(n, adj):\n    in_degree = [0] * (n+1)\n    for u in range(1, n+1):\n        for v in adj[u]:\n            in_degree[v] += 1\n    queue = []\n    for u in range(1, n+1):\n        if in_degree[u] == 0:\n            queue.append(u)\n    res = []\n    while queue:\n        u = queue.pop()\n        res.append(u)\n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    return res\n\n\n# DFS\ndef dfs(adj, u):\n    visited = [False] * (len(adj))\n    stack = [u]\n    while stack:\n        u = stack.pop()\n        if not visited[u]:\n            visited[u] = True\n            for v in adj[u]:\n                stack.append(v)\n    return visited\n\n\ndef main():\n    n, adj = read_input()\n    res = toposort(n, adj)\n    if len(res) != n:\n        print(\"Sandro fails.\")\n    else:\n        for u in res:\n            print(u, end=' ')\n        print()\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0] + [int(x) for x in sys.stdin.readline().split()]\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n + 1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n    \n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\n# Read the input\ndef read_input():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().split()]\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    return n, adj\n\n\ndef main():\n    n, adj = read_input()\n    for i in range(n):\n        print(len(adj[i]))\n\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0] + [int(x) for x in sys.stdin.readline().split()]\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    visited.add(u)\n    if len(visited) == k:\n        return u\n    for v in tree[u]:\n        if v not in visited:\n            res = dfs(tree, v, k, visited)\n            if res:\n                return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650095842,
  "object": "edit"
}
2022-04-16 07:57:43.410201 fix syntax errors 9 ['\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n + 1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef read_input():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        adj[u].append(v)\n    return n, adj\n\n\ndef toposort(n, adj):\n    in_degree = [0] * (n+1)\n    for u in range(1, n+1):\n        for v in adj[u]:\n            in_degree[v] += 1\n    queue = []\n    for u in range(1, n+1):\n        if in_degree[u] == 0:\n            queue.append(u)\n    res = []\n    while queue:\n        u = queue.pop()\n        res.append(u)\n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    return res\n\n\n# DFS\ndef dfs(adj, u):\n    visited = [False] * (len(adj))\n    stack = [u]\n    while stack:\n        u = stack.pop()\n        if not visited[u]:\n            visited[u] = True\n            for v in adj[u]:\n                stack.append(v)\n    return visited\n\n\ndef main():\n    n, adj = read_input()\n    res = toposort(n, adj)\n    if len(res) != n:\n        print("Sandro fails.")\n    else:\n        for u in res:\n            print(u, end=\' \')\n        print()\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0] + [int(x) for x in sys.stdin.readline().split()]\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n + 1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n    \n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\n# Read the input\ndef read_input():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().split()]\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    return n, adj\n\n\ndef main():\n    n, adj = read_input()\n    for i in range(n):\n        print(len(adj[i]))\n\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0] + [int(x) for x in sys.stdin.readline().split()]\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\ndef dfs(tree, u, k, visited):\n    if u not in visited:\n        visited.add(u)\n        if len(visited) == k:\n            return u\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(tree, v, k, visited)\n                if res:\n                    return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\n# Read the input\ndef read_input():\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    adj = [0]\n    adj.extend([int(x) for x in sys.stdin.readline().split()])\n    queries = []\n    for _ in range(q):\n        queries.append([int(x) for x in sys.stdin.readline().split()])\n    return n, q, adj, queries\n\n\n# Build the tree\ndef build_tree(n, adj):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[adj[i]].append(i)\n    return tree\n\n\n# DFS\ndef dfs(tree, u, k, visited):\n    visited.add(u)\n    if len(visited) == k:\n        return u\n    for v in tree[u]:\n        if v not in visited:\n            res = dfs(tree, v, k, visited)\n            if res:\n                return res\n    return None\n\n\ndef main():\n    n, q, adj, queries = read_input()\n    tree = build_tree(n, adj)\n    for u, k in queries:\n        visited = set()\n        res = dfs(tree, u, k, visited)\n        if res:\n            print(res)\n        else:\n            print(-1)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 07:57:43.410317 size on output set 9
2022-04-16 07:57:43.410329 num operations 1
2022-04-16 07:57:43.410335 size on input set 1
2022-04-16 07:57:58.107029 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(sys.stdin.readline()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, sys.stdin.readline().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(sys.stdin.readline()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, sys.stdin.readline().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            sys.stdout.write(str(res[k-1] + 1) + '\\n')\n        else:\n            sys.stdout.write('-1\\n')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        # self.nodes[0].parent = self.nodes[0]\n        # self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input())-1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1]+1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "import sys\n\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.parent = None\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\n    def print_graph(self):\n        for n in self.nodes:\n            print('id: {}, parent: {}, children: {}'.format(n.id, n.parent.id, [c.id for c in n.children]))\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(sys.stdin.readline()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, sys.stdin.readline().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1, flush=True)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nfrom collections import deque\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\n    def __str__(self):\n        return str(self.id)\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\n    def bfs(self, root):\n        res = [root.id]\n        root.visited = True\n        q = deque([root])\n        while q:\n            curr = q.popleft()\n            for c in curr.children:\n                if not c.visited:\n                    res.append(c.id)\n                    c.visited = True\n                    q.append(c)\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, i) for i in range(n)]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nfrom collections import deque\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport math\n\ndef solve(n, q, g, queries):\n    res = []\n    for u, k in queries:\n        res.append(dfs(g, u, k))\n    return res\n\ndef dfs(g, u, k):\n    res = [u]\n    for c in g[u]:\n        res.extend(dfs(g, c, k))\n    if k > len(res):\n        return -1\n    return res[k-1]\n\ndef main():\n    n, q = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for i in range(1, n):\n        g[int(input()) - 1].append(i)\n    queries = []\n    for _ in range(q):\n        queries.append(tuple(map(int, input().split())))\n    res = solve(n, q, g, queries)\n    for r in res:\n        print(r)\n\nif __name__ == '__main__':\n    main()\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n"
    }
  ],
  "created": 1650095863,
  "object": "edit"
}
2022-04-16 07:57:58.107654 fix syntax errors 9 ["\nimport sys\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(sys.stdin.readline()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, sys.stdin.readline().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(sys.stdin.readline()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, sys.stdin.readline().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            sys.stdout.write(str(res[k-1] + 1) + '\\n')\n        else:\n            sys.stdout.write('-1\\n')\n\nif __name__ == '__main__':\n    main()\n", "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        # self.nodes[0].parent = self.nodes[0]\n        # self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input())-1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1]+1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\nclass Node:\n    def __init__(self, id):\n        self.id = id\n        self.parent = None\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\n    def print_graph(self):\n        for n in self.nodes:\n            print('id: {}, parent: {}, children: {}'.format(n.id, n.parent.id, [c.id for c in n.children]))\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(sys.stdin.readline()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, sys.stdin.readline().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1, flush=True)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\n    def __str__(self):\n        return str(self.id)\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\n    def bfs(self, root):\n        res = [root.id]\n        root.visited = True\n        q = deque([root])\n        while q:\n            curr = q.popleft()\n            for c in curr.children:\n                if not c.visited:\n                    res.append(c.id)\n                    c.visited = True\n                    q.append(c)\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, i) for i in range(n)]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n\ndef main():\n    n, q = map(int, input().split())\n    g = Graph(n)\n    for i in range(1, n):\n        g.add_edge(int(input()) - 1, i)\n    for _ in range(q):\n        u, k = map(int, input().split())\n        u -= 1\n        res = g.dfs(g.nodes[u])\n        if k <= len(res):\n            print(res[k-1] + 1)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n\ndef solve(n, q, g, queries):\n    res = []\n    for u, k in queries:\n        res.append(dfs(g, u, k))\n    return res\n\ndef dfs(g, u, k):\n    res = [u]\n    for c in g[u]:\n        res.extend(dfs(g, c, k))\n    if k > len(res):\n        return -1\n    return res[k-1]\n\ndef main():\n    n, q = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for i in range(1, n):\n        g[int(input()) - 1].append(i)\n    queries = []\n    for _ in range(q):\n        queries.append(tuple(map(int, input().split())))\n    res = solve(n, q, g, queries)\n    for r in res:\n        print(r)\n\nif __name__ == '__main__':\n    main()\n\nclass Node:\n    def __init__(self, id, parent):\n        self.id = id\n        self.parent = parent\n        self.children = []\n        self.visited = False\n\nclass Graph:\n    def __init__(self, n):\n        self.nodes = [Node(i, None) for i in range(n)]\n        self.nodes[0].parent = self.nodes[0]\n        self.nodes[0].visited = True\n\n    def add_edge(self, u, v):\n        self.nodes[v].parent = self.nodes[u]\n        self.nodes[u].children.append(self.nodes[v])\n\n    def dfs(self, root):\n        res = [root.id]\n        root.visited = True\n        for c in root.children:\n            if not c.visited:\n                res.extend(self.dfs(c))\n        return res\n"]
2022-04-16 07:57:58.107842 size on output set 9
