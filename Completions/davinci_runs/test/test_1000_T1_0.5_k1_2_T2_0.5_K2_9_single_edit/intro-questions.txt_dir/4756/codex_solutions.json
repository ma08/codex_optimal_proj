["\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(y_n - x_n)\n\nif __name__ == '__main__':\n    main()", "\n\n\nimport sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min)", "\n\nN = int(input())\ncitizens = []\nfor i in range(N):\n    x, y = [int(s) for s in input().split()]\n    citizens.append([x, y])\n\n# Find the smallest value of a that minimizes the total unusefulness\n# for a given set of citizens\ndef min_a(citizens):\n    if len(citizens) == 0:\n        return 0\n    elif len(citizens) == 1:\n        return citizens[0][1] - citizens[0][0]\n    else:\n        # Sort the citizens by x-coordinate\n        citizens.sort()\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right\n        mid = len(citizens) // 2\n        left = min_a(citizens[:mid])\n        right = min_a(citizens[mid:])\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        left_line = citizens[mid-1][1] - citizens[mid-1][0]\n        right_line = citizens[mid][1] - citizens[mid][0]\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        #mid_line = (left_line + right_line) / 2\n        mid_line = left_line + (right_line - left_line) / 2\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        mid_left = mid_line\n        mid_right = mid_line + 1\n        mid_left_total = 0\n        mid_right_total = 0\n        for citizen in citizens[:mid]:\n            mid_left_total += citizen[1] - (citizen[0] + mid_left)\n        for citizen in citizens[mid:]:\n            mid_right_total += citizen[1] - (citizen[0] + mid_right)\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        #mid_line = (left_line + right_line) / 2\n        mid_line = left_line + (right_line - left_line) / 2\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        mid_left = mid_line\n        mid_right = mid_line + 1\n        mid_left_total = 0\n        mid_right_total = 0\n        for citizen in citizens[:mid]:\n            mid_left_total += citizen[1] - (citizen[0] + mid_left)\n        for citizen in citizens[mid:]:\n            mid_right_total += citizen[1] - (citizen[0] + mid_right)\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        if left_line == right_line:\n            return left_line\n        elif mid_left_total < mid_right_total:\n            return mid_left\n        else:\n            return mid_right\n\nprint(min_a(citizens))", "\n\nimport sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a", "\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)"]