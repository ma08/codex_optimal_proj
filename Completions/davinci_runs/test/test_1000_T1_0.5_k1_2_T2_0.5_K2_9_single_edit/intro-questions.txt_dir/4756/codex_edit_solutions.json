["import sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something) # check if div by 0\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "import sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min)\n", "\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    #print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n", "\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = (sum(y)/n - sum(x)/n)\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n#!/usr/bin/python3\n\nimport sys\n\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n    points = sorted(points, key=lambda x: x[1])\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1],\n                                          points[j][0], points[j][1],\n                                          points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x[i] = x_i\n        y[i] = y_i\n    x.sort()\n    y.sort()\n    x_n = sum(x) / n\n    y_n = sum(y) / n\n    print(y_n - x_n)\n\nif __name__ == '__main__':\n    main()\n", "import sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin_distance = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min_distance:\n        min_distance = fabs(x[i] - y[i])\n\nprint(min_distance)\n", "\n\nN = int(input())\ncitizens = []\nfor i in range(N):\n    x, y = [int(s) for s in input().split()]\n    citizens.append([x, y])\n\n# Find the smallest value of a that minimizes the total unusefulness\n# for a given set of citizens\ndef min_a(citizens):\n    if len(citizens) == 0:\n        return 0\n    elif len(citizens) == 1:\n        return citizens[0][1] - citizens[0][0]\n    else:\n        # Sort the citizens by x-coordinate\n        citizens.sort()\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right\n        mid = len(citizens) // 2\n        left = min_a(citizens[:mid])\n        right = min_a(citizens[mid:])\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        left_line = citizens[mid-1][1] - citizens[mid-1][0]\n        right_line = citizens[mid][1] - citizens[mid][0]\n\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        #mid_line = (left_line + right_line) / 2\n        mid_line = left_line + (right_line - left_line) / 2\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        mid_left = mid_line\n        mid_right = mid_line + 1\n        mid_left_total = 0\n        mid_right_total = 0\n        for citizen in citizens[:mid]:\n            mid_left_total += citizen[1] - (citizen[0] + mid_left)\n        for citizen in citizens[mid:]:\n            mid_right_total += citizen[1] - (citizen[0] + mid_right)\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        if left_line == right_line:\n            return left_line\n        elif mid_left_total < mid_right_total:\n            return mid_left\n        else:\n            return mid_right\n\nprint(min_a(citizens))\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort(reverse=True)\n    y.sort(reverse=True)\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(y_n - x_n)\n\nif __name__ == '__main__':\n    main()\n", "\n\nN = int(input())\ncitizens = []\nfor i in range(N):\n    x, y = [int(s) for s in input().split()]\n    citizens.append([x, y])\n\n# Find the smallest value of a that minimizes the total unusefulness\n# for a given set of citizens\ndef min_a(citizens):\n    if len(citizens) == 0:\n        return 0\n    elif len(citizens) == 1:\n        return citizens[0][1] - citizens[0][0]\n    else:\n        # Sort the citizens by x-coordinate\n        citizens.sort()\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right\n        mid = len(citizens) // 2\n        left = min_a(citizens[:mid])\n        right = min_a(citizens[mid:])\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        left_line = citizens[mid-1][1] - citizens[mid-1][0]\n        right_line = citizens[mid][1] - citizens[mid][0]\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        mid_line = left_line + (right_line - left_line) / 2\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        mid_left = mid_line\n        mid_right = mid_line + 1\n        mid_left_total = 0\n        mid_right_total = 0\n        for citizen in citizens[:mid]:\n            mid_left_total += citizen[1] - (citizen[0] + mid_left)\n        for citizen in citizens[mid:]:\n            mid_right_total += citizen[1] - (citizen[0] + mid_right)\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        if left_line == right_line:\n            return left_line\n        elif mid_left_total < mid_right_total:\n            return mid_left\n        else:\n            return mid_right\n\nprint(min_a(citizens))\n", "\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "\n\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n\n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min)\n", "import sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) // 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) // 2\n    print(y_n - x_n)\n\nif __name__ == '__main__':\n    main()\n", "\n#\n# def main():\n#     n = int(input())\n#     x = []\n#     y = []\n#     for i in range(n):\n#         x_i, y_i = map(int, input().split())\n#         x.append(x_i)\n#         y.append(y_i)\n#     x.sort()\n#     y.sort()\n#     if n % 2 == 1:\n#         x_n = x[n // 2]\n#         y_n = y[n // 2]\n#     else:\n#         x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n#         y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n#     print(y_n - x_n)\n#\n# if __name__ == '__main__':\n#     main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    a = [input() for i in range(n)]\n    b = [input() for i in range(m)]\n    for i in range(n - m + 1):\n        for j in range(n - m + 1):\n            if a[i][j:j+m] == b[0]:\n                for k in range(1, m):\n                    if a[i+k][j:j+m] != b[k]:\n                        break\n                else:\n                    print('Yes')\n                    exit()\n    print('No')\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates) # \u0442\u043e \u0436\u0435, \u0447\u0442\u043e zip(citizen_coordinates[0], citizen_coordinates[1])\n    a = sum(y)/n - sum(x)/n # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u043f\u0440\u0438 x\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n\nN = int(input())\ncitizens = []\nfor i in range(N):\n    x, y = [int(s) for s in input().split()]\n    citizens.append([x, y])\n\n# Find the smallest value of a that minimizes the total unusefulness\n# for a given set of citizens\ndef min_a(citizens):\n    if len(citizens) == 0:\n        return 0\n    elif len(citizens) == 1:\n        return citizens[0][1] - citizens[0][0]\n    else:\n        # Sort the citizens by x-coordinate\n        citizens.sort()\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right\n        mid = len(citizens) // 2\n        left = min_a(citizens[:mid])\n        right = min_a(citizens[mid:])\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        left_line = citizens[mid-1][1] - citizens[mid-1][0]\n        right_line = citizens[mid][1] - citizens[mid][0]\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        #mid_line = (left_line + right_line) / 2\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        #mid_line = (left_line + right_line) / 2\n        mid_line = left_line + (right_line - left_line) / 2\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        mid_left = mid_line\n        mid_right = mid_line + 1\n        mid_left_total = 0\n        mid_right_total = 0\n        for citizen in citizens[:mid]:\n            mid_left_total += citizen[1] - (citizen[0] + mid_left)\n        for citizen in citizens[mid:]:\n            mid_right_total += citizen[1] - (citizen[0] + mid_right)\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        if left_line == right_line:\n            return left_line\n        elif mid_left_total < mid_right_total:\n            return mid_left\n        else:\n            return mid_right\n\nprint(min_a(citizens))\n", "\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(list(map(int, sys.stdin.readline().split())))\n\npoints = sorted(points, key=lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n\n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min)\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(y_n - x_n + 1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\nimport sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\nN = int(sys.stdin.readline())\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "\n\nN = int(input())\ncitizens = []\nfor i in range(N):\n    x, y = [int(s) for s in input().split()]\n    citizens.append([x, y])\n\n# Find the smallest value of a that minimizes the total unusefulness\n# for a given set of citizens\ndef min_a(citizens):\n    if len(citizens) == 0:\n        return 0\n    elif len(citizens) == 1:\n        return citizens[0][1] - citizens[0][0]\n    else:\n        # Sort the citizens by x-coordinate\n        citizens.sort()\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right\n        mid = len(citizens) // 2\n        left = min_a(citizens[:mid])\n        right = min_a(citizens[mid:])\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        left_line = citizens[mid-1][1] - citizens[mid-1][0]\n        right_line = citizens[mid][1] - citizens[mid][0]\n\n        if left_line == right_line:\n            return left_line\n        elif left < right:\n            return left\n        else:\n            return right\n\nprint(min_a(citizens))\n", "\n\nimport sys\n\ndef main():\n    # Read the number of test cases\n    num_test_cases = int(sys.stdin.readline())\n\n    # Loop through the test cases\n    for _ in range(num_test_cases):\n        # Read input\n        num_citizens = int(sys.stdin.readline())\n        coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n        # Find the minimum and maximum x and y coordinates\n        min_x, max_x = float(\"inf\"), float(\"-inf\")\n        min_y, max_y = float(\"inf\"), float(\"-inf\")\n        for x, y in coordinates:\n            min_x = min(min_x, x)\n            max_x = max(max_x, x)\n            min_y = min(min_y, y)\n            max_y = max(max_y, y)\n\n        # Check if the citizens are perfectly aligned\n        if min_x == max_x or min_y == max_y:\n            print(0)\n            continue\n\n        # Calculate the slope of the line\n        slope = (max_y - min_y) / (max_x - min_x)\n\n        # Calculate the y-intercept\n        intercept = max_y - slope * max_x\n\n        # Print the result\n        print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something) #what is this for?\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    x.sort()\n    y.sort()\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2\n    print(int(y_n - x_n))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    # Read input\n    num_citizens = int(sys.stdin.readline())\n    coordinates = [tuple(map(int, sys.stdin.readline().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n\n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    # Read input and remove newline character\n    num_citizens = int(sys.stdin.readline().strip())\n    coordinates = [tuple(map(int, line.split())) for line in sys.stdin.readlines()]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n    \n    # Calculate the y-intercept of the line\n    intercept = max_y - ((max_y - min_y) / (max_x - min_x)) * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)  # unzip\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]  # map to int\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    a = abs(points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint min_a\n", "\ndef main():\n    n = int(input())\n    xy = []\n    for i in range(n):\n        x_i, y_i = map(int, input().split())\n        xy.append((x_i, y_i))\n    xy.sort()\n    x = [xy[i][0] for i in range(n)]\n    y = [xy[i][1] for i in range(n)]\n    if n % 2 == 1:\n        x_n = x[n // 2]\n        y_n = y[n // 2]\n    else:\n        x_n = (x[n // 2 - 1] + x[n // 2]) / 2.0\n        y_n = (y[n // 2 - 1] + y[n // 2]) / 2.0\n    print(y_n - x_n)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    # Read the input\n    num_citizens = int(input())\n    coordinates = [tuple(map(int, input().split())) for _ in range(num_citizens)]\n\n    # Find the minimum and maximum x and y coordinates of the citizens\n    min_x, max_x = float(\"inf\"), float(\"-inf\")\n    min_y, max_y = float(\"inf\"), float(\"-inf\")\n    for x, y in coordinates:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n\n    # Check if the citizens are perfectly aligned in either the x-axis or the y-axis\n    if min_x == max_x or min_y == max_y:\n        print(0)\n        return\n\n    # Calculate the slope of the line\n    slope = (max_y - min_y) / (max_x - min_x)\n\n    # Calculate the y-intercept\n    intercept = max_y - slope * max_x\n\n    # Print the result\n    print(intercept)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\nN = int(sys.stdin.readline())\n\npoints = []\n\nfor i in range(N):\n    points.append(map(int, sys.stdin.readline().split()))\n\npoints = sorted(points, key = lambda p: p[1])\n\nmin_a = float(\"inf\")\n\nfor i in range(N):\n    if i == N - 1:\n        break\n    \n    a = (points[i][0] + points[i][1] - points[i + 1][0] - points[i + 1][1]) / float(2)\n    min_a = min(min_a, a)\n\nprint(min_a)\n", "\nimport sys\nimport math\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py \n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something) \n    if u > 1:\n        u = 1\n    elif u < 0: \n        u = 0\n    x = x1 + u * px \n    y = y1 + u * py\n    dx = x - x3 \n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy) \n    return dist \n\ndef main():\n    n = int(sys.stdin.readline()) \n    points = [] \n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split()) \n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1]) \n    # print points\n    min_dist = 100000 \n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]) \n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist) \n\nif __name__ == '__main__':\n    main() \n", "\n\nN = int(input())\ncitizens = []\nfor i in range(N):\n    x, y = [int(s) for s in input().split()]\n    citizens.append([x, y])\n\n# Find the smallest value of a that minimizes the total unusefulness\n# for a given set of citizens\ndef min_a(citizens):\n    if len(citizens) == 0:\n        return 0\n    elif len(citizens) == 1:\n        return citizens[0][1] - citizens[0][0]\n    else:\n        # Sort the citizens by x-coordinate\n        citizens.sort()\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right\n        mid = len(citizens) // 2\n        left = min_a(citizens[:mid])\n        right = min_a(citizens[mid:])\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        left_line = citizens[mid-1][1] - citizens[mid-1][0]\n        right_line = citizens[mid][1] - citizens[mid][0]\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        # Note: The following line does not work in the case where\n        # the left and right lines are the same\n        #mid_line = (left_line + right_line) / 2\n        mid_line = left_line + (right_line - left_line) / 2\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        mid_left = mid_line\n        mid_right = mid_line + 1\n        mid_left_total = 0\n        mid_right_total = 0\n        for citizen in citizens[:mid]:\n            mid_left_total += citizen[1] - (citizen[0] + mid_left)\n        for citizen in citizens[mid:]:\n            mid_right_total += citizen[1] - (citizen[0] + mid_right)\n\n        # Find the line that minimizes the total unusefulness of the\n        # citizens to the left and right of the line\n        if left_line == right_line:\n            return left_line\n        elif mid_left_total < mid_right_total:\n            return mid_left\n        else:\n            return mid_right\n\nprint(min_a(citizens))\n", "\n\n\nimport sys\n\ndef find_a(citizen_coordinates):\n    n = len(citizen_coordinates)\n    x, y = zip(*citizen_coordinates)\n    a = sum(y)/n - sum(x)/n\n    return a\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    citizen_coordinates = [tuple(map(int, i.split())) for i in lines[1:]]\n    a = find_a(citizen_coordinates)\n    print(a)\n", "\n#\n\nimport sys\nfrom math import sqrt, fabs\n\nn = int(sys.stdin.readline())\n\nx = []\ny = []\n\nfor i in range(n):\n    data = sys.stdin.readline().split()\n    x.append(int(data[0]))\n    y.append(int(data[1]))\n\nx.sort()\ny.sort()\n\nmin = 10**6\n\nfor i in range(n):\n    if fabs(x[i] - y[i]) < min:\n        min = fabs(x[i] - y[i])\n\nprint(min)\n", "\nimport sys\nimport math\n\ndef find_closest_point(x1, y1, x2, y2, x3, y3):\n    px = x2-x1\n    py = y2-y1\n    something = px*px + py*py\n    u =  ((x3 - x1) * px + (y3 - y1) * py) / float(something)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    x = x1 + u * px\n    y = y1 + u * py\n    dx = x - x3\n    dy = y - y3\n    dist = math.sqrt(dx*dx + dy*dy)\n    return dist\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x,y))\n    points = sorted(points, key=lambda x: x[1])\n    # print points\n    min_dist = 100000\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                dist = find_closest_point(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n    print(\"%.6f\" % min_dist)\n\nif __name__ == '__main__':\n    main()\n"]