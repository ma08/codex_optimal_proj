["\n\n#Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n# define the method which will be called recursively\n# s is the string to be parsed\n# i is the current index in the string\n# op is the operator to use for this call\n# op_prev is the operator used in the previous call\n# returns the number of distinct values\ndef parse(s, i, op, op_prev):\n    # get the next number\n    # if we are at the end of the string, return 1\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        # if the previous operator was a star sign, return the sum of the two possibilities\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) - int(s[i + 2]))\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\n# define the method which will be called recursively\n# s is the string to be parsed\n# i is the current index in the string\n# op is the operator to use for this call\n# op_prev is the operator used in the previous call\n# returns the number of distinct values\ndef parse(s, i, op, op_prev):\n    # get the next number\n    num = int(s[i])\n    # if we are at the end of the string, return 1\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        # if the previous operator was a star sign, return the product of the two possibilities\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\n\n# Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\n#Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1 + sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# define the method which will be called recursively.\n# s is the string to be parsed.\n# i is the current index in the string.\n# op is the operator to use for this call.\n# op_prev is the operator used in the previous call.\n# returns the number of distinct values.\ndef parse(s, i, op, op_prev): \n    # get the next number\n    num = int(s[i])\n    # if we are at the end of the string, return 1\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        # if the previous operator was a star sign, return the product of the two possibilities\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\n\ndef dpg(str):\n    if '+' not in str:\n        return 1\n    else:\n        count = 0\n        for i in range(len(str)):\n            if str[i] == '+':\n                count += dpg(str[:i]) * dpg(str[i+1:])\n        return count\n\nprint(dpg(input()))\n", "\nimport sys\n\n\ndef parse(s, i, op, op_prev):\n    num = int(s[i])\n    if i == len(s) - 1:\n        return 1\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    elif s[i + 1] == '*':\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\ns = sys.stdin.readline()\ns = s[:-1]\nprint parse(s, 0, '+', '+')\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is the same as\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)^2\n        num_subsets = factorial(n) / (factorial(n // 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\", \" \")\n\ts = s.split()\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the string can be evaluated\n\tcount = 0\n\tfor i in range(1, len(s)):\n\t\tcount += len(s) - i\n\tprint(count)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\ndef dpg(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count\n\nprint(dpg(input()))\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression))\n\ndef count_distinct_integers_helper(expression, start, end):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end) + \\\n               count_distinct_integers_helper(expression, start + 1, end)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, 10 * count + int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        for i in range(n):\n            dp[i][i+1] = 1\n            if i > 0:\n                dp[i-1][i+1] = 2\n        for i in range(n-1):\n            for j in range(i+2, n+1):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j-1] == line[j-2]*10 + line[j-1]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) * int(s[i + 2]))\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n# Complete the solve function below.\ndef solve(meal_cost, tip_percent, tax_percent):\n    total_cost = meal_cost + (meal_cost * (tip_percent/100)) + (meal_cost * (tax_percent/100))\n    print(round(total_cost))\n\nif __name__ == '__main__':\n    meal_cost = float(input())\n\n    tip_percent = int(input())\n\n    tax_percent = int(input())\n\n    solve(meal_cost, tip_percent, tax_percent)\n", "\n\n#Solved by: Andrew Xing and Andrew Wang\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('-')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef dpg(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count + 1\n\nprint(dpg(input()))\n", "\n\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\" \")\n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the string can be evaluated\n\tcount = 0\n\tfor i in range(1,len(s)):\n\t\tcount += len(s) - i\n\tprint(count)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split(' ')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start])) \n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j-2]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\ndef dpg(string):  # dpg stands for \"Dynamic Programming\"\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i+1:])\n        return count\n\nif __name__ == '__main__':\n    print(dpg(input()))\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "\nimport sys\n\n\ndef parse(s, i, op, op_prev):\n    # get the next number\n    num = int(s[i])\n    # if we are at the end of the string, return 1\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        # if the previous operator was a star sign, return the product of the two possibilities\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\n\nfrom sys import stdin, stdout\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j-2]:\n                    dp[i][j] += 1\n        stdout.write(str(dp[0][-1]) + '\\n')\n\nmain()\n", "import sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\"\\n\")\n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the string can be evaluated\n\tcount = 0\n\tfor i in range(1,len(s)):\n\t\tcount += len(s) - i\n\tprint(count)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\n\ndef next_permutation(s):\n\ti = len(s) - 1\n\twhile i > 0 and s[i-1] >= s[i]:\n\t\ti -= 1\n\tif i <= 0:\n\t\treturn False\n\tj = len(s) - 1\n\twhile s[j] <= s[i-1]:\n\t\tj -= 1\n\ts[i-1], s[j] = s[j], s[i-1]\n\ts[i:] = s[len(s) - 1 : i-1 : -1]\n\treturn True\n\ndef eval(s):\n\tres = 0\n\tcurr = 0\n\tfor i in range(len(s)):\n\t\tif s[i] == 1:\n\t\t\tcurr += 1\n\t\telse:\n\t\t\tres += curr\n\t\t\tcurr = 0\n\tres += curr\n\treturn res\n\ndef num_ways(s):\n\tcount = 0\n\tfor i in range(1, len(s)):\n\t\tcount += len(s) - i\n\treturn count\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\n\t# Convert the input to a list of 1s and 0s\n\tfor i in range(len(s)):\n\t\tif s[i] == '+':\n\t\t\ts[i] = 1\n\t\telse:\n\t\t\ts[i] = 0\n\n\t# Count the number of ways the string can be evaluated to a 1\n\tprint(num_ways(s))\n\n\t# Find the minimum number of flips\n\twhile next_permutation(s):\n\t\tpass\n\tprint(eval(s))\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) - int(s[i + 2]))\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\n\ndef main():\n    for line in stdin:\n        line = list(map(int, line.strip().split('+')))\n        n = len(line)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i > 0:\n                dp[i-1][i] = 2\n        for i in range(n-1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                if line[j] == line[j-1]*10 + line[j]:\n                    dp[i][j] += 1\n        print(dp[0][-1])\n\nmain()\n", "\n\nimport sys\n\n#\n# # define the method which will be called recursively\n# # s is the string to be parsed\n# # i is the current index in the string\n# # op is the operator to use for this call\n# # op_prev is the operator used in the previous call\n# # returns the number of distinct values\n# def parse(s, i, op, op_prev):\n#     # get the next number\n#     num = int(s[i])\n#     # if we are at the end of the string, return 1\n#     if i == len(s) - 1:\n#         return 1\n#     # if the next operator is a plus sign, return the sum of the two possibilities\n#     if s[i + 1] == '+':\n#         return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n#     # if the next operator is a star sign, return the product of the two possibilities\n#     elif s[i + 1] == '*':\n#         # if the previous operator was a plus sign, return the sum of the two possibilities\n#         if op_prev == '+':\n#             return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n#         # if the previous operator was a star sign, return the product of the two possibilities\n#         elif op_prev == '*':\n#             return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n#\n# # get the input\n# s = sys.stdin.readline()\n# # remove the newline character from the string\n# s = s[:-1]\n# # call the function to get the number of distinct values\n# print parse(s, 0, '+', '+')\n", "\ndef dpg(string):\n    if '+' not in string:\n        return 1  # base case\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i + 1:])\n        return count\n\nprint(dpg(input()))\n", "\nimport sys\n\n# define the method which will be called recursively\n# s is the string to be parsed\n# i is the current index in the string\n# op is the operator to use for this call\n# op_prev is the operator used in the previous call\n# returns the number of distinct values\ndef parse(s, i, op, op_prev):\n    # get the next number\n    num = int(s[i])\n    # if we are at the end of the string, return 1\n    if i == len(s) - 1:\n        return 1\n    # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+':\n        return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n    # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*':\n        # if the previous operator was a plus sign, return the sum of the two possibilities\n        if op_prev == '+':\n            return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op)\n        # if the previous operator was a star sign, return the product of the two possibilities\n        elif op_prev == '*':\n            return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input\ns = sys.stdin.readline()\n# remove the newline character from the string\ns = s[:-1]\n# call the function to get the number of distinct values\nprint parse(s, 0, '+', '+')\n", "\n\n#Solved by: Andrew Xing and Kevin Wang\n\nimport sys\n\ndef num_of_eval(exp):\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\"\\n\") \n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the string can be evaluated\n\tcount = 0\n\tfor i in range(1,len(s)):\n\t\tcount += len(s) - i\n\tprint(count)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom sys import stdin\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(int(s[i]) + int(s[i + 2]))\n        else:\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is the same as\n        # the number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this to\n        # n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of\n        # n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)^2\n        num_subsets = factorial(n) / ((factorial(n // 2)) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\" \")\n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the string can be evaluated\n\tcount = 0\n\tfor i in range(len(s)):\n\t\tcount += len(s[i]) - 1\n\tprint(count)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression))\n\ndef count_distinct_integers_helper(expression, start, end):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression starting at the given\n    index and ending at the given index.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end) + \\\n               count_distinct_integers_helper(expression, start + 1, end)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n    # Recursive case: We've reached a plus symbol.\n    else:\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n#Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    # get the input\n    s = sys.stdin.readline()\n    # remove the newline character from the string\n    s = s[:-1]\n    # call the function to get the number of distinct values\n    print parse(s, 0, '+', '+')\n", "\n\nfrom sys import stdin\n\nimport sys\n\ndef evaluate(s):\n    if len(s) == 1:\n        return int(s)\n\n    res = []\n    for i in range(len(s) - 1):\n        if s[i + 1] == '+':\n            res.append(s[i] + s[i + 2])\n        else:\n\n            res.append(int(s[i]) + int(s[i + 2]))\n    return set(res)\n\ndef main():\n    s = stdin.readline().strip()\n    print(len(evaluate(s)))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef dpg(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i + 1:])\n        return count\n\n\nprint(dpg(input()))\n", "\ndef dpg(string):\n    if '+' not in string:\n        return 1\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i]) * dpg(string[i + 1:])\n        return count\n\n\nprint(dpg(input()))\n", "\n\ndef main():\n    expression = input()\n\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a plus symbol\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    # Recursive case: We've reached a digit\n    else:\n        # We concatenate the digit to the integer formed so far\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression))\n\ndef count_distinct_integers_helper(expression, start, end):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end) + \\\n               count_distinct_integers_helper(expression, start + 1, end)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n# define the method which will be called recursively s is the string to be parsed i is the current index in the string op is the operator to use for this call op_prev is the operator used in the previous call returns the number of distinct values\ndef parse(s, i, op, op_prev): # get the next number num = int(s[i]) # if we are at the end of the string, return 1\n    if i == len(s) - 1: return 1 # if the next operator is a plus sign, return the sum of the two possibilities\n    if s[i + 1] == '+': return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op) # if the next operator is a star sign, return the product of the two possibilities\n    elif s[i + 1] == '*': # if the previous operator was a plus sign, return the sum of the two possibilities\n        if op_prev == '+': return parse(s, i + 2, '+', op) + parse(s, i + 2, '*', op) # if the previous operator was a star sign, return the product of the two possibilities\n        elif op_prev == '*': return parse(s, i + 2, '+', op) * parse(s, i + 2, '*', op)\n\n# get the input s = sys.stdin.readline() # remove the newline character from the string s = s[:-1] # call the function to get the number of distinct values\nprint(parse(s, 0, '+', '+'))\n", "\n\n# Solved by: Andrew Xing\n\n\nimport sys\n\ndef num_of_eval(exp):\n    #exp = list(exp)\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression,\n    # where n is the number of pluses. For each of these possible ways, the expression\n    # can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression), 0)\n\ndef count_distinct_integers_helper(expression, start, end, count):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :param count: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return count + 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end, count) + \\\n               count_distinct_integers_helper(expression, start + 1, end, count)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, count * 10 + int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is (n choose n/2).\n        # We can calculate this by taking the factorial of n and dividing by\n        # the square of the factorial of n/2.\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n\t# Read the input\n\ts = sys.stdin.readline()\n\ts = s.replace(\"+\",\"\\n\").replace(\"-\",\"\\n\")\n\ts = s.split(\"\\n\")\n\n\t# Convert the input to a list of integers\n\tfor i in range(len(s)):\n\t\ts[i] = int(s[i])\n\n\t# Count the number of ways the string can be evaluated\n\tcount = 0\n\tfor i in range(1,len(s)):\n\t\tcount += len(s) - i\n\tprint(count+1)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\n# Solved by: Andrew Xing\n\nimport sys\n\ndef num_of_eval(exp):\n    exp = exp.split('+')\n    exp = [int(x) for x in exp]\n    return 1+sum([len(str(x)) for x in exp])\n\ndef main():\n    exp = sys.stdin.readline().strip()\n    print(num_of_eval(exp))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"This function will be run when the input data is piped to the script.\"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ** n\n        # The number of ways to pick a subset of n operators is the same as the\n        # number of ways to choose k operators out of n.\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2.\n        #\n        # We know that this is the same as (n choose n-k) as well, so we can\n        # simplify this to\n        #\n        #     (n choose k) = n! / (k! * (n-k)!)\n        #\n        # Since we know that k = n/2, we can simplify this further to\n        #\n        #     (n choose k) = n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as:\n        #\n        #     (n choose k) = n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of n/2.\n        # So we can simplify this even further to:\n        #\n        #     (n choose k) = n! / (n!!)^2\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    expression = input()\n    print(count_distinct_integers(expression))\n\ndef count_distinct_integers(expression):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :return: int\n    \"\"\"\n    # There are 2^(n-1) possible ways of interpreting the pluses in the expression, where n is the number of pluses.\n    # For each of these possible ways, the expression can be evaluated to a single integer, which we count.\n    return count_distinct_integers_helper(expression, 0, len(expression))\n\ndef count_distinct_integers_helper(expression, start, end):\n    \"\"\"\n    Counts the number of distinct integers that can be formed from the given DPG expression.\n    :param expression: string\n    :param start: int\n    :param end: int\n    :return: int\n    \"\"\"\n    # Base case: We've reached the end of the expression.\n    if start == end:\n        return 1\n    # Recursive case: We've reached a plus symbol.\n    if expression[start] == \"+\":\n        # We can either add or concatenate, so we call the helper function twice.\n        return count_distinct_integers_helper(expression, start + 1, end) + \\\n               count_distinct_integers_helper(expression, start + 1, end)\n    # Recursive case: We've reached a digit.\n    else:\n        # We concatenate the digit to the integer formed so far.\n        return count_distinct_integers_helper(expression, start + 1, end, int(expression[start]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom math import factorial\n\ndef main():\n    \"\"\"\n    This function will be run when the input data is piped to the script.\n    \"\"\"\n\n    # Read all of the input data.\n    data = stdin.read().split('\\n')\n\n    # For each line of input data, do something with it.\n    for line in data:\n        # If we don't have a line of input data, just continue.\n        if line == \"\":\n            continue\n\n        # Split the input data into a list of integers and a list of operators.\n        nums = [int(x) for x in line.split('+')]\n        ops = ['+'] * (len(nums) - 1)\n\n        # The number of ways to evaluate the expression is the number of ways\n        # to pick a subset of the operators to be concatenated.\n        #\n        # Each subset of operators can be represented by a binary number\n        # where a 1 means concatenate and a 0 means add.\n        #\n        # So we just need to find the number of ways to pick a subset of the\n        # operators.\n        n = len(ops)\n        # The number of ways to pick a subset of n operators is 2^n.\n        num_subsets = 2 ** n\n        #\n        # This is the binomial coefficient (n choose k) where k = n/2,\n        # which is the same as (n choose n-k) as well.\n        #\n        # The formula for (n choose k) is n! / (k! * (n-k)!).\n        #\n        # Since we know that k = n/2, we can simplify this to n! / ((n/2)! * (n/2)!)\n        #\n        # This is the same as\n        # n! / ((n/2)!)^2\n        #\n        # The square root of the factorial of n/2 is the double factorial of n/2.\n        #\n        # So we can simplify this even further to\n        # n! / (n!!)^2\n        num_subsets = factorial(n) / (factorial(n / 2) ** 2)\n\n        # Print the number of subsets.\n        print(int(num_subsets))\n\n# If this script is being run directly (as opposed to being imported), run\n# the main function.\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef dpg(string, d):\n    if '+' not in string:\n        return d\n    else:\n        count = 0\n        for i in range(len(string)):\n            if string[i] == '+':\n                count += dpg(string[:i], d+1) * dpg(string[i+1:], d+1)\n        return count\n\nprint(dpg(input()))\n"]