2022-04-16 07:28:11.254281 num operations 1
2022-04-16 07:28:11.254300 size on input set 1
2022-04-16 07:28:25.288209 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 3,
      "text": "#!/usr/bin/env python3\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 4,
      "text": "#!/usr/bin/env python3\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\nimport heapq\n\nclass Graph:\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def clear(self, num_of_nodes):\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 6,
      "text": "import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1), edge[2])\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes # float(\"inf\") is infinity\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_vertices):\n        self.num_of_vertices = num_of_vertices\n        self.adj_list = [[] for _ in range(num_of_vertices)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float(\"inf\")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == \"__main__\":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n"
    }
  ],
  "created": 1650094091,
  "object": "edit"
}
2022-04-16 07:28:25.288604 fix syntax errors 9 ['\nimport sys\n\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '#!/usr/bin/env python3\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '#!/usr/bin/env python3\n\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\n\nimport sys\nimport heapq\n\nclass Graph:\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def clear(self, num_of_nodes):\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', 'import sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_nodes):\n        self.num_of_nodes = num_of_nodes\n        self.adj_list = [[] for _ in range(num_of_nodes)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1), edge[2])\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes # float("inf") is infinity\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n', '\nimport sys\nimport heapq\n\nclass Graph:\n    def __init__(self, num_of_vertices):\n        self.num_of_vertices = num_of_vertices\n        self.adj_list = [[] for _ in range(num_of_vertices)]\n        self.edges = set()\n\n    def add_edge(self, edge):\n        # edge = (x, y, weight)\n        self.adj_list[edge[0] - 1].append((edge[1] - 1, edge[2]))\n        self.adj_list[edge[1] - 1].append((edge[0] - 1, edge[2]))\n        self.edges.add((edge[0] - 1, edge[1] - 1))\n\n    def dijkstra(self, start, end):\n        visited = [False] * self.num_of_nodes\n        dist = [float("inf")] * self.num_of_nodes\n        dist[start] = 0\n\n        queue = []\n        heapq.heappush(queue, (0, start))\n        while queue:\n            node = heapq.heappop(queue)\n            if visited[node[1]]:\n                continue\n            visited[node[1]] = True\n            for adj_node in self.adj_list[node[1]]:\n                if not visited[adj_node[0]] and dist[adj_node[0]] > dist[node[1]] + adj_node[1]:\n                    dist[adj_node[0]] = dist[node[1]] + adj_node[1]\n                    heapq.heappush(queue, (dist[adj_node[0]], adj_node[0]))\n\n        return dist[end]\n\n    def kth_shortest_path(self, k):\n        dist = []\n        for i in range(self.num_of_nodes):\n            for j in range(i + 1, self.num_of_nodes):\n                if (i, j) not in self.edges:\n                    dist.append(self.dijkstra(i, j))\n        dist.sort()\n        return dist[k - 1]\n\n\nif __name__ == "__main__":\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, m, k = next(reader)\n    graph = Graph(n)\n    for edge in reader:\n        graph.add_edge(edge)\n    print(graph.kth_shortest_path(k))\n']
2022-04-16 07:28:25.288754 size on output set 7
2022-04-16 07:28:25.288764 num operations 1
2022-04-16 07:28:25.288769 size on input set 1
2022-04-16 07:28:34.999085 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b, w = [int(x) for x in input().split()]\n    graph[a - 1].append((b - 1, w))\n    graph[b - 1].append((a - 1, w))\n\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 1,
      "text": "from heapq import heappop, heappush\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) - 1 for x in input().split()]\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 2,
      "text": "\nfrom heapq import heappop, heappush\n\nn, m, k = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 3,
      "text": "from heapq import heappush, heappop\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 4,
      "text": "\nfrom heapq import heappush, heappop\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 5,
      "text": "\nfrom heapq import heappop, heappush\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 6,
      "text": "from heapq import heappop, heappush\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[-k])\n"
    },
    {
      "index": 7,
      "text": "\nfrom heapq import *\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf') for _ in range(n)]\n    visited = [False for _ in range(n)]\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    },
    {
      "index": 8,
      "text": "\n\nfrom heapq import *\n\nn, m, k = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"
    }
  ],
  "created": 1650094105,
  "object": "edit"
}
2022-04-16 07:28:34.999363 fix syntax errors 9 ["\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b, w = [int(x) for x in input().split()]\n    graph[a - 1].append((b - 1, w))\n    graph[b - 1].append((a - 1, w))\n\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "from heapq import heappop, heappush\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) - 1 for x in input().split()]\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "\nfrom heapq import heappop, heappush\n\nn, m, k = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "from heapq import heappush, heappop\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "\nfrom heapq import heappush, heappop\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "\nfrom heapq import heappop, heappush\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "from heapq import heappop, heappush\n\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[-k])\n", "\nfrom heapq import *\nn, m, k = [int(x) for x in input().split()]\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = [int(x) for x in input().split()]\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf') for _ in range(n)]\n    visited = [False for _ in range(n)]\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n", "\n\nfrom heapq import *\n\nn, m, k = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y, w = map(int, input().split())\n    graph[x - 1].append((y - 1, w))\n    graph[y - 1].append((x - 1, w))\n\ndef dijkstra(graph, source):\n    dist = [float('inf')] * n\n    visited = [False] * n\n    dist[source] = 0\n    pq = [(0, source)]\n\n    while pq:\n        d, u = heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\ndist = dijkstra(graph, 0)\ndist.sort()\n\nprint(dist[k - 1])\n"]
2022-04-16 07:28:34.999497 size on output set 9
