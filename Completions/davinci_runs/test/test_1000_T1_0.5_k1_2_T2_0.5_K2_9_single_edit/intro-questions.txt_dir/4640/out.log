2022-04-09 21:15:38.466632 """
There are $n$ points on a plane. The $i$-th point has coordinates $(x_i, y_i)$. You have two horizontal platforms, both of length $k$. Each platform can be placed anywhere on a plane but it should be placed horizontally (on the same $y$-coordinate) and have integer borders. If the left border of the platform is $(x, y)$ then the right border is $(x + k, y)$ and all points between borders (including borders) belong to the platform.

Note that platforms can share common points (overlap) and it is not necessary to place both platforms on the same $y$-coordinate.

When you place both platforms on a plane, all points start falling down decreasing their $y$-coordinate. If a point collides with some platform at some moment, the point stops and is saved. Points which never collide with any platform are lost.

Your task is to find the maximum number of points you can save if you place both platforms optimally.

You have to answer $t$ independent test cases.

For better understanding, please read the Note section below to see a picture for the first test case.


-----Input-----

The first line of the input contains one integer $t$ ($1 \le t \le 2 \cdot 10^4$) — the number of test cases. Then $t$ test cases follow.

The first line of the test case contains two integers $n$ and $k$ ($1 \le n \le 2 \cdot 10^5$; $1 \le k \le 10^9$) — the number of points and the length of each platform, respectively. The second line of the test case contains $n$ integers $x_1, x_2, \dots, x_n$ ($1 \le x_i \le 10^9$), where $x_i$ is $x$-coordinate of the $i$-th point. The third line of the input contains $n$ integers $y_1, y_2, \dots, y_n$ ($1 \le y_i \le 10^9$), where $y_i$ is $y$-coordinate of the $i$-th point. All points are distinct (there is no pair $1 \le i < j \le n$ such that $x_i = x_j$ and $y_i = y_j$).

It is guaranteed that the sum of $n$ does not exceed $2 \cdot 10^5$ ($\sum n \le 2 \cdot 10^5$).


-----Output-----

For each test case, print the answer: the maximum number of points you can save if you place both platforms optimally.


-----Example-----
Input
4
7 1
1 5 2 3 1 5 4
1 3 6 7 2 5 4
1 1
1000000000
1000000000
5 10
10 7 5 15 8
20 199 192 219 1904
10 10
15 19 8 17 20 10 9 2 10 19
12 13 6 17 1 14 7 9 19 3

Output
6
1
5
10



-----Note-----

The picture corresponding to the first test case of the example:

[Image]

Blue dots represent the points, red segments represent the platforms. One of the possible ways is to place the first platform between points $(1, -1)$ and $(2, -1)$ and the second one between points $(4, 3)$ and $(5, 3)$. Vectors represent how the points will fall down. As you can see, the only point we can't save is the point $(3, 7)$ so it falls down infinitely and will be lost. It can be proven that we can't achieve better answer here. Also note that the point $(5, 3)$ doesn't fall at all because it is already on the platform.
"""
2022-04-09 21:15:38.466672 --------------------------
2022-04-09 21:16:05.179345 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\n# The idea is to sort the points by x-coordinate, and then process them in that order.\n# When processing a point, we maintain a set of all the platforms that have already been placed.\n# We can do this in O(log n) time by keeping the platforms sorted by y-coordinate.\n# For each platform, we check if the point is above or below it.\n# If it's above, we can safely ignore it.\n# If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it.\n# If we remove it, we also check if the point is close enough to the next platform that we should remove it too.\n# This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform.\n# If it is, then we remove the next platform as well.\n# Otherwise, we keep the platform.\n# We then insert the new platform into the set.\n# We repeat this process for all the points, and then we're done.\n# This runs in O(n log n) time, which is fast enough for the time limit.\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        points = list(zip(x, y))\n        points.sort()\n        left = [y for x, y in points]\n        right = [y for x, y in points]\n        left.sort()\n        right.sort()\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1649553338,
  "id": "cmpl-4vGSwpdIeXE28R1LvnjzbmlpTsADO",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 21:16:05.179616 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\n# The idea is to sort the points by x-coordinate, and then process them in that order.\n# When processing a point, we maintain a set of all the platforms that have already been placed.\n# We can do this in O(log n) time by keeping the platforms sorted by y-coordinate.\n# For each platform, we check if the point is above or below it.\n# If it's above, we can safely ignore it.\n# If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it.\n# If we remove it, we also check if the point is close enough to the next platform that we should remove it too.\n# This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform.\n# If it is, then we remove the next platform as well.\n# Otherwise, we keep the platform.\n# We then insert the new platform into the set.\n# We repeat this process for all the points, and then we're done.\n# This runs in O(n log n) time, which is fast enough for the time limit.\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 21:16:05.179686 REASON stop
2022-04-09 21:16:05.181254 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        points = list(zip(x, y))\n        points.sort()\n        left = [y for x, y in points]\n        right = [y for x, y in points]\n        left.sort()\n        right.sort()\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 21:16:05.181449 REASON stop
