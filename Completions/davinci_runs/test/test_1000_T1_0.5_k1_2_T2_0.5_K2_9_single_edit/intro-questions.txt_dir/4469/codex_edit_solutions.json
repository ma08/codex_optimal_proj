["\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\n# Get the number of queries\nq = int(input())\n\n# Initialize the shelf\nshelf = []\n\n# Loop over the queries\nfor i in range(q):\n    # Get the query\n    query = input().split()\n\n    # If it's a left query\n    if query[0] == 'L':\n        # Add it to the left of the shelf\n        shelf.insert(0, int(query[1]))\n\n    # If it's a right query\n    elif query[0] == 'R':\n        # Add it to the right of the shelf\n        shelf.append(int(query[1]))\n\n    # If it's a question\n    else:\n        # Find the index of the book\n        index = shelf.index(int(query[1]))\n\n        # Print the minimum number of books to pop\n        print(min(index, len(shelf) - index - 1))\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\n# freopen equivalent\nimport os\nimport sys\n\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\nimport sys\nimport heapq\nimport math\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nimport os\nimport heapq\nimport math\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the list of books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it's a left book\n        if book[0] == 'L':\n            # Add it to the left of the books\n            books.insert(0, int(book[1]))\n\n        # If it's a right book\n        elif book[0] == 'R':\n            # Add it to the right of the books\n            books.append(int(book[1]))\n\n        # If it's a book\n        else:\n            # Find the index of the books\n            index = books.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(books) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it's a left book\n        if book[0] == 'L':\n            # Add it to the left of the books\n            books.insert(0, int(book[1]))\n\n        # If it's a right book\n        elif book[0] == 'R':\n            # Add it to the right of the books\n            books.append(int(book[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = books.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(books) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the stack\n    stack = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input()\n\n        # If it's the first book\n        if i == 0:\n            # Add it to the stack\n            stack.append(book)\n\n        # If it's not the first book\n        else:\n            # If it's not the first book and the book is not already in the stack\n            if book not in stack:\n                # Add it to the stack\n                stack.append(book)\n\n    # Print the number of books in the stack\n    print(len(stack))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef get_characters():\n    # Get the number of characters\n    n = int(input())\n\n    # Get the characters\n    characters = input().split()\n\n    return n, characters\n\n\ndef get_queries():\n    # Get the number of queries\n    q = int(input())\n\n    # Get the queries\n    queries = []\n    for i in range(q):\n        queries.append(input())\n\n    return q, queries\n\n\ndef get_substrings(string, length):\n    # Initialize the list of substrings\n    substrings = []\n\n    # Loop over the characters\n    for i in range(len(string) - length + 1):\n        # Add the substring to the list\n        substrings.append(string[i:i + length])\n\n    return substrings\n\n\ndef get_substring_counts(substrings):\n    # Initialize the counts\n    counts = {}\n\n    # Loop over the substrings\n    for substring in substrings:\n        # If the substring is already in the counts\n        if substring in counts:\n            # Increment the count\n            counts[substring] += 1\n\n        # If the substring is not in the counts\n        else:\n            # Set the count to 1\n            counts[substring] = 1\n\n    return counts\n\n\ndef get_substring_probabilities(substring_counts, n, length):\n    # Initialize the probabilities\n    probabilities = {}\n\n    # Loop over the substrings\n    for substring in substring_counts:\n        # Get the probability\n        probabilities[substring] = substring_counts[substring] / (n - length + 1)\n\n    return probabilities\n\n\ndef get_best_probabilities(probabilities):\n    # Initialize the return value\n    best_probabilities = []\n\n    # Initialize the best probability\n    best_probability = 0\n\n    # Loop over the substrings\n    for substring in probabilities:\n        # If the probability is greater than the best probability\n        if probabilities[substring] > best_probability:\n            # Set the best probability\n            best_probability = probabilities[substring]\n\n    # Loop over the substrings\n    for substring in probabilities:\n        # If the probability is equal to the best probability\n        if probabilities[substring] == best_probability:\n            # Add the substring to the list\n            best_probabilities.append(substring)\n\n    return best_probabilities\n\n\ndef print_best_probabilities(best_probabilities):\n    # Sort the substrings\n    best_probabilities.sort()\n\n    # Loop over the substrings\n    for substring in best_probabilities:\n        # Print the substring\n        print(substring)\n\n\n\ndef main():\n    # Get the characters\n    n, characters = get_characters()\n\n    # Get the queries\n    q, queries = get_queries()\n\n    # Loop over the lengths\n    for i in range(q):\n        # Get the length\n        length = int(queries[i])\n\n        # Get the substrings\n        substrings = get_substrings(characters, length)\n\n        # Get the substring counts\n        substring_counts = get_substring_counts(substrings)\n\n        # Get the substring probabilities\n        substring_probabilities = get_substring_probabilities(substring_counts, n, length)\n\n        # Get the best probabilities\n        best_probabilities = get_best_probabilities(substring_probabilities)\n\n        # Print the best probabilities\n        print_best_probabilities(best_probabilities)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n# freopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = int(input())\n\n        # If the book is already on the shelf\n        if book in shelf:\n            # Find the index of the book\n            index = shelf.index(book)\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n        # If the book is not already on the shelf\n        else:\n            # Add it to the right of the shelf\n            shelf.append(book)\n\n            # Print 0\n            print(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"]