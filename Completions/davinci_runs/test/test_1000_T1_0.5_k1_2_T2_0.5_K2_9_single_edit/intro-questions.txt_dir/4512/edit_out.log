2022-04-16 07:56:35.816921 num operations 1
2022-04-16 07:56:35.816939 size on input set 1
2022-04-16 07:56:46.886555 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2]) - 1] + query[4] + s[int(query[2]):]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2]) - 1:int(query[4])])))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])]))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):len(s)]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])-1])))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):len(s)]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):] # query[2] is the index of the char to be changed\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])]))) # query[2] is the start index of the substring and query[4] is the end index\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 6
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):-1]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):] + query[4]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])] + query[4])))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650095795,
  "object": "edit"
}
2022-04-16 07:56:46.886832 NO RESULT
2022-04-16 07:56:46.886840 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 6
}
2022-04-16 07:56:46.886930 fix syntax errors 8 ['\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2]) - 1] + query[4] + s[int(query[2]):]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2]) - 1:int(query[4])])))\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])]))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):len(s)]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])-1])))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):len(s)]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):] # query[2] is the index of the char to be changed\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])]))) # query[2] is the start index of the substring and query[4] is the end index\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):-1]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == "1":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):] + query[4]\n        elif query[0] == "2":\n            print(len(set(s[int(query[2])-1:int(query[4])] + query[4])))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 07:56:46.886975 size on output set 7
2022-04-16 07:56:46.886984 num operations 1
2022-04-16 07:56:46.886990 size on input set 1
2022-04-16 07:57:03.343336 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# TODO: implement using a Trie instead of a hashmap.\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def add(self, data):\n        node = Node(data)\n        if self.head is None:\n            self.head = node\n        else:\n            node.next = self.head\n            self.head = node\n\n    def printList(self):\n        curr = self.head\n        while curr:\n            print(curr.data)\n            curr = curr.next\n\n\ndef main():\n    llist.add(1)\n    llist.add(2)\n    llist.add(3)\n    llist.add(4)\n    llist.add(5)\n    llist.printList()\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input()\n        query = query.split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = dict()\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split(' ')\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr = curr.children[char]\n        curr.count += 1\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[1])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr = curr.children[char]\n        curr.count += 1\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for i in range(len(word)):\n            curr = curr.children[word[i]]\n            if word[i] not in curr.children:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[1])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\n# TODO: implement using a Trie instead of a hashmap.\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[1])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\n# TODO: implement using a Trie instead of a hashmap.\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr = curr.children[char]\n        curr.count += 1\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.insert(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.insert(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650095806,
  "object": "edit"
}
2022-04-16 07:57:03.343907 fix syntax errors 9 ["\n\n# TODO: implement using a Trie instead of a hashmap.\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def add(self, data):\n        node = Node(data)\n        if self.head is None:\n            self.head = node\n        else:\n            node.next = self.head\n            self.head = node\n\n    def printList(self):\n        curr = self.head\n        while curr:\n            print(curr.data)\n            curr = curr.next\n\n\ndef main():\n    llist.add(1)\n    llist.add(2)\n    llist.add(3)\n    llist.add(4)\n    llist.add(5)\n    llist.printList()\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input()\n        query = query.split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = dict()\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split(' ')\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr = curr.children[char]\n        curr.count += 1\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[1])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr = curr.children[char]\n        curr.count += 1\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for i in range(len(word)):\n            curr = curr.children[word[i]]\n            if word[i] not in curr.children:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[1])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# TODO: implement using a Trie instead of a hashmap.\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[1])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# TODO: implement using a Trie instead of a hashmap.\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n# TODO: implement using a Trie instead of a hashmap\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr = curr.children[char]\n        curr.count += 1\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.insert(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.insert(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 07:57:03.344092 size on output set 8
