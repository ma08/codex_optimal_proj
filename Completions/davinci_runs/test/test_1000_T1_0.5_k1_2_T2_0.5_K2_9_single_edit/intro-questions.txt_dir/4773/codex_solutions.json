["\n\nimport sys\n\ndef main():\n    data = sys.stdin.readline().strip()\n    print(len(data))\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\n\ndef main():\n    sequence = sys.stdin.readline().strip()\n    #sequence = \"WNEENWEENEENE\"\n    #sequence = \"NSEW\"\n\n    # find the largest possible macro\n    # we want to find the largest substring that is repeated at least twice\n    # we can do this by counting the number of times each substring occurs\n    # and then sorting by the number of occurrences\n\n    # create a dictionary of substrings with their number of occurrences\n    substrings = {}\n    for i in range(1, len(sequence)):\n        for j in range(len(sequence)-i+1):\n            substring = sequence[j:j+i]\n            if substring in substrings:\n                substrings[substring] += 1\n            else:\n                substrings[substring] = 1\n\n    # sort the substrings by their occurrences\n    substrings = sorted(substrings.items(), key=lambda x: x[1], reverse=True)\n\n    # the first substring will be the largest substring that is repeated at least twice\n    # so we can use that as our macro\n    macro = substrings[0][0]\n\n    # create a new sequence with the macro\n    new_sequence = \"\"\n    while macro in sequence:\n        new_sequence += \"M\"\n        sequence = sequence.replace(macro, \"\", 1)\n    new_sequence += sequence\n\n    print(len(new_sequence))\n\nmain()", "\n\ndef main():\n    macro = []\n    route = []\n    route_string = input()\n    route_len = len(route_string)\n    for i in range(route_len):\n        route.append(route_string[i])\n    while len(route) > 0:\n        if len(route) == 1:\n            macro.append(route[0])\n            del route[0]\n        else:\n            if route[0] == route[1]:\n                macro.append('M')\n                del route[0]\n                del route[0]\n            else:\n                macro.append(route[0])\n                del route[0]\n    print(len(macro))\n\nmain()", "\n\nroute = input()\n\ndef compress(route):\n    if len(route) < 2:\n        return route\n    for i in range(1, len(route)):\n        if route[i] == route[i-1]:\n            return compress(route[:i-1] + 'M' + route[i+1:])\n    return route\n\ndef encode(route):\n    if len(route) < 2:\n        return route\n    else:\n        return route[0] + encode(route[1:])\n\ndef decode(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + decode(route[1:])\n        else:\n            return route[0] + decode(route[1:])\n\ndef expand(route):\n    if len(route) < 2:\n        return route\n    else:\n        if route[0] == 'M':\n            return route[1] + expand(route[1:])\n        else:\n            return route[0] + expand(route[1:])\n\nprint(len(encode(compress(route))))", "\n\nimport sys\nimport math\n\n# This solution is a little tricky.\n# We can't use any of the standard compression algorithms (LZW, Huffman, etc.)\n# because we don't know what the input will be.\n#\n# So instead, we need to come up with a way to compress the input and still be able\n# to decode it.\n#\n# The key insight is that we can use a \"macro\" to reduce the size of a sequence of\n# moves that is repeated.\n#\n# So, we can build a \"macro\" by starting with the first move, and then continuing\n# to add moves until we find a repeated sequence.\n#\n# We then replace the repeated sequence with a 'M' and continue to build the macro.\n#\n# We repeat this process until we have built a macro that covers the entire input.\n#\n# We then compare the size of the original input to the size of the macro and\n# return the smaller one.\n\ndef compress(s):\n  \"\"\"Compress the input string using a macro.\n\n  Args:\n    s: The string to compress.\n\n  Returns:\n    The compressed string.\n  \"\"\"\n  # If the string is empty, return it.\n  if s == '':\n    return s\n  \n  # If the string has less than 2 moves, return it.\n  if len(s) < 2:\n    return s\n  \n  # The compressed string.\n  compressed = ''\n  \n  # The macro string.\n  macro = ''\n  \n  # The current index in the input string.\n  index = 0\n  \n  # The length of the input string.\n  length = len(s)\n  \n  # While there are still moves in the input string.\n  while index < length:\n    # Get the next move.\n    move = s[index]\n    \n    # If the macro is empty, add the move to the macro.\n    if macro == '':\n      macro += move\n    # Otherwise, if the move is the same as the last move in the macro,\n    # add the move to the macro.\n    elif move == macro[-1]:\n      macro += move\n    # Otherwise, if the move is different from the last move in the macro,\n    # look for a repeated sequence in the input string.\n    else:\n      # The length of the repeated sequence.\n      repeat_length = 2\n      \n      # While the repeated sequence is less than the length of the macro,\n      # and the repeated sequence is at the end of the input string.\n      while repeat_length <= len(macro) and s.endswith(macro[-repeat_length:]):\n        # If the repeated sequence is the same length as the macro,\n        # we have found a repeated sequence.\n        if repeat_length == len(macro):\n          # Remove the repeated sequence from the input string.\n          s = s[:-repeat_length]\n          \n          # Add the macro to the compressed string.\n          compressed += 'M'\n          \n          # Reset the macro.\n          macro = ''\n          \n          # Reset the index.\n          index = 0\n          \n          # Reset the length of the input string.\n          length = len(s)\n          \n          # Break out of the loop.\n          break\n        # Otherwise, increase the length of the repeated sequence.\n        else:\n          repeat_length += 1\n      \n      # If we found a repeated sequence, add the move to the macro.\n      if repeat_length <= len(macro):\n        macro += move\n      # Otherwise, add the macro to the compressed string,\n      # and add the move to the macro.\n      else:\n        compressed += macro\n        macro = move\n    \n    # Increase the index.\n    index += 1\n  \n  # If the input string is not empty, add the macro to the compressed string.\n  if s != '':\n    compressed += macro\n  \n  # Return the compressed string.\n  return compressed\n\ndef main():\n  # Read the input string.\n  s = sys.stdin.readline().strip()\n  \n  # Compress the input string.\n  compressed = compress(s)\n  \n  # Print the size of the smaller string.\n  print min(len(s), len(compressed))\n\nif __name__ == '__main__':\n  main()", "\n\nimport sys\nimport math\n\ndef main():\n    route = input()\n    route = list(route)\n    route.reverse()\n    curr_move = route.pop()\n    curr_count = 1\n    while route:\n        next_move = route.pop()\n        if next_move == curr_move:\n            curr_count += 1\n        else:\n            curr_move = next_move\n            curr_count = 1\n    print(curr_count)\n\nmain()", "\n\n#-----Solution-----\n\ndef min_chars(route):\n    \"\"\"\n    Returns the minimum number of characters needed to transmit a route to a rover\n    \"\"\"\n    # The minimum number of characters needed to transmit the route\n    min_chars = len(route)\n    \n    # The number of characters in the route\n    num_chars = len(route)\n    \n    # The number of characters in the macro\n    num_macro = 1\n    \n    # Loop through possible macro lengths\n    while num_macro < num_chars:\n        \n        # The number of times the macro appears in the route\n        num_times = 0\n        \n        # The length of the macro\n        macro = route[:num_macro]\n        \n        # Loop through the route\n        for i in range(num_chars - num_macro + 1):\n            \n            # If the route at the current index is equal to the macro, the macro is used\n            if route[i:i+num_macro] == macro:\n                num_times += 1\n                \n        # If the number of times the macro appears is greater than 1, the minimum number of characters needed is updated\n        if num_times > 1:\n            min_chars = min(min_chars, num_times + num_macro)\n            \n        # The length of the macro is increased\n        num_macro += 1\n        \n    return min_chars\n\n#-----Test Cases-----\n\nprint(min_chars('WNEENWEENEENE'))\nprint(min_chars('NSEW'))"]