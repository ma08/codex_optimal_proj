["\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n", "\nimport sys\n\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n\n        dna.append(line.strip())\n\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\n\ndef print_tree(n):\n\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child): \n        while parent[child] != child:\n            child = parent[child] \n        return child \n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport heapq\nimport sys\n\nif __name__ == \"__main__\":\n    # Read input and build graph\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        dna = sys.stdin.readline().strip()\n        for j in range(i):\n            u, v = i, j\n            graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n            graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n    # Prim's algorithm\n    min_tree = []\n    min_weight = 0\n    visited = [False] * n\n    pq = [(0, 0, dna)]\n    while pq:\n        weight, u, dna = heapq.heappop(pq)\n        if not visited[u]:\n            visited[u] = True\n            min_tree.append((u, dna))\n            min_weight += weight\n            for v, w in graph[u]:\n                if not visited[v]:\n                    heapq.heappush(pq, (w, v, dna))\n\n    # Print results\n    print(min_weight)\n    for u, dna in min_tree[1:]:\n        print(min_tree.index((u, dna)), u)\n", "\n\n# from math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline()\n# stdin = f\n\nn, k = map(int, stdin.readline().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().split()))\n# print(dna)\n\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [100 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 100:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()), end='\\n')\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key, end=' ')\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i + 1, j + 1, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    # for i, j, d in edges:\n    #     if components[i] != components[j]:\n    #         print(i, j)\n    #         c1 = components[i]\n    #         c2 = components[j]\n    #         for k in range(n):\n    #             if components[k] == c2:\n    #                 components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\nfrom sys import stdin, stdout\n\ndef main():\n    n, k = map(int, stdin.readline().split())\n    dna = [stdin.readline().strip() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip() # readline() returns a string\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b))) # first edge of graph[j] is the one that connects it to j\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key = lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            sys.stdout.write(str(i) + ' ' + str(j) + '\\n')\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "import heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n        \n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\nprint(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\nprint(d)\n\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n", "import sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\ndef main():\n    print(\"Hello\")\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n", "\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "import heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n)\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\nimport sys\n\ndef main():\n    pass\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(edge.weight for edge in mst))\n    for edge in mst:\n        print(edge.vertex1 + 1, edge.vertex2 + 1)\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys, collections\n\ndef main():\n    pass\n\nmain()\n", "\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, _ in edges))\n# for e, v in edges:\n#     print(v, e)\n", "\n\nfrom __future__ import print_function\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[float('inf') for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float('inf'):\n                print(i, j, sep=' ', end='\\n')\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    dna_dict = {}\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n", "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)) + 1, u + 1)\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n", "\nimport sys\n\ndef main():    \n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {}\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)  # number of dna\n    edge = [[0 for i in range(n)] for j in range(n)]  # edge weight\n    for i in range(n):  # calculate edge weight\n        for j in range(i+1, n):  # only calculate upper triangle\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)]  # minimum spanning tree\n    used = [False for i in range(n)]  # if i-th dna is used\n    mst[0][0] = 0  # first row is 0\n    ans = 0  # answer\n    for i in range(n):  # each row\n        v = -1\n        for j in range(n):  # find minimum edge weight\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True  # current dna is used\n        ans += mst[v][i]  # add edge weight\n        for j in range(n):  # update minimum edge weight\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)  # print answer\n    for i in range(n):  # print minimum spanning tree\n        for j in range(i+1, n):\n            if mst[i][j] != math.inf:  # if edge weight is not infinite\n                print(i, j)  # print edge\n\ndef main():\n    line = sys.stdin.readline()  # input n and k\n    n, k = [int(x) for x in line.split()]  # parse n and k\n    dna = [sys.stdin.readline().strip() for i in range(n)]  # input dna\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = {(i,j): 0 for i in range(n) for j in range(n) if i < j}\n\n    for i in range(n):\n        for j in range(i, n):\n            if i != j:\n                count = 0\n                for x in range(k):\n                    if dna[i][x] != dna[j][x]:\n                        count += 1\n                dna_dict[(i,j)] = count\n\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split(' '))\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, _ in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(distances[i][j] for i, j in tree))\n    for i, j in tree:\n        print(dna[i], dna[j])\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u+1)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(child):\n        while parent[child] != child: child = parent[child]\n        return child \n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "import sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\n\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    dna_dict = {}\n\n    for i in range(n-1):\n        for j in range(i+1, n-1):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna, k))\n\ndef kruskal(dna, k):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight)[:k]:\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v, e)\n", "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][2]) if a != b)))\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\n\nfor e, v in edges:\n    print(v, e)\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\n# dna = [input().strip() for i in range(n)]\ndna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\n# d = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\n\n# edges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n", "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans, end=\"\")\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n-1):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i+1, j+1)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nimport math\n\n\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)]\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna, k))\n\ndef kruskal(dna, k):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph with k-1 edges\n    graph = Graph(dna, k - 1)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna, k):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        # Iterate through the vertices\n        for vertex1 in self.vertices:\n            # Iterate through the vertices\n            for vertex2 in self.vertices:\n                # If the vertices are not the same vertex\n                if vertex1 != vertex2:\n                    # Add the edge to the graph\n                    self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n        # Sort the edges in ascending order by weight\n        self.edges.sort(key=lambda x: x.weight)\n        # Remove the last k - 1 edges\n        self.edges = self.edges[:k]\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the sum of the weights of the edges in the minimum spanning tree\n    return sum(edge.weight for edge in mst)\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    mst = kruskal(dna)\n    print(sum(edge.weight for edge in mst))\n    for edge in mst:\n        print(edge.vertex1 + 1, edge.vertex2 + 1)\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint set\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree: print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "def main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance // 2)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\n", "\n\nimport sys\n\ndef main():\n\n    n, k = map(int, sys.stdin.readline().split())\n    dna = [sys.stdin.readline() for i in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i, j)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\n\nmain()\n", "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    dna = [sys.stdin.readline().strip() for _ in range(n)]\n    print(dna)\n    # edges = []\n    # for i in range(n):\n    #     for j in range(i + 1, n):\n    #         edges.append((i, j, hamming(dna[i], dna[j])))\n    # edges.sort(key=lambda x: x[2])\n    # components = {i: i for i in range(n)}\n    # total_distance = 0\n    # for i, j, d in edges:\n    #     if components[i] != components[j]:\n    #         total_distance += d\n    #         c1 = components[i]\n    #         c2 = components[j]\n    #         for k in range(n):\n    #             if components[k] == c2:\n    #                 components[k] = c1\n    # print(total_distance)\n    # for i, j, d in edges:\n    #     if components[i] != components[j]:\n    #         print(i, j)\n    #         c1 = components[i]\n    #         c2 = components[j]\n    #         for k in range(n):\n    #             if components[k] == c2:\n    #                 components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\n#\n", "\n\nimport sys\n\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    dna_dict = {}\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i,j)] = count\n\n    print(min(dna_dict.values()), end=\"\\n\")\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key, sep=\" \")\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())  # noqa\n    dna = []\n    for _ in range(n):\n        dna.append(input())  # noqa\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))  # noqa\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport heapq\nimport sys\n\n# Read input and build graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for i in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))  # noqa\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))  # noqa\n\n# Prim's algorithm\nmin_tree = []\nmin_weight = 0\nvisited = [False] * n\npq = [(0, 0, dna)]\nwhile pq:\n    weight, u, dna = heapq.heappop(pq)\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n"]