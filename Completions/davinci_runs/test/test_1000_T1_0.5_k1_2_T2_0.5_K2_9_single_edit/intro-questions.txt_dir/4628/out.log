2022-04-09 21:11:20.293774 """
You are a mayor of Berlyatov. There are $n$ districts and $m$ two-way roads between them. The $i$-th road connects districts $x_i$ and $y_i$. The cost of travelling along this road is $w_i$. There is some path between each pair of districts, so the city is connected.

There are $k$ delivery routes in Berlyatov. The $i$-th route is going from the district $a_i$ to the district $b_i$. There is one courier on each route and the courier will always choose the cheapest (minimum by total cost) path from the district $a_i$ to the district $b_i$ to deliver products.

The route can go from the district to itself, some couriers routes can coincide (and you have to count them independently).

You can make at most one road to have cost zero (i.e. you choose at most one road and change its cost with $0$).

Let $d(x, y)$ be the cheapest cost of travel between districts $x$ and $y$.

Your task is to find the minimum total courier routes cost you can achieve, if you optimally select the some road and change its cost with $0$. In other words, you have to find the minimum possible value of $\sum\limits_{i = 1}^{k} d(a_i, b_i)$ after applying the operation described above optimally.


-----Input-----

The first line of the input contains three integers $n$, $m$ and $k$ ($2 \le n \le 1000$; $n - 1 \le m \le min(1000, \frac{n(n-1)}{2})$; $1 \le k \le 1000$) — the number of districts, the number of roads and the number of courier routes.

The next $m$ lines describe roads. The $i$-th road is given as three integers $x_i$, $y_i$ and $w_i$ ($1 \le x_i, y_i \le n$; $x_i \ne y_i$; $1 \le w_i \le 1000$), where $x_i$ and $y_i$ are districts the $i$-th road connects and $w_i$ is its cost. It is guaranteed that there is some path between each pair of districts, so the city is connected. It is also guaranteed that there is at most one road between each pair of districts.

The next $k$ lines describe courier routes. The $i$-th route is given as two integers $a_i$ and $b_i$ ($1 \le a_i, b_i \le n$) — the districts of the $i$-th route. The route can go from the district to itself, some couriers routes can coincide (and you have to count them independently).


-----Output-----

Print one integer — the minimum total courier routes cost you can achieve (i.e. the minimum value $\sum\limits_{i=1}^{k} d(a_i, b_i)$, where $d(x, y)$ is the cheapest cost of travel between districts $x$ and $y$) if you can make some (at most one) road cost zero.


-----Examples-----
Input
6 5 2
1 2 5
2 3 7
2 4 4
4 5 2
4 6 8
1 6
5 3

Output
22

Input
5 5 4
1 2 5
2 3 4
1 4 3
4 3 7
3 5 2
1 5
1 3
3 3
1 5

Output
13



-----Note-----

The picture corresponding to the first example:

[Image]

There, you can choose either the road $(2, 4)$ or the road $(4, 6)$. Both options lead to the total cost $22$.

The picture corresponding to the second example:

$A$

There, you can choose the road $(3, 4)$. This leads to the total cost $13$.
"""
2022-04-09 21:11:20.294062 --------------------------
2022-04-09 21:12:02.113920 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)"
    }
  ],
  "created": 1649553080,
  "id": "cmpl-4vGOmHnE85RjTptA8KSmrcwWHORQz",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 21:12:02.114345 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().strip().split())\n    graph = defaultdict(dict)\n    for i in range(m):\n        x, y, w = map(int, sys.stdin.readline().strip().split())\n        graph[x][y] = w\n        graph[y][x] = w\n    routes = []\n    for i in range(k):\n        a, b = map(int, sys.stdin.readline().strip().split())\n        routes.append((a, b))\n    print(solve(graph, routes))\n\ndef solve(graph, routes):\n    max_dist = 0\n    for r1, r2 in routes:\n        d = dijkstra(graph, r1, r2)\n        max_dist = max(max_dist, d)\n    return max_dist\n\ndef dijkstra(graph, start, end):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            break\n        for neighbor in graph[current]:\n            distance = distances[current] + graph[current][neighbor]\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                queue.append(neighbor)\n    return distances[end]\n\nif __name__ == '__main__':\n    main()"
}
2022-04-09 21:12:02.114870 REASON stop
2022-04-09 21:12:02.116632 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main(n, m, k, edges, routes):\n    # compute the minimum spanning tree\n    mst = minimum_spanning_tree(edges, n)\n\n    # find the maximum cost edge in the MST\n    max_edge = max(mst, key=lambda e: e[-1])\n\n    # zero out the maximum cost edge\n    max_edge[-1] = 0\n\n    # compute the shortest paths from the source to each vertex\n    dist = dijkstra(mst, n, max_edge[0])\n\n    # compute the total cost of all routes\n    route_cost = sum(dist[a-1][b-1] for a, b in routes)\n\n    print(route_cost)\n\ndef minimum_spanning_tree(edges, n):\n    # sort the edges by cost\n    edges.sort(key=lambda e: e[-1])\n\n    # create a disjoint set of vertices\n    ds = DisjointSet(n)\n\n    # create a list to store the edges in the MST\n    mst = []\n\n    # for each edge in the sorted list\n    for edge in edges:\n        # if the vertices are in different sets\n        if ds.find(edge[0]-1) != ds.find(edge[1]-1):\n            # union the sets\n            ds.union(edge[0]-1, edge[1]-1)\n            # add the edge to the MST\n            mst.append(edge)\n\n    return mst\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank   = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        if self.rank[xRoot] < self.rank[yRoot]:\n            self.parent[xRoot] = yRoot\n        elif self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n\ndef dijkstra(edges, n, s):\n    # create a list to store the shortest paths to each vertex\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n\n    # create a set to store the vertices\n    vertices = set(range(n))\n\n    # set the source distance to 0\n    dist[s-1][s-1] = 0\n\n    # while there are vertices to explore\n    while vertices:\n        # find the vertex with the shortest distance\n        v = min(vertices, key=lambda v: dist[s-1][v])\n\n        # remove the vertex from the set\n        vertices.remove(v)\n\n        # for each edge adjacent to the vertex\n        for u, w in edges:\n            # if the edge connects the vertex and u\n            if v+1 in (u, w):\n                # set the distance of u to the distance to v plus the weight of the edge\n                dist[s-1][u-1] = min(dist[s-1][u-1], dist[s-1][v] + w)\n                dist[s-1][w-1] = min(dist[s-1][w-1], dist[s-1][v] + w)\n\n    return dist\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    routes = [list(map(int, input().split())) for _ in range(k)]\n    main(n, m, k, edges, routes)"
}
2022-04-09 21:12:02.116824 REASON stop
