["\n\nn = int(input())\nl = [int(x) for x in input().split()]\nprint(l)\n", "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        else:\n            y = str(x)\n            if y == y[::-1]:\n                return True\n            else:\n                return False\n", "\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.append(0)\nd.sort()\n# print(d)\ndef possible(a, b):\n    return (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n    if possible(d[l], d[r]):\n        ans += 2\n        l += 1\n        r -= 1\n    else:\n        ans += 1\n        r -= 1\n\nif l == r:\n    ans += 1\n\nprint(ans)\n", "\n#!/bin/python3\nimport math\nimport os\nimport random\nimport re\nimport sys\n# Complete the isValid function below.\ndef isValid(s):\n    if len(s) == 1:\n        return \"YES\"\n    dic = {}\n    for i in range(len(s)):\n        if s[i] not in dic:\n            dic[s[i]] = 1\n        else:\n            dic[s[i]] += 1\n    m = max(dic.values())\n    m_key = max(dic, key=dic.get)\n    for key in dic:\n        if key != m_key:\n            if dic[key] == m:\n                return \"YES\"\n            else:\n                return \"NO\"\n    if m-1 in dic.values():\n        return \"YES\"\n    else:\n        return \"NO\"\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n    s = input()\n    result = isValid(s)\n    fptr.write(result + '\\n')\n    fptr.close()\n", "\nn = int(input())\na = list(map(int, input().split()))\nprint(all([True if i > 0 else False for i in a]) and any([True if str(i) == str(i)[::-1] else False for i in a]))\n", "\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n", "#!/usr/bin/python3\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\n\nd.sort()\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n", "import sys\n\ninput = sys.stdin.readline\n\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort(reverse=True)\n\ndef possible(a, b):\n    return (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n    if possible(d[l], d[r]):\n        ans += 2\n        l += 1\n        r -= 1\n    else:\n        ans += 1\n        r -= 1\n\nif l == r:\n    ans += 1\n\nprint(ans)\n", "t = int(input())\nfor i in range(t):\n    n, k = [int(x) for x in input().split()]\n    d = [int(x) for x in input().split()]\n    d.sort()\n    # build a lookup table for each mod value\n    mods = [0] * k\n    for i in d:\n        mods[i%k] += 1\n    # find the most common mod value\n    max_mod_val = 0\n    for i in range(k):\n        if mods[i] > mods[max_mod_val]:\n            max_mod_val = i\n    # find the number of pairs that can be made with the most common mod value\n    num_pairs = int(mods[max_mod_val]/2)\n    # find the number of pairs that can be made with the second most common mod value\n    if k%2 == 0:\n        if max_mod_val == int(k/2):\n            num_pairs += int(mods[0]/2)\n        else:\n            num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n    print(2*num_pairs)\n", "\n\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort(reverse=True)\n\ndef possible(a, b):\n\treturn (a + b) % k == 0\n\nans = 0\nl, r = 0, n - 1\nwhile l < r:\n\tif possible(d[l], d[r]):\n\t\tans += 2\n\t\tl += 1\n\t\tr -= 1\n\telse:\n\t\tans += 1\n\t\tr -= 1\n\nif l == r:\n\tans += 1\n\nprint(ans)\n", "\n\nn, k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\n\nd.sort()\n\n# build a lookup table for each mod value\nmods = [0] * k\nfor i in d:\n    mods[i % k] += 1\n\n# find the most common mod value\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\n\n# find the number of pairs that can be made with the most common mod value\nnum_pairs = int(mods[max_mod_val] / 2)\n\n# find the number of pairs that can be made with the second most common mod value\nif k % 2 == 0:\n    if max_mod_val == int(k / 2):\n        num_pairs += int(mods[0] / 2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k - max_mod_val]) / 2)\n\nprint(2 * num_pairs)\n", "\ns = input()\nlength = len(s)\nif length % 2 == 0:\n    print(s[:length//2-1] + s[length//2+1:])\nelse:\n    print(s[:length//2] + s[length//2+1:])\n", "\ndef sum(a,b):\n    return a+b\ndef diff(a,b):\n    return a-b\ndef prod(a,b):\n    return a*b\ndef div(a,b):\n    return a/b\na=int(input())\nb=int(input())\nprint(sum(a,b))\nprint(diff(a,b))\nprint(prod(a,b))\nprint(div(a,b))\n", "\n\nn,k=input().split()\nfor i in range(int(n)+1,int(k)):\n    if(i%2!=0):\n        print(i,end=\" \")\n", "n=input(\"Enter string:\")\nk=0\nfor i in range(len(n)):\n  if(n[i].isdigit()):\n    k=k+1\nprint(k)\n", "\n\nn,k = [int(x) for x in input().split()]\nd = [int(x) for x in input().split()]\nd.sort()\nmods = [0] * k\nfor i in d:\n    mods[i%k] += 1\nmax_mod_val = 0\nfor i in range(k):\n    if mods[i] > mods[max_mod_val]:\n        max_mod_val = i\nnum_pairs = int(mods[max_mod_val]/2)\nif k%2 == 0:\n    if max_mod_val == int(k/2):\n        num_pairs += int(mods[0]/2)\n    else:\n        num_pairs += int(min(mods[max_mod_val], mods[k-max_mod_val])/2)\n\nprint(2*num_pairs)\n"]