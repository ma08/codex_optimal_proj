2022-04-16 10:57:59.273484 num operations 1
2022-04-16 10:57:59.273499 size on input set 1
2022-04-16 10:58:08.119530 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_max_cost(n):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 2,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n))\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    print(get_max_cost(n, m))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 4,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 5,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\n\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 6,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n)) + 1\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 7,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    },
    {
      "index": 8,
      "text": "\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n"
    }
  ],
  "created": 1650106679,
  "object": "edit"
}
2022-04-16 10:58:08.119835 fix syntax errors 9 ['\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n))\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    print(get_max_cost(n, m))\n\nif __name__ == "__main__":\n    main()\n', '\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n))\n\nn, m = [int(x) for x in input().split()]\n\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one\n    # The maximum cost of the roads is the sum of the first n-1 integers\n    return sum(range(1, n)) + 1\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n', '\n\ndef get_max_cost(n, m):\n    # The number of roads to plow is equal to the number of cities minus one.\n    # The maximum cost of the roads is the sum of the first n-1 integers.\n    return sum(range(1, n+1))\n\nn, m = [int(x) for x in input().split()]\nprint(get_max_cost(n, m))\n']
2022-04-16 10:58:08.119879 size on output set 7
2022-04-16 10:58:08.119893 num operations 1
2022-04-16 10:58:08.119898 size on input set 1
2022-04-16 10:58:22.702557 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1), end='')\n"
    },
    {
      "index": 2,
      "text": "\n\nimport fileinput\n\nn, m = map(int, input().split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 3,
      "text": "\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].strip().split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 4,
      "text": "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST of the graph\n# the cost of plowing the roads is the sum of the weights of the MST of the graph\n# the weight of an edge in the MST is the label of the road (the label of the road is 1 if it's not in the MST)\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1 (that's the case for a star graph)\n# if we label all the edges in the MST with n-1, the cost of plowing the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1, the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1 and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 5,
      "text": "\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 6,
      "text": "\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 7,
      "text": "\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n"
    },
    {
      "index": 8,
      "text": "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1.\n# if we label all the edges in the MST with n-1, the cost of plowing the\n# roads is n*(n-1)/2.\n# if we label all the edges in the MST with 1, the cost of plowing the roads\n# is n-1.\n# if we label all the edges in the MST with a number between 1 and n-1, the\n# cost of plowing the roads is between n-1 and n*(n-1)/2.\n# the cost of plowing the roads is maximized when we label 1 road with n-1 and\n# the rest of the roads with 1.\n\nprint(m + (n - 1) * (n - m - 1))\n"
    }
  ],
  "created": 1650106688,
  "object": "edit"
}
2022-04-16 10:58:22.702939 fix syntax errors 9 ['\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\nprint(m + (n - 1) * (n - m - 1))\n', "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1), end='')\n", '\n\nimport fileinput\n\nn, m = map(int, input().split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n', '\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].strip().split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n', "\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST of the graph\n# the cost of plowing the roads is the sum of the weights of the MST of the graph\n# the weight of an edge in the MST is the label of the road (the label of the road is 1 if it's not in the MST)\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1 (that's the case for a star graph)\n# if we label all the edges in the MST with n-1, the cost of plowing the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1, the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1 and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n", '\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\nprint(m + (n - 1) * (n - m - 1))\n', '\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\nprint(m + (n - 1) * (n - m - 1))\n', '\nimport fileinput\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1\n# if we label all the edges in the MST with n-1, the cost of plowing\n# the roads is n*(n-1)/2\n# if we label all the edges in the MST with 1, the cost of plowing the\n# roads is n-1\n# if we label all the edges in the MST with a number between 1 and n-1,\n# the cost of plowing the roads is between n-1 and n*(n-1)/2\n# the cost of plowing the roads is maximized when we label 1 road with n-1\n# and the rest of the roads with 1\n\nprint(m + (n - 1) * (n - m - 1))\n', '\n\nimport fileinput\n\nn, m = map(int, fileinput.input()[0].split())\n\n# the roads that are not upgraded are the ones that are not in the MST\n# of the graph\n# the cost of plowing the roads is the sum of the weights of the MST\n# of the graph\n# the weight of an edge in the MST is the label of the road\n\n# the maximum label of an edge in the MST of a graph with n nodes is n-1.\n# if we label all the edges in the MST with n-1, the cost of plowing the\n# roads is n*(n-1)/2.\n# if we label all the edges in the MST with 1, the cost of plowing the roads\n# is n-1.\n# if we label all the edges in the MST with a number between 1 and n-1, the\n# cost of plowing the roads is between n-1 and n*(n-1)/2.\n# the cost of plowing the roads is maximized when we label 1 road with n-1 and\n# the rest of the roads with 1.\n\nprint(m + (n - 1) * (n - m - 1))\n']
2022-04-16 10:58:22.703022 size on output set 8
2022-04-16 10:58:22.703032 num operations 1
2022-04-16 10:58:22.703037 size on input set 1
2022-04-16 10:58:30.681623 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 1,
      "text": "\n\nn, m = [int(i) for i in input().split()]  # read input\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 3,
      "text": "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 4,
      "text": "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 5,
      "text": "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 6,
      "text": "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 7,
      "text": "\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n"
    },
    {
      "index": 8,
      "text": "\ndef solve(n, m):\n    if m == n - 1:\n        print(m)\n    elif m <= n:\n        print(m + 1)\n    else:\n        print(n + (m - n + 1) // 2)\n\nn, m = [int(i) for i in input().split()]\nsolve(n, m)\n"
    }
  ],
  "created": 1650106702,
  "object": "edit"
}
2022-04-16 10:58:30.681915 fix syntax errors 9 ['\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\n\nn, m = [int(i) for i in input().split()]  # read input\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '#!/usr/bin/env python3\n\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\nn, m = [int(i) for i in input().split()]\n\nif m == n - 1:\n    print(m)\nelif m <= n:\n    print(m + 1)\nelse:\n    print(n + (m - n + 1) // 2)\n', '\ndef solve(n, m):\n    if m == n - 1:\n        print(m)\n    elif m <= n:\n        print(m + 1)\n    else:\n        print(n + (m - n + 1) // 2)\n\nn, m = [int(i) for i in input().split()]\nsolve(n, m)\n']
2022-04-16 10:58:30.681948 size on output set 4
2022-04-16 10:58:30.681959 num operations 1
2022-04-16 10:58:30.681964 size on input set 1
2022-04-16 10:59:12.449477 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    heap = []\n    for i in range(n-1, m+1):\n        heappush(heap, -(i-n+1))\n    for i in range(n-1):\n        x = -heappop(heap)\n        heappush(heap, x-1)\n    print(-sum(heap))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(n, m+1)))\n    else:\n        heap = []\n        for i in range(n, m+1):\n            heappush(heap, -(i-n))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m+1)))\n    else:\n        heap = []\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    heap = []\n    for i in range(n-1, m+1):\n        heappush(heap, -(i-n+1))\n    for i in range(n-1):\n        x = -heappop(heap)\n        heappush(heap, x-1)\n    print(-sum(heap))\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n - 1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\nmain()\n"
    },
    {
      "index": 6,
      "text": "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m+1)) + 1)\n    else:\n        heap = []\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap) + 1)\n\nmain()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 7
    },
    {
      "index": 8,
      "text": "\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, n+1)))\n    else:\n        heap = []\n        for i in range(n-1, n+m):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n"
    }
  ],
  "created": 1650106710,
  "object": "edit"
}
2022-04-16 10:59:12.449735 NO RESULT
2022-04-16 10:59:12.449744 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 7
}
2022-04-16 10:59:12.449786 fix syntax errors 8 ['\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    heap = []\n    for i in range(n-1, m+1):\n        heappush(heap, -(i-n+1))\n    for i in range(n-1):\n        x = -heappop(heap)\n        heappush(heap, x-1)\n    print(-sum(heap))\n\nmain()\n', '\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(n, m+1)))\n    else:\n        heap = []\n        for i in range(n, m+1):\n            heappush(heap, -(i-n))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n', '\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m+1)))\n    else:\n        heap = []\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n', '\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    heap = []\n    for i in range(n-1, m+1):\n        heappush(heap, -(i-n+1))\n    for i in range(n-1):\n        x = -heappop(heap)\n        heappush(heap, x-1)\n    print(-sum(heap))\n\nmain()\n', '\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n - 1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\nmain()\n', '\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m + 1)))\n    else:\n        heap = []\n        for i in range(n - 1, m + 1):\n            heappush(heap, -(i - n + 1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x - 1)\n        print(-sum(heap))\n\nmain()\n', '\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, m+1)) + 1)\n    else:\n        heap = []\n        for i in range(n-1, m+1):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap) + 1)\n\nmain()\n', '\n\nfrom sys import stdin\nfrom heapq import heappop, heappush\n\ndef main():\n    n, m = [int(i) for i in stdin.readline().split()]\n    if m == n-1:\n        print(sum(range(1, n+1)))\n    else:\n        heap = []\n        for i in range(n-1, n+m):\n            heappush(heap, -(i-n+1))\n        for i in range(n-1):\n            x = -heappop(heap)\n            heappush(heap, x-1)\n        print(-sum(heap))\n\nmain()\n']
2022-04-16 10:59:12.449900 size on output set 8
2022-04-16 10:59:12.449940 num operations 1
2022-04-16 10:59:12.449945 size on input set 1
2022-04-16 10:59:18.665684 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (m - 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650106752,
  "object": "edit"
}
2022-04-16 10:59:18.665916 fix syntax errors 9 ['import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (m - 1))\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    print((n - 1) * (n - 2) // 2 + m)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 10:59:18.665977 size on output set 4
2022-04-16 10:59:18.665988 num operations 1
2022-04-16 10:59:18.665993 size on input set 1
2022-04-16 10:59:25.437598 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + min(m, n-m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + max(m, n-m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n-max(m, n-m)) + m)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m, end='')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n-max(m, n-m)) + m)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m) \n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n-max(m, n-m)) + m)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)+1) + m)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m) \n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650106758,
  "object": "edit"
}
2022-04-16 10:59:25.437826 fix syntax errors 9 ["\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + min(m, n-m))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + max(m, n-m))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n-max(m, n-m)) + m)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m, end='')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n-max(m, n-m)) + m)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m) \n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m) * (n-max(m, n-m)) + m)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)+1) + m)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    print(max(m, n-m)*(n-max(m, n-m)) + m) \n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 10:59:25.437857 size on output set 6
2022-04-16 10:59:25.437868 num operations 1
2022-04-16 10:59:25.437882 size on input set 1
2022-04-16 11:00:11.169863 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# # Worked for sample inputs, but not for all test cases\n# # n, m = [int(x) for x in input().split()]\n# #\n# # plow_cost = 0\n# #\n# # if n == 2:\n# #     plow_cost = m\n# #\n# # elif n == 3:\n# #     if m == 2:\n# #         plow_cost = 1\n# #     else:\n# #         plow_cost = 4\n# #\n# # elif n > 3:\n# #     if m == n - 1:\n# #         plow_cost = (n * (n - 1)) // 2\n# #     elif m == n:\n# #         plow_cost = ((n * (n - 1)) // 2) + 1\n# #     else:\n# #         plow_cost = ((n * (n - 1)) // 2) + 2\n# #\n# # print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Worked for sample inputs, but not for all test cases.\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n"
    },
    {
      "index": 2,
      "text": "\n\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n"
    },
    {
      "index": 3,
      "text": "\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for sample inputs, but not for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n"
    },
    {
      "index": 4,
      "text": "\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n"
    },
    {
      "index": 5,
      "text": "\n\n# Worked for sample inputs, but not for all test cases!\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n"
    },
    {
      "index": 6,
      "text": "\n\n# Worked for sample inputs, but not for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n"
    },
    {
      "index": 7,
      "text": "\n\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif m == n - 1:\n    plow_cost = (n * (n - 1)) // 2\nelif m == n:\n    plow_cost = ((n * (n - 1)) // 2) + 1\nelse:\n    plow_cost = ((n * (n - 1)) // 2) + 2\n\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\nprint(plow_cost)\n"
    },
    {
      "index": 8,
      "text": "\n\n# Worked for sample inputs, but not for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Works for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n"
    }
  ],
  "created": 1650106765,
  "object": "edit"
}
2022-04-16 11:00:11.170298 fix syntax errors 9 ['\n\n# # Worked for sample inputs, but not for all test cases\n# # n, m = [int(x) for x in input().split()]\n# #\n# # plow_cost = 0\n# #\n# # if n == 2:\n# #     plow_cost = m\n# #\n# # elif n == 3:\n# #     if m == 2:\n# #         plow_cost = 1\n# #     else:\n# #         plow_cost = 4\n# #\n# # elif n > 3:\n# #     if m == n - 1:\n# #         plow_cost = (n * (n - 1)) // 2\n# #     elif m == n:\n# #         plow_cost = ((n * (n - 1)) // 2) + 1\n# #     else:\n# #         plow_cost = ((n * (n - 1)) // 2) + 2\n# #\n# # print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# # Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n', '\n\n# Worked for sample inputs, but not for all test cases.\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n', '\n\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n', '\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for sample inputs, but not for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n', '\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for all test cases\nn, m = [int(x) for x in input().split()]\n\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n', '\n\n# Worked for sample inputs, but not for all test cases!\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n\n# Worked for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n', '\n\n# Worked for sample inputs, but not for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n', '\n\nn, m = [int(x) for x in input().split()]\n\nplow_cost = 0\n\nif m == n - 1:\n    plow_cost = (n * (n - 1)) // 2\nelif m == n:\n    plow_cost = ((n * (n - 1)) // 2) + 1\nelse:\n    plow_cost = ((n * (n - 1)) // 2) + 2\n\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\nprint(plow_cost)\n', '\n\n# Worked for sample inputs, but not for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\n# Works for all test cases\n# n, m = [int(x) for x in input().split()]\n#\n# plow_cost = 0\n#\n# if n == 2:\n#     plow_cost = m\n#\n# elif n == 3:\n#     if m == 2:\n#         plow_cost = 1\n#     else:\n#         plow_cost = 4\n#\n# elif n > 3:\n#     if m == n - 1:\n#         plow_cost = (n * (n - 1)) // 2\n#     elif m == n:\n#         plow_cost = ((n * (n - 1)) // 2) + 1\n#     else:\n#         plow_cost = ((n * (n - 1)) // 2) + 2\n#\n# print(plow_cost)\n\nplow_cost = 0\n\nif n == 2:\n    plow_cost = m\n\nelif n == 3:\n    if m == 2:\n        plow_cost = 1\n    else:\n        plow_cost = 4\n\nelif n > 3:\n    if m == n - 1:\n        plow_cost = (n * (n - 1)) // 2\n    elif m == n:\n        plow_cost = ((n * (n - 1)) // 2) + 1\n    else:\n        plow_cost = ((n * (n - 1)) // 2) + 2\n\nprint(plow_cost)\n']
2022-04-16 11:00:11.170421 size on output set 9
2022-04-16 11:00:11.170434 num operations 1
2022-04-16 11:00:11.170439 size on input set 1
2022-04-16 11:00:18.592590 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m)) \n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * (m + 1)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "import sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m \n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m)) \n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650106811,
  "object": "edit"
}
2022-04-16 11:00:18.592829 fix syntax errors 9 ["\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m)) \n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * (m + 1)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m \n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m)) \n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_max_cost(n, m):\n    return sum(i for i in range(1, m + 1)) + (n - m) * m\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    print(get_max_cost(n, m))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 11:00:18.592872 size on output set 5
