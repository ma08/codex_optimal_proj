["\na, b, c, k = map(int, input().split())\nans = min(a, k)\nk -= ans\nif k > 0:\n    ans -= min(b, k)\nprint(ans)\n", "\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i + 1][j] = dp[i][j] + (h[i] - 1) // a\n            else:\n                dp[i + 1][j] = dp[i][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease this value by one.\n# We will also keep track of the number of secret technique uses we have left. We start by assuming that we have k secret technique uses left.\n# If we later find out that we don't have enough secret technique uses left to kill a monster, we will decrease this value to 0.\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease this value by one.\n# We will also keep track of the number of secret technique uses we have left. We start by assuming that we have k uses.\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn\n# If we use our secret technique on a monster with high health points, we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [0] * (k + 1)\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[j] = dp[j] + (h[i] - 1) // a\n            else:\n                dp[j] = dp[j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[j] = max(dp[j], dp[j - 1] + (h[i] - b) // a)\n    print(dp[k])\n\nmain()\n", "#!/usr/bin/env python3\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i - 1] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i - 1] - 1) // a + (h[i - 1] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n", "\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n", "\n\ndef main():\n    s = input()\n    t = input()\n    if s == t:\n        print('same')\n    elif s.lower() == t.lower():\n        print('case-insensitive')\n    else:\n        print('different')\n\nmain()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    s = input()\n    ans = 0\n    for i in range(1, n):\n        a = set(s[:i])\n        b = set(s[i:])\n        ans = max(ans, len(a & b))\n    print(ans)\n\nmain()\n", "\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0 for _ in range(k + 1)] for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\nhp.sort(reverse=True)\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn,\n# so we want to use it on monsters that have the lowest health points.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn,\n# and which monsters we can't kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False and use our secret technique on the monster.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n        if i == 0:\n            dp[i][0] = (h[i] - 1) // a\n            continue\n    for i in range(n):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n            if i > 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n", "\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"]