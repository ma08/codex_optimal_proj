2022-04-16 06:54:23.434605 num operations 1
2022-04-16 06:54:23.434622 size on input set 1
2022-04-16 06:54:36.857465 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = a[root - 1]\n    dp[root][1] = a[root - 1]\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += dp[child][1]\n        dp[root][1] += max(dp[child][0], dp[child][1])\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\n#import sys\n#sys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] = max(dp[child][0], dp[child][1])\n        dp[root][1] = dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\n'''\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n'''\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 3,
      "text": "\n"
    },
    {
      "index": 4,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = sum(max(dp[child][0], dp[child][1]) for child in children)\ndp[root][1] = sum(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 6,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = sum(max(dp[child][0], dp[child][1]) for child in children)\ndp[root][1] = sum(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 7,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n'''\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n'''\n"
    },
    {
      "index": 8,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1650092063,
  "object": "edit"
}
2022-04-16 06:54:36.857762 fix syntax errors 9 ['\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children) + a[root - 1]\ndp[root][1] = max(dp[child][0] for child in children) + a[root - 1]\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = a[root - 1]\n    dp[root][1] = a[root - 1]\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += dp[child][1]\n        dp[root][1] += max(dp[child][0], dp[child][1])\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\n#import sys\n#sys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] = max(dp[child][0], dp[child][1])\n        dp[root][1] = dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', "\n\n'''\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n'''\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n", '\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = sum(max(dp[child][0], dp[child][1]) for child in children)\ndp[root][1] = sum(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = sum(max(dp[child][0], dp[child][1]) for child in children)\ndp[root][1] = sum(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\'\'\'\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n\'\'\'\n', '\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-16 06:54:36.857920 size on output set 8
2022-04-16 06:54:36.857930 num operations 1
2022-04-16 06:54:36.857935 size on input set 1
2022-04-16 06:54:43.902229 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\n\ndef main():\n\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\n\ndef main() -> None:\n    pass\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650092076,
  "object": "edit"
}
2022-04-16 06:54:43.902560 fix syntax errors 9 ["\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\n\ndef main():\n\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\n\ndef main() -> None:\n    pass\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef readline_from_stdin():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 06:54:43.902605 size on output set 5
