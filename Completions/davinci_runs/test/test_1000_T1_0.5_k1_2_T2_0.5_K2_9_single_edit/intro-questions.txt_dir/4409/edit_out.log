2022-04-16 07:07:14.036690 num operations 1
2022-04-16 07:07:14.036708 size on input set 1
2022-04-16 07:07:27.708126 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys, os, math\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()] + [0]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i <= n:\n        j = i + 1\n        while j <= n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 2):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 2]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 2, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 2].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != len(indices) - 1:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != min_node:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = []\n    for i in range(len(indices)):\n        adj_list.append([])\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[x2] - a[y1]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[y2] - a[x1]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(range(len(adj_list)), key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650092834,
  "object": "edit"
}
2022-04-16 07:07:27.708568 fix syntax errors 9 ["\nimport sys, os, math\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()] + [0]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i <= n:\n        j = i + 1\n        while j <= n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 2):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 2]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 2, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 2].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != len(indices) - 1:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != min_node:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = []\n    for i in range(len(indices)):\n        adj_list.append([])\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[x2] - a[y1]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[y2] - a[x1]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(range(len(adj_list)), key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-16 07:07:27.708817 size on output set 6
2022-04-16 07:07:27.708829 num operations 1
2022-04-16 07:07:27.708834 size on input set 1
2022-04-16 07:07:49.980197 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 1,
      "text": "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i,i-1)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i,i+1)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i,i-1)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i,i+1)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 2,
      "text": "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1] and a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i-1] and a[i]>a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1] and a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i-1] and a[i]<a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 3,
      "text": "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    if a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    if a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 4,
      "text": "\n\n# cook your dish here \nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 5,
      "text": "\n\n# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    s=input()\n    d={}\n    for i in s:\n        if i not in d:\n            d[i]=1\n        else:\n            d[i]+=1\n    p=0\n    for i in d:\n        if d[i]%2==0:\n            p+=1\n    if p%2==0:\n        print(\"Player2\")\n    else:\n        print(\"Player1\")\n"
    },
    {
      "index": 6,
      "text": "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i+1)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i+1)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 7,
      "text": "# cook your dish here\nn=int(input())\narr=list(map(int,input().split()))\ncount=0\nfor i in range(0,n):\n    if i==0:\n        if arr[i]>arr[i+1]:\n            arr[i]=arr[i]-arr[i+1]\n            count+=1\n            print(2,i+1,i+2)\n    elif i==n-1:\n        if arr[i]>arr[i-1]:\n            arr[i]=arr[i]-arr[i-1]\n            count+=1\n            print(2,i+1,i)\n    else:\n        if arr[i]>arr[i-1] and arr[i]>arr[i+1]:\n            arr[i]=arr[i]-max(arr[i-1],arr[i+1])\n            count+=1\n            if arr[i-1]>arr[i+1]:\n                print(2,i+1,i)\n            else:\n                print(2,i+1,i+2)\n        elif arr[i]<arr[i+1] and arr[i]<arr[i-1]:\n            arr[i]=arr[i]+max(arr[i-1],arr[i+1])\n            count+=1\n            if arr[i-1]>arr[i+1]:\n                print(1,i+1,i)\n            else:\n                print(1,i+1,i+2)\n        elif arr[i]>arr[i-1]:\n            arr[i]=arr[i]-arr[i-1]\n            count+=1\n            print(2,i+1,i)\n        elif arr[i]>arr[i+1]:\n            arr[i]=arr[i]-arr[i+1]\n            count+=1\n            print(2,i+1,i+2)\n        elif arr[i]<arr[i-1]:\n            arr[i]=arr[i]+arr[i-1]\n            count+=1\n            print(1,i+1,i)\n        elif arr[i]<arr[i+1]:\n            arr[i]=arr[i]+arr[i+1]\n            count+=1\n            print(1,i+1,i+2)\nprint(count)\n"
    },
    {
      "index": 8,
      "text": "\n\n\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i+1)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i+1)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    }
  ],
  "created": 1650092847,
  "object": "edit"
}
2022-04-16 07:07:49.980472 fix syntax errors 9 ['\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i,i-1)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i,i+1)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i,i-1)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i,i+1)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1] and a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i-1] and a[i]>a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1] and a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i-1] and a[i]<a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    if a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    if a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here \nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n\n# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    s=input()\n    d={}\n    for i in s:\n        if i not in d:\n            d[i]=1\n        else:\n            d[i]+=1\n    p=0\n    for i in d:\n        if d[i]%2==0:\n            p+=1\n    if p%2==0:\n        print("Player2")\n    else:\n        print("Player1")\n', '\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i+1)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i+1)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '# cook your dish here\nn=int(input())\narr=list(map(int,input().split()))\ncount=0\nfor i in range(0,n):\n    if i==0:\n        if arr[i]>arr[i+1]:\n            arr[i]=arr[i]-arr[i+1]\n            count+=1\n            print(2,i+1,i+2)\n    elif i==n-1:\n        if arr[i]>arr[i-1]:\n            arr[i]=arr[i]-arr[i-1]\n            count+=1\n            print(2,i+1,i)\n    else:\n        if arr[i]>arr[i-1] and arr[i]>arr[i+1]:\n            arr[i]=arr[i]-max(arr[i-1],arr[i+1])\n            count+=1\n            if arr[i-1]>arr[i+1]:\n                print(2,i+1,i)\n            else:\n                print(2,i+1,i+2)\n        elif arr[i]<arr[i+1] and arr[i]<arr[i-1]:\n            arr[i]=arr[i]+max(arr[i-1],arr[i+1])\n            count+=1\n            if arr[i-1]>arr[i+1]:\n                print(1,i+1,i)\n            else:\n                print(1,i+1,i+2)\n        elif arr[i]>arr[i-1]:\n            arr[i]=arr[i]-arr[i-1]\n            count+=1\n            print(2,i+1,i)\n        elif arr[i]>arr[i+1]:\n            arr[i]=arr[i]-arr[i+1]\n            count+=1\n            print(2,i+1,i+2)\n        elif arr[i]<arr[i-1]:\n            arr[i]=arr[i]+arr[i-1]\n            count+=1\n            print(1,i+1,i)\n        elif arr[i]<arr[i+1]:\n            arr[i]=arr[i]+arr[i+1]\n            count+=1\n            print(1,i+1,i+2)\nprint(count)\n', '\n\n\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i+1)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i+1)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n']
2022-04-16 07:07:49.980616 size on output set 9
