2022-04-16 08:00:01.052612 num operations 1
2022-04-16 08:00:01.052629 size on input set 1
2022-04-16 08:00:17.593666 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(segments))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, segments):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(segments[i][2])\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(segments))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove())) + \" \")\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove().reverse())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            return self.segments[left]\n        mid = (left + right) // 2\n        return self.merge(self.build(left, mid, 2 * i + 1), self.build(mid + 1, right, 2 * i + 2))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2 + 1\n        return self.query(left, right, segment[:mid]) + self.query(left, right, segment[mid:])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.segments)):\n            if self.query(self.segments[i][0], self.segments[i][1], self.tree) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(n - i)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        mid = (left + right) // 2\n        self.tree.append(self.segments[mid])\n        if left != right:\n            self.build(left, mid - 1, 2 * i + 1)\n            self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2 + 1\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k).remove()))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove()))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650096001,
  "object": "edit"
}
2022-04-16 08:00:17.594100 fix syntax errors 9 ['\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(segments))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, segments):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(segments[i][2])\n        return removed\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(segments))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove())) + " ")\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove().reverse())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            return self.segments[left]\n        mid = (left + right) // 2\n        return self.merge(self.build(left, mid, 2 * i + 1), self.build(mid + 1, right, 2 * i + 2))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2 + 1\n        return self.query(left, right, segment[:mid]) + self.query(left, right, segment[mid:])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.segments)):\n            if self.query(self.segments[i][0], self.segments[i][1], self.tree) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(n - i)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        mid = (left + right) // 2\n        self.tree.append(self.segments[mid])\n        if left != right:\n            self.build(left, mid - 1, 2 * i + 1)\n            self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2 + 1\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove())))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k).remove()))\n    print(" ".join(map(str, SegmentTree(segments, k).remove()))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 08:00:17.594266 size on output set 9
