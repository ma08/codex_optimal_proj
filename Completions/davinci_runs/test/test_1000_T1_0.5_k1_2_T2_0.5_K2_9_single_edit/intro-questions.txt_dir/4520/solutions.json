["from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) + [i] for i in range(n)]\ninfo = sorted(info, key = itemgetter(1))\nmax_num = info[-1][1]\n\nN = max_num\nINF = 0\nLV = (N-1).bit_length()\nN0 = 2**LV\ndata = [0]*(2*N0)\nlazy = [0]*(2*N0)\n\ndef gindex(l, r):\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if not v:\n            continue\n        lazy[2*i-1] += v; lazy[2*i] += v\n        data[2*i-1] += v; data[2*i] += v\n        lazy[i-1] = 0\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] += x; data[R-1] += x\n        if L & 1:\n            lazy[L-1] += x; data[L-1] += x\n            L += 1\n        L >>= 1; R >>= 1\n    for i in ids:\n        data[i-1] = max(data[2*i-1], data[2*i])\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R-1])\n        if L & 1:\n            s = max(s, data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\nans = []\nfor i in range(n):\n    l, r, j = info[i]\n    r += 1\n    if query(l, r) < m:\n        update(l, r, 1)\n    else:\n        ans.append(j+1)\nprint(len(ans))\nprint(*ans)", "\nn,k = list(map(int,input().split()))\nL = [list(map(int,input().split())) for i in range(n)]\n\nfor i in range(n):\n    L[i].append(i)\n\nL.sort(key=lambda x:x[1])\n\n# print(L)\n\n\ndef c(x):\n    for i in range(x[0],x[1]+1):\n        if T[i] >= k:\n            return 0\n    return 1\n\nans = 0\nA=[]\nT = [0] * 203\ni = 0\nt = 0\nwhile i < n :\n    if c(L[i]) == 1:\n        for j in range(L[i][0], L[i][1]+1):\n            T[j] += 1\n        t = L[i][0]\n    else:\n        A.append(L[i][2]+1)\n        ans += 1\n\n    i += 1\n# print(T)\nA.sort()\nprint(ans)\nprint(\" \".join([str(i) for i in A]))\n\n", "n, k = list(map(int, input().split()))\nar = []\nfor i in range(n):\n    lolk = list(map(int, input().split()))\n    ar.append([lolk[0], 0, lolk[1], i + 1])\n    ar.append([lolk[1], 1, lolk[0], i + 1])\nar.sort()\nqueue = []\nkek = 0\nans = 0\nans1 = []\nksjdfks = set()\nfor time, type, end, lol in ar:\n    if lol not in ksjdfks:\n        if type == 0:\n            kek += 1\n            queue.append([time, type, end, lol])\n            queue.sort(key=lambda x: x[2])\n            if kek > k:\n                ans += 1\n                ans1.append(queue[-1][3])\n                ksjdfks.add(queue[-1][3])\n                queue.pop()\n                kek -= 1\n        else:\n            kek -= 1\n            queue.pop(queue.index([end, 0, time, lol]))\nprint(ans)\nprint(*ans1)", "from heapq import heapify, heappop, heappush\nn, k = list(map(int, input().split()))\nN = 2*10**5+2\nsegs = []\nplus = [0 for _ in range(N)]\nminus = [0 for _ in range(N)]\nans = []\nheapmin = []\nheapmax = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    heappush(heapmin, (x-1,y-1,i+1))\n\nheight = 0\nfor i in range(N):\n    height+=plus[i]\n    height-=minus[i]\n    while len(heapmin) > 0 and heapmin[0][0] <= i:\n        x, y, ii = heappop(heapmin)\n        heappush(heapmax, (-y, x, ii))\n        height += 1 \n        minus[y+1]+=1\n    while height > k:\n        y, x, ii = heappop(heapmax)\n        y=-y\n        height-=1\n        plus[y+1]+=1\n        ans.append(ii)\nprint(len(ans))\nprint(*ans)", "from math import *\nn,k = map(int,input().split())\na = []\npre = [0 for i in range(205)]\nfor i in range(n):\n    u,v = map(int,input().split())\n    a.append([u,v,i+1])\n    for i in range(u,v+1):\n        pre[i] += 1\nans = []\na.sort()\ni = 1\nwhile(1):\n    flag = 0\n    for i in range(205):\n        if pre[i] > k:\n            flag = i\n            break\n    if flag == 0:\n        break\n    m = 0\n    m1 = 0\n    for i in range(n):\n        if a[i][0] > flag:\n            break\n        if m < a[i][1]:\n            m = a[i][1]\n            m1 =i\n    ans.append(a[m1][2])\n    for i in range(a[m1][0],a[m1][1]+1):\n        pre[i] -= 1\n    del(a[m1])\n    n -= 1\nprint(len(ans))\nfor i in ans:\n    print(i,end = \" \")\nprint()", "from math import *\n\nn,k = map(int, input().split())\n\nnum = [[] for i in range( 300) ]\n\nsegment = [0]\n\nfor i in range(1, n+1):\n    l, r = map(int, input().split())\n\n    num[l].append(i)\n    num[r+1].append(-i)\n\n    segment.append((l, r+1, r-l))\n\nrep = 0\ncurSegment = []\nrem = []\n\nfor i in range(300):\n    for a in num[i]:\n        if a >= 0:\n            curSegment.append(a)\n        elif (-a) in curSegment:\n            curSegment.remove(-a)\n\n    while len(curSegment) > k:\n        rep += 1\n        plusAdroite = 0\n        aVirer = 0\n        for j in curSegment:\n            if segment[j][1] >= plusAdroite:\n                plusAdroite = segment[j][1]\n                aVirer = j\n        \n        curSegment.remove(aVirer)\n        rem.append(aVirer)\n\nprint(rep)\nprint(*sorted(rem))", "import heapq\n\nn,k = list(map(int,input().split()))\n\nllis = [ [] for i in range(2 * (10**5) + 1) ]\nrlis = [ [] for i in range(2 * (10**5) + 1) ]\nflag = [0] * (2 * (10**5) + 1)\n\nfor i in range(n):\n\n    l,r = list(map(int,input().split()))\n    \n    llis[l].append([i+1,r])\n    rlis[r].append([i+1,l])\n\nnow = 0\nrq = []\nans = []\nfor i in range(2 * (10 ** 5)):\n    \n    i += 1\n\n    for j in llis[i]:\n        now += 1\n        ind = j[0]\n        r = j[1]\n        flag[ind] = 1\n        heapq.heappush(rq,[-1 * r,ind])\n\n    for j in rlis[i-1]:\n        \n        ind = j[0]\n        if flag[ind] == 1:\n            now -= 1\n            flag[ind] = 0\n\n    while now > k:\n\n        nowq = heapq.heappop(rq)\n        ind = nowq[1]\n\n        if flag[ind] == 1:\n            ans.append(ind)\n            now -= 1\n            flag[ind] = 0\n\n\nprint(len(ans))\nprint(\" \".join(map(str,ans)))\n\n        \n", "from bisect import insort_left as bs\nb=[]\na=[]\nn,k=list(map(int,input().split()))\nfor i in range(n):\n    x,y=list(map(int,input().split()))\n    a.append([x,y,i+1])\n    b.append([x,y,i+1])\na.sort()\nans=[[a[0][1],a[0][2]]]\nle=1\nvis=[0]*201\nprintans=[]\nfor i in a:\n    x,y,ind=i[0],i[1],i[2]\n    if i!=a[0]:\n        bs(ans,[y,ind],0,le)\n        le+=1\n    for j in range(x,y+1):\n        if vis[j]>=k:\n            p,q=ans.pop()\n            le-=1\n            for l in range(b[q-1][0],p+1):\n                vis[l]-=1\n                # print(\"cnkjsn\")\n            printans.append(q)    \n            for l in range(x,y+1):\n                vis[l]+=1\n            # print(vis[28:31])\n            break\n    else:\n        for j in range(x,y+1):\n            vis[j]+=1\n    # print(ans,vis[28:31])        \n            \n    # print(print(vis[1:10],ans)\n    #     \n    # )\n    # print(vis[1:10],ans)\n        \nprint(len(printans))\nprint(*printans)\n    \n        \n        \n", "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\n\nS=[tuple(map(int,input().split()))+(i+1,) for i in range(n)]\nS.sort()\n\nsegtemp=2*10**5\nseg_el=1<<((segtemp).bit_length())# Segment tree\u306e\u53f0\u306e\u8981\u7d20\u6570\nSEG=[0]*(2*seg_el)# 1-indexed\u306a\u306e\u3067\u3001\u8981\u7d20\u65702*seg_el.Segment tree\u306e\u521d\u671f\u5024\u3067\u521d\u671f\u5316\n\ndef getvalue(n,seg_el):# \u4e00\u70b9\u306e\u5024\u3092\u53d6\u5f97\n    i=n+seg_el\n    ANS=0\n    \n    ANS+=SEG[i]\n    i>>=1# \u5b50\u30ce\u30fc\u30c9\u3078\n    \n    while i!=0:\n        ANS+=SEG[i]\n        i>>=1\n\n    return ANS\n\ndef updates(l,r,x):# \u533a\u9593[l,r)\u306emin\u3092\u66f4\u65b0.\n    L=l+seg_el\n    R=r+seg_el\n\n    while L<R:\n        if L & 1:\n            SEG[L]+=x\n            L+=1\n\n        if R & 1:\n            R-=1\n            SEG[R]+=x\n        L>>=1\n        R>>=1\n\nind=0\nSH=[]\nANS=[]\nimport heapq\n\nfor point in range(segtemp):\n    while ind<n and S[ind][0]<=point:\n        l,r,x=S[ind]\n        updates(l,r+1,1)\n        ind+=1\n\n        heapq.heappush(SH,(-r,l,x))\n\n    #print(getvalue(point,seg_el),SH)\n\n    while getvalue(point,seg_el)>k:\n        r,l,x=heapq.heappop(SH)\n        r=-r\n        ANS.append(x)\n        updates(l,r+1,-1)\n\n    #print(point,ANS,getvalue(point,seg_el))\n        \nprint(len(ANS))\nprint(*ANS)\n        \n", "from heapq import *\nn, k = map(int, input().split())\nE = []\nopent = {}\nclos = {}\nfor i in range(n):\n    l, r = map(int, input().split())\n    E.append([l, 1, i])\n    E.append([r, -1, i])\n    opent[i] = r\n    clos[i] = l\nE.sort(key=lambda x: (x[0], -x[1], -opent[x[2]]))\nb = 0\nnow_r = []\nheapify(now_r)\ncnt_delet = 0\nans = []\ndeleted = set()\nfor x, t, i in E:\n    if t == 1:\n        heappush(now_r, -(opent[i] * 10 ** 6 + i))\n    else:\n        if i not in deleted:\n            cnt_delet += 1\n    if len(now_r) - cnt_delet > k:\n        for _ in range(len(now_r) - cnt_delet - k):\n            nm = heappop(now_r)\n            ind = (-nm) % 10 ** 6\n            ans.append(ind + 1)\n            deleted.add(ind)\nprint(len(ans))\nprint(*ans)", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\n\nn, k = map(int, readline().split())\n\ntmp = []\nfor i in range(n):\n    a,b = map(int, readline().split())\n    tmp.append([b,a,i])\ntmp.sort()\nans = []\nfor i in range(201):\n    s = 0\n    asd = []\n    for x in tmp:\n        if i <= x[0] and i >= x[1]:\n            s+=1\n            if s > k:\n                ans.append(x[2] + 1)\n                asd.append(x)\n    for x in asd:\n        tmp.remove(x)\nprint(len(ans))\nfor x in ans:\n    print(x,end=' ')", "n, k = map(int,input().split())\nN = 2 * 10 ** 5 + 1\npre = [0] * (N+1)\nseg = []\nfor i in range(n):\n\tx, y = map(int,input().split())\n\tx -= 1\n\ty -= 1\n\tseg.append([y,-x, i+1])\n\tpre[x] += 1\n\tpre[y + 1] -= 1\nseg.sort()\nseg.reverse()\nseg = [[-seg[i][1], seg[i][0], seg[i][2]] for i in range(len(seg))]\ncov = [0] * (N+1)\ncov[0] = pre[0]\nfor i in range(1, N):\n\tcov[i] = cov[i - 1] + pre[i]\nwyn = 0\nziomy = []\nfor i in range(N):\n\tp = 0\n\twhile cov[i] > k:\n\t\tmaksi = -1\n\t\topti = -1\n\t\tmini = 100000000000\n\t\tfor d in range(len(seg)):\n\t\t\tif seg[d][1] > maksi and seg[d][0] <= i:\n\t\t\t\tmini = 100000000000000\n\t\t\t\tmaksi = seg[d][1]\n\t\t\t\topti = d\n\t\t\telif seg[d][1] == maksi and seg[d][0] < mini and seg[d][0] <= i:\n\t\t\t\tmini = seg[d][0]\n\t\t\t\topti = d\n\t\tpt = seg[opti][1]\n\t\tziomy.append(seg[opti][2])\n\t\tpre[pt + 1] += 1\n\t\tpre[i] -= 1\n\t\tcov[i] -= 1\n\t\tp += 1\n\t\tseg.pop(opti)\n\tcov[i+1] = cov[i] + pre[i + 1]\n\twyn += p\nprint(wyn)\nprint(*ziomy)", "N = int(2e5+3)\ncum = [0] * N\nn, k = list(map(int, input().split()))\narr = [0] * n\nfor i in range(n):\n    arr[i] = [[0,0], i+1]\n    arr[i][0] = list(map(int, input().split()))    \n    cum[arr[i][0][0]] += 1\n    cum[arr[i][0][1]+1] -= 1\nfor i in range(1, N):\n    cum[i] += cum[i-1]\narr.sort()\nst = set()\nres, j, prev = [], 0, 0\nrmv = [0] * N\nfor i in range(N):\n    while j < n and arr[j][0][0] <= i:\n        st.add((arr[j][0][1], arr[j][1]))\n        j += 1\n    prev -= rmv[i]\n    while len(st) > 0 and cum[i] - prev > k:\n        it = max(st)\n        st.remove(it)\n        res.append(it[1])\n        rmv[it[0]+1] += 1\n        prev += 1\n\nprint(len(res))\nprint(*res)\n", "n, k = list(map(int, input().split()))\nar = []\nfor i in range(n):\n    lolk = list(map(int, input().split()))\n    ar.append([lolk[0], 0, lolk[1], i + 1])\n    ar.append([lolk[1], 1, lolk[0], i + 1])\nar.sort()\nqueue = []\nkek = 0\nans = 0\nans1 = []\nksjdfks = set()\nfor time, type, end, lol in ar:\n    if lol not in ksjdfks:\n        if type == 0:\n            kek += 1\n            queue.append([time, type, end, lol])\n            queue.sort(key=lambda x: x[2])\n            if kek > k:\n                ans += 1\n                ans1.append(queue[-1][3])\n                ksjdfks.add(queue[-1][3])\n                queue.pop()\n                kek -= 1\n        else:\n            kek -= 1\n            queue.pop(queue.index([end, 0, time, lol]))\nprint(ans)\nprint(*ans1)", "# -*- coding: utf-8 -*-\n\nimport sys\n\nline_count = 0\nsegments = []\nfor line in sys.stdin.readlines():\n    inputs = line.split()\n    if line_count == 0:\n        n = int(inputs[0])\n        k = int(inputs[1])\n    else:\n        l = int(inputs[0])\n        r = int(inputs[1])\n        segments.append((l, r))\n    if line_count == n:\n        break\n    line_count += 1\n\nremoved = [False for i in range(n)]\nremove_count = 0\nremoved_list = []\nfor i in range(1, 201):\n    max_i = 0\n    covering = []\n    for j in range(n):\n        if removed[j]:\n            continue\n        l, r = segments[j]\n        if l <= i and i <= r:\n            covering.append((r, j))\n    to_remove = len(covering) - k\n    if to_remove > 0:\n        covering.sort()\n        for _ in range(to_remove):\n            _, j = covering.pop()\n#            print(i, j, segments[j])\n            removed[j] = True\n            removed_list.append(j)\n\nprint(len(removed_list))\nfor j in removed_list:\n    print(j + 1, end = \" \")", "import sys\n\n[n,k]=[int(i) for i in sys.stdin.readline().split()]\n\narr=[0]*201\n\nseg=[]\n\nfor i in range(n):\n\t[l,r]=[int(j) for j in sys.stdin.readline().split()]\n\n\tseg.append([r,l,r,i+1])\n\n\tfor x in range(l,r+1):\n\t\tarr[x]+=1\n\nseg.sort(reverse=True)\n\nans_arr=[]\n# ind=0\ninc=[0]*n\n\nfor w in range(n):\n\t# check\n\tdone=1\n\tval=0\n\tfor g in range(1,201):\n\t\tif(arr[g]>k):\n\t\t\tdone=0\n\t\t\tval=g\n\t\t\tbreak\n\n\tif(done==1):\n\t\tbreak\n\telse:\n\t\tcur=n+2\n\t\tfor q in range(n):\n\t\t\tif(inc[q]==0):\n\t\t\t\tl1=seg[q][1]\n\t\t\t\tr1=seg[q][2]\n\t\t\t\tif(l1<=val<=r1):\n\t\t\t\t\tinc[q]=1\n\t\t\t\t\tcur=q\n\t\t\t\t\tans_arr.append(seg[q][3])\n\t\t\t\t\tbreak\t\t\t\t\t\n\n\t\t# l1=seg[ind][1]\n\t\t# r1=seg[ind][2]\n\n\t\tfor p in range(seg[cur][1],seg[cur][2]+1):\n\t\t\tarr[p]-=1\n\n\t\t# ans_arr.append(seg[ind][3])\n\t\t# ind+=1\n\nans_arr.sort()\n\nprint(len(ans_arr))\nfor e in range(len(ans_arr)):\n\tprint(ans_arr[e],end=\" \")\n\n\n\n\n", "n, k = map(int, input().split())\ns = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    s.append([r, l, i]) # Greedy on largest right endpoint\ns.sort()\n\nans = []\nfor i in range(201):\n    a = 0\n    u = []\n    for tmp in s:\n        if i <= tmp[0] and i >= tmp[1]:\n            a += 1\n            if a > k:\n                u.append(tmp)\n                ans.append(tmp[2] + 1)\n    for tmp in u:\n        s.remove(tmp)\nprint(len(ans))\nprint(' '.join(map(str, ans)))", "'''\ntemplate author-: Pyduper\n'''\n \n# MAX = pow(10, 5)\n# stdin = open(\"testdata.txt\", \"r\")\n# ip = stdin\n# def input():\n# \treturn ip.readline().strip()\n\nN = 250\nn, k = map(int, input().split())\n\nsegs = [[0, 0] for _ in range(n)]\ncnt = [0]*N \nans = [0]*n\nfor i in range(n):\n\tsegs[i][0], segs[i][1] = map(int, input().split())\n\tcnt[segs[i][0]] += 1\n\tcnt[segs[i][1]+1] -= 1\n\nfor i in range(N-1):\n\tcnt[i+1] += cnt[i]\n\nfor i in range(N-1):\n\twhile cnt[i] > k:\n\t\tpos = -1\n\t\tfor p in range(n):\n\t\t\tif not ans[p] and segs[p][0] <= i <= segs[p][1] and (pos == -1 or segs[p][1] > segs[pos][1]):\n\t\t\t\tpos = p \n\t\tassert pos != -1\n\n\t\tfor j in range(segs[pos][0], segs[pos][1]+1):\n\t\t\tcnt[j] -= 1\n\t\tans[pos] = 1\nprint(ans.count(1))\nfor i in range(n):\n\tif ans[i]: print(i+1, end=\" \")\nprint()", "n, k = map(int, input().split())\n\np = []\n\nt = [0]*200\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    p.append((i+1, l, r))\n\n\np.sort(key=lambda x:x[1])\n\n\nr = []\nopened = []\nfor pp in p:\n    #print(\"---\")\n    #print(pp)\n    #print(opened)\n    opened = list(filter(lambda x:x[2] >= pp[1], opened))\n    #print(opened)\n    opened.append(pp)\n    #print(opened)\n    if len(opened) > k:\n        opened.sort(key=lambda x: x[2])\n        x, _, _ = opened.pop()\n        r.append(x)\nprint(len(r))\n\nprint(*r)", "scount, badness = [int(x) for x in input().split(' ')]\nsegments = []\nlength = 200\nfor i in range(scount):\n    segments.append([int(x) - 1 for x in input().split(' ')])\n    segments[-1].append(True)\narray = [[] for x in range(length)]\nbadcheck = [0 for x in range(length)]\nfor i in range(scount):\n    for k in range(segments[i][0], segments[i][1] + 1):\n        array[k].append([segments[i][1], i])\n        badcheck[k] += 1\nfor i in range(length):\n    array[i].sort()\nres = []\nfor i in range(length):\n    while badcheck[i] > badness:\n        fn = array[i].pop()\n        while not segments[fn[1]][2] == True:\n            fn = array[i].pop()\n        segments[fn[1]][2] = False\n        res.append(fn[1])\n        for k in range(i, fn[0] + 1):\n            badcheck[k] -= 1\nres.sort()\nprintable = ''\nfor i in res:\n    printable += str(i + 1) + ' '\nprint(len(res))\nprint(printable)", "# -*- coding: utf-8 -*-\n \nimport sys\n \ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n \nclass SegTreeIndex:\n \n    def __init__(self, n, func, init):\n \n        self.n = n\n        self.func = func\n        self.init = init\n        n2 = 1\n        while n2 < n:\n            n2 <<= 1\n        self.n2 = n2\n        self.tree = [self.init] * (n2 << 1)\n        self.index = [self.init] * (n2 << 1)\n        for i in range(n2):\n            self.index[i+n2] = i\n        for i in range(n2-1, -1, -1):\n            self.index[i] = self.index[i*2]\n \n    def update(self, i, x):\n \n        i += self.n2\n        self.tree[i] = x\n        while i > 1:\n            left, right = min(i, i^1), max(i, i^1)\n            if self.func(self.tree[left], self.tree[right]) == self.tree[left]:\n                self.tree[i >> 1] = self.tree[left]\n                self.index[i >> 1] = self.index[left]\n            else:\n                self.tree[i >> 1] = self.tree[right]\n                self.index[i >> 1] = self.index[right]\n            i >>= 1\n \n    def query(self, a, b):\n \n        l = a + self.n2\n        r = b + self.n2\n        s = (self.init, -1)\n        while l < r:\n            if r & 1:\n                r -= 1\n                res = self.func(s[0], self.tree[r])\n                if res == s[0]:\n                    pass\n                else:\n                    s = (self.tree[r], self.index[r])\n            if l & 1:\n                res = self.func(self.tree[l], s[0])\n                if res == self.tree[l]:\n                    s = (self.tree[l], self.index[l])\n                else:\n                    pass\n                l += 1\n            l >>= 1\n            r >>= 1\n        return s\n \nN, K = MAP()\nMAX = 200007\n \nLRs = [[] for i in range(MAX+2)]\nR = [0] * (N+1)\nfor i in range(N):\n    l, r = MAP()\n    LRs[l].append(i+1)\n    LRs[r+1].append(-(i+1))\n    R[i+1] = r\n \nsti = SegTreeIndex(N+1, max, -INF)\nsegcnt = 0\nans = []\nremoved = set()\nfor i in range(1, MAX+2):\n    for idx in LRs[i]:\n        if idx > 0:\n            sti.update(idx, R[idx])\n            segcnt += 1\n        else:\n            idx = abs(idx)\n            if idx not in removed:\n                sti.update(idx, -INF)\n                segcnt -= 1\n    while segcnt > K:\n        mx, idx = sti.query(0, N+1)\n        sti.update(idx, -INF)\n        ans.append(idx)\n        removed.add(idx)\n        segcnt -= 1\nprint(len(ans))\nprint(*ans)\n", "import functools\nfrom math import inf\n\nclass event:\n\tdef __init__(self, x, type, index):\n\t\tself.x = x\n\t\tself.type = type\n\t\tself.i = index\n\ndef custom_sort(a, b):\n\t# if a.i == b.i:\n\t# \tif a.type == \"s\" and b.type == \"e\":\n\t# \t\treturn -1\n\t# \tif a.type == \"e\" and b.type == \"s\":\n\t# \t\treturn 1\n\tif a.x < b.x:\n\t\treturn - 1\n\tif a.x > b.x:\n\t\treturn 1\n\tif a.type == \"e\" and b.type == \"s\":\n\t\treturn 1\n\tif a.type == \"s\" and b.type == \"e\":\n\t\treturn -1\n\treturn 0\n\ndef __starting_point():\n\tline = input().split(\" \")\n\tn, k = int(line[0]), int(line[1])\n\n\tevents = []\n\toriginal_events = []\n\tfor i in range(n):\n\t\tline = input().split(\" \")\n\t\ts = int(line[0])\n\t\te = int(line[1])\n\n\t\tevents.append(event(s, \"s\", i))\n\t\tevents.append(event(e, \"e\", i))\n\t\toriginal_events.append([s, e])\n\n\tevents.sort(key=functools.cmp_to_key(custom_sort))\n\n\tactive = {}\n\tans = []\n\n\tcnt = 0\n\tfor curr in events:\n\t\t# print(curr.x, curr.type, curr.i, cnt)\n\t\tif curr.type == \"s\":\n\t\t\tcnt += 1\n\t\t\tactive[curr.i] = 1\n\n\t\t\tif cnt > k:\n\t\t\t\t# print(\"over:\", curr.i, cnt)\n\t\t\t\tto_remove = 0\n\t\t\t\trightmost = -inf\n\t\t\t\tfor i in active.keys():\n\t\t\t\t\tif original_events[i][1] > rightmost:\n\t\t\t\t\t\trightmost = original_events[i][1]\n\t\t\t\t\t\tto_remove = i\n\t\t\t\tans.append(str(to_remove + 1))\n\t\t\t\tdel active[to_remove]\n\t\t\t\tcnt -= 1\n\n\t\telse:\n\t\t\tif curr.i in active.keys():\n\t\t\t\tcnt -= 1\n\t\t\t\tdel active[curr.i]\n\n\tprint(len(ans))\n\tprint(\" \".join(ans))\n__starting_point()", "# -*- coding: utf-8 -*-\n\nimport sys\nimport bisect\n\nline_count = 0\nsegments = [None]\nnum_points = 200000\nfor line in sys.stdin.readlines():\n    inputs = line.split()\n    if line_count == 0:\n        n = int(inputs[0])\n        k = int(inputs[1])\n        opening = {}\n        closing = {}\n        removed_right = {}\n        segment_index = 0\n        for i in range(1, num_points + 1):\n            opening[i] = []\n            closing[i] = []\n            removed_right[i] = 0\n    else:\n        l = int(inputs[0])\n        r = int(inputs[1])\n        segment_index += 1\n        segments.append((l, r))\n        opening[l].append(segment_index)\n        closing[r].append(segment_index)\n    if line_count == n:\n        break\n    line_count += 1\n\nworking = []\nremoved = []\nfor i in range(1, num_points + 1):\n    for segment_index in opening[i]:\n        _, r = segments[segment_index]\n        bisect.insort_right(working, (r, segment_index))\n    working_count = len(working)\n    while working_count > k:\n        r, segment_index = working.pop()\n        working_count -= 1\n        removed.append(segment_index)\n        removed_right[r] += 1\n    squeezed_out = len(closing[i]) - removed_right[i]\n    working = working[squeezed_out: ]\n\nprint(len(removed))\nfor j in removed:\n    print(j, end = \" \")", "n, k = list(map(int, input().split()))\nl = [0] * n\nr = [0] * n\nevents = [(0, 0)] * 2 * n\nfor i in range(n):\n  l[i], r[i] = list(map(int, input().split()))\n  events[2 * i] = (l[i], 0, i)\n  events[2 * i + 1] = (r[i], 1, i)\nevents.sort()\nimport heapq as h\ns = []\nans = []\nfor e in events:\n  x, t, id = e\n  if t == 0:\n    h.heappush(s, (-r[id], l[id], id)) \n  else:\n    temp = []\n    while s:\n      x = h.heappop(s)\n      if x == (-r[id], l[id], id):\n        break\n      temp.append(x)\n    for x in temp:\n      h.heappush(s, x)\n  while len(s) > k:\n    x = h.heappop(s)\n    ans.append(x[2])\nprint(len(ans))\nprint(*[x + 1 for x in ans])\n\n"]